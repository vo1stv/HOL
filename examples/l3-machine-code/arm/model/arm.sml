(* arm - generated by L3 - Tue Apr 11 15:17:19 2017 *)

structure arm :> arm =
struct

structure Map = MutableMap

(* -------------------------------------------------------------------------
   Type declarations
   ------------------------------------------------------------------------- *)

datatype Architecture
  = ARMv4 | ARMv4T | ARMv5T | ARMv5TE | ARMv6 | ARMv6K | ARMv6T2 | ARMv7_A
  | ARMv7_R

datatype Extensions
  = Extension_ThumbEE | Extension_Security | Extension_Multiprocessing
  | Extension_Virtualization | Extension_AdvanvedSIMD

type PSR =
  { A: bool, C: bool, E: bool, F: bool, GE: BitsN.nbit, I: bool,
    IT: BitsN.nbit, J: bool, M: BitsN.nbit, N: bool, Q: bool, T: bool,
    V: bool, Z: bool, psr'rst: BitsN.nbit }

type CP14 = { TEEHBR: BitsN.nbit }

type SCTLR =
  { A: bool, B: bool, BR: bool, C: bool, DZ: bool, EE: bool, FI: bool,
    I: bool, IE: bool, M: bool, NMFI: bool, RR: bool, SW: bool, TE: bool,
    U: bool, V: bool, VE: bool, Z: bool, sctlr'rst: BitsN.nbit }

type HSCTLR =
  { A: bool, C: bool, CP15BEN: bool, EE: bool, FI: bool, I: bool, M: bool,
    TE: bool, WXN: bool, hsctlr'rst: BitsN.nbit }

type HSR = { EC: BitsN.nbit, IL: bool, ISS: BitsN.nbit }

type SCR =
  { AW: bool, EA: bool, FIQ: bool, FW: bool, HCE: bool, IRQ: bool,
    NS: bool, SCD: bool, SIF: bool, nET: bool, scr'rst: BitsN.nbit }

type NSACR =
  { NSASEDIS: bool, NSD32DIS: bool, NSTRCDIS: bool, RFR: bool,
    cp: BitsN.nbit, nsacr'rst: BitsN.nbit }

type HCR =
  { AMO: bool, BSU: BitsN.nbit, DC: bool, FB: bool, FMO: bool, IMO: bool,
    PTW: bool, SWIO: bool, TAC: bool, TGE: bool, TID: BitsN.nbit,
    TIDCP: bool, TPC: bool, TPU: bool, TSC: bool, TSW: bool, TTLB: bool,
    TVM: bool, TWE: bool, TWI: bool, VA: bool, VF: bool, VI: bool,
    VM: bool, hcr'rst: BitsN.nbit }

type CP15 =
  { HCR: HCR, HSCTLR: HSCTLR, HSR: HSR, MVBAR: BitsN.nbit, NSACR: NSACR,
    SCR: SCR, SCTLR: SCTLR, VBAR: BitsN.nbit }

datatype InstrSet
  = InstrSet_ARM | InstrSet_Thumb | InstrSet_Jazelle | InstrSet_ThumbEE

datatype Encoding = Encoding_Thumb | Encoding_Thumb2 | Encoding_ARM

datatype RName
  = RName_0usr | RName_1usr | RName_2usr | RName_3usr | RName_4usr
  | RName_5usr | RName_6usr | RName_7usr | RName_8usr | RName_8fiq
  | RName_9usr | RName_9fiq | RName_10usr | RName_10fiq | RName_11usr
  | RName_11fiq | RName_12usr | RName_12fiq | RName_SPusr | RName_SPfiq
  | RName_SPirq | RName_SPsvc | RName_SPabt | RName_SPund | RName_SPmon
  | RName_SPhyp | RName_LRusr | RName_LRfiq | RName_LRirq | RName_LRsvc
  | RName_LRabt | RName_LRund | RName_LRmon | RName_PC

datatype SRType
  = SRType_LSL | SRType_LSR | SRType_ASR | SRType_ROR | SRType_RRX

datatype offset1
  = immediate_form1 of BitsN.nbit
  | register_form1 of BitsN.nbit * (SRType * Nat.nat)

datatype offset2
  = immediate_form2 of BitsN.nbit | register_form2 of BitsN.nbit

datatype VFPExtension = NoVFP | VFPv2 | VFPv3 | VFPv4

type FPSCR =
  { AHP: bool, C: bool, DN: bool, DZC: bool, DZE: bool, FZ: bool,
    IDC: bool, IDE: bool, IOC: bool, IOE: bool, IXC: bool, IXE: bool,
    N: bool, OFC: bool, OFE: bool, QC: bool, RMode: BitsN.nbit, UFC: bool,
    UFE: bool, V: bool, Z: bool, fpscr'rst: BitsN.nbit }

type FP = { FPSCR: FPSCR, REG: BitsN.nbit Map.map }

datatype VFPNegMul = VFPNegMul_VNMLA | VFPNegMul_VNMLS | VFPNegMul_VNMUL

datatype VFP
  = vabs of bool * (BitsN.nbit * BitsN.nbit)
  | vadd of bool * (BitsN.nbit * (BitsN.nbit * BitsN.nbit))
  | vcmp of bool * (BitsN.nbit * (BitsN.nbit option))
  | vcvt_float of bool * (BitsN.nbit * BitsN.nbit)
  | vcvt_from_integer of bool * (bool * (BitsN.nbit * BitsN.nbit))
  | vcvt_to_integer of bool * (bool * (bool * (BitsN.nbit * BitsN.nbit)))
  | vdiv of bool * (BitsN.nbit * (BitsN.nbit * BitsN.nbit))
  | vfma_vfms of bool * (bool * (BitsN.nbit * (BitsN.nbit * BitsN.nbit)))
  | vfnma_vfnms of
      bool * (bool * (BitsN.nbit * (BitsN.nbit * BitsN.nbit)))
  | vldm of
      bool * (bool * (bool * (BitsN.nbit * (BitsN.nbit * BitsN.nbit))))
  | vldr of bool * (bool * (BitsN.nbit * (BitsN.nbit * BitsN.nbit)))
  | vmla_vmls of bool * (bool * (BitsN.nbit * (BitsN.nbit * BitsN.nbit)))
  | vmov of bool * (BitsN.nbit * BitsN.nbit)
  | vmov_double of bool * (BitsN.nbit * (BitsN.nbit * BitsN.nbit))
  | vmov_imm of bool * (BitsN.nbit * BitsN.nbit)
  | vmov_single of bool * (BitsN.nbit * BitsN.nbit)
  | vmov_two_singles of bool * (BitsN.nbit * (BitsN.nbit * BitsN.nbit))
  | vmrs of BitsN.nbit
  | vmsr of BitsN.nbit
  | vmul of bool * (BitsN.nbit * (BitsN.nbit * BitsN.nbit))
  | vneg of bool * (BitsN.nbit * BitsN.nbit)
  | vneg_mul of
      bool * (VFPNegMul * (BitsN.nbit * (BitsN.nbit * BitsN.nbit)))
  | vsqrt of bool * (BitsN.nbit * BitsN.nbit)
  | vstm of
      bool * (bool * (bool * (BitsN.nbit * (BitsN.nbit * BitsN.nbit))))
  | vstr of bool * (bool * (BitsN.nbit * (BitsN.nbit * BitsN.nbit)))
  | vsub of bool * (BitsN.nbit * (BitsN.nbit * BitsN.nbit))

datatype Hint
  = Breakpoint of BitsN.nbit
  | DataMemoryBarrier of BitsN.nbit
  | DataSynchronizationBarrier of BitsN.nbit
  | Debug of BitsN.nbit
  | InstructionSynchronizationBarrier of BitsN.nbit
  | PreloadData of bool * (bool * (BitsN.nbit * offset1))
  | PreloadDataLiteral of bool * BitsN.nbit
  | PreloadInstruction of bool * (BitsN.nbit * offset1)
  | SendEvent
  | WaitForEvent
  | WaitForInterrupt
  | Yield

datatype System
  = ChangeProcessorState of
      bool * (bool * (bool * (bool * (bool * (BitsN.nbit option)))))
  | EnterxLeavex of bool
  | ExceptionReturn
  | HypervisorCall of BitsN.nbit
  | MoveToBankedOrSpecialRegister of bool * (BitsN.nbit * BitsN.nbit)
  | MoveToRegisterFromBankedOrSpecial of bool * (BitsN.nbit * BitsN.nbit)
  | MoveToRegisterFromSpecial of bool * BitsN.nbit
  | MoveToSpecialFromImmediate of bool * (BitsN.nbit * BitsN.nbit)
  | MoveToSpecialFromRegister of bool * (BitsN.nbit * BitsN.nbit)
  | ReturnFromException of bool * (bool * (bool * BitsN.nbit))
  | SecureMonitorCall of BitsN.nbit
  | Setend of bool
  | StoreReturnState of bool * (bool * (bool * BitsN.nbit))
  | SupervisorCall of BitsN.nbit

datatype Store
  = StoreByte of
      bool * (bool * (bool * (BitsN.nbit * (BitsN.nbit * offset1))))
  | StoreByteUnprivileged of
      bool * (bool * (BitsN.nbit * (BitsN.nbit * offset1)))
  | StoreDual of
      bool *
      (bool *
       (bool * (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * offset2)))))
  | StoreExclusive of
      BitsN.nbit * (BitsN.nbit * (BitsN.nbit * BitsN.nbit))
  | StoreExclusiveByte of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | StoreExclusiveDoubleword of
      BitsN.nbit * (BitsN.nbit * (BitsN.nbit * BitsN.nbit))
  | StoreExclusiveHalf of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | StoreHalf of
      bool * (bool * (bool * (BitsN.nbit * (BitsN.nbit * offset1))))
  | StoreHalfUnprivileged of
      bool * (bool * (BitsN.nbit * (BitsN.nbit * offset2)))
  | StoreMultiple of bool * (bool * (bool * (BitsN.nbit * BitsN.nbit)))
  | StoreMultipleUserRegisters of
      bool * (bool * (BitsN.nbit * BitsN.nbit))
  | StoreUnprivileged of
      bool * (bool * (BitsN.nbit * (BitsN.nbit * offset1)))
  | StoreWord of
      bool * (bool * (bool * (BitsN.nbit * (BitsN.nbit * offset1))))

datatype Load
  = LoadByte of
      bool *
      (bool * (bool * (bool * (BitsN.nbit * (BitsN.nbit * offset1)))))
  | LoadByteLiteral of bool * (bool * (BitsN.nbit * BitsN.nbit))
  | LoadByteUnprivileged of
      bool * (bool * (BitsN.nbit * (BitsN.nbit * offset1)))
  | LoadDual of
      bool *
      (bool *
       (bool * (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * offset2)))))
  | LoadDualLiteral of bool * (BitsN.nbit * (BitsN.nbit * BitsN.nbit))
  | LoadExclusive of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | LoadExclusiveByte of BitsN.nbit * BitsN.nbit
  | LoadExclusiveDoubleword of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | LoadExclusiveHalf of BitsN.nbit * BitsN.nbit
  | LoadHalf of
      bool *
      (bool * (bool * (bool * (BitsN.nbit * (BitsN.nbit * offset1)))))
  | LoadHalfLiteral of bool * (bool * (BitsN.nbit * BitsN.nbit))
  | LoadHalfUnprivileged of
      bool * (bool * (bool * (BitsN.nbit * (BitsN.nbit * offset2))))
  | LoadLiteral of bool * (BitsN.nbit * BitsN.nbit)
  | LoadMultiple of bool * (bool * (bool * (BitsN.nbit * BitsN.nbit)))
  | LoadMultipleExceptionReturn of
      bool * (bool * (bool * (BitsN.nbit * BitsN.nbit)))
  | LoadMultipleUserRegisters of bool * (bool * (BitsN.nbit * BitsN.nbit))
  | LoadSignedByteUnprivileged of
      bool * (bool * (BitsN.nbit * (BitsN.nbit * offset2)))
  | LoadUnprivileged of
      bool * (bool * (BitsN.nbit * (BitsN.nbit * offset1)))
  | LoadWord of
      bool * (bool * (bool * (BitsN.nbit * (BitsN.nbit * offset1))))

datatype Media
  = BitFieldClearOrInsert of
      BitsN.nbit * (BitsN.nbit * (Nat.nat * Nat.nat))
  | BitFieldExtract of
      bool * (BitsN.nbit * (BitsN.nbit * (Nat.nat * Nat.nat)))
  | ByteReverse of BitsN.nbit * BitsN.nbit
  | ByteReversePackedHalfword of BitsN.nbit * BitsN.nbit
  | ByteReverseSignedHalfword of BitsN.nbit * BitsN.nbit
  | ExtendByte of
      bool * (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * Nat.nat)))
  | ExtendByte16 of
      bool * (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * Nat.nat)))
  | ExtendHalfword of
      bool * (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * Nat.nat)))
  | PackHalfword of
      SRType *
      (Nat.nat * (bool * (BitsN.nbit * (BitsN.nbit * BitsN.nbit))))
  | ReverseBits of BitsN.nbit * BitsN.nbit
  | Saturate of
      SRType * (Nat.nat * (Nat.nat * (bool * (BitsN.nbit * BitsN.nbit))))
  | Saturate16 of Nat.nat * (bool * (BitsN.nbit * BitsN.nbit))
  | SaturatingAddSubtract of
      BitsN.nbit * (BitsN.nbit * (BitsN.nbit * BitsN.nbit))
  | SelectBytes of BitsN.nbit * (BitsN.nbit * BitsN.nbit)

datatype SIMD
  = SignedAddSub16 of
      BitsN.nbit * (BitsN.nbit * (BitsN.nbit * BitsN.nbit))
  | SignedAddSub8 of bool * (BitsN.nbit * (BitsN.nbit * BitsN.nbit))
  | SignedHalvingAddSub16 of
      BitsN.nbit * (BitsN.nbit * (BitsN.nbit * BitsN.nbit))
  | SignedHalvingAddSub8 of
      bool * (BitsN.nbit * (BitsN.nbit * BitsN.nbit))
  | SignedSaturatingAddSub16 of
      BitsN.nbit * (BitsN.nbit * (BitsN.nbit * BitsN.nbit))
  | SignedSaturatingAddSub8 of
      bool * (BitsN.nbit * (BitsN.nbit * BitsN.nbit))
  | UnsignedAddSub16 of
      BitsN.nbit * (BitsN.nbit * (BitsN.nbit * BitsN.nbit))
  | UnsignedAddSub8 of bool * (BitsN.nbit * (BitsN.nbit * BitsN.nbit))
  | UnsignedHalvingAddSub16 of
      BitsN.nbit * (BitsN.nbit * (BitsN.nbit * BitsN.nbit))
  | UnsignedHalvingAddSub8 of
      bool * (BitsN.nbit * (BitsN.nbit * BitsN.nbit))
  | UnsignedSaturatingAddSub16 of
      BitsN.nbit * (BitsN.nbit * (BitsN.nbit * BitsN.nbit))
  | UnsignedSaturatingAddSub8 of
      bool * (BitsN.nbit * (BitsN.nbit * BitsN.nbit))
  | UnsignedSumAbsoluteDifferences of
      BitsN.nbit * (BitsN.nbit * (BitsN.nbit * BitsN.nbit))

datatype Multiply
  = Multiply32 of bool * (BitsN.nbit * (BitsN.nbit * BitsN.nbit))
  | MultiplyAccumulate of
      bool * (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * BitsN.nbit)))
  | MultiplyAccumulateAccumulate of
      BitsN.nbit * (BitsN.nbit * (BitsN.nbit * BitsN.nbit))
  | MultiplyLong of
      bool *
      (bool *
       (bool * (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * BitsN.nbit)))))
  | MultiplySubtract of
      BitsN.nbit * (BitsN.nbit * (BitsN.nbit * BitsN.nbit))
  | Signed16Multiply32Accumulate of
      bool *
      (bool * (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * BitsN.nbit))))
  | Signed16Multiply32Result of
      bool * (bool * (BitsN.nbit * (BitsN.nbit * BitsN.nbit)))
  | Signed16Multiply64Accumulate of
      bool *
      (bool * (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * BitsN.nbit))))
  | Signed16x32Multiply32Accumulate of
      bool * (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * BitsN.nbit)))
  | Signed16x32Multiply32Result of
      bool * (BitsN.nbit * (BitsN.nbit * BitsN.nbit))
  | SignedMostSignificantMultiply of
      bool * (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * BitsN.nbit)))
  | SignedMostSignificantMultiplySubtract of
      bool * (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * BitsN.nbit)))
  | SignedMultiplyDual of
      bool *
      (bool * (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * BitsN.nbit))))
  | SignedMultiplyLongDual of
      bool *
      (bool * (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * BitsN.nbit))))

datatype Data
  = AddSub of bool * (BitsN.nbit * (BitsN.nbit * BitsN.nbit))
  | ArithLogicImmediate of
      BitsN.nbit * (bool * (BitsN.nbit * (BitsN.nbit * BitsN.nbit)))
  | CountLeadingZeroes of BitsN.nbit * BitsN.nbit
  | Move of bool * (bool * (BitsN.nbit * BitsN.nbit))
  | MoveHalfword of bool * (BitsN.nbit * BitsN.nbit)
  | Register of
      BitsN.nbit *
      (bool *
       (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * (SRType * Nat.nat)))))
  | RegisterShiftedRegister of
      BitsN.nbit *
      (bool *
       (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * (SRType * BitsN.nbit)))))
  | ShiftImmediate of
      bool * (bool * (BitsN.nbit * (BitsN.nbit * (SRType * Nat.nat))))
  | ShiftRegister of
      bool * (bool * (BitsN.nbit * (BitsN.nbit * (SRType * BitsN.nbit))))
  | TestCompareImmediate of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | TestCompareRegister of
      BitsN.nbit * (BitsN.nbit * (BitsN.nbit * (SRType * Nat.nat)))

datatype Branch
  = BranchExchange of BitsN.nbit
  | BranchLinkExchangeImmediate of InstrSet * BitsN.nbit
  | BranchLinkExchangeRegister of BitsN.nbit
  | BranchTarget of BitsN.nbit
  | CheckArray of BitsN.nbit * BitsN.nbit
  | CompareBranch of bool * (BitsN.nbit * BitsN.nbit)
  | HandlerBranchLink of bool * BitsN.nbit
  | HandlerBranchLinkParameter of BitsN.nbit * BitsN.nbit
  | HandlerBranchParameter of BitsN.nbit * BitsN.nbit
  | TableBranchByte of bool * (BitsN.nbit * BitsN.nbit)

datatype instruction
  = Branch of Branch
  | ClearExclusive
  | Data of Data
  | Divide of bool * (BitsN.nbit * (BitsN.nbit * BitsN.nbit))
  | Hint of Hint
  | IfThen of BitsN.nbit * BitsN.nbit
  | Load of Load
  | Media of Media
  | Multiply of Multiply
  | NoOperation
  | SIMD of SIMD
  | Store of Store
  | Swap of bool * (BitsN.nbit * (BitsN.nbit * BitsN.nbit))
  | System of System
  | Undefined of BitsN.nbit
  | VFP of VFP

datatype MachineCode
  = ARM of BitsN.nbit
  | BadCode of string
  | Thumb of BitsN.nbit
  | Thumb2 of BitsN.nbit * BitsN.nbit
  | ThumbEE of BitsN.nbit

datatype enc = Enc_ARM | Enc_Thumb | Enc_Narrow | Enc_Wide

datatype maybe_instruction
  = FAIL of string
  | OK of (BitsN.nbit * string) * instruction
  | PENDING of string * ((BitsN.nbit * string) * instruction)
  | WORD of BitsN.nbit

datatype nat_or_reg = NAT of Nat.nat | REGISTER of BitsN.nbit

(* -------------------------------------------------------------------------
   Casting maps (for enumerated types)
   ------------------------------------------------------------------------- *)

structure Cast =
struct
fun natToArchitecture x =
  case Nat.toInt x of
     0 => ARMv4
   | 1 => ARMv4T
   | 2 => ARMv5T
   | 3 => ARMv5TE
   | 4 => ARMv6
   | 5 => ARMv6K
   | 6 => ARMv6T2
   | 7 => ARMv7_A
   | 8 => ARMv7_R
   | _ => raise Fail "natToArchitecture"

fun natToExtensions x =
  case Nat.toInt x of
     0 => Extension_ThumbEE
   | 1 => Extension_Security
   | 2 => Extension_Multiprocessing
   | 3 => Extension_Virtualization
   | 4 => Extension_AdvanvedSIMD
   | _ => raise Fail "natToExtensions"

fun natToInstrSet x =
  case Nat.toInt x of
     0 => InstrSet_ARM
   | 1 => InstrSet_Thumb
   | 2 => InstrSet_Jazelle
   | 3 => InstrSet_ThumbEE
   | _ => raise Fail "natToInstrSet"

fun natToEncoding x =
  case Nat.toInt x of
     0 => Encoding_Thumb
   | 1 => Encoding_Thumb2
   | 2 => Encoding_ARM
   | _ => raise Fail "natToEncoding"

fun natToRName x =
  case Nat.toInt x of
     0 => RName_0usr
   | 1 => RName_1usr
   | 2 => RName_2usr
   | 3 => RName_3usr
   | 4 => RName_4usr
   | 5 => RName_5usr
   | 6 => RName_6usr
   | 7 => RName_7usr
   | 8 => RName_8usr
   | 9 => RName_8fiq
   | 10 => RName_9usr
   | 11 => RName_9fiq
   | 12 => RName_10usr
   | 13 => RName_10fiq
   | 14 => RName_11usr
   | 15 => RName_11fiq
   | 16 => RName_12usr
   | 17 => RName_12fiq
   | 18 => RName_SPusr
   | 19 => RName_SPfiq
   | 20 => RName_SPirq
   | 21 => RName_SPsvc
   | 22 => RName_SPabt
   | 23 => RName_SPund
   | 24 => RName_SPmon
   | 25 => RName_SPhyp
   | 26 => RName_LRusr
   | 27 => RName_LRfiq
   | 28 => RName_LRirq
   | 29 => RName_LRsvc
   | 30 => RName_LRabt
   | 31 => RName_LRund
   | 32 => RName_LRmon
   | 33 => RName_PC
   | _ => raise Fail "natToRName"

fun natToSRType x =
  case Nat.toInt x of
     0 => SRType_LSL
   | 1 => SRType_LSR
   | 2 => SRType_ASR
   | 3 => SRType_ROR
   | 4 => SRType_RRX
   | _ => raise Fail "natToSRType"

fun natToVFPExtension x =
  case Nat.toInt x of
     0 => NoVFP
   | 1 => VFPv2
   | 2 => VFPv3
   | 3 => VFPv4
   | _ => raise Fail "natToVFPExtension"

fun natToVFPNegMul x =
  case Nat.toInt x of
     0 => VFPNegMul_VNMLA
   | 1 => VFPNegMul_VNMLS
   | 2 => VFPNegMul_VNMUL
   | _ => raise Fail "natToVFPNegMul"

fun natToenc x =
  case Nat.toInt x of
     0 => Enc_ARM
   | 1 => Enc_Thumb
   | 2 => Enc_Narrow
   | 3 => Enc_Wide
   | _ => raise Fail "natToenc"

fun ArchitectureToNat x =
  case x of
     ARMv4 => 0
   | ARMv4T => 1
   | ARMv5T => 2
   | ARMv5TE => 3
   | ARMv6 => 4
   | ARMv6K => 5
   | ARMv6T2 => 6
   | ARMv7_A => 7
   | ARMv7_R => 8

fun ExtensionsToNat x =
  case x of
     Extension_ThumbEE => 0
   | Extension_Security => 1
   | Extension_Multiprocessing => 2
   | Extension_Virtualization => 3
   | Extension_AdvanvedSIMD => 4

fun InstrSetToNat x =
  case x of
     InstrSet_ARM => 0
   | InstrSet_Thumb => 1
   | InstrSet_Jazelle => 2
   | InstrSet_ThumbEE => 3

fun EncodingToNat x =
  case x of
     Encoding_Thumb => 0 | Encoding_Thumb2 => 1 | Encoding_ARM => 2

fun RNameToNat x =
  case x of
     RName_0usr => 0
   | RName_1usr => 1
   | RName_2usr => 2
   | RName_3usr => 3
   | RName_4usr => 4
   | RName_5usr => 5
   | RName_6usr => 6
   | RName_7usr => 7
   | RName_8usr => 8
   | RName_8fiq => 9
   | RName_9usr => 10
   | RName_9fiq => 11
   | RName_10usr => 12
   | RName_10fiq => 13
   | RName_11usr => 14
   | RName_11fiq => 15
   | RName_12usr => 16
   | RName_12fiq => 17
   | RName_SPusr => 18
   | RName_SPfiq => 19
   | RName_SPirq => 20
   | RName_SPsvc => 21
   | RName_SPabt => 22
   | RName_SPund => 23
   | RName_SPmon => 24
   | RName_SPhyp => 25
   | RName_LRusr => 26
   | RName_LRfiq => 27
   | RName_LRirq => 28
   | RName_LRsvc => 29
   | RName_LRabt => 30
   | RName_LRund => 31
   | RName_LRmon => 32
   | RName_PC => 33

fun SRTypeToNat x =
  case x of
     SRType_LSL => 0
   | SRType_LSR => 1
   | SRType_ASR => 2
   | SRType_ROR => 3
   | SRType_RRX => 4

fun VFPExtensionToNat x =
  case x of
     NoVFP => 0 | VFPv2 => 1 | VFPv3 => 2 | VFPv4 => 3

fun VFPNegMulToNat x =
  case x of
     VFPNegMul_VNMLA => 0 | VFPNegMul_VNMLS => 1 | VFPNegMul_VNMUL => 2

fun encToNat x =
  case x of
     Enc_ARM => 0 | Enc_Thumb => 1 | Enc_Narrow => 2 | Enc_Wide => 3

fun ArchitectureToString x =
  case x of
     ARMv4 => "ARMv4"
   | ARMv4T => "ARMv4T"
   | ARMv5T => "ARMv5T"
   | ARMv5TE => "ARMv5TE"
   | ARMv6 => "ARMv6"
   | ARMv6K => "ARMv6K"
   | ARMv6T2 => "ARMv6T2"
   | ARMv7_A => "ARMv7_A"
   | ARMv7_R => "ARMv7_R"

fun ExtensionsToString x =
  case x of
     Extension_ThumbEE => "Extension_ThumbEE"
   | Extension_Security => "Extension_Security"
   | Extension_Multiprocessing => "Extension_Multiprocessing"
   | Extension_Virtualization => "Extension_Virtualization"
   | Extension_AdvanvedSIMD => "Extension_AdvanvedSIMD"

fun InstrSetToString x =
  case x of
     InstrSet_ARM => "InstrSet_ARM"
   | InstrSet_Thumb => "InstrSet_Thumb"
   | InstrSet_Jazelle => "InstrSet_Jazelle"
   | InstrSet_ThumbEE => "InstrSet_ThumbEE"

fun EncodingToString x =
  case x of
     Encoding_Thumb => "Encoding_Thumb"
   | Encoding_Thumb2 => "Encoding_Thumb2"
   | Encoding_ARM => "Encoding_ARM"

fun RNameToString x =
  case x of
     RName_0usr => "RName_0usr"
   | RName_1usr => "RName_1usr"
   | RName_2usr => "RName_2usr"
   | RName_3usr => "RName_3usr"
   | RName_4usr => "RName_4usr"
   | RName_5usr => "RName_5usr"
   | RName_6usr => "RName_6usr"
   | RName_7usr => "RName_7usr"
   | RName_8usr => "RName_8usr"
   | RName_8fiq => "RName_8fiq"
   | RName_9usr => "RName_9usr"
   | RName_9fiq => "RName_9fiq"
   | RName_10usr => "RName_10usr"
   | RName_10fiq => "RName_10fiq"
   | RName_11usr => "RName_11usr"
   | RName_11fiq => "RName_11fiq"
   | RName_12usr => "RName_12usr"
   | RName_12fiq => "RName_12fiq"
   | RName_SPusr => "RName_SPusr"
   | RName_SPfiq => "RName_SPfiq"
   | RName_SPirq => "RName_SPirq"
   | RName_SPsvc => "RName_SPsvc"
   | RName_SPabt => "RName_SPabt"
   | RName_SPund => "RName_SPund"
   | RName_SPmon => "RName_SPmon"
   | RName_SPhyp => "RName_SPhyp"
   | RName_LRusr => "RName_LRusr"
   | RName_LRfiq => "RName_LRfiq"
   | RName_LRirq => "RName_LRirq"
   | RName_LRsvc => "RName_LRsvc"
   | RName_LRabt => "RName_LRabt"
   | RName_LRund => "RName_LRund"
   | RName_LRmon => "RName_LRmon"
   | RName_PC => "RName_PC"

fun SRTypeToString x =
  case x of
     SRType_LSL => "SRType_LSL"
   | SRType_LSR => "SRType_LSR"
   | SRType_ASR => "SRType_ASR"
   | SRType_ROR => "SRType_ROR"
   | SRType_RRX => "SRType_RRX"

fun VFPExtensionToString x =
  case x of
     NoVFP => "NoVFP"
   | VFPv2 => "VFPv2"
   | VFPv3 => "VFPv3"
   | VFPv4 => "VFPv4"

fun VFPNegMulToString x =
  case x of
     VFPNegMul_VNMLA => "VFPNegMul_VNMLA"
   | VFPNegMul_VNMLS => "VFPNegMul_VNMLS"
   | VFPNegMul_VNMUL => "VFPNegMul_VNMUL"

fun encToString x =
  case x of
     Enc_ARM => "Enc_ARM"
   | Enc_Thumb => "Enc_Thumb"
   | Enc_Narrow => "Enc_Narrow"
   | Enc_Wide => "Enc_Wide"

fun stringToArchitecture x =
  case x of
     "ARMv4" => ARMv4
   | "ARMv4T" => ARMv4T
   | "ARMv5T" => ARMv5T
   | "ARMv5TE" => ARMv5TE
   | "ARMv6" => ARMv6
   | "ARMv6K" => ARMv6K
   | "ARMv6T2" => ARMv6T2
   | "ARMv7_A" => ARMv7_A
   | "ARMv7_R" => ARMv7_R
   | _ => raise Fail "stringToArchitecture"

fun stringToExtensions x =
  case x of
     "Extension_ThumbEE" => Extension_ThumbEE
   | "Extension_Security" => Extension_Security
   | "Extension_Multiprocessing" => Extension_Multiprocessing
   | "Extension_Virtualization" => Extension_Virtualization
   | "Extension_AdvanvedSIMD" => Extension_AdvanvedSIMD
   | _ => raise Fail "stringToExtensions"

fun stringToInstrSet x =
  case x of
     "InstrSet_ARM" => InstrSet_ARM
   | "InstrSet_Thumb" => InstrSet_Thumb
   | "InstrSet_Jazelle" => InstrSet_Jazelle
   | "InstrSet_ThumbEE" => InstrSet_ThumbEE
   | _ => raise Fail "stringToInstrSet"

fun stringToEncoding x =
  case x of
     "Encoding_Thumb" => Encoding_Thumb
   | "Encoding_Thumb2" => Encoding_Thumb2
   | "Encoding_ARM" => Encoding_ARM
   | _ => raise Fail "stringToEncoding"

fun stringToRName x =
  case x of
     "RName_0usr" => RName_0usr
   | "RName_1usr" => RName_1usr
   | "RName_2usr" => RName_2usr
   | "RName_3usr" => RName_3usr
   | "RName_4usr" => RName_4usr
   | "RName_5usr" => RName_5usr
   | "RName_6usr" => RName_6usr
   | "RName_7usr" => RName_7usr
   | "RName_8usr" => RName_8usr
   | "RName_8fiq" => RName_8fiq
   | "RName_9usr" => RName_9usr
   | "RName_9fiq" => RName_9fiq
   | "RName_10usr" => RName_10usr
   | "RName_10fiq" => RName_10fiq
   | "RName_11usr" => RName_11usr
   | "RName_11fiq" => RName_11fiq
   | "RName_12usr" => RName_12usr
   | "RName_12fiq" => RName_12fiq
   | "RName_SPusr" => RName_SPusr
   | "RName_SPfiq" => RName_SPfiq
   | "RName_SPirq" => RName_SPirq
   | "RName_SPsvc" => RName_SPsvc
   | "RName_SPabt" => RName_SPabt
   | "RName_SPund" => RName_SPund
   | "RName_SPmon" => RName_SPmon
   | "RName_SPhyp" => RName_SPhyp
   | "RName_LRusr" => RName_LRusr
   | "RName_LRfiq" => RName_LRfiq
   | "RName_LRirq" => RName_LRirq
   | "RName_LRsvc" => RName_LRsvc
   | "RName_LRabt" => RName_LRabt
   | "RName_LRund" => RName_LRund
   | "RName_LRmon" => RName_LRmon
   | "RName_PC" => RName_PC
   | _ => raise Fail "stringToRName"

fun stringToSRType x =
  case x of
     "SRType_LSL" => SRType_LSL
   | "SRType_LSR" => SRType_LSR
   | "SRType_ASR" => SRType_ASR
   | "SRType_ROR" => SRType_ROR
   | "SRType_RRX" => SRType_RRX
   | _ => raise Fail "stringToSRType"

fun stringToVFPExtension x =
  case x of
     "NoVFP" => NoVFP
   | "VFPv2" => VFPv2
   | "VFPv3" => VFPv3
   | "VFPv4" => VFPv4
   | _ => raise Fail "stringToVFPExtension"

fun stringToVFPNegMul x =
  case x of
     "VFPNegMul_VNMLA" => VFPNegMul_VNMLA
   | "VFPNegMul_VNMLS" => VFPNegMul_VNMLS
   | "VFPNegMul_VNMUL" => VFPNegMul_VNMUL
   | _ => raise Fail "stringToVFPNegMul"

fun stringToenc x =
  case x of
     "Enc_ARM" => Enc_ARM
   | "Enc_Thumb" => Enc_Thumb
   | "Enc_Narrow" => Enc_Narrow
   | "Enc_Wide" => Enc_Wide
   | _ => raise Fail "stringToenc"
end

(* -------------------------------------------------------------------------
   Record update functions
   ------------------------------------------------------------------------- *)

fun PSR_A_rupd ({A, C, E, F, GE, I, IT, J, M, N, Q, T, V, Z, psr'rst}
  : PSR, x') =
  {A = x', C = C, E = E, F = F, GE = GE, I = I, IT = IT, J = J, M = M,
   N = N, Q = Q, T = T, V = V, Z = Z, psr'rst = psr'rst}: PSR

fun PSR_C_rupd ({A, C, E, F, GE, I, IT, J, M, N, Q, T, V, Z, psr'rst}
  : PSR, x') =
  {A = A, C = x', E = E, F = F, GE = GE, I = I, IT = IT, J = J, M = M,
   N = N, Q = Q, T = T, V = V, Z = Z, psr'rst = psr'rst}: PSR

fun PSR_E_rupd ({A, C, E, F, GE, I, IT, J, M, N, Q, T, V, Z, psr'rst}
  : PSR, x') =
  {A = A, C = C, E = x', F = F, GE = GE, I = I, IT = IT, J = J, M = M,
   N = N, Q = Q, T = T, V = V, Z = Z, psr'rst = psr'rst}: PSR

fun PSR_F_rupd ({A, C, E, F, GE, I, IT, J, M, N, Q, T, V, Z, psr'rst}
  : PSR, x') =
  {A = A, C = C, E = E, F = x', GE = GE, I = I, IT = IT, J = J, M = M,
   N = N, Q = Q, T = T, V = V, Z = Z, psr'rst = psr'rst}: PSR

fun PSR_GE_rupd ({A, C, E, F, GE, I, IT, J, M, N, Q, T, V, Z, psr'rst}
  : PSR, x') =
  {A = A, C = C, E = E, F = F, GE = x', I = I, IT = IT, J = J, M = M,
   N = N, Q = Q, T = T, V = V, Z = Z, psr'rst = psr'rst}: PSR

fun PSR_I_rupd ({A, C, E, F, GE, I, IT, J, M, N, Q, T, V, Z, psr'rst}
  : PSR, x') =
  {A = A, C = C, E = E, F = F, GE = GE, I = x', IT = IT, J = J, M = M,
   N = N, Q = Q, T = T, V = V, Z = Z, psr'rst = psr'rst}: PSR

fun PSR_IT_rupd ({A, C, E, F, GE, I, IT, J, M, N, Q, T, V, Z, psr'rst}
  : PSR, x') =
  {A = A, C = C, E = E, F = F, GE = GE, I = I, IT = x', J = J, M = M,
   N = N, Q = Q, T = T, V = V, Z = Z, psr'rst = psr'rst}: PSR

fun PSR_J_rupd ({A, C, E, F, GE, I, IT, J, M, N, Q, T, V, Z, psr'rst}
  : PSR, x') =
  {A = A, C = C, E = E, F = F, GE = GE, I = I, IT = IT, J = x', M = M,
   N = N, Q = Q, T = T, V = V, Z = Z, psr'rst = psr'rst}: PSR

fun PSR_M_rupd ({A, C, E, F, GE, I, IT, J, M, N, Q, T, V, Z, psr'rst}
  : PSR, x') =
  {A = A, C = C, E = E, F = F, GE = GE, I = I, IT = IT, J = J, M = x',
   N = N, Q = Q, T = T, V = V, Z = Z, psr'rst = psr'rst}: PSR

fun PSR_N_rupd ({A, C, E, F, GE, I, IT, J, M, N, Q, T, V, Z, psr'rst}
  : PSR, x') =
  {A = A, C = C, E = E, F = F, GE = GE, I = I, IT = IT, J = J, M = M,
   N = x', Q = Q, T = T, V = V, Z = Z, psr'rst = psr'rst}: PSR

fun PSR_Q_rupd ({A, C, E, F, GE, I, IT, J, M, N, Q, T, V, Z, psr'rst}
  : PSR, x') =
  {A = A, C = C, E = E, F = F, GE = GE, I = I, IT = IT, J = J, M = M,
   N = N, Q = x', T = T, V = V, Z = Z, psr'rst = psr'rst}: PSR

fun PSR_T_rupd ({A, C, E, F, GE, I, IT, J, M, N, Q, T, V, Z, psr'rst}
  : PSR, x') =
  {A = A, C = C, E = E, F = F, GE = GE, I = I, IT = IT, J = J, M = M,
   N = N, Q = Q, T = x', V = V, Z = Z, psr'rst = psr'rst}: PSR

fun PSR_V_rupd ({A, C, E, F, GE, I, IT, J, M, N, Q, T, V, Z, psr'rst}
  : PSR, x') =
  {A = A, C = C, E = E, F = F, GE = GE, I = I, IT = IT, J = J, M = M,
   N = N, Q = Q, T = T, V = x', Z = Z, psr'rst = psr'rst}: PSR

fun PSR_Z_rupd ({A, C, E, F, GE, I, IT, J, M, N, Q, T, V, Z, psr'rst}
  : PSR, x') =
  {A = A, C = C, E = E, F = F, GE = GE, I = I, IT = IT, J = J, M = M,
   N = N, Q = Q, T = T, V = V, Z = x', psr'rst = psr'rst}: PSR

fun PSR_psr'rst_rupd ({A, C, E, F, GE, I, IT, J, M, N, Q, T, V, Z, psr'rst}
  : PSR, x') =
  {A = A, C = C, E = E, F = F, GE = GE, I = I, IT = IT, J = J, M = M,
   N = N, Q = Q, T = T, V = V, Z = Z, psr'rst = x'}: PSR

fun CP14_TEEHBR_rupd ({TEEHBR}: CP14, x') = {TEEHBR = x'}: CP14

fun SCTLR_A_rupd ({A, B, BR, C, DZ, EE, FI, I, IE, M, NMFI, RR, SW, TE, U,
   V, VE, Z, sctlr'rst}: SCTLR, x') =
  {A = x', B = B, BR = BR, C = C, DZ = DZ, EE = EE, FI = FI, I = I,
   IE = IE, M = M, NMFI = NMFI, RR = RR, SW = SW, TE = TE, U = U, V = V,
   VE = VE, Z = Z, sctlr'rst = sctlr'rst}: SCTLR

fun SCTLR_B_rupd ({A, B, BR, C, DZ, EE, FI, I, IE, M, NMFI, RR, SW, TE, U,
   V, VE, Z, sctlr'rst}: SCTLR, x') =
  {A = A, B = x', BR = BR, C = C, DZ = DZ, EE = EE, FI = FI, I = I,
   IE = IE, M = M, NMFI = NMFI, RR = RR, SW = SW, TE = TE, U = U, V = V,
   VE = VE, Z = Z, sctlr'rst = sctlr'rst}: SCTLR

fun SCTLR_BR_rupd ({A, B, BR, C, DZ, EE, FI, I, IE, M, NMFI, RR, SW, TE,
   U, V, VE, Z, sctlr'rst}: SCTLR, x') =
  {A = A, B = B, BR = x', C = C, DZ = DZ, EE = EE, FI = FI, I = I,
   IE = IE, M = M, NMFI = NMFI, RR = RR, SW = SW, TE = TE, U = U, V = V,
   VE = VE, Z = Z, sctlr'rst = sctlr'rst}: SCTLR

fun SCTLR_C_rupd ({A, B, BR, C, DZ, EE, FI, I, IE, M, NMFI, RR, SW, TE, U,
   V, VE, Z, sctlr'rst}: SCTLR, x') =
  {A = A, B = B, BR = BR, C = x', DZ = DZ, EE = EE, FI = FI, I = I,
   IE = IE, M = M, NMFI = NMFI, RR = RR, SW = SW, TE = TE, U = U, V = V,
   VE = VE, Z = Z, sctlr'rst = sctlr'rst}: SCTLR

fun SCTLR_DZ_rupd ({A, B, BR, C, DZ, EE, FI, I, IE, M, NMFI, RR, SW, TE,
   U, V, VE, Z, sctlr'rst}: SCTLR, x') =
  {A = A, B = B, BR = BR, C = C, DZ = x', EE = EE, FI = FI, I = I,
   IE = IE, M = M, NMFI = NMFI, RR = RR, SW = SW, TE = TE, U = U, V = V,
   VE = VE, Z = Z, sctlr'rst = sctlr'rst}: SCTLR

fun SCTLR_EE_rupd ({A, B, BR, C, DZ, EE, FI, I, IE, M, NMFI, RR, SW, TE,
   U, V, VE, Z, sctlr'rst}: SCTLR, x') =
  {A = A, B = B, BR = BR, C = C, DZ = DZ, EE = x', FI = FI, I = I,
   IE = IE, M = M, NMFI = NMFI, RR = RR, SW = SW, TE = TE, U = U, V = V,
   VE = VE, Z = Z, sctlr'rst = sctlr'rst}: SCTLR

fun SCTLR_FI_rupd ({A, B, BR, C, DZ, EE, FI, I, IE, M, NMFI, RR, SW, TE,
   U, V, VE, Z, sctlr'rst}: SCTLR, x') =
  {A = A, B = B, BR = BR, C = C, DZ = DZ, EE = EE, FI = x', I = I,
   IE = IE, M = M, NMFI = NMFI, RR = RR, SW = SW, TE = TE, U = U, V = V,
   VE = VE, Z = Z, sctlr'rst = sctlr'rst}: SCTLR

fun SCTLR_I_rupd ({A, B, BR, C, DZ, EE, FI, I, IE, M, NMFI, RR, SW, TE, U,
   V, VE, Z, sctlr'rst}: SCTLR, x') =
  {A = A, B = B, BR = BR, C = C, DZ = DZ, EE = EE, FI = FI, I = x',
   IE = IE, M = M, NMFI = NMFI, RR = RR, SW = SW, TE = TE, U = U, V = V,
   VE = VE, Z = Z, sctlr'rst = sctlr'rst}: SCTLR

fun SCTLR_IE_rupd ({A, B, BR, C, DZ, EE, FI, I, IE, M, NMFI, RR, SW, TE,
   U, V, VE, Z, sctlr'rst}: SCTLR, x') =
  {A = A, B = B, BR = BR, C = C, DZ = DZ, EE = EE, FI = FI, I = I,
   IE = x', M = M, NMFI = NMFI, RR = RR, SW = SW, TE = TE, U = U, V = V,
   VE = VE, Z = Z, sctlr'rst = sctlr'rst}: SCTLR

fun SCTLR_M_rupd ({A, B, BR, C, DZ, EE, FI, I, IE, M, NMFI, RR, SW, TE, U,
   V, VE, Z, sctlr'rst}: SCTLR, x') =
  {A = A, B = B, BR = BR, C = C, DZ = DZ, EE = EE, FI = FI, I = I,
   IE = IE, M = x', NMFI = NMFI, RR = RR, SW = SW, TE = TE, U = U, V = V,
   VE = VE, Z = Z, sctlr'rst = sctlr'rst}: SCTLR

fun SCTLR_NMFI_rupd ({A, B, BR, C, DZ, EE, FI, I, IE, M, NMFI, RR, SW, TE,
   U, V, VE, Z, sctlr'rst}: SCTLR, x') =
  {A = A, B = B, BR = BR, C = C, DZ = DZ, EE = EE, FI = FI, I = I,
   IE = IE, M = M, NMFI = x', RR = RR, SW = SW, TE = TE, U = U, V = V,
   VE = VE, Z = Z, sctlr'rst = sctlr'rst}: SCTLR

fun SCTLR_RR_rupd ({A, B, BR, C, DZ, EE, FI, I, IE, M, NMFI, RR, SW, TE,
   U, V, VE, Z, sctlr'rst}: SCTLR, x') =
  {A = A, B = B, BR = BR, C = C, DZ = DZ, EE = EE, FI = FI, I = I,
   IE = IE, M = M, NMFI = NMFI, RR = x', SW = SW, TE = TE, U = U, V = V,
   VE = VE, Z = Z, sctlr'rst = sctlr'rst}: SCTLR

fun SCTLR_SW_rupd ({A, B, BR, C, DZ, EE, FI, I, IE, M, NMFI, RR, SW, TE,
   U, V, VE, Z, sctlr'rst}: SCTLR, x') =
  {A = A, B = B, BR = BR, C = C, DZ = DZ, EE = EE, FI = FI, I = I,
   IE = IE, M = M, NMFI = NMFI, RR = RR, SW = x', TE = TE, U = U, V = V,
   VE = VE, Z = Z, sctlr'rst = sctlr'rst}: SCTLR

fun SCTLR_TE_rupd ({A, B, BR, C, DZ, EE, FI, I, IE, M, NMFI, RR, SW, TE,
   U, V, VE, Z, sctlr'rst}: SCTLR, x') =
  {A = A, B = B, BR = BR, C = C, DZ = DZ, EE = EE, FI = FI, I = I,
   IE = IE, M = M, NMFI = NMFI, RR = RR, SW = SW, TE = x', U = U, V = V,
   VE = VE, Z = Z, sctlr'rst = sctlr'rst}: SCTLR

fun SCTLR_U_rupd ({A, B, BR, C, DZ, EE, FI, I, IE, M, NMFI, RR, SW, TE, U,
   V, VE, Z, sctlr'rst}: SCTLR, x') =
  {A = A, B = B, BR = BR, C = C, DZ = DZ, EE = EE, FI = FI, I = I,
   IE = IE, M = M, NMFI = NMFI, RR = RR, SW = SW, TE = TE, U = x', V = V,
   VE = VE, Z = Z, sctlr'rst = sctlr'rst}: SCTLR

fun SCTLR_V_rupd ({A, B, BR, C, DZ, EE, FI, I, IE, M, NMFI, RR, SW, TE, U,
   V, VE, Z, sctlr'rst}: SCTLR, x') =
  {A = A, B = B, BR = BR, C = C, DZ = DZ, EE = EE, FI = FI, I = I,
   IE = IE, M = M, NMFI = NMFI, RR = RR, SW = SW, TE = TE, U = U, V = x',
   VE = VE, Z = Z, sctlr'rst = sctlr'rst}: SCTLR

fun SCTLR_VE_rupd ({A, B, BR, C, DZ, EE, FI, I, IE, M, NMFI, RR, SW, TE,
   U, V, VE, Z, sctlr'rst}: SCTLR, x') =
  {A = A, B = B, BR = BR, C = C, DZ = DZ, EE = EE, FI = FI, I = I,
   IE = IE, M = M, NMFI = NMFI, RR = RR, SW = SW, TE = TE, U = U, V = V,
   VE = x', Z = Z, sctlr'rst = sctlr'rst}: SCTLR

fun SCTLR_Z_rupd ({A, B, BR, C, DZ, EE, FI, I, IE, M, NMFI, RR, SW, TE, U,
   V, VE, Z, sctlr'rst}: SCTLR, x') =
  {A = A, B = B, BR = BR, C = C, DZ = DZ, EE = EE, FI = FI, I = I,
   IE = IE, M = M, NMFI = NMFI, RR = RR, SW = SW, TE = TE, U = U, V = V,
   VE = VE, Z = x', sctlr'rst = sctlr'rst}: SCTLR

fun SCTLR_sctlr'rst_rupd ({A, B, BR, C, DZ, EE, FI, I, IE, M, NMFI, RR,
   SW, TE, U, V, VE, Z, sctlr'rst}: SCTLR, x') =
  {A = A, B = B, BR = BR, C = C, DZ = DZ, EE = EE, FI = FI, I = I,
   IE = IE, M = M, NMFI = NMFI, RR = RR, SW = SW, TE = TE, U = U, V = V,
   VE = VE, Z = Z, sctlr'rst = x'}: SCTLR

fun HSCTLR_A_rupd ({A, C, CP15BEN, EE, FI, I, M, TE, WXN, hsctlr'rst}
  : HSCTLR, x') =
  {A = x', C = C, CP15BEN = CP15BEN, EE = EE, FI = FI, I = I, M = M,
   TE = TE, WXN = WXN, hsctlr'rst = hsctlr'rst}: HSCTLR

fun HSCTLR_C_rupd ({A, C, CP15BEN, EE, FI, I, M, TE, WXN, hsctlr'rst}
  : HSCTLR, x') =
  {A = A, C = x', CP15BEN = CP15BEN, EE = EE, FI = FI, I = I, M = M,
   TE = TE, WXN = WXN, hsctlr'rst = hsctlr'rst}: HSCTLR

fun HSCTLR_CP15BEN_rupd ({A, C, CP15BEN, EE, FI, I, M, TE, WXN, hsctlr'rst}
  : HSCTLR, x') =
  {A = A, C = C, CP15BEN = x', EE = EE, FI = FI, I = I, M = M, TE = TE,
   WXN = WXN, hsctlr'rst = hsctlr'rst}: HSCTLR

fun HSCTLR_EE_rupd ({A, C, CP15BEN, EE, FI, I, M, TE, WXN, hsctlr'rst}
  : HSCTLR, x') =
  {A = A, C = C, CP15BEN = CP15BEN, EE = x', FI = FI, I = I, M = M,
   TE = TE, WXN = WXN, hsctlr'rst = hsctlr'rst}: HSCTLR

fun HSCTLR_FI_rupd ({A, C, CP15BEN, EE, FI, I, M, TE, WXN, hsctlr'rst}
  : HSCTLR, x') =
  {A = A, C = C, CP15BEN = CP15BEN, EE = EE, FI = x', I = I, M = M,
   TE = TE, WXN = WXN, hsctlr'rst = hsctlr'rst}: HSCTLR

fun HSCTLR_I_rupd ({A, C, CP15BEN, EE, FI, I, M, TE, WXN, hsctlr'rst}
  : HSCTLR, x') =
  {A = A, C = C, CP15BEN = CP15BEN, EE = EE, FI = FI, I = x', M = M,
   TE = TE, WXN = WXN, hsctlr'rst = hsctlr'rst}: HSCTLR

fun HSCTLR_M_rupd ({A, C, CP15BEN, EE, FI, I, M, TE, WXN, hsctlr'rst}
  : HSCTLR, x') =
  {A = A, C = C, CP15BEN = CP15BEN, EE = EE, FI = FI, I = I, M = x',
   TE = TE, WXN = WXN, hsctlr'rst = hsctlr'rst}: HSCTLR

fun HSCTLR_TE_rupd ({A, C, CP15BEN, EE, FI, I, M, TE, WXN, hsctlr'rst}
  : HSCTLR, x') =
  {A = A, C = C, CP15BEN = CP15BEN, EE = EE, FI = FI, I = I, M = M,
   TE = x', WXN = WXN, hsctlr'rst = hsctlr'rst}: HSCTLR

fun HSCTLR_WXN_rupd ({A, C, CP15BEN, EE, FI, I, M, TE, WXN, hsctlr'rst}
  : HSCTLR, x') =
  {A = A, C = C, CP15BEN = CP15BEN, EE = EE, FI = FI, I = I, M = M,
   TE = TE, WXN = x', hsctlr'rst = hsctlr'rst}: HSCTLR

fun HSCTLR_hsctlr'rst_rupd ({A, C, CP15BEN, EE, FI, I, M, TE, WXN,
   hsctlr'rst}: HSCTLR, x') =
  {A = A, C = C, CP15BEN = CP15BEN, EE = EE, FI = FI, I = I, M = M,
   TE = TE, WXN = WXN, hsctlr'rst = x'}: HSCTLR

fun HSR_EC_rupd ({EC, IL, ISS}: HSR, x') = {EC = x', IL = IL, ISS = ISS}
  : HSR

fun HSR_IL_rupd ({EC, IL, ISS}: HSR, x') = {EC = EC, IL = x', ISS = ISS}
  : HSR

fun HSR_ISS_rupd ({EC, IL, ISS}: HSR, x') = {EC = EC, IL = IL, ISS = x'}
  : HSR

fun SCR_AW_rupd ({AW, EA, FIQ, FW, HCE, IRQ, NS, SCD, SIF, nET, scr'rst}
  : SCR, x') =
  {AW = x', EA = EA, FIQ = FIQ, FW = FW, HCE = HCE, IRQ = IRQ, NS = NS,
   SCD = SCD, SIF = SIF, nET = nET, scr'rst = scr'rst}: SCR

fun SCR_EA_rupd ({AW, EA, FIQ, FW, HCE, IRQ, NS, SCD, SIF, nET, scr'rst}
  : SCR, x') =
  {AW = AW, EA = x', FIQ = FIQ, FW = FW, HCE = HCE, IRQ = IRQ, NS = NS,
   SCD = SCD, SIF = SIF, nET = nET, scr'rst = scr'rst}: SCR

fun SCR_FIQ_rupd ({AW, EA, FIQ, FW, HCE, IRQ, NS, SCD, SIF, nET, scr'rst}
  : SCR, x') =
  {AW = AW, EA = EA, FIQ = x', FW = FW, HCE = HCE, IRQ = IRQ, NS = NS,
   SCD = SCD, SIF = SIF, nET = nET, scr'rst = scr'rst}: SCR

fun SCR_FW_rupd ({AW, EA, FIQ, FW, HCE, IRQ, NS, SCD, SIF, nET, scr'rst}
  : SCR, x') =
  {AW = AW, EA = EA, FIQ = FIQ, FW = x', HCE = HCE, IRQ = IRQ, NS = NS,
   SCD = SCD, SIF = SIF, nET = nET, scr'rst = scr'rst}: SCR

fun SCR_HCE_rupd ({AW, EA, FIQ, FW, HCE, IRQ, NS, SCD, SIF, nET, scr'rst}
  : SCR, x') =
  {AW = AW, EA = EA, FIQ = FIQ, FW = FW, HCE = x', IRQ = IRQ, NS = NS,
   SCD = SCD, SIF = SIF, nET = nET, scr'rst = scr'rst}: SCR

fun SCR_IRQ_rupd ({AW, EA, FIQ, FW, HCE, IRQ, NS, SCD, SIF, nET, scr'rst}
  : SCR, x') =
  {AW = AW, EA = EA, FIQ = FIQ, FW = FW, HCE = HCE, IRQ = x', NS = NS,
   SCD = SCD, SIF = SIF, nET = nET, scr'rst = scr'rst}: SCR

fun SCR_NS_rupd ({AW, EA, FIQ, FW, HCE, IRQ, NS, SCD, SIF, nET, scr'rst}
  : SCR, x') =
  {AW = AW, EA = EA, FIQ = FIQ, FW = FW, HCE = HCE, IRQ = IRQ, NS = x',
   SCD = SCD, SIF = SIF, nET = nET, scr'rst = scr'rst}: SCR

fun SCR_SCD_rupd ({AW, EA, FIQ, FW, HCE, IRQ, NS, SCD, SIF, nET, scr'rst}
  : SCR, x') =
  {AW = AW, EA = EA, FIQ = FIQ, FW = FW, HCE = HCE, IRQ = IRQ, NS = NS,
   SCD = x', SIF = SIF, nET = nET, scr'rst = scr'rst}: SCR

fun SCR_SIF_rupd ({AW, EA, FIQ, FW, HCE, IRQ, NS, SCD, SIF, nET, scr'rst}
  : SCR, x') =
  {AW = AW, EA = EA, FIQ = FIQ, FW = FW, HCE = HCE, IRQ = IRQ, NS = NS,
   SCD = SCD, SIF = x', nET = nET, scr'rst = scr'rst}: SCR

fun SCR_nET_rupd ({AW, EA, FIQ, FW, HCE, IRQ, NS, SCD, SIF, nET, scr'rst}
  : SCR, x') =
  {AW = AW, EA = EA, FIQ = FIQ, FW = FW, HCE = HCE, IRQ = IRQ, NS = NS,
   SCD = SCD, SIF = SIF, nET = x', scr'rst = scr'rst}: SCR

fun SCR_scr'rst_rupd ({AW, EA, FIQ, FW, HCE, IRQ, NS, SCD, SIF, nET,
   scr'rst}: SCR, x') =
  {AW = AW, EA = EA, FIQ = FIQ, FW = FW, HCE = HCE, IRQ = IRQ, NS = NS,
   SCD = SCD, SIF = SIF, nET = nET, scr'rst = x'}: SCR

fun NSACR_NSASEDIS_rupd ({NSASEDIS, NSD32DIS, NSTRCDIS, RFR, cp, nsacr'rst}
  : NSACR, x') =
  {NSASEDIS = x', NSD32DIS = NSD32DIS, NSTRCDIS = NSTRCDIS, RFR = RFR,
   cp = cp, nsacr'rst = nsacr'rst}: NSACR

fun NSACR_NSD32DIS_rupd ({NSASEDIS, NSD32DIS, NSTRCDIS, RFR, cp, nsacr'rst}
  : NSACR, x') =
  {NSASEDIS = NSASEDIS, NSD32DIS = x', NSTRCDIS = NSTRCDIS, RFR = RFR,
   cp = cp, nsacr'rst = nsacr'rst}: NSACR

fun NSACR_NSTRCDIS_rupd ({NSASEDIS, NSD32DIS, NSTRCDIS, RFR, cp, nsacr'rst}
  : NSACR, x') =
  {NSASEDIS = NSASEDIS, NSD32DIS = NSD32DIS, NSTRCDIS = x', RFR = RFR,
   cp = cp, nsacr'rst = nsacr'rst}: NSACR

fun NSACR_RFR_rupd ({NSASEDIS, NSD32DIS, NSTRCDIS, RFR, cp, nsacr'rst}
  : NSACR, x') =
  {NSASEDIS = NSASEDIS, NSD32DIS = NSD32DIS, NSTRCDIS = NSTRCDIS,
   RFR = x', cp = cp, nsacr'rst = nsacr'rst}: NSACR

fun NSACR_cp_rupd ({NSASEDIS, NSD32DIS, NSTRCDIS, RFR, cp, nsacr'rst}
  : NSACR, x') =
  {NSASEDIS = NSASEDIS, NSD32DIS = NSD32DIS, NSTRCDIS = NSTRCDIS,
   RFR = RFR, cp = x', nsacr'rst = nsacr'rst}: NSACR

fun NSACR_nsacr'rst_rupd ({NSASEDIS, NSD32DIS, NSTRCDIS, RFR, cp,
   nsacr'rst}: NSACR, x') =
  {NSASEDIS = NSASEDIS, NSD32DIS = NSD32DIS, NSTRCDIS = NSTRCDIS,
   RFR = RFR, cp = cp, nsacr'rst = x'}: NSACR

fun HCR_AMO_rupd ({AMO, BSU, DC, FB, FMO, IMO, PTW, SWIO, TAC, TGE, TID,
   TIDCP, TPC, TPU, TSC, TSW, TTLB, TVM, TWE, TWI, VA, VF, VI, VM, hcr'rst}
  : HCR, x') =
  {AMO = x', BSU = BSU, DC = DC, FB = FB, FMO = FMO, IMO = IMO, PTW = PTW,
   SWIO = SWIO, TAC = TAC, TGE = TGE, TID = TID, TIDCP = TIDCP, TPC = TPC,
   TPU = TPU, TSC = TSC, TSW = TSW, TTLB = TTLB, TVM = TVM, TWE = TWE,
   TWI = TWI, VA = VA, VF = VF, VI = VI, VM = VM, hcr'rst = hcr'rst}: HCR

fun HCR_BSU_rupd ({AMO, BSU, DC, FB, FMO, IMO, PTW, SWIO, TAC, TGE, TID,
   TIDCP, TPC, TPU, TSC, TSW, TTLB, TVM, TWE, TWI, VA, VF, VI, VM, hcr'rst}
  : HCR, x') =
  {AMO = AMO, BSU = x', DC = DC, FB = FB, FMO = FMO, IMO = IMO, PTW = PTW,
   SWIO = SWIO, TAC = TAC, TGE = TGE, TID = TID, TIDCP = TIDCP, TPC = TPC,
   TPU = TPU, TSC = TSC, TSW = TSW, TTLB = TTLB, TVM = TVM, TWE = TWE,
   TWI = TWI, VA = VA, VF = VF, VI = VI, VM = VM, hcr'rst = hcr'rst}: HCR

fun HCR_DC_rupd ({AMO, BSU, DC, FB, FMO, IMO, PTW, SWIO, TAC, TGE, TID,
   TIDCP, TPC, TPU, TSC, TSW, TTLB, TVM, TWE, TWI, VA, VF, VI, VM, hcr'rst}
  : HCR, x') =
  {AMO = AMO, BSU = BSU, DC = x', FB = FB, FMO = FMO, IMO = IMO,
   PTW = PTW, SWIO = SWIO, TAC = TAC, TGE = TGE, TID = TID, TIDCP = TIDCP,
   TPC = TPC, TPU = TPU, TSC = TSC, TSW = TSW, TTLB = TTLB, TVM = TVM,
   TWE = TWE, TWI = TWI, VA = VA, VF = VF, VI = VI, VM = VM,
   hcr'rst = hcr'rst}: HCR

fun HCR_FB_rupd ({AMO, BSU, DC, FB, FMO, IMO, PTW, SWIO, TAC, TGE, TID,
   TIDCP, TPC, TPU, TSC, TSW, TTLB, TVM, TWE, TWI, VA, VF, VI, VM, hcr'rst}
  : HCR, x') =
  {AMO = AMO, BSU = BSU, DC = DC, FB = x', FMO = FMO, IMO = IMO,
   PTW = PTW, SWIO = SWIO, TAC = TAC, TGE = TGE, TID = TID, TIDCP = TIDCP,
   TPC = TPC, TPU = TPU, TSC = TSC, TSW = TSW, TTLB = TTLB, TVM = TVM,
   TWE = TWE, TWI = TWI, VA = VA, VF = VF, VI = VI, VM = VM,
   hcr'rst = hcr'rst}: HCR

fun HCR_FMO_rupd ({AMO, BSU, DC, FB, FMO, IMO, PTW, SWIO, TAC, TGE, TID,
   TIDCP, TPC, TPU, TSC, TSW, TTLB, TVM, TWE, TWI, VA, VF, VI, VM, hcr'rst}
  : HCR, x') =
  {AMO = AMO, BSU = BSU, DC = DC, FB = FB, FMO = x', IMO = IMO, PTW = PTW,
   SWIO = SWIO, TAC = TAC, TGE = TGE, TID = TID, TIDCP = TIDCP, TPC = TPC,
   TPU = TPU, TSC = TSC, TSW = TSW, TTLB = TTLB, TVM = TVM, TWE = TWE,
   TWI = TWI, VA = VA, VF = VF, VI = VI, VM = VM, hcr'rst = hcr'rst}: HCR

fun HCR_IMO_rupd ({AMO, BSU, DC, FB, FMO, IMO, PTW, SWIO, TAC, TGE, TID,
   TIDCP, TPC, TPU, TSC, TSW, TTLB, TVM, TWE, TWI, VA, VF, VI, VM, hcr'rst}
  : HCR, x') =
  {AMO = AMO, BSU = BSU, DC = DC, FB = FB, FMO = FMO, IMO = x', PTW = PTW,
   SWIO = SWIO, TAC = TAC, TGE = TGE, TID = TID, TIDCP = TIDCP, TPC = TPC,
   TPU = TPU, TSC = TSC, TSW = TSW, TTLB = TTLB, TVM = TVM, TWE = TWE,
   TWI = TWI, VA = VA, VF = VF, VI = VI, VM = VM, hcr'rst = hcr'rst}: HCR

fun HCR_PTW_rupd ({AMO, BSU, DC, FB, FMO, IMO, PTW, SWIO, TAC, TGE, TID,
   TIDCP, TPC, TPU, TSC, TSW, TTLB, TVM, TWE, TWI, VA, VF, VI, VM, hcr'rst}
  : HCR, x') =
  {AMO = AMO, BSU = BSU, DC = DC, FB = FB, FMO = FMO, IMO = IMO, PTW = x',
   SWIO = SWIO, TAC = TAC, TGE = TGE, TID = TID, TIDCP = TIDCP, TPC = TPC,
   TPU = TPU, TSC = TSC, TSW = TSW, TTLB = TTLB, TVM = TVM, TWE = TWE,
   TWI = TWI, VA = VA, VF = VF, VI = VI, VM = VM, hcr'rst = hcr'rst}: HCR

fun HCR_SWIO_rupd ({AMO, BSU, DC, FB, FMO, IMO, PTW, SWIO, TAC, TGE, TID,
   TIDCP, TPC, TPU, TSC, TSW, TTLB, TVM, TWE, TWI, VA, VF, VI, VM, hcr'rst}
  : HCR, x') =
  {AMO = AMO, BSU = BSU, DC = DC, FB = FB, FMO = FMO, IMO = IMO,
   PTW = PTW, SWIO = x', TAC = TAC, TGE = TGE, TID = TID, TIDCP = TIDCP,
   TPC = TPC, TPU = TPU, TSC = TSC, TSW = TSW, TTLB = TTLB, TVM = TVM,
   TWE = TWE, TWI = TWI, VA = VA, VF = VF, VI = VI, VM = VM,
   hcr'rst = hcr'rst}: HCR

fun HCR_TAC_rupd ({AMO, BSU, DC, FB, FMO, IMO, PTW, SWIO, TAC, TGE, TID,
   TIDCP, TPC, TPU, TSC, TSW, TTLB, TVM, TWE, TWI, VA, VF, VI, VM, hcr'rst}
  : HCR, x') =
  {AMO = AMO, BSU = BSU, DC = DC, FB = FB, FMO = FMO, IMO = IMO,
   PTW = PTW, SWIO = SWIO, TAC = x', TGE = TGE, TID = TID, TIDCP = TIDCP,
   TPC = TPC, TPU = TPU, TSC = TSC, TSW = TSW, TTLB = TTLB, TVM = TVM,
   TWE = TWE, TWI = TWI, VA = VA, VF = VF, VI = VI, VM = VM,
   hcr'rst = hcr'rst}: HCR

fun HCR_TGE_rupd ({AMO, BSU, DC, FB, FMO, IMO, PTW, SWIO, TAC, TGE, TID,
   TIDCP, TPC, TPU, TSC, TSW, TTLB, TVM, TWE, TWI, VA, VF, VI, VM, hcr'rst}
  : HCR, x') =
  {AMO = AMO, BSU = BSU, DC = DC, FB = FB, FMO = FMO, IMO = IMO,
   PTW = PTW, SWIO = SWIO, TAC = TAC, TGE = x', TID = TID, TIDCP = TIDCP,
   TPC = TPC, TPU = TPU, TSC = TSC, TSW = TSW, TTLB = TTLB, TVM = TVM,
   TWE = TWE, TWI = TWI, VA = VA, VF = VF, VI = VI, VM = VM,
   hcr'rst = hcr'rst}: HCR

fun HCR_TID_rupd ({AMO, BSU, DC, FB, FMO, IMO, PTW, SWIO, TAC, TGE, TID,
   TIDCP, TPC, TPU, TSC, TSW, TTLB, TVM, TWE, TWI, VA, VF, VI, VM, hcr'rst}
  : HCR, x') =
  {AMO = AMO, BSU = BSU, DC = DC, FB = FB, FMO = FMO, IMO = IMO,
   PTW = PTW, SWIO = SWIO, TAC = TAC, TGE = TGE, TID = x', TIDCP = TIDCP,
   TPC = TPC, TPU = TPU, TSC = TSC, TSW = TSW, TTLB = TTLB, TVM = TVM,
   TWE = TWE, TWI = TWI, VA = VA, VF = VF, VI = VI, VM = VM,
   hcr'rst = hcr'rst}: HCR

fun HCR_TIDCP_rupd ({AMO, BSU, DC, FB, FMO, IMO, PTW, SWIO, TAC, TGE, TID,
   TIDCP, TPC, TPU, TSC, TSW, TTLB, TVM, TWE, TWI, VA, VF, VI, VM, hcr'rst}
  : HCR, x') =
  {AMO = AMO, BSU = BSU, DC = DC, FB = FB, FMO = FMO, IMO = IMO,
   PTW = PTW, SWIO = SWIO, TAC = TAC, TGE = TGE, TID = TID, TIDCP = x',
   TPC = TPC, TPU = TPU, TSC = TSC, TSW = TSW, TTLB = TTLB, TVM = TVM,
   TWE = TWE, TWI = TWI, VA = VA, VF = VF, VI = VI, VM = VM,
   hcr'rst = hcr'rst}: HCR

fun HCR_TPC_rupd ({AMO, BSU, DC, FB, FMO, IMO, PTW, SWIO, TAC, TGE, TID,
   TIDCP, TPC, TPU, TSC, TSW, TTLB, TVM, TWE, TWI, VA, VF, VI, VM, hcr'rst}
  : HCR, x') =
  {AMO = AMO, BSU = BSU, DC = DC, FB = FB, FMO = FMO, IMO = IMO,
   PTW = PTW, SWIO = SWIO, TAC = TAC, TGE = TGE, TID = TID, TIDCP = TIDCP,
   TPC = x', TPU = TPU, TSC = TSC, TSW = TSW, TTLB = TTLB, TVM = TVM,
   TWE = TWE, TWI = TWI, VA = VA, VF = VF, VI = VI, VM = VM,
   hcr'rst = hcr'rst}: HCR

fun HCR_TPU_rupd ({AMO, BSU, DC, FB, FMO, IMO, PTW, SWIO, TAC, TGE, TID,
   TIDCP, TPC, TPU, TSC, TSW, TTLB, TVM, TWE, TWI, VA, VF, VI, VM, hcr'rst}
  : HCR, x') =
  {AMO = AMO, BSU = BSU, DC = DC, FB = FB, FMO = FMO, IMO = IMO,
   PTW = PTW, SWIO = SWIO, TAC = TAC, TGE = TGE, TID = TID, TIDCP = TIDCP,
   TPC = TPC, TPU = x', TSC = TSC, TSW = TSW, TTLB = TTLB, TVM = TVM,
   TWE = TWE, TWI = TWI, VA = VA, VF = VF, VI = VI, VM = VM,
   hcr'rst = hcr'rst}: HCR

fun HCR_TSC_rupd ({AMO, BSU, DC, FB, FMO, IMO, PTW, SWIO, TAC, TGE, TID,
   TIDCP, TPC, TPU, TSC, TSW, TTLB, TVM, TWE, TWI, VA, VF, VI, VM, hcr'rst}
  : HCR, x') =
  {AMO = AMO, BSU = BSU, DC = DC, FB = FB, FMO = FMO, IMO = IMO,
   PTW = PTW, SWIO = SWIO, TAC = TAC, TGE = TGE, TID = TID, TIDCP = TIDCP,
   TPC = TPC, TPU = TPU, TSC = x', TSW = TSW, TTLB = TTLB, TVM = TVM,
   TWE = TWE, TWI = TWI, VA = VA, VF = VF, VI = VI, VM = VM,
   hcr'rst = hcr'rst}: HCR

fun HCR_TSW_rupd ({AMO, BSU, DC, FB, FMO, IMO, PTW, SWIO, TAC, TGE, TID,
   TIDCP, TPC, TPU, TSC, TSW, TTLB, TVM, TWE, TWI, VA, VF, VI, VM, hcr'rst}
  : HCR, x') =
  {AMO = AMO, BSU = BSU, DC = DC, FB = FB, FMO = FMO, IMO = IMO,
   PTW = PTW, SWIO = SWIO, TAC = TAC, TGE = TGE, TID = TID, TIDCP = TIDCP,
   TPC = TPC, TPU = TPU, TSC = TSC, TSW = x', TTLB = TTLB, TVM = TVM,
   TWE = TWE, TWI = TWI, VA = VA, VF = VF, VI = VI, VM = VM,
   hcr'rst = hcr'rst}: HCR

fun HCR_TTLB_rupd ({AMO, BSU, DC, FB, FMO, IMO, PTW, SWIO, TAC, TGE, TID,
   TIDCP, TPC, TPU, TSC, TSW, TTLB, TVM, TWE, TWI, VA, VF, VI, VM, hcr'rst}
  : HCR, x') =
  {AMO = AMO, BSU = BSU, DC = DC, FB = FB, FMO = FMO, IMO = IMO,
   PTW = PTW, SWIO = SWIO, TAC = TAC, TGE = TGE, TID = TID, TIDCP = TIDCP,
   TPC = TPC, TPU = TPU, TSC = TSC, TSW = TSW, TTLB = x', TVM = TVM,
   TWE = TWE, TWI = TWI, VA = VA, VF = VF, VI = VI, VM = VM,
   hcr'rst = hcr'rst}: HCR

fun HCR_TVM_rupd ({AMO, BSU, DC, FB, FMO, IMO, PTW, SWIO, TAC, TGE, TID,
   TIDCP, TPC, TPU, TSC, TSW, TTLB, TVM, TWE, TWI, VA, VF, VI, VM, hcr'rst}
  : HCR, x') =
  {AMO = AMO, BSU = BSU, DC = DC, FB = FB, FMO = FMO, IMO = IMO,
   PTW = PTW, SWIO = SWIO, TAC = TAC, TGE = TGE, TID = TID, TIDCP = TIDCP,
   TPC = TPC, TPU = TPU, TSC = TSC, TSW = TSW, TTLB = TTLB, TVM = x',
   TWE = TWE, TWI = TWI, VA = VA, VF = VF, VI = VI, VM = VM,
   hcr'rst = hcr'rst}: HCR

fun HCR_TWE_rupd ({AMO, BSU, DC, FB, FMO, IMO, PTW, SWIO, TAC, TGE, TID,
   TIDCP, TPC, TPU, TSC, TSW, TTLB, TVM, TWE, TWI, VA, VF, VI, VM, hcr'rst}
  : HCR, x') =
  {AMO = AMO, BSU = BSU, DC = DC, FB = FB, FMO = FMO, IMO = IMO,
   PTW = PTW, SWIO = SWIO, TAC = TAC, TGE = TGE, TID = TID, TIDCP = TIDCP,
   TPC = TPC, TPU = TPU, TSC = TSC, TSW = TSW, TTLB = TTLB, TVM = TVM,
   TWE = x', TWI = TWI, VA = VA, VF = VF, VI = VI, VM = VM,
   hcr'rst = hcr'rst}: HCR

fun HCR_TWI_rupd ({AMO, BSU, DC, FB, FMO, IMO, PTW, SWIO, TAC, TGE, TID,
   TIDCP, TPC, TPU, TSC, TSW, TTLB, TVM, TWE, TWI, VA, VF, VI, VM, hcr'rst}
  : HCR, x') =
  {AMO = AMO, BSU = BSU, DC = DC, FB = FB, FMO = FMO, IMO = IMO,
   PTW = PTW, SWIO = SWIO, TAC = TAC, TGE = TGE, TID = TID, TIDCP = TIDCP,
   TPC = TPC, TPU = TPU, TSC = TSC, TSW = TSW, TTLB = TTLB, TVM = TVM,
   TWE = TWE, TWI = x', VA = VA, VF = VF, VI = VI, VM = VM,
   hcr'rst = hcr'rst}: HCR

fun HCR_VA_rupd ({AMO, BSU, DC, FB, FMO, IMO, PTW, SWIO, TAC, TGE, TID,
   TIDCP, TPC, TPU, TSC, TSW, TTLB, TVM, TWE, TWI, VA, VF, VI, VM, hcr'rst}
  : HCR, x') =
  {AMO = AMO, BSU = BSU, DC = DC, FB = FB, FMO = FMO, IMO = IMO,
   PTW = PTW, SWIO = SWIO, TAC = TAC, TGE = TGE, TID = TID, TIDCP = TIDCP,
   TPC = TPC, TPU = TPU, TSC = TSC, TSW = TSW, TTLB = TTLB, TVM = TVM,
   TWE = TWE, TWI = TWI, VA = x', VF = VF, VI = VI, VM = VM,
   hcr'rst = hcr'rst}: HCR

fun HCR_VF_rupd ({AMO, BSU, DC, FB, FMO, IMO, PTW, SWIO, TAC, TGE, TID,
   TIDCP, TPC, TPU, TSC, TSW, TTLB, TVM, TWE, TWI, VA, VF, VI, VM, hcr'rst}
  : HCR, x') =
  {AMO = AMO, BSU = BSU, DC = DC, FB = FB, FMO = FMO, IMO = IMO,
   PTW = PTW, SWIO = SWIO, TAC = TAC, TGE = TGE, TID = TID, TIDCP = TIDCP,
   TPC = TPC, TPU = TPU, TSC = TSC, TSW = TSW, TTLB = TTLB, TVM = TVM,
   TWE = TWE, TWI = TWI, VA = VA, VF = x', VI = VI, VM = VM,
   hcr'rst = hcr'rst}: HCR

fun HCR_VI_rupd ({AMO, BSU, DC, FB, FMO, IMO, PTW, SWIO, TAC, TGE, TID,
   TIDCP, TPC, TPU, TSC, TSW, TTLB, TVM, TWE, TWI, VA, VF, VI, VM, hcr'rst}
  : HCR, x') =
  {AMO = AMO, BSU = BSU, DC = DC, FB = FB, FMO = FMO, IMO = IMO,
   PTW = PTW, SWIO = SWIO, TAC = TAC, TGE = TGE, TID = TID, TIDCP = TIDCP,
   TPC = TPC, TPU = TPU, TSC = TSC, TSW = TSW, TTLB = TTLB, TVM = TVM,
   TWE = TWE, TWI = TWI, VA = VA, VF = VF, VI = x', VM = VM,
   hcr'rst = hcr'rst}: HCR

fun HCR_VM_rupd ({AMO, BSU, DC, FB, FMO, IMO, PTW, SWIO, TAC, TGE, TID,
   TIDCP, TPC, TPU, TSC, TSW, TTLB, TVM, TWE, TWI, VA, VF, VI, VM, hcr'rst}
  : HCR, x') =
  {AMO = AMO, BSU = BSU, DC = DC, FB = FB, FMO = FMO, IMO = IMO,
   PTW = PTW, SWIO = SWIO, TAC = TAC, TGE = TGE, TID = TID, TIDCP = TIDCP,
   TPC = TPC, TPU = TPU, TSC = TSC, TSW = TSW, TTLB = TTLB, TVM = TVM,
   TWE = TWE, TWI = TWI, VA = VA, VF = VF, VI = VI, VM = x',
   hcr'rst = hcr'rst}: HCR

fun HCR_hcr'rst_rupd ({AMO, BSU, DC, FB, FMO, IMO, PTW, SWIO, TAC, TGE,
   TID, TIDCP, TPC, TPU, TSC, TSW, TTLB, TVM, TWE, TWI, VA, VF, VI, VM,
   hcr'rst}: HCR, x') =
  {AMO = AMO, BSU = BSU, DC = DC, FB = FB, FMO = FMO, IMO = IMO,
   PTW = PTW, SWIO = SWIO, TAC = TAC, TGE = TGE, TID = TID, TIDCP = TIDCP,
   TPC = TPC, TPU = TPU, TSC = TSC, TSW = TSW, TTLB = TTLB, TVM = TVM,
   TWE = TWE, TWI = TWI, VA = VA, VF = VF, VI = VI, VM = VM, hcr'rst = x'}
  : HCR

fun CP15_HCR_rupd ({HCR, HSCTLR, HSR, MVBAR, NSACR, SCR, SCTLR, VBAR}
  : CP15, x') =
  {HCR = x', HSCTLR = HSCTLR, HSR = HSR, MVBAR = MVBAR, NSACR = NSACR,
   SCR = SCR, SCTLR = SCTLR, VBAR = VBAR}: CP15

fun CP15_HSCTLR_rupd ({HCR, HSCTLR, HSR, MVBAR, NSACR, SCR, SCTLR, VBAR}
  : CP15, x') =
  {HCR = HCR, HSCTLR = x', HSR = HSR, MVBAR = MVBAR, NSACR = NSACR,
   SCR = SCR, SCTLR = SCTLR, VBAR = VBAR}: CP15

fun CP15_HSR_rupd ({HCR, HSCTLR, HSR, MVBAR, NSACR, SCR, SCTLR, VBAR}
  : CP15, x') =
  {HCR = HCR, HSCTLR = HSCTLR, HSR = x', MVBAR = MVBAR, NSACR = NSACR,
   SCR = SCR, SCTLR = SCTLR, VBAR = VBAR}: CP15

fun CP15_MVBAR_rupd ({HCR, HSCTLR, HSR, MVBAR, NSACR, SCR, SCTLR, VBAR}
  : CP15, x') =
  {HCR = HCR, HSCTLR = HSCTLR, HSR = HSR, MVBAR = x', NSACR = NSACR,
   SCR = SCR, SCTLR = SCTLR, VBAR = VBAR}: CP15

fun CP15_NSACR_rupd ({HCR, HSCTLR, HSR, MVBAR, NSACR, SCR, SCTLR, VBAR}
  : CP15, x') =
  {HCR = HCR, HSCTLR = HSCTLR, HSR = HSR, MVBAR = MVBAR, NSACR = x',
   SCR = SCR, SCTLR = SCTLR, VBAR = VBAR}: CP15

fun CP15_SCR_rupd ({HCR, HSCTLR, HSR, MVBAR, NSACR, SCR, SCTLR, VBAR}
  : CP15, x') =
  {HCR = HCR, HSCTLR = HSCTLR, HSR = HSR, MVBAR = MVBAR, NSACR = NSACR,
   SCR = x', SCTLR = SCTLR, VBAR = VBAR}: CP15

fun CP15_SCTLR_rupd ({HCR, HSCTLR, HSR, MVBAR, NSACR, SCR, SCTLR, VBAR}
  : CP15, x') =
  {HCR = HCR, HSCTLR = HSCTLR, HSR = HSR, MVBAR = MVBAR, NSACR = NSACR,
   SCR = SCR, SCTLR = x', VBAR = VBAR}: CP15

fun CP15_VBAR_rupd ({HCR, HSCTLR, HSR, MVBAR, NSACR, SCR, SCTLR, VBAR}
  : CP15, x') =
  {HCR = HCR, HSCTLR = HSCTLR, HSR = HSR, MVBAR = MVBAR, NSACR = NSACR,
   SCR = SCR, SCTLR = SCTLR, VBAR = x'}: CP15

fun FPSCR_AHP_rupd ({AHP, C, DN, DZC, DZE, FZ, IDC, IDE, IOC, IOE, IXC,
   IXE, N, OFC, OFE, QC, RMode, UFC, UFE, V, Z, fpscr'rst}: FPSCR, x') =
  {AHP = x', C = C, DN = DN, DZC = DZC, DZE = DZE, FZ = FZ, IDC = IDC,
   IDE = IDE, IOC = IOC, IOE = IOE, IXC = IXC, IXE = IXE, N = N,
   OFC = OFC, OFE = OFE, QC = QC, RMode = RMode, UFC = UFC, UFE = UFE,
   V = V, Z = Z, fpscr'rst = fpscr'rst}: FPSCR

fun FPSCR_C_rupd ({AHP, C, DN, DZC, DZE, FZ, IDC, IDE, IOC, IOE, IXC, IXE,
   N, OFC, OFE, QC, RMode, UFC, UFE, V, Z, fpscr'rst}: FPSCR, x') =
  {AHP = AHP, C = x', DN = DN, DZC = DZC, DZE = DZE, FZ = FZ, IDC = IDC,
   IDE = IDE, IOC = IOC, IOE = IOE, IXC = IXC, IXE = IXE, N = N,
   OFC = OFC, OFE = OFE, QC = QC, RMode = RMode, UFC = UFC, UFE = UFE,
   V = V, Z = Z, fpscr'rst = fpscr'rst}: FPSCR

fun FPSCR_DN_rupd ({AHP, C, DN, DZC, DZE, FZ, IDC, IDE, IOC, IOE, IXC,
   IXE, N, OFC, OFE, QC, RMode, UFC, UFE, V, Z, fpscr'rst}: FPSCR, x') =
  {AHP = AHP, C = C, DN = x', DZC = DZC, DZE = DZE, FZ = FZ, IDC = IDC,
   IDE = IDE, IOC = IOC, IOE = IOE, IXC = IXC, IXE = IXE, N = N,
   OFC = OFC, OFE = OFE, QC = QC, RMode = RMode, UFC = UFC, UFE = UFE,
   V = V, Z = Z, fpscr'rst = fpscr'rst}: FPSCR

fun FPSCR_DZC_rupd ({AHP, C, DN, DZC, DZE, FZ, IDC, IDE, IOC, IOE, IXC,
   IXE, N, OFC, OFE, QC, RMode, UFC, UFE, V, Z, fpscr'rst}: FPSCR, x') =
  {AHP = AHP, C = C, DN = DN, DZC = x', DZE = DZE, FZ = FZ, IDC = IDC,
   IDE = IDE, IOC = IOC, IOE = IOE, IXC = IXC, IXE = IXE, N = N,
   OFC = OFC, OFE = OFE, QC = QC, RMode = RMode, UFC = UFC, UFE = UFE,
   V = V, Z = Z, fpscr'rst = fpscr'rst}: FPSCR

fun FPSCR_DZE_rupd ({AHP, C, DN, DZC, DZE, FZ, IDC, IDE, IOC, IOE, IXC,
   IXE, N, OFC, OFE, QC, RMode, UFC, UFE, V, Z, fpscr'rst}: FPSCR, x') =
  {AHP = AHP, C = C, DN = DN, DZC = DZC, DZE = x', FZ = FZ, IDC = IDC,
   IDE = IDE, IOC = IOC, IOE = IOE, IXC = IXC, IXE = IXE, N = N,
   OFC = OFC, OFE = OFE, QC = QC, RMode = RMode, UFC = UFC, UFE = UFE,
   V = V, Z = Z, fpscr'rst = fpscr'rst}: FPSCR

fun FPSCR_FZ_rupd ({AHP, C, DN, DZC, DZE, FZ, IDC, IDE, IOC, IOE, IXC,
   IXE, N, OFC, OFE, QC, RMode, UFC, UFE, V, Z, fpscr'rst}: FPSCR, x') =
  {AHP = AHP, C = C, DN = DN, DZC = DZC, DZE = DZE, FZ = x', IDC = IDC,
   IDE = IDE, IOC = IOC, IOE = IOE, IXC = IXC, IXE = IXE, N = N,
   OFC = OFC, OFE = OFE, QC = QC, RMode = RMode, UFC = UFC, UFE = UFE,
   V = V, Z = Z, fpscr'rst = fpscr'rst}: FPSCR

fun FPSCR_IDC_rupd ({AHP, C, DN, DZC, DZE, FZ, IDC, IDE, IOC, IOE, IXC,
   IXE, N, OFC, OFE, QC, RMode, UFC, UFE, V, Z, fpscr'rst}: FPSCR, x') =
  {AHP = AHP, C = C, DN = DN, DZC = DZC, DZE = DZE, FZ = FZ, IDC = x',
   IDE = IDE, IOC = IOC, IOE = IOE, IXC = IXC, IXE = IXE, N = N,
   OFC = OFC, OFE = OFE, QC = QC, RMode = RMode, UFC = UFC, UFE = UFE,
   V = V, Z = Z, fpscr'rst = fpscr'rst}: FPSCR

fun FPSCR_IDE_rupd ({AHP, C, DN, DZC, DZE, FZ, IDC, IDE, IOC, IOE, IXC,
   IXE, N, OFC, OFE, QC, RMode, UFC, UFE, V, Z, fpscr'rst}: FPSCR, x') =
  {AHP = AHP, C = C, DN = DN, DZC = DZC, DZE = DZE, FZ = FZ, IDC = IDC,
   IDE = x', IOC = IOC, IOE = IOE, IXC = IXC, IXE = IXE, N = N, OFC = OFC,
   OFE = OFE, QC = QC, RMode = RMode, UFC = UFC, UFE = UFE, V = V, Z = Z,
   fpscr'rst = fpscr'rst}: FPSCR

fun FPSCR_IOC_rupd ({AHP, C, DN, DZC, DZE, FZ, IDC, IDE, IOC, IOE, IXC,
   IXE, N, OFC, OFE, QC, RMode, UFC, UFE, V, Z, fpscr'rst}: FPSCR, x') =
  {AHP = AHP, C = C, DN = DN, DZC = DZC, DZE = DZE, FZ = FZ, IDC = IDC,
   IDE = IDE, IOC = x', IOE = IOE, IXC = IXC, IXE = IXE, N = N, OFC = OFC,
   OFE = OFE, QC = QC, RMode = RMode, UFC = UFC, UFE = UFE, V = V, Z = Z,
   fpscr'rst = fpscr'rst}: FPSCR

fun FPSCR_IOE_rupd ({AHP, C, DN, DZC, DZE, FZ, IDC, IDE, IOC, IOE, IXC,
   IXE, N, OFC, OFE, QC, RMode, UFC, UFE, V, Z, fpscr'rst}: FPSCR, x') =
  {AHP = AHP, C = C, DN = DN, DZC = DZC, DZE = DZE, FZ = FZ, IDC = IDC,
   IDE = IDE, IOC = IOC, IOE = x', IXC = IXC, IXE = IXE, N = N, OFC = OFC,
   OFE = OFE, QC = QC, RMode = RMode, UFC = UFC, UFE = UFE, V = V, Z = Z,
   fpscr'rst = fpscr'rst}: FPSCR

fun FPSCR_IXC_rupd ({AHP, C, DN, DZC, DZE, FZ, IDC, IDE, IOC, IOE, IXC,
   IXE, N, OFC, OFE, QC, RMode, UFC, UFE, V, Z, fpscr'rst}: FPSCR, x') =
  {AHP = AHP, C = C, DN = DN, DZC = DZC, DZE = DZE, FZ = FZ, IDC = IDC,
   IDE = IDE, IOC = IOC, IOE = IOE, IXC = x', IXE = IXE, N = N, OFC = OFC,
   OFE = OFE, QC = QC, RMode = RMode, UFC = UFC, UFE = UFE, V = V, Z = Z,
   fpscr'rst = fpscr'rst}: FPSCR

fun FPSCR_IXE_rupd ({AHP, C, DN, DZC, DZE, FZ, IDC, IDE, IOC, IOE, IXC,
   IXE, N, OFC, OFE, QC, RMode, UFC, UFE, V, Z, fpscr'rst}: FPSCR, x') =
  {AHP = AHP, C = C, DN = DN, DZC = DZC, DZE = DZE, FZ = FZ, IDC = IDC,
   IDE = IDE, IOC = IOC, IOE = IOE, IXC = IXC, IXE = x', N = N, OFC = OFC,
   OFE = OFE, QC = QC, RMode = RMode, UFC = UFC, UFE = UFE, V = V, Z = Z,
   fpscr'rst = fpscr'rst}: FPSCR

fun FPSCR_N_rupd ({AHP, C, DN, DZC, DZE, FZ, IDC, IDE, IOC, IOE, IXC, IXE,
   N, OFC, OFE, QC, RMode, UFC, UFE, V, Z, fpscr'rst}: FPSCR, x') =
  {AHP = AHP, C = C, DN = DN, DZC = DZC, DZE = DZE, FZ = FZ, IDC = IDC,
   IDE = IDE, IOC = IOC, IOE = IOE, IXC = IXC, IXE = IXE, N = x',
   OFC = OFC, OFE = OFE, QC = QC, RMode = RMode, UFC = UFC, UFE = UFE,
   V = V, Z = Z, fpscr'rst = fpscr'rst}: FPSCR

fun FPSCR_OFC_rupd ({AHP, C, DN, DZC, DZE, FZ, IDC, IDE, IOC, IOE, IXC,
   IXE, N, OFC, OFE, QC, RMode, UFC, UFE, V, Z, fpscr'rst}: FPSCR, x') =
  {AHP = AHP, C = C, DN = DN, DZC = DZC, DZE = DZE, FZ = FZ, IDC = IDC,
   IDE = IDE, IOC = IOC, IOE = IOE, IXC = IXC, IXE = IXE, N = N, OFC = x',
   OFE = OFE, QC = QC, RMode = RMode, UFC = UFC, UFE = UFE, V = V, Z = Z,
   fpscr'rst = fpscr'rst}: FPSCR

fun FPSCR_OFE_rupd ({AHP, C, DN, DZC, DZE, FZ, IDC, IDE, IOC, IOE, IXC,
   IXE, N, OFC, OFE, QC, RMode, UFC, UFE, V, Z, fpscr'rst}: FPSCR, x') =
  {AHP = AHP, C = C, DN = DN, DZC = DZC, DZE = DZE, FZ = FZ, IDC = IDC,
   IDE = IDE, IOC = IOC, IOE = IOE, IXC = IXC, IXE = IXE, N = N,
   OFC = OFC, OFE = x', QC = QC, RMode = RMode, UFC = UFC, UFE = UFE,
   V = V, Z = Z, fpscr'rst = fpscr'rst}: FPSCR

fun FPSCR_QC_rupd ({AHP, C, DN, DZC, DZE, FZ, IDC, IDE, IOC, IOE, IXC,
   IXE, N, OFC, OFE, QC, RMode, UFC, UFE, V, Z, fpscr'rst}: FPSCR, x') =
  {AHP = AHP, C = C, DN = DN, DZC = DZC, DZE = DZE, FZ = FZ, IDC = IDC,
   IDE = IDE, IOC = IOC, IOE = IOE, IXC = IXC, IXE = IXE, N = N,
   OFC = OFC, OFE = OFE, QC = x', RMode = RMode, UFC = UFC, UFE = UFE,
   V = V, Z = Z, fpscr'rst = fpscr'rst}: FPSCR

fun FPSCR_RMode_rupd ({AHP, C, DN, DZC, DZE, FZ, IDC, IDE, IOC, IOE, IXC,
   IXE, N, OFC, OFE, QC, RMode, UFC, UFE, V, Z, fpscr'rst}: FPSCR, x') =
  {AHP = AHP, C = C, DN = DN, DZC = DZC, DZE = DZE, FZ = FZ, IDC = IDC,
   IDE = IDE, IOC = IOC, IOE = IOE, IXC = IXC, IXE = IXE, N = N,
   OFC = OFC, OFE = OFE, QC = QC, RMode = x', UFC = UFC, UFE = UFE, V = V,
   Z = Z, fpscr'rst = fpscr'rst}: FPSCR

fun FPSCR_UFC_rupd ({AHP, C, DN, DZC, DZE, FZ, IDC, IDE, IOC, IOE, IXC,
   IXE, N, OFC, OFE, QC, RMode, UFC, UFE, V, Z, fpscr'rst}: FPSCR, x') =
  {AHP = AHP, C = C, DN = DN, DZC = DZC, DZE = DZE, FZ = FZ, IDC = IDC,
   IDE = IDE, IOC = IOC, IOE = IOE, IXC = IXC, IXE = IXE, N = N,
   OFC = OFC, OFE = OFE, QC = QC, RMode = RMode, UFC = x', UFE = UFE,
   V = V, Z = Z, fpscr'rst = fpscr'rst}: FPSCR

fun FPSCR_UFE_rupd ({AHP, C, DN, DZC, DZE, FZ, IDC, IDE, IOC, IOE, IXC,
   IXE, N, OFC, OFE, QC, RMode, UFC, UFE, V, Z, fpscr'rst}: FPSCR, x') =
  {AHP = AHP, C = C, DN = DN, DZC = DZC, DZE = DZE, FZ = FZ, IDC = IDC,
   IDE = IDE, IOC = IOC, IOE = IOE, IXC = IXC, IXE = IXE, N = N,
   OFC = OFC, OFE = OFE, QC = QC, RMode = RMode, UFC = UFC, UFE = x',
   V = V, Z = Z, fpscr'rst = fpscr'rst}: FPSCR

fun FPSCR_V_rupd ({AHP, C, DN, DZC, DZE, FZ, IDC, IDE, IOC, IOE, IXC, IXE,
   N, OFC, OFE, QC, RMode, UFC, UFE, V, Z, fpscr'rst}: FPSCR, x') =
  {AHP = AHP, C = C, DN = DN, DZC = DZC, DZE = DZE, FZ = FZ, IDC = IDC,
   IDE = IDE, IOC = IOC, IOE = IOE, IXC = IXC, IXE = IXE, N = N,
   OFC = OFC, OFE = OFE, QC = QC, RMode = RMode, UFC = UFC, UFE = UFE,
   V = x', Z = Z, fpscr'rst = fpscr'rst}: FPSCR

fun FPSCR_Z_rupd ({AHP, C, DN, DZC, DZE, FZ, IDC, IDE, IOC, IOE, IXC, IXE,
   N, OFC, OFE, QC, RMode, UFC, UFE, V, Z, fpscr'rst}: FPSCR, x') =
  {AHP = AHP, C = C, DN = DN, DZC = DZC, DZE = DZE, FZ = FZ, IDC = IDC,
   IDE = IDE, IOC = IOC, IOE = IOE, IXC = IXC, IXE = IXE, N = N,
   OFC = OFC, OFE = OFE, QC = QC, RMode = RMode, UFC = UFC, UFE = UFE,
   V = V, Z = x', fpscr'rst = fpscr'rst}: FPSCR

fun FPSCR_fpscr'rst_rupd ({AHP, C, DN, DZC, DZE, FZ, IDC, IDE, IOC, IOE,
   IXC, IXE, N, OFC, OFE, QC, RMode, UFC, UFE, V, Z, fpscr'rst}
  : FPSCR, x') =
  {AHP = AHP, C = C, DN = DN, DZC = DZC, DZE = DZE, FZ = FZ, IDC = IDC,
   IDE = IDE, IOC = IOC, IOE = IOE, IXC = IXC, IXE = IXE, N = N,
   OFC = OFC, OFE = OFE, QC = QC, RMode = RMode, UFC = UFC, UFE = UFE,
   V = V, Z = Z, fpscr'rst = x'}: FPSCR

fun FP_FPSCR_rupd ({FPSCR, REG}: FP, x') = {FPSCR = x', REG = REG}: FP

fun FP_REG_rupd ({FPSCR, REG}: FP, x') = {FPSCR = FPSCR, REG = x'}: FP

(* -------------------------------------------------------------------------
   Exceptions
   ------------------------------------------------------------------------- *)

exception ASSERT of string

exception AlignmentFault of BitsN.nbit

exception IMPLEMENTATION_DEFINED of string

exception UNPREDICTABLE of string

exception VFP_EXCEPTION of string

(* -------------------------------------------------------------------------
   Global variables (state)
   ------------------------------------------------------------------------- *)

val Architecture = ref (ARMv4): Architecture ref

val CP14 = ref ({TEEHBR = BitsN.B(0x0,32)}): CP14 ref

val CP15 = ref
  ({HCR =
      {AMO = false, BSU = BitsN.B(0x0,2), DC = false, FB = false,
       FMO = false, IMO = false, PTW = false, SWIO = false, TAC = false,
       TGE = false, TID = BitsN.B(0x0,4), TIDCP = false, TPC = false,
       TPU = false, TSC = false, TSW = false, TTLB = false, TVM = false,
       TWE = false, TWI = false, VA = false, VF = false, VI = false,
       VM = false, hcr'rst = BitsN.B(0x0,4)},
    HSCTLR =
      {A = false, C = false, CP15BEN = false, EE = false, FI = false,
       I = false, M = false, TE = false, WXN = false,
       hsctlr'rst = BitsN.B(0x0,23)},
    HSR = {EC = BitsN.B(0x0,6), IL = false, ISS = BitsN.B(0x0,25)},
    MVBAR = BitsN.B(0x0,32),
    NSACR =
      {NSASEDIS = false, NSD32DIS = false, NSTRCDIS = false, RFR = false,
       cp = BitsN.B(0x0,14), nsacr'rst = BitsN.B(0x0,14)},
    SCR =
      {AW = false, EA = false, FIQ = false, FW = false, HCE = false,
       IRQ = false, NS = false, SCD = false, SIF = false, nET = false,
       scr'rst = BitsN.B(0x0,22)},
    SCTLR =
      {A = false, B = false, BR = false, C = false, DZ = false,
       EE = false, FI = false, I = false, IE = false, M = false,
       NMFI = false, RR = false, SW = false, TE = false, U = false,
       V = false, VE = false, Z = false, sctlr'rst = BitsN.B(0x0,14)},
    VBAR = BitsN.B(0x0,32)}): CP15 ref

val CPSR = ref
  ({A = false, C = false, E = false, F = false, GE = BitsN.B(0x0,4),
    I = false, IT = BitsN.B(0x0,8), J = false, M = BitsN.B(0x0,5),
    N = false, Q = false, T = false, V = false, Z = false,
    psr'rst = BitsN.B(0x0,4)}): PSR ref

val CurrentCondition = ref (BitsN.B(0x0,4)): BitsN.nbit ref

val ELR_hyp = ref (BitsN.B(0x0,32)): BitsN.nbit ref

val Encoding = ref (Encoding_ARM): Encoding ref

val Extensions = ref ([]): (Extensions list) ref

val FP = ref
  ({FPSCR =
      {AHP = false, C = false, DN = false, DZC = false, DZE = false,
       FZ = false, IDC = false, IDE = false, IOC = false, IOE = false,
       IXC = false, IXE = false, N = false, OFC = false, OFE = false,
       QC = false, RMode = BitsN.B(0x0,2), UFC = false, UFE = false,
       V = false, Z = false, fpscr'rst = BitsN.B(0x0,10)},
    REG = Map.mkMap(SOME 32,BitsN.B(0x0,64))}): FP ref

val MEM = ref (Map.mkMap(SOME 4294967296,BitsN.B(0x0,8)))
  : (BitsN.nbit Map.map) ref

val REG = ref (Map.mkMap(SOME 34,BitsN.B(0x0,32)))
  : (BitsN.nbit Map.map) ref

val SPSR_abt = ref
  ({A = false, C = false, E = false, F = false, GE = BitsN.B(0x0,4),
    I = false, IT = BitsN.B(0x0,8), J = false, M = BitsN.B(0x0,5),
    N = false, Q = false, T = false, V = false, Z = false,
    psr'rst = BitsN.B(0x0,4)}): PSR ref

val SPSR_fiq = ref
  ({A = false, C = false, E = false, F = false, GE = BitsN.B(0x0,4),
    I = false, IT = BitsN.B(0x0,8), J = false, M = BitsN.B(0x0,5),
    N = false, Q = false, T = false, V = false, Z = false,
    psr'rst = BitsN.B(0x0,4)}): PSR ref

val SPSR_hyp = ref
  ({A = false, C = false, E = false, F = false, GE = BitsN.B(0x0,4),
    I = false, IT = BitsN.B(0x0,8), J = false, M = BitsN.B(0x0,5),
    N = false, Q = false, T = false, V = false, Z = false,
    psr'rst = BitsN.B(0x0,4)}): PSR ref

val SPSR_irq = ref
  ({A = false, C = false, E = false, F = false, GE = BitsN.B(0x0,4),
    I = false, IT = BitsN.B(0x0,8), J = false, M = BitsN.B(0x0,5),
    N = false, Q = false, T = false, V = false, Z = false,
    psr'rst = BitsN.B(0x0,4)}): PSR ref

val SPSR_mon = ref
  ({A = false, C = false, E = false, F = false, GE = BitsN.B(0x0,4),
    I = false, IT = BitsN.B(0x0,8), J = false, M = BitsN.B(0x0,5),
    N = false, Q = false, T = false, V = false, Z = false,
    psr'rst = BitsN.B(0x0,4)}): PSR ref

val SPSR_svc = ref
  ({A = false, C = false, E = false, F = false, GE = BitsN.B(0x0,4),
    I = false, IT = BitsN.B(0x0,8), J = false, M = BitsN.B(0x0,5),
    N = false, Q = false, T = false, V = false, Z = false,
    psr'rst = BitsN.B(0x0,4)}): PSR ref

val SPSR_und = ref
  ({A = false, C = false, E = false, F = false, GE = BitsN.B(0x0,4),
    I = false, IT = BitsN.B(0x0,8), J = false, M = BitsN.B(0x0,5),
    N = false, Q = false, T = false, V = false, Z = false,
    psr'rst = BitsN.B(0x0,4)}): PSR ref

val VFPExtension = ref (NoVFP): VFPExtension ref

val undefined = ref (false): bool ref

(* -------------------------------------------------------------------------
   Main specification
   ------------------------------------------------------------------------- *)

local
  fun tuple'5 [t0,t1,t2,t3,t4] = (t0,(t1,(t2,(t3,t4))))
    | tuple'5 (_: bool list) = raise Fail "tuple'5"
in
  val boolify'5 = tuple'5 o BitsN.toList
end

local
  fun tuple'32 [t0,t1,t2,t3,t4,t5,t6,t7,t8,t9,t10,t11,t12,t13,t14,t15,t16,
                t17,t18,t19,t20,t21,t22,t23,t24,t25,t26,t27,t28,t29,t30,
                t31] =
    (t0,
     (t1,
      (t2,
       (t3,
        (t4,
         (t5,
          (t6,
           (t7,
            (t8,
             (t9,
              (t10,
               (t11,
                (t12,
                 (t13,
                  (t14,
                   (t15,
                    (t16,
                     (t17,
                      (t18,
                       (t19,
                        (t20,
                         (t21,
                          (t22,
                           (t23,
                            (t24,(t25,(t26,(t27,(t28,(t29,(t30,t31)))))))))))))))))))))))))))))))
    | tuple'32 (_: bool list) = raise Fail "tuple'32"
in
  val boolify'32 = tuple'32 o BitsN.toList
end

local
  fun tuple'16 [t0,t1,t2,t3,t4,t5,t6,t7,t8,t9,t10,t11,t12,t13,t14,t15] =
    (t0,
     (t1,
      (t2,
       (t3,(t4,(t5,(t6,(t7,(t8,(t9,(t10,(t11,(t12,(t13,(t14,t15)))))))))))))))
    | tuple'16 (_: bool list) = raise Fail "tuple'16"
in
  val boolify'16 = tuple'16 o BitsN.toList
end

local
  fun tuple'4 [t0,t1,t2,t3] = (t0,(t1,(t2,t3)))
    | tuple'4 (_: bool list) = raise Fail "tuple'4"
in
  val boolify'4 = tuple'4 o BitsN.toList
end

local
  fun tuple'28 [t0,t1,t2,t3,t4,t5,t6,t7,t8,t9,t10,t11,t12,t13,t14,t15,t16,
                t17,t18,t19,t20,t21,t22,t23,t24,t25,t26,t27] =
    (t0,
     (t1,
      (t2,
       (t3,
        (t4,
         (t5,
          (t6,
           (t7,
            (t8,
             (t9,
              (t10,
               (t11,
                (t12,
                 (t13,
                  (t14,
                   (t15,
                    (t16,
                     (t17,
                      (t18,
                       (t19,(t20,(t21,(t22,(t23,(t24,(t25,(t26,t27)))))))))))))))))))))))))))
    | tuple'28 (_: bool list) = raise Fail "tuple'28"
in
  val boolify'28 = tuple'28 o BitsN.toList
end

local
  fun tuple'3 [t0,t1,t2] = (t0,(t1,t2))
    | tuple'3 (_: bool list) = raise Fail "tuple'3"
in
  val boolify'3 = tuple'3 o BitsN.toList
end

local
  fun tuple'8 [t0,t1,t2,t3,t4,t5,t6,t7] =
    (t0,(t1,(t2,(t3,(t4,(t5,(t6,t7)))))))
    | tuple'8 (_: bool list) = raise Fail "tuple'8"
in
  val boolify'8 = tuple'8 o BitsN.toList
end

fun ArchVersion () =
  case (!Architecture) of
     ARMv4 => 4
   | ARMv4T => 4
   | ARMv5T => 5
   | ARMv5TE => 5
   | ARMv6 => 6
   | ARMv6K => 6
   | ARMv6T2 => 6
   | ARMv7_A => 7
   | ARMv7_R => 7;

fun HaveDSPSupport () =
  not(Set.mem((!Architecture),[ARMv4,ARMv4T,ARMv5T]));

fun HaveThumb2 () = Set.mem((!Architecture),[ARMv6T2,ARMv7_A,ARMv7_R]);

fun HaveThumbEE () =
  ((!Architecture) = ARMv7_A) orelse
  (((!Architecture) = ARMv7_R) andalso
   (Set.mem(Extension_ThumbEE,(!Extensions))));

fun HaveMPExt () =
  (Nat.>=(ArchVersion (),7)) andalso
  (Set.mem(Extension_Multiprocessing,(!Extensions)));

fun HaveSecurityExt () =
  (Set.mem((!Architecture),[ARMv6K,ARMv7_A])) andalso
  (Set.mem(Extension_Security,(!Extensions)));

fun HaveVirtExt () =
  (Nat.>=(ArchVersion (),7)) andalso
  (Set.mem(Extension_Virtualization,(!Extensions)));

fun rec'PSR x =
  {A = BitsN.bit(x,8), C = BitsN.bit(x,29), E = BitsN.bit(x,9),
   F = BitsN.bit(x,6), GE = BitsN.bits(19,16) x, I = BitsN.bit(x,7),
   IT = BitsN.@@(BitsN.bits(15,10) x,BitsN.bits(26,25) x),
   J = BitsN.bit(x,24), M = BitsN.bits(4,0) x, N = BitsN.bit(x,31),
   Q = BitsN.bit(x,27), T = BitsN.bit(x,5), V = BitsN.bit(x,28),
   Z = BitsN.bit(x,30), psr'rst = BitsN.bits(23,20) x};

fun reg'PSR x =
  case x of
     {A = A, C = C, E = E, F = F, GE = GE, I = I, IT = IT, J = J, M = M,
      N = N, Q = Q, T = T, V = V, Z = Z, psr'rst = psr'rst} =>
       BitsN.concat
         [BitsN.fromBit N,BitsN.fromBit Z,BitsN.fromBit C,BitsN.fromBit V,
          BitsN.fromBit Q,BitsN.bits(1,0) IT,BitsN.fromBit J,psr'rst,GE,
          BitsN.bits(7,2) IT,BitsN.fromBit E,BitsN.fromBit A,
          BitsN.fromBit I,BitsN.fromBit F,BitsN.fromBit T,M];

fun write'rec'PSR (_,x) = reg'PSR x;

fun write'reg'PSR (_,x) = rec'PSR x;

fun rec'SCTLR x =
  {A = BitsN.bit(x,1), B = BitsN.bit(x,7), BR = BitsN.bit(x,17),
   C = BitsN.bit(x,2), DZ = BitsN.bit(x,19), EE = BitsN.bit(x,25),
   FI = BitsN.bit(x,21), I = BitsN.bit(x,12), IE = BitsN.bit(x,31),
   M = BitsN.bit(x,0), NMFI = BitsN.bit(x,27), RR = BitsN.bit(x,14),
   SW = BitsN.bit(x,10), TE = BitsN.bit(x,30), U = BitsN.bit(x,22),
   V = BitsN.bit(x,13), VE = BitsN.bit(x,24), Z = BitsN.bit(x,11),
   sctlr'rst =
     BitsN.concat
       [BitsN.bits(6,3) x,BitsN.bits(9,8) x,BitsN.bits(16,15) x,
        BitsN.bits(18,18) x,BitsN.bits(20,20) x,BitsN.bits(23,23) x,
        BitsN.bits(26,26) x,BitsN.bits(29,28) x]};

fun reg'SCTLR x =
  case x of
     {A = A, B = B, BR = BR, C = C, DZ = DZ, EE = EE, FI = FI, I = I,
      IE = IE, M = M, NMFI = NMFI, RR = RR, SW = SW, TE = TE, U = U,
      V = V, VE = VE, Z = Z, sctlr'rst = sctlr'rst} =>
       BitsN.concat
         [BitsN.fromBit IE,BitsN.fromBit TE,BitsN.bits(1,0) sctlr'rst,
          BitsN.fromBit NMFI,BitsN.bits(2,2) sctlr'rst,BitsN.fromBit EE,
          BitsN.fromBit VE,BitsN.bits(3,3) sctlr'rst,BitsN.fromBit U,
          BitsN.fromBit FI,BitsN.bits(4,4) sctlr'rst,BitsN.fromBit DZ,
          BitsN.bits(5,5) sctlr'rst,BitsN.fromBit BR,
          BitsN.bits(7,6) sctlr'rst,BitsN.fromBit RR,BitsN.fromBit V,
          BitsN.fromBit I,BitsN.fromBit Z,BitsN.fromBit SW,
          BitsN.bits(9,8) sctlr'rst,BitsN.fromBit B,
          BitsN.bits(13,10) sctlr'rst,BitsN.fromBit C,BitsN.fromBit A,
          BitsN.fromBit M];

fun write'rec'SCTLR (_,x) = reg'SCTLR x;

fun write'reg'SCTLR (_,x) = rec'SCTLR x;

fun rec'HSCTLR x =
  {A = BitsN.bit(x,1), C = BitsN.bit(x,2), CP15BEN = BitsN.bit(x,5),
   EE = BitsN.bit(x,25), FI = BitsN.bit(x,21), I = BitsN.bit(x,12),
   M = BitsN.bit(x,0), TE = BitsN.bit(x,30), WXN = BitsN.bit(x,19),
   hsctlr'rst =
     BitsN.concat
       [BitsN.bits(4,3) x,BitsN.bits(11,6) x,BitsN.bits(18,13) x,
        BitsN.bits(20,20) x,BitsN.bits(24,22) x,BitsN.bits(29,26) x,
        BitsN.bits(31,31) x]};

fun reg'HSCTLR x =
  case x of
     {A = A, C = C, CP15BEN = CP15BEN, EE = EE, FI = FI, I = I, M = M,
      TE = TE, WXN = WXN, hsctlr'rst = hsctlr'rst} =>
       BitsN.concat
         [BitsN.bits(0,0) hsctlr'rst,BitsN.fromBit TE,
          BitsN.bits(4,1) hsctlr'rst,BitsN.fromBit EE,
          BitsN.bits(7,5) hsctlr'rst,BitsN.fromBit FI,
          BitsN.bits(8,8) hsctlr'rst,BitsN.fromBit WXN,
          BitsN.bits(14,9) hsctlr'rst,BitsN.fromBit I,
          BitsN.bits(20,15) hsctlr'rst,BitsN.fromBit CP15BEN,
          BitsN.bits(22,21) hsctlr'rst,BitsN.fromBit C,BitsN.fromBit A,
          BitsN.fromBit M];

fun write'rec'HSCTLR (_,x) = reg'HSCTLR x;

fun write'reg'HSCTLR (_,x) = rec'HSCTLR x;

fun rec'HSR x =
  {EC = BitsN.bits(31,26) x, IL = BitsN.bit(x,25),
   ISS = BitsN.bits(24,0) x};

fun reg'HSR x =
  case x of
     {EC = EC, IL = IL, ISS = ISS} =>
       BitsN.concat[EC,BitsN.fromBit IL,ISS];

fun write'rec'HSR (_,x) = reg'HSR x;

fun write'reg'HSR (_,x) = rec'HSR x;

fun rec'SCR x =
  {AW = BitsN.bit(x,5), EA = BitsN.bit(x,3), FIQ = BitsN.bit(x,2),
   FW = BitsN.bit(x,4), HCE = BitsN.bit(x,8), IRQ = BitsN.bit(x,1),
   NS = BitsN.bit(x,0), SCD = BitsN.bit(x,7), SIF = BitsN.bit(x,9),
   nET = BitsN.bit(x,6), scr'rst = BitsN.bits(31,10) x};

fun reg'SCR x =
  case x of
     {AW = AW, EA = EA, FIQ = FIQ, FW = FW, HCE = HCE, IRQ = IRQ, NS = NS,
      SCD = SCD, SIF = SIF, nET = nET, scr'rst = scr'rst} =>
       BitsN.concat
         [scr'rst,BitsN.fromBit SIF,BitsN.fromBit HCE,BitsN.fromBit SCD,
          BitsN.fromBit nET,BitsN.fromBit AW,BitsN.fromBit FW,
          BitsN.fromBit EA,BitsN.fromBit FIQ,BitsN.fromBit IRQ,
          BitsN.fromBit NS];

fun write'rec'SCR (_,x) = reg'SCR x;

fun write'reg'SCR (_,x) = rec'SCR x;

fun rec'NSACR x =
  {NSASEDIS = BitsN.bit(x,15), NSD32DIS = BitsN.bit(x,14),
   NSTRCDIS = BitsN.bit(x,20), RFR = BitsN.bit(x,19),
   cp = BitsN.bits(13,0) x,
   nsacr'rst = BitsN.@@(BitsN.bits(18,16) x,BitsN.bits(31,21) x)};

fun reg'NSACR x =
  case x of
     {NSASEDIS = NSASEDIS, NSD32DIS = NSD32DIS, NSTRCDIS = NSTRCDIS,
      RFR = RFR, cp = cp, nsacr'rst = nsacr'rst} =>
       BitsN.concat
         [BitsN.bits(10,0) nsacr'rst,BitsN.fromBit NSTRCDIS,
          BitsN.fromBit RFR,BitsN.bits(13,11) nsacr'rst,
          BitsN.fromBit NSASEDIS,BitsN.fromBit NSD32DIS,cp];

fun write'rec'NSACR (_,x) = reg'NSACR x;

fun write'reg'NSACR (_,x) = rec'NSACR x;

fun rec'HCR x =
  {AMO = BitsN.bit(x,5), BSU = BitsN.bits(11,10) x, DC = BitsN.bit(x,12),
   FB = BitsN.bit(x,9), FMO = BitsN.bit(x,3), IMO = BitsN.bit(x,4),
   PTW = BitsN.bit(x,2), SWIO = BitsN.bit(x,1), TAC = BitsN.bit(x,21),
   TGE = BitsN.bit(x,27), TID = BitsN.bits(18,15) x,
   TIDCP = BitsN.bit(x,20), TPC = BitsN.bit(x,23), TPU = BitsN.bit(x,24),
   TSC = BitsN.bit(x,19), TSW = BitsN.bit(x,22), TTLB = BitsN.bit(x,25),
   TVM = BitsN.bit(x,26), TWE = BitsN.bit(x,14), TWI = BitsN.bit(x,13),
   VA = BitsN.bit(x,8), VF = BitsN.bit(x,6), VI = BitsN.bit(x,7),
   VM = BitsN.bit(x,0), hcr'rst = BitsN.bits(31,28) x};

fun reg'HCR x =
  case x of
     {AMO = AMO, BSU = BSU, DC = DC, FB = FB, FMO = FMO, IMO = IMO,
      PTW = PTW, SWIO = SWIO, TAC = TAC, TGE = TGE, TID = TID,
      TIDCP = TIDCP, TPC = TPC, TPU = TPU, TSC = TSC, TSW = TSW,
      TTLB = TTLB, TVM = TVM, TWE = TWE, TWI = TWI, VA = VA, VF = VF,
      VI = VI, VM = VM, hcr'rst = hcr'rst} =>
       BitsN.concat
         [hcr'rst,BitsN.fromBit TGE,BitsN.fromBit TVM,BitsN.fromBit TTLB,
          BitsN.fromBit TPU,BitsN.fromBit TPC,BitsN.fromBit TSW,
          BitsN.fromBit TAC,BitsN.fromBit TIDCP,BitsN.fromBit TSC,TID,
          BitsN.fromBit TWE,BitsN.fromBit TWI,BitsN.fromBit DC,BSU,
          BitsN.fromBit FB,BitsN.fromBit VA,BitsN.fromBit VI,
          BitsN.fromBit VF,BitsN.fromBit AMO,BitsN.fromBit IMO,
          BitsN.fromBit FMO,BitsN.fromBit PTW,BitsN.fromBit SWIO,
          BitsN.fromBit VM];

fun write'rec'HCR (_,x) = reg'HCR x;

fun write'reg'HCR (_,x) = rec'HCR x;

fun ProcessorID () = 0;

fun IsExternalAbort () = false;

fun IsSecure () =
  (not(HaveSecurityExt ())) orelse
  ((not(#NS((#SCR((!CP15) : CP15)) : SCR))) orelse
   ((#M((!CPSR) : PSR)) = (BitsN.B(0x16,5))));

fun UnalignedSupport () =
  let
    val v = ArchVersion ()
  in
    (Nat.>=(v,7)) orelse
    ((v = 6) andalso (#U((#SCTLR((!CP15) : CP15)) : SCTLR)))
  end;

fun BadMode mode =
  case mode of
     BitsN.B(0x10,_) => false
   | BitsN.B(0x11,_) => false
   | BitsN.B(0x12,_) => false
   | BitsN.B(0x13,_) => false
   | BitsN.B(0x16,_) => not(HaveSecurityExt ())
   | BitsN.B(0x17,_) => false
   | BitsN.B(0x1A,_) => not(HaveVirtExt ())
   | BitsN.B(0x1B,_) => false
   | BitsN.B(0x1F,_) => false
   | _ => true;

fun CurrentModeIsNotUser () =
  ( if BadMode(#M((!CPSR) : PSR))
      then raise UNPREDICTABLE
             (("BadMode: ") ^ (BitsN.toHexString(#M((!CPSR) : PSR))))
    else ()
  ; not((#M((!CPSR) : PSR)) = (BitsN.B(0x10,5)))
  );

fun CurrentModeIsUserOrSystem () =
  ( if BadMode(#M((!CPSR) : PSR))
      then raise UNPREDICTABLE
             (("BadMode: ") ^ (BitsN.toHexString(#M((!CPSR) : PSR))))
    else ()
  ; Set.mem(#M((!CPSR) : PSR),[BitsN.B(0x10,5),BitsN.B(0x1F,5)])
  );

fun CurrentModeIsHyp () =
  ( if BadMode(#M((!CPSR) : PSR))
      then raise UNPREDICTABLE
             (("BadMode: ") ^ (BitsN.toHexString(#M((!CPSR) : PSR))))
    else ()
  ; (#M((!CPSR) : PSR)) = (BitsN.B(0x1A,5))
  );

fun IntegerZeroDivideTrappingEnabled () =
  #DZ((#SCTLR((!CP15) : CP15)) : SCTLR);

fun ISETSTATE () =
  BitsN.@@
    (BitsN.fromBit(#J((!CPSR) : PSR)),BitsN.fromBit(#T((!CPSR) : PSR)));

fun write'ISETSTATE value =
  ( CPSR := (PSR_J_rupd((!CPSR),BitsN.bit(value,1)))
  ; CPSR := (PSR_T_rupd((!CPSR),BitsN.bit(value,0)))
  );

fun CurrentInstrSet () =
  case ISETSTATE () of
     BitsN.B(0x0,_) => InstrSet_ARM
   | BitsN.B(0x1,_) => InstrSet_Thumb
   | BitsN.B(0x2,_) => InstrSet_Jazelle
   | BitsN.B(0x3,_) => InstrSet_ThumbEE
   | _ => raise General.Bind;

fun SelectInstrSet iset =
  case iset of
     InstrSet_ARM =>
       if (CurrentInstrSet ()) = InstrSet_ThumbEE
         then raise UNPREDICTABLE ("SelectInstrSet")
       else write'ISETSTATE(BitsN.B(0x0,2))
   | InstrSet_Thumb => write'ISETSTATE(BitsN.B(0x1,2))
   | InstrSet_Jazelle => write'ISETSTATE(BitsN.B(0x2,2))
   | InstrSet_ThumbEE => write'ISETSTATE(BitsN.B(0x3,2));

fun ITSTATE () =
  if HaveThumb2 () then #IT((!CPSR) : PSR) else BitsN.B(0x0,8);

fun write'ITSTATE value = CPSR := (PSR_IT_rupd((!CPSR),value));

fun ITAdvance () =
  if (HaveThumb2 ()) andalso (not((!Encoding) = Encoding_ARM))
    then if (BitsN.bits(2,0) (ITSTATE ())) = (BitsN.B(0x0,3))
           then write'ITSTATE(BitsN.B(0x0,8))
         else let
                val w = ITSTATE ()
              in
                write'ITSTATE
                  (BitsN.bitFieldInsert(4,0)
                     (w,BitsN.<<(BitsN.bits(4,0) (ITSTATE ()),1)))
              end
  else ();

fun InITBlock () = not((BitsN.bits(3,0) (ITSTATE ())) = (BitsN.B(0x0,4)));

fun LastInITBlock () = (BitsN.bits(3,0) (ITSTATE ())) = (BitsN.B(0x8,4));

fun ThumbCondition () =
  if (ITSTATE ()) = (BitsN.B(0x0,8))
    then BitsN.B(0xE,4)
  else if not((BitsN.bits(3,0) (#IT((!CPSR) : PSR))) = (BitsN.B(0x0,4)))
    then BitsN.bits(7,4) (#IT((!CPSR) : PSR))
  else raise UNPREDICTABLE ("ThumbCondition");

fun BigEndian () = #E((!CPSR) : PSR);

fun SetExclusiveMonitors (address,n) = ();

fun ExclusiveMonitorsPass (address,n) = false;

fun ClearExclusiveLocal id = ();

fun CurrentCond () = (!CurrentCondition);

fun ConditionPassed () =
  let
    val cond = CurrentCond ()
    val result =
      case BitsN.bits(3,1) cond of
         BitsN.B(0x0,_) => #Z((!CPSR) : PSR)
       | BitsN.B(0x1,_) => #C((!CPSR) : PSR)
       | BitsN.B(0x2,_) => #N((!CPSR) : PSR)
       | BitsN.B(0x3,_) => #V((!CPSR) : PSR)
       | BitsN.B(0x4,_) =>
         (#C((!CPSR) : PSR)) andalso (not(#Z((!CPSR) : PSR)))
       | BitsN.B(0x5,_) => (#N((!CPSR) : PSR)) = (#V((!CPSR) : PSR))
       | BitsN.B(0x6,_) =>
         ((#N((!CPSR) : PSR)) = (#V((!CPSR) : PSR))) andalso
         (not(#Z((!CPSR) : PSR)))
       | BitsN.B(0x7,_) => true
       | _ => raise General.Bind
  in
    if (BitsN.bit(cond,0)) andalso (not(cond = (BitsN.B(0xF,4))))
      then not result
    else result
  end;

fun SPSR () =
  if BadMode(#M((!CPSR) : PSR))
    then raise UNPREDICTABLE
           (("SPSR: BadMode: ") ^ (BitsN.toHexString(#M((!CPSR) : PSR))))
  else case #M((!CPSR) : PSR) of
          BitsN.B(0x11,_) => (!SPSR_fiq)
        | BitsN.B(0x12,_) => (!SPSR_irq)
        | BitsN.B(0x13,_) => (!SPSR_svc)
        | BitsN.B(0x16,_) => (!SPSR_mon)
        | BitsN.B(0x17,_) => (!SPSR_abt)
        | BitsN.B(0x1A,_) => (!SPSR_hyp)
        | BitsN.B(0x1B,_) => (!SPSR_und)
        | _ => raise UNPREDICTABLE ("SPSR");

fun write'SPSR value =
  if BadMode(#M((!CPSR) : PSR))
    then raise UNPREDICTABLE
           (("SPSR: BadMode: ") ^ (BitsN.toHexString(#M((!CPSR) : PSR))))
  else case #M((!CPSR) : PSR) of
          BitsN.B(0x11,_) => SPSR_fiq := value
        | BitsN.B(0x12,_) => SPSR_irq := value
        | BitsN.B(0x13,_) => SPSR_svc := value
        | BitsN.B(0x16,_) => SPSR_mon := value
        | BitsN.B(0x17,_) => SPSR_abt := value
        | BitsN.B(0x1A,_) => SPSR_hyp := value
        | BitsN.B(0x1B,_) => SPSR_und := value
        | _ => raise UNPREDICTABLE ("SPSR");

fun CPSRWriteByInstr (value,(bytemask,is_excpt_return)) =
  let
    val privileged = CurrentModeIsNotUser ()
    val nmfi = #NMFI((#SCTLR((!CP15) : CP15)) : SCTLR)
  in
    ( if BitsN.bit(bytemask,3)
        then ( let
                 val w = reg'PSR (!CPSR)
               in
                 CPSR :=
                 (write'reg'PSR
                    ((!CPSR),
                     BitsN.bitFieldInsert(31,27)
                       (w,BitsN.bits(31,27) value)))
               end
             ; if is_excpt_return
                 then let
                        val w = reg'PSR (!CPSR)
                      in
                        CPSR :=
                        (write'reg'PSR
                           ((!CPSR),
                            BitsN.bitFieldInsert(26,24)
                              (w,BitsN.bits(26,24) value)))
                      end
               else ()
             )
      else ()
    ; if BitsN.bit(bytemask,2)
        then let
               val w = reg'PSR (!CPSR)
             in
               CPSR :=
               (write'reg'PSR
                  ((!CPSR),
                   BitsN.bitFieldInsert(19,16) (w,BitsN.bits(19,16) value)))
             end
      else ()
    ; if BitsN.bit(bytemask,1)
        then ( if is_excpt_return
                 then let
                        val w = reg'PSR (!CPSR)
                      in
                        CPSR :=
                        (write'reg'PSR
                           ((!CPSR),
                            BitsN.bitFieldInsert(15,10)
                              (w,BitsN.bits(15,10) value)))
                      end
               else ()
             ; let
                 val w = reg'PSR (!CPSR)
               in
                 CPSR :=
                 (write'reg'PSR
                    ((!CPSR),
                     BitsN.bitFieldInsert(9,9)
                       (w,BitsN.fromBit(BitsN.bit(value,9)))))
               end
             ; if privileged andalso
                  ((IsSecure ()) orelse
                   (#AW((#SCR((!CP15) : CP15)) : SCR)))
                 then let
                        val w = reg'PSR (!CPSR)
                      in
                        CPSR :=
                        (write'reg'PSR
                           ((!CPSR),
                            BitsN.bitFieldInsert(8,8)
                              (w,BitsN.fromBit(BitsN.bit(value,8)))))
                      end
               else ()
             )
      else ()
    ; if BitsN.bit(bytemask,0)
        then ( if privileged
                 then let
                        val w = reg'PSR (!CPSR)
                      in
                        CPSR :=
                        (write'reg'PSR
                           ((!CPSR),
                            BitsN.bitFieldInsert(7,7)
                              (w,BitsN.fromBit(BitsN.bit(value,7)))))
                      end
               else ()
             ; if privileged andalso
                  (((not nmfi) orelse (not(BitsN.bit(value,6)))) andalso
                   ((IsSecure ()) orelse
                    ((#FW((#SCR((!CP15) : CP15)) : SCR)) orelse
                     (HaveVirtExt ()))))
                 then let
                        val w = reg'PSR (!CPSR)
                      in
                        CPSR :=
                        (write'reg'PSR
                           ((!CPSR),
                            BitsN.bitFieldInsert(6,6)
                              (w,BitsN.fromBit(BitsN.bit(value,6)))))
                      end
               else ()
             ; if is_excpt_return
                 then let
                        val w = reg'PSR (!CPSR)
                      in
                        CPSR :=
                        (write'reg'PSR
                           ((!CPSR),
                            BitsN.bitFieldInsert(5,5)
                              (w,BitsN.fromBit(BitsN.bit(value,5)))))
                      end
               else ()
             ; if privileged
                 then if BadMode(BitsN.bits(4,0) value)
                        then raise UNPREDICTABLE
                               (("CPSRWriteByInstr: BadMode: ")
                                  ^
                                  (BitsN.toHexString
                                     (BitsN.bits(4,0) value)))
                      else ( if (not(IsSecure ())) andalso
                                ((BitsN.bits(4,0) value) =
                                 (BitsN.B(0x16,5)))
                               then raise UNPREDICTABLE
                                      ("CPSRWriteByInstr")
                             else ()
                           ; if (not(IsSecure ())) andalso
                                (((BitsN.bits(4,0) value) =
                                  (BitsN.B(0x11,5))) andalso
                                 (#RFR((#NSACR((!CP15) : CP15)) : NSACR)))
                               then raise UNPREDICTABLE
                                      ("CPSRWriteByInstr")
                             else ()
                           ; if (not(#NS((#SCR((!CP15) : CP15)) : SCR))) andalso
                                ((BitsN.bits(4,0) value) =
                                 (BitsN.B(0x1A,5)))
                               then raise UNPREDICTABLE
                                      ("CPSRWriteByInstr")
                             else ()
                           ; if (not(IsSecure ())) andalso
                                ((not((#M((!CPSR) : PSR)) =
                                      (BitsN.B(0x1A,5)))) andalso
                                 ((BitsN.bits(4,0) value) =
                                  (BitsN.B(0x1A,5))))
                               then raise UNPREDICTABLE
                                      ("CPSRWriteByInstr")
                             else ()
                           ; if ((#M((!CPSR) : PSR)) = (BitsN.B(0x1A,5))) andalso
                                ((not((BitsN.bits(4,0) value) =
                                      (BitsN.B(0x1A,5)))) andalso
                                 (not is_excpt_return))
                               then raise UNPREDICTABLE
                                      ("CPSRWriteByInstr")
                             else ()
                           ; let
                               val w = reg'PSR (!CPSR)
                             in
                               CPSR :=
                               (write'reg'PSR
                                  ((!CPSR),
                                   BitsN.bitFieldInsert(4,0)
                                     (w,BitsN.bits(4,0) value)))
                             end
                           )
               else ()
             )
      else ()
    )
  end;

fun SPSRWriteByInstr (value,bytemask) =
  ( if CurrentModeIsUserOrSystem ()
      then raise UNPREDICTABLE ("SPSRWriteByInstr")
    else ()
  ; if BitsN.bit(bytemask,3)
      then let
             val x = SPSR ()
             val w = reg'PSR x
           in
             write'SPSR
               (write'reg'PSR
                  (x,
                   BitsN.bitFieldInsert(31,24) (w,BitsN.bits(31,24) value)))
           end
    else ()
  ; if BitsN.bit(bytemask,2)
      then let
             val x = SPSR ()
             val w = reg'PSR x
           in
             write'SPSR
               (write'reg'PSR
                  (x,
                   BitsN.bitFieldInsert(19,16) (w,BitsN.bits(19,16) value)))
           end
    else ()
  ; if BitsN.bit(bytemask,1)
      then let
             val x = SPSR ()
             val w = reg'PSR x
           in
             write'SPSR
               (write'reg'PSR
                  (x,BitsN.bitFieldInsert(15,8) (w,BitsN.bits(15,8) value)))
           end
    else ()
  ; if BitsN.bit(bytemask,0)
      then ( let
               val x = SPSR ()
               val w = reg'PSR x
             in
               write'SPSR
                 (write'reg'PSR
                    (x,BitsN.bitFieldInsert(7,5) (w,BitsN.bits(7,5) value)))
             end
           ; if BadMode(BitsN.bits(4,0) value)
               then raise UNPREDICTABLE
                      (("SPSRWriteByInstr: BadMode: ")
                         ^
                         (BitsN.toHexString(BitsN.bits(4,0) value)))
             else let
                    val x = SPSR ()
                    val w = reg'PSR x
                  in
                    write'SPSR
                      (write'reg'PSR
                         (x,
                          BitsN.bitFieldInsert(4,0)
                            (w,BitsN.bits(4,0) value)))
                  end
           )
    else ()
  );

fun RBankSelect (mode,(usr,(fiq,(irq,(svc,(abt,(und,(mon,hyp)))))))) =
  if BadMode mode
    then raise UNPREDICTABLE
           (("RBankSelect: BadMode") ^ (BitsN.toHexString mode))
  else case mode of
          BitsN.B(0x10,_) => usr
        | BitsN.B(0x11,_) => fiq
        | BitsN.B(0x12,_) => irq
        | BitsN.B(0x13,_) => svc
        | BitsN.B(0x16,_) => mon
        | BitsN.B(0x17,_) => abt
        | BitsN.B(0x1A,_) => hyp
        | BitsN.B(0x1B,_) => und
        | BitsN.B(0x1F,_) => usr
        | _ => raise General.Bind;

fun RfiqBankSelect (mode,(usr,fiq)) =
  RBankSelect(mode,(usr,(fiq,(usr,(usr,(usr,(usr,(usr,usr))))))));

fun LookUpRName (n,mode) =
  case n of
     BitsN.B(0x0,_) => RName_0usr
   | BitsN.B(0x1,_) => RName_1usr
   | BitsN.B(0x2,_) => RName_2usr
   | BitsN.B(0x3,_) => RName_3usr
   | BitsN.B(0x4,_) => RName_4usr
   | BitsN.B(0x5,_) => RName_5usr
   | BitsN.B(0x6,_) => RName_6usr
   | BitsN.B(0x7,_) => RName_7usr
   | BitsN.B(0x8,_) => RfiqBankSelect(mode,(RName_8usr,RName_8fiq))
   | BitsN.B(0x9,_) => RfiqBankSelect(mode,(RName_9usr,RName_9fiq))
   | BitsN.B(0xA,_) => RfiqBankSelect(mode,(RName_10usr,RName_10fiq))
   | BitsN.B(0xB,_) => RfiqBankSelect(mode,(RName_11usr,RName_11fiq))
   | BitsN.B(0xC,_) => RfiqBankSelect(mode,(RName_12usr,RName_12fiq))
   | BitsN.B(0xD,_) =>
     RBankSelect
       (mode,
        (RName_SPusr,
         (RName_SPfiq,
          (RName_SPirq,
           (RName_SPsvc,
            (RName_SPabt,(RName_SPund,(RName_SPmon,RName_SPhyp))))))))
   | BitsN.B(0xE,_) =>
     RBankSelect
       (mode,
        (RName_LRusr,
         (RName_LRfiq,
          (RName_LRirq,
           (RName_LRsvc,
            (RName_LRabt,(RName_LRund,(RName_LRmon,RName_LRusr))))))))
   | BitsN.B(0xF,_) => raise ASSERT ("LookUpRName: n >= 0 and n <= 14")
   | _ => raise General.Bind;

fun Rmode (n,mode) =
  let
    val notSecure = not(IsSecure ())
  in
    ( if notSecure andalso (mode = (BitsN.B(0x16,5)))
        then raise UNPREDICTABLE ("Rmode")
      else ()
    ; if notSecure andalso
         ((mode = (BitsN.B(0x11,5))) andalso
          (#RFR((#NSACR((!CP15) : CP15)) : NSACR)))
        then raise UNPREDICTABLE ("Rmode")
      else ()
    ; Map.lookup((!REG),Cast.RNameToNat(LookUpRName(n,mode)))
    )
  end;

fun write'Rmode (value,(n,mode)) =
  let
    val notSecure = not(IsSecure ())
  in
    ( if notSecure andalso (mode = (BitsN.B(0x16,5)))
        then raise UNPREDICTABLE ("Rmode")
      else ()
    ; if notSecure andalso
         ((mode = (BitsN.B(0x11,5))) andalso
          (#RFR((#NSACR((!CP15) : CP15)) : NSACR)))
        then raise UNPREDICTABLE ("Rmode")
      else ()
    ; if (n = (BitsN.B(0xD,4))) andalso
         ((not((BitsN.bits(1,0) value) = (BitsN.B(0x0,2)))) andalso
          (not((CurrentInstrSet ()) = InstrSet_ARM)))
        then raise UNPREDICTABLE ("Rmode")
      else ()
    ; let
        val x = LookUpRName(n,mode)
      in
        REG := (Map.update((!REG),Cast.RNameToNat x,value))
      end
    )
  end;

fun R n =
  if n = (BitsN.B(0xF,4))
    then let
           val offset =
             if (CurrentInstrSet ()) = InstrSet_ARM
               then BitsN.B(0x8,32)
             else BitsN.B(0x4,32)
         in
           BitsN.+(Map.lookup((!REG),Cast.RNameToNat RName_PC),offset)
         end
  else Rmode(n,#M((!CPSR) : PSR));

fun write'R (value,n) =
  let val x = (n,#M((!CPSR) : PSR)) in write'Rmode(value,x) end;

fun SP () = R(BitsN.B(0xD,4));

fun write'SP value = write'R(value,BitsN.B(0xD,4));

fun LR () = R(BitsN.B(0xE,4));

fun write'LR value = write'R(value,BitsN.B(0xE,4));

fun PC () = R(BitsN.B(0xF,4));

fun BranchTo address =
  REG := (Map.update((!REG),Cast.RNameToNat RName_PC,address));

fun PCStoreValue () = PC ();

fun BranchWritePC address =
  if (CurrentInstrSet ()) = InstrSet_ARM
    then ( if (Nat.<(ArchVersion (),6)) andalso
              (not((BitsN.bits(1,0) address) = (BitsN.B(0x0,2))))
             then raise UNPREDICTABLE ("BranchWritePC")
           else ()
         ; BranchTo(BitsN.@@(BitsN.bits(31,2) address,BitsN.B(0x0,2)))
         )
  else BranchTo(BitsN.@@(BitsN.bits(31,1) address,BitsN.B(0x0,1)));

fun BXWritePC address =
  if (CurrentInstrSet ()) = InstrSet_ThumbEE
    then if BitsN.bit(address,0)
           then BranchTo
                  (BitsN.@@(BitsN.bits(31,1) address,BitsN.B(0x0,1)))
         else raise UNPREDICTABLE ("BXWritePC")
  else if BitsN.bit(address,0)
    then ( SelectInstrSet InstrSet_Thumb
         ; BranchTo(BitsN.@@(BitsN.bits(31,1) address,BitsN.B(0x0,1)))
         )
  else if not(BitsN.bit(address,1))
    then ( SelectInstrSet InstrSet_ARM; BranchTo address )
  else raise UNPREDICTABLE ("BXWritePC");

fun LoadWritePC address =
  if Nat.>=(ArchVersion (),5)
    then BXWritePC address
  else BranchWritePC address;

fun ALUWritePC address =
  if (Nat.>=(ArchVersion (),7)) andalso
     ((CurrentInstrSet ()) = InstrSet_ARM)
    then BXWritePC address
  else BranchWritePC address;

fun ThisInstrLength () = if (!Encoding) = Encoding_Thumb then 16 else 32;

fun IncPC () =
  BranchTo
    (BitsN.+
       (Map.lookup((!REG),Cast.RNameToNat RName_PC),
        if (ThisInstrLength ()) = 16
          then BitsN.B(0x2,32)
        else BitsN.B(0x4,32)));

fun mem1 address =
  BitsN.toBitstring(Map.lookup((!MEM),BitsN.toNat address));

fun mem (address,size) =
  case size of
     1 => Bitstring.bits(7,0) (mem1(BitsN.+(address,BitsN.B(0x0,32))))
   | 2 =>
     Bitstring.bits(15,0)
       ((mem1(BitsN.+(address,BitsN.B(0x1,32))))
          @
          (mem1(BitsN.+(address,BitsN.B(0x0,32)))))
   | 4 =>
     Bitstring.bits(31,0)
       (List.concat
          [mem1(BitsN.+(address,BitsN.B(0x3,32))),
           mem1(BitsN.+(address,BitsN.B(0x2,32))),
           mem1(BitsN.+(address,BitsN.B(0x1,32))),
           mem1(BitsN.+(address,BitsN.B(0x0,32)))])
   | 8 =>
     Bitstring.bits(63,0)
       (List.concat
          [mem1(BitsN.+(address,BitsN.B(0x7,32))),
           mem1(BitsN.+(address,BitsN.B(0x6,32))),
           mem1(BitsN.+(address,BitsN.B(0x5,32))),
           mem1(BitsN.+(address,BitsN.B(0x4,32))),
           mem1(BitsN.+(address,BitsN.B(0x3,32))),
           mem1(BitsN.+(address,BitsN.B(0x2,32))),
           mem1(BitsN.+(address,BitsN.B(0x1,32))),
           mem1(BitsN.+(address,BitsN.B(0x0,32)))])
   | _ => raise ASSERT ("mem: size in {1, 2, 4, 8}");

fun write'mem (value,(address,size)) =
  case size of
     1 =>
       let
         val x = BitsN.+(address,BitsN.B(0x0,32))
       in
         MEM :=
         (Map.update
            ((!MEM),BitsN.toNat x,
             BitsN.fromBitstring(Bitstring.bits(7,0) value,8)))
       end
   | 2 =>
     ( let
         val x = BitsN.+(address,BitsN.B(0x0,32))
       in
         MEM :=
         (Map.update
            ((!MEM),BitsN.toNat x,
             BitsN.fromBitstring(Bitstring.bits(7,0) value,8)))
       end
     ; let
         val x = BitsN.+(address,BitsN.B(0x1,32))
       in
         MEM :=
         (Map.update
            ((!MEM),BitsN.toNat x,
             BitsN.fromBitstring(Bitstring.bits(15,8) value,8)))
       end
     )
   | 4 =>
     ( let
         val x = BitsN.+(address,BitsN.B(0x0,32))
       in
         MEM :=
         (Map.update
            ((!MEM),BitsN.toNat x,
             BitsN.fromBitstring(Bitstring.bits(7,0) value,8)))
       end
     ; let
         val x = BitsN.+(address,BitsN.B(0x1,32))
       in
         MEM :=
         (Map.update
            ((!MEM),BitsN.toNat x,
             BitsN.fromBitstring(Bitstring.bits(15,8) value,8)))
       end
     ; let
         val x = BitsN.+(address,BitsN.B(0x2,32))
       in
         MEM :=
         (Map.update
            ((!MEM),BitsN.toNat x,
             BitsN.fromBitstring(Bitstring.bits(23,16) value,8)))
       end
     ; let
         val x = BitsN.+(address,BitsN.B(0x3,32))
       in
         MEM :=
         (Map.update
            ((!MEM),BitsN.toNat x,
             BitsN.fromBitstring(Bitstring.bits(31,24) value,8)))
       end
     )
   | 8 =>
     ( let
         val x = BitsN.+(address,BitsN.B(0x0,32))
       in
         MEM :=
         (Map.update
            ((!MEM),BitsN.toNat x,
             BitsN.fromBitstring(Bitstring.bits(7,0) value,8)))
       end
     ; let
         val x = BitsN.+(address,BitsN.B(0x1,32))
       in
         MEM :=
         (Map.update
            ((!MEM),BitsN.toNat x,
             BitsN.fromBitstring(Bitstring.bits(15,8) value,8)))
       end
     ; let
         val x = BitsN.+(address,BitsN.B(0x2,32))
       in
         MEM :=
         (Map.update
            ((!MEM),BitsN.toNat x,
             BitsN.fromBitstring(Bitstring.bits(23,16) value,8)))
       end
     ; let
         val x = BitsN.+(address,BitsN.B(0x3,32))
       in
         MEM :=
         (Map.update
            ((!MEM),BitsN.toNat x,
             BitsN.fromBitstring(Bitstring.bits(31,24) value,8)))
       end
     ; let
         val x = BitsN.+(address,BitsN.B(0x4,32))
       in
         MEM :=
         (Map.update
            ((!MEM),BitsN.toNat x,
             BitsN.fromBitstring(Bitstring.bits(39,32) value,8)))
       end
     ; let
         val x = BitsN.+(address,BitsN.B(0x5,32))
       in
         MEM :=
         (Map.update
            ((!MEM),BitsN.toNat x,
             BitsN.fromBitstring(Bitstring.bits(47,40) value,8)))
       end
     ; let
         val x = BitsN.+(address,BitsN.B(0x6,32))
       in
         MEM :=
         (Map.update
            ((!MEM),BitsN.toNat x,
             BitsN.fromBitstring(Bitstring.bits(55,48) value,8)))
       end
     ; let
         val x = BitsN.+(address,BitsN.B(0x7,32))
       in
         MEM :=
         (Map.update
            ((!MEM),BitsN.toNat x,
             BitsN.fromBitstring(Bitstring.bits(63,56) value,8)))
       end
     )
   | _ => raise ASSERT ("mem: size in {1, 2, 4, 8}");

fun BigEndianReverse (value,n) =
  case n of
     1 => Bitstring.bits(7,0) value
   | 2 => (Bitstring.bits(7,0) value) @ (Bitstring.bits(15,8) value)
   | 4 =>
     List.concat
       [Bitstring.bits(7,0) value,Bitstring.bits(15,8) value,
        Bitstring.bits(23,16) value,Bitstring.bits(31,24) value]
   | 8 =>
     List.concat
       [Bitstring.bits(7,0) value,Bitstring.bits(15,8) value,
        Bitstring.bits(23,16) value,Bitstring.bits(31,24) value,
        Bitstring.bits(39,32) value,Bitstring.bits(47,40) value,
        Bitstring.bits(55,48) value,Bitstring.bits(63,56) value]
   | _ => raise ASSERT ("BigEndianReverse: n in {1, 2, 4, 8}");

fun Align N (w,n) = BitsN.fromNat(Nat.*(n,Nat.div(BitsN.toNat w,n)),N);

fun Aligned N (w,n) = w = (Align N (w,n));

fun MemA_with_priv N (address,(size,privileged)) =
  let
    val VA = ref (BitsN.B(0x0,32))
  in
    ( if Aligned 32 (address,size)
        then VA := address
      else if (#A((#SCTLR((!CP15) : CP15)) : SCTLR)) orelse
         (#U((#SCTLR((!CP15) : CP15)) : SCTLR))
        then raise AlignmentFault address
      else VA := (Align 32 (address,size))
    ; let
        val value = ref (mem((!VA),size))
      in
        ( if #E((!CPSR) : PSR)
            then value := (BigEndianReverse((!value),size))
          else ()
        ; BitsN.fromBitstring((!value),N)
        )
      end
    )
  end;

fun write'MemA_with_priv N (value,(address,(size,privileged))) =
  let
    val VA = ref (BitsN.B(0x0,32))
  in
    ( if Aligned 32 (address,size)
        then VA := address
      else if (#A((#SCTLR((!CP15) : CP15)) : SCTLR)) orelse
         (#U((#SCTLR((!CP15) : CP15)) : SCTLR))
        then raise AlignmentFault address
      else VA := (Align 32 (address,size))
    ; let
        val end_value =
          if #E((!CPSR) : PSR)
            then BigEndianReverse(BitsN.toBitstring value,size)
          else BitsN.toBitstring value
        val x = ((!VA),size)
      in
        write'mem(end_value,x)
      end
    )
  end;

fun MemA_unpriv N (address,size) =
  MemA_with_priv N (address,(size,false));

fun write'MemA_unpriv N (value,(address,size)) =
  let
    val x = (address,(size,false))
  in
    write'MemA_with_priv N (value,x)
  end;

fun MemA N (address,size) =
  MemA_with_priv N (address,(size,CurrentModeIsNotUser ()));

fun write'MemA N (value,(address,size)) =
  let
    val x = (address,(size,CurrentModeIsNotUser ()))
  in
    write'MemA_with_priv N (value,x)
  end;

fun MemU_with_priv N (address,(size,privileged)) =
  let
    val value = ref (Bitstring.replicate([false],64))
  in
    let
      val VA =
        if (not(#A((#SCTLR((!CP15) : CP15)) : SCTLR))) andalso
           (not(#U((#SCTLR((!CP15) : CP15)) : SCTLR)))
          then Align 32 (address,size)
        else address
    in
      ( if Aligned 32 (VA,size)
          then value :=
               (BitsN.toBitstring(MemA_with_priv N (VA,(size,privileged))))
        else if #A((#SCTLR((!CP15) : CP15)) : SCTLR)
          then raise AlignmentFault address
        else ( L3.for
                 (0,Nat.-(size,1),
                  fn i =>
                    let
                      val h = Nat.+(Nat.*(8,i),7)
                      val l = Nat.*(8,i)
                    in
                      value :=
                      (Bitstring.bitFieldInsert(h,l)
                         ((!value),
                          BitsN.toBitstring
                            (MemA_with_priv 8
                               (BitsN.+(VA,BitsN.fromNat(i,32)),
                                (1,privileged)))))
                    end)
             ; if #E((!CPSR) : PSR)
                 then value := (BigEndianReverse((!value),size))
               else ()
             )
      ; BitsN.fromBitstring((!value),N)
      )
    end
  end;

fun write'MemU_with_priv N (value,(address,(size,privileged))) =
  let
    val VA =
      if (not(#A((#SCTLR((!CP15) : CP15)) : SCTLR))) andalso
         (not(#U((#SCTLR((!CP15) : CP15)) : SCTLR)))
        then Align 32 (address,size)
      else address
  in
    if Aligned 32 (VA,size)
      then let
             val x = (VA,(size,privileged))
           in
             write'MemA_with_priv N (value,x)
           end
    else if #A((#SCTLR((!CP15) : CP15)) : SCTLR)
      then raise AlignmentFault address
    else let
           val v =
             if #E((!CPSR) : PSR)
               then BigEndianReverse(BitsN.toBitstring value,size)
             else BitsN.toBitstring value
         in
           L3.for
             (0,Nat.-(size,1),
              fn i =>
                let
                  val x = (BitsN.+(VA,BitsN.fromNat(i,32)),(1,privileged))
                in
                  write'MemA_with_priv 8
                    (BitsN.fromBitstring
                       (Bitstring.bits(Nat.+(Nat.*(8,i),7),Nat.*(8,i)) v,8),
                     x)
                end)
         end
  end;

fun MemU_unpriv N (address,size) =
  MemU_with_priv N (address,(size,false));

fun write'MemU_unpriv N (value,(address,size)) =
  let
    val x = (address,(size,false))
  in
    write'MemU_with_priv N (value,x)
  end;

fun MemU N (address,size) =
  MemU_with_priv N (address,(size,CurrentModeIsNotUser ()));

fun write'MemU N (value,(address,size)) =
  let
    val x = (address,(size,CurrentModeIsNotUser ()))
  in
    write'MemU_with_priv N (value,x)
  end;

fun NullCheckIfThumbEE n =
  let
    val EndOfInstruction = ref false
  in
    ( if (CurrentInstrSet ()) = InstrSet_ThumbEE
        then if n = (BitsN.B(0xF,4))
               then if (Align 32 (PC (),4)) = (BitsN.B(0x0,32))
                      then raise UNPREDICTABLE ("NullCheckIfThumbEE")
                    else ()
             else if n = (BitsN.B(0xD,4))
               then if (SP ()) = (BitsN.B(0x0,32))
                      then raise UNPREDICTABLE ("NullCheckIfThumbEE")
                    else ()
             else if (R n) = (BitsN.B(0x0,32))
               then ( write'LR
                        (BitsN.@@(BitsN.bits(31,1) (PC ()),BitsN.B(0x1,1)))
                    ; write'ITSTATE(BitsN.B(0x0,8))
                    ; BranchWritePC
                        (BitsN.-(#TEEHBR((!CP14) : CP14),BitsN.B(0x4,32)))
                    ; EndOfInstruction := true
                    )
             else ()
      else ()
    ; not (!EndOfInstruction)
    )
  end;

fun HighestSetBit N w =
  if w = (BitsN.BV(0x0,N)) then IntInf.~ 1 else BitsN.toInt(BitsN.log2 w);

fun CountLeadingZeroBits N w =
  Nat.fromInt
    (IntInf.-
       (IntInf.-(Nat.toInt(BitsN.size(BitsN.BV(0x0,N))),1),
        HighestSetBit N w));

fun LowestSetBit N w = CountLeadingZeroBits N (BitsN.reverse w);

fun BitCount N w =
  let
    val result = ref 0
  in
    ( L3.for
        (0,Nat.-(BitsN.size(BitsN.BV(0x0,N)),1),
         fn i =>
           if BitsN.bit(w,i) then result := (Nat.+((!result),1)) else ())
    ; (!result)
    )
  end;

fun SignExtendFrom N (w,p) =
  let
    val s = Nat.-(Nat.-(BitsN.size(BitsN.BV(0x0,N)),1),p)
  in
    BitsN.>>(BitsN.<<(w,s),s)
  end;

fun Extend (M,N) (unsigned,w) =
  if unsigned then BitsN.zeroExtend N w else BitsN.signExtend N w;

fun UInt N w = Nat.toInt(BitsN.toNat w);

fun SignedSatQ M (i,N) =
  ( if Nat.<(BitsN.size(BitsN.BV(0x0,M)),N)
      then raise ASSERT ("SignedSatQ: M < N")
    else ()
  ; let
      val max = Nat.toInt(Nat.pow(2,Nat.-(N,1)))
    in
      if IntInf.>(i,IntInf.-(max,1))
        then (BitsN.fromInt(IntInf.-(max,1),M),true)
      else if IntInf.<(i,IntInf.~ max)
        then (BitsN.fromInt(IntInf.~ max,M),true)
      else (BitsN.fromInt(i,M),false)
    end
  );

fun UnsignedSatQ M (i,N) =
  ( if Nat.<(BitsN.size(BitsN.BV(0x0,M)),N)
      then raise ASSERT ("UnsignedSatQ: M < N")
    else ()
  ; let
      val max = Nat.toInt(Nat.-(Nat.pow(2,N),1))
    in
      if IntInf.>(i,max)
        then (BitsN.fromInt(max,M),true)
      else if IntInf.<(i,0)
        then (BitsN.BV(0x0,M),true)
      else (BitsN.fromInt(i,M),false)
    end
  );

fun SatQ M (i,(N,unsigned)) =
  if unsigned then UnsignedSatQ M (i,N) else SignedSatQ M (i,N);

fun SignedSat M (i,N) = L3.fst(SignedSatQ M (i,N));

fun UnsignedSat M (i,N) = L3.fst(UnsignedSatQ M (i,N));

fun LSL_C N (x,shift) =
  ( if shift = 0 then raise ASSERT ("LSL_C") else ()
  ; let
      val extended_x =
        (BitsN.toBitstring x) @ (Bitstring.replicate([false],shift))
    in
      (BitsN.<<(x,shift),
       Bitstring.bit(extended_x,BitsN.size(BitsN.BV(0x0,N))))
    end
  );

fun LSL N (x,shift) = if shift = 0 then x else L3.fst(LSL_C N (x,shift));

fun LSR_C N (x,shift) =
  ( if shift = 0 then raise ASSERT ("LSR_C") else ()
  ; (BitsN.>>+(x,shift),
     (Nat.<=(shift,BitsN.size(BitsN.BV(0x0,N)))) andalso
     (BitsN.bit(x,Nat.-(shift,1))))
  );

fun LSR N (x,shift) = if shift = 0 then x else L3.fst(LSR_C N (x,shift));

fun ASR_C N (x,shift) =
  ( if shift = 0 then raise ASSERT ("ASR_C") else ()
  ; (BitsN.>>(x,shift),
     BitsN.bit(x,Nat.-(Nat.min(BitsN.size(BitsN.BV(0x0,N)),shift),1)))
  );

fun ASR N (x,shift) = if shift = 0 then x else L3.fst(ASR_C N (x,shift));

fun ROR_C N (x,shift) =
  ( if shift = 0 then raise ASSERT ("ROR_C") else ()
  ; let val result = BitsN.#>>(x,shift) in (result,BitsN.msb result) end
  );

fun ROR N (x,shift) = if shift = 0 then x else L3.fst(ROR_C N (x,shift));

fun RRX_C N (x,carry_in) =
  let
    val result =
      BitsN.fromBitstring
        ((Bitstring.fromBool carry_in)
           @
           (Bitstring.bits(Nat.-(BitsN.size(BitsN.BV(0x0,N)),1),1)
              (BitsN.toBitstring x)),N)
  in
    (result,BitsN.bit(x,0))
  end;

fun RRX N (x,carry_in) = L3.fst(RRX_C N (x,carry_in));

fun DecodeImmShift (typ,imm5) =
  case typ of
     BitsN.B(0x0,_) => (SRType_LSL,BitsN.toNat imm5)
   | BitsN.B(0x1,_) =>
     (SRType_LSR,if imm5 = (BitsN.B(0x0,5)) then 32 else BitsN.toNat imm5)
   | BitsN.B(0x2,_) =>
     (SRType_ASR,if imm5 = (BitsN.B(0x0,5)) then 32 else BitsN.toNat imm5)
   | BitsN.B(0x3,_) =>
     if imm5 = (BitsN.B(0x0,5))
       then (SRType_RRX,1)
     else (SRType_ROR,BitsN.toNat imm5)
   | _ => raise General.Bind;

fun DecodeRegShift typ =
  case typ of
     BitsN.B(0x0,_) => SRType_LSL
   | BitsN.B(0x1,_) => SRType_LSR
   | BitsN.B(0x2,_) => SRType_ASR
   | BitsN.B(0x3,_) => SRType_ROR
   | _ => raise General.Bind;

fun Shift_C N (value,(typ,(amount,carry_in))) =
  if amount = 0
    then (value,carry_in)
  else case typ of
          SRType_LSL => LSL_C N (value,amount)
        | SRType_LSR => LSR_C N (value,amount)
        | SRType_ASR => ASR_C N (value,amount)
        | SRType_ROR => ROR_C N (value,amount)
        | SRType_RRX => RRX_C N (value,carry_in);

fun Shift N (value,(typ,(amount,carry_in))) =
  L3.fst(Shift_C N (value,(typ,(amount,carry_in))));

fun ARMExpandImm_C (imm12,carry_in) =
  let
    val unroatated_value = BitsN.zeroExtend 32 (BitsN.bits(7,0) imm12)
  in
    Shift_C 32
      (unroatated_value,
       (SRType_ROR,(Nat.*(2,BitsN.toNat(BitsN.bits(11,8) imm12)),carry_in)))
  end;

fun ARMExpandImm imm12 = L3.fst(ARMExpandImm_C(imm12,#C((!CPSR) : PSR)));

fun ThumbExpandImm_C (imm12,carry_in) =
  if (BitsN.bits(11,10) imm12) = (BitsN.B(0x0,2))
    then let
           val imm32 =
             case BitsN.bits(9,8) imm12 of
                BitsN.B(0x0,_) =>
                  BitsN.zeroExtend 32 (BitsN.bits(7,0) imm12)
              | BitsN.B(0x1,_) =>
                if (BitsN.bits(7,0) imm12) = (BitsN.B(0x0,8))
                  then raise UNPREDICTABLE ("ThumbExpandImm_C")
                else BitsN.concat
                       [BitsN.B(0x0,8),BitsN.bits(7,0) imm12,
                        BitsN.B(0x0,8),BitsN.bits(7,0) imm12]
              | BitsN.B(0x2,_) =>
                if (BitsN.bits(7,0) imm12) = (BitsN.B(0x0,8))
                  then raise UNPREDICTABLE ("ThumbExpandImm_C")
                else BitsN.concat
                       [BitsN.bits(7,0) imm12,BitsN.B(0x0,8),
                        BitsN.bits(7,0) imm12,BitsN.B(0x0,8)]
              | BitsN.B(0x3,_) =>
                if (BitsN.bits(7,0) imm12) = (BitsN.B(0x0,8))
                  then raise UNPREDICTABLE ("ThumbExpandImm_C")
                else BitsN.concat
                       [BitsN.bits(7,0) imm12,BitsN.bits(7,0) imm12,
                        BitsN.bits(7,0) imm12,BitsN.bits(7,0) imm12]
              | _ => raise General.Bind
         in
           (imm32,carry_in)
         end
  else let
         val unroatated_value =
           BitsN.zeroExtend 32
             (BitsN.@@(BitsN.B(0x1,1),BitsN.bits(6,0) imm12))
       in
         ROR_C 32 (unroatated_value,BitsN.toNat(BitsN.bits(11,7) imm12))
       end;

fun ExpandImm_C (imm12,carry_in) =
  if (!Encoding) = Encoding_Thumb2
    then ThumbExpandImm_C(imm12,carry_in)
  else ARMExpandImm_C(imm12,carry_in);

fun AddWithCarry N (x,(y,carry_in)) =
  let
    val unsigned_sum =
      Nat.+(Nat.+(BitsN.toNat x,BitsN.toNat y),Nat.fromBool carry_in)
    val signed_sum =
      IntInf.+
        (IntInf.+(BitsN.toInt x,BitsN.toInt y),IntExtra.fromBool carry_in)
    val result = BitsN.fromNat(unsigned_sum,N)
    val carry_out = not((BitsN.toNat result) = unsigned_sum)
    val overflow = not((BitsN.toInt result) = signed_sum)
  in
    (result,(carry_out,overflow))
  end;

fun DataProcessingALU (opc,(a,(b,c))) =
  case opc of
     BitsN.B(0x0,_) => (BitsN.&&(a,b),(c,false))
   | BitsN.B(0x8,_) => (BitsN.&&(a,b),(c,false))
   | BitsN.B(0x1,_) => (BitsN.??(a,b),(c,false))
   | BitsN.B(0x9,_) => (BitsN.??(a,b),(c,false))
   | BitsN.B(0x2,_) => AddWithCarry 32 (a,(BitsN.~ b,true))
   | BitsN.B(0xA,_) => AddWithCarry 32 (a,(BitsN.~ b,true))
   | BitsN.B(0x3,_) => AddWithCarry 32 (BitsN.~ a,(b,true))
   | BitsN.B(0x4,_) => AddWithCarry 32 (a,(b,false))
   | BitsN.B(0xB,_) => AddWithCarry 32 (a,(b,false))
   | BitsN.B(0x5,_) => AddWithCarry 32 (a,(b,c))
   | BitsN.B(0x6,_) => AddWithCarry 32 (a,(BitsN.~ b,c))
   | BitsN.B(0x7,_) => AddWithCarry 32 (BitsN.~ a,(b,c))
   | BitsN.B(0xC,_) => (BitsN.||(a,b),(c,false))
   | BitsN.B(0xD,_) => (b,(c,false))
   | BitsN.B(0xE,_) => (BitsN.&&(a,BitsN.~ b),(c,false))
   | BitsN.B(0xF,_) => (BitsN.||(a,BitsN.~ b),(c,false))
   | _ => raise General.Bind;

fun ArithmeticOpcode opc =
  ((BitsN.bit(opc,2)) orelse (BitsN.bit(opc,1))) andalso
  (not((BitsN.bit(opc,3)) andalso (BitsN.bit(opc,2))));

fun ExcVectorBase () =
  if #V((#SCTLR((!CP15) : CP15)) : SCTLR)
    then BitsN.B(0xFFFF000,32)
  else if HaveSecurityExt ()
    then #VBAR((!CP15) : CP15)
  else BitsN.B(0x0,32);

fun EnterMonitorMode (new_spsr_value,(new_lr_value,vect_offset)) =
  ( CPSR := (PSR_M_rupd((!CPSR),BitsN.B(0x16,5)))
  ; write'SPSR new_spsr_value
  ; write'R(new_lr_value,BitsN.B(0xE,4))
  ; CPSR := (PSR_J_rupd((!CPSR),false))
  ; CPSR := (PSR_T_rupd((!CPSR),#TE((#SCTLR((!CP15) : CP15)) : SCTLR)))
  ; CPSR := (PSR_E_rupd((!CPSR),#EE((#SCTLR((!CP15) : CP15)) : SCTLR)))
  ; CPSR := (PSR_A_rupd((!CPSR),true))
  ; CPSR := (PSR_F_rupd((!CPSR),true))
  ; CPSR := (PSR_I_rupd((!CPSR),true))
  ; CPSR := (PSR_IT_rupd((!CPSR),BitsN.B(0x0,8)))
  ; BranchTo(BitsN.+(#MVBAR((!CP15) : CP15),vect_offset))
  );

fun EnterHypMode (new_spsr_value,(new_lr_value,vect_offset)) =
  ( CPSR := (PSR_M_rupd((!CPSR),BitsN.B(0x1A,5)))
  ; write'SPSR new_spsr_value
  ; write'R(new_lr_value,BitsN.B(0xE,4))
  ; CPSR := (PSR_J_rupd((!CPSR),false))
  ; CPSR := (PSR_T_rupd((!CPSR),#TE((#SCTLR((!CP15) : CP15)) : SCTLR)))
  ; CPSR := (PSR_E_rupd((!CPSR),#EE((#SCTLR((!CP15) : CP15)) : SCTLR)))
  ; CPSR := (PSR_A_rupd((!CPSR),true))
  ; CPSR := (PSR_F_rupd((!CPSR),true))
  ; CPSR := (PSR_I_rupd((!CPSR),true))
  ; CPSR := (PSR_IT_rupd((!CPSR),BitsN.B(0x0,8)))
  ; BranchTo(BitsN.+(#MVBAR((!CP15) : CP15),vect_offset))
  );

fun TakeReset () =
  ( CPSR := (PSR_M_rupd((!CPSR),BitsN.B(0x13,5)))
  ; if HaveSecurityExt ()
      then let
             val x0 = #SCR((!CP15) : CP15)
           in
             CP15 := (CP15_SCR_rupd((!CP15),SCR_NS_rupd(x0,false)))
           end
    else ()
  ; CPSR := (PSR_I_rupd((!CPSR),true))
  ; CPSR := (PSR_F_rupd((!CPSR),true))
  ; CPSR := (PSR_A_rupd((!CPSR),true))
  ; CPSR := (PSR_IT_rupd((!CPSR),BitsN.B(0x0,8)))
  ; CPSR := (PSR_J_rupd((!CPSR),false))
  ; CPSR := (PSR_T_rupd((!CPSR),#TE((#SCTLR((!CP15) : CP15)) : SCTLR)))
  ; CPSR := (PSR_E_rupd((!CPSR),#EE((#SCTLR((!CP15) : CP15)) : SCTLR)))
  ; BranchTo(BitsN.+(ExcVectorBase (),BitsN.B(0x0,32)))
  );

fun TakeUndefInstrException () =
  let
    val new_lr_value =
      if #T((!CPSR) : PSR)
        then BitsN.-(PC (),BitsN.B(0x2,32))
      else BitsN.-(PC (),BitsN.B(0x4,32))
    val new_spsr_value = (!CPSR)
    val vect_offset = BitsN.B(0x4,32)
    val take_to_hyp =
      (HaveVirtExt ()) andalso
      ((HaveSecurityExt ()) andalso
       ((#NS((#SCR((!CP15) : CP15)) : SCR)) andalso
        ((#M((!CPSR) : PSR)) = (BitsN.B(0x1A,5)))))
    val route_to_hyp =
      (HaveVirtExt ()) andalso
      ((HaveSecurityExt ()) andalso
       ((not(IsSecure ())) andalso
        ((#TGE((#HCR((!CP15) : CP15)) : HCR)) andalso
         ((#M((!CPSR) : PSR)) = (BitsN.B(0x10,5))))))
    val return_offset =
      if #T((!CPSR) : PSR) then BitsN.B(0x2,32) else BitsN.B(0x4,32)
    val preferred_exceptn_return = BitsN.-(new_lr_value,return_offset)
  in
    if take_to_hyp
      then EnterHypMode
             (new_spsr_value,(preferred_exceptn_return,vect_offset))
    else if route_to_hyp
      then EnterHypMode
             (new_spsr_value,(preferred_exceptn_return,BitsN.B(0x14,32)))
    else ( if (#M((!CPSR) : PSR)) = (BitsN.B(0x16,5))
             then let
                    val x0 = #SCR((!CP15) : CP15)
                  in
                    CP15 := (CP15_SCR_rupd((!CP15),SCR_NS_rupd(x0,false)))
                  end
           else ()
         ; CPSR := (PSR_M_rupd((!CPSR),BitsN.B(0x1B,5)))
         ; write'SPSR new_spsr_value
         ; write'R(new_lr_value,BitsN.B(0xE,4))
         ; CPSR := (PSR_I_rupd((!CPSR),true))
         ; CPSR := (PSR_IT_rupd((!CPSR),BitsN.B(0x0,8)))
         ; CPSR := (PSR_J_rupd((!CPSR),false))
         ; CPSR :=
           (PSR_T_rupd((!CPSR),#TE((#SCTLR((!CP15) : CP15)) : SCTLR)))
         ; CPSR :=
           (PSR_E_rupd((!CPSR),#EE((#SCTLR((!CP15) : CP15)) : SCTLR)))
         ; BranchTo(BitsN.+(ExcVectorBase (),vect_offset))
         )
  end;

fun TakeSVCException () =
  ( ITAdvance ()
  ; let
      val new_lr_value =
        if #T((!CPSR) : PSR)
          then BitsN.-(PC (),BitsN.B(0x2,32))
        else BitsN.-(PC (),BitsN.B(0x4,32))
      val new_spsr_value = (!CPSR)
      val vect_offset = BitsN.B(0x8,32)
      val take_to_hyp =
        (HaveVirtExt ()) andalso
        ((HaveSecurityExt ()) andalso
         ((#NS((#SCR((!CP15) : CP15)) : SCR)) andalso
          ((#M((!CPSR) : PSR)) = (BitsN.B(0x1A,5)))))
      val route_to_hyp =
        (HaveVirtExt ()) andalso
        ((HaveSecurityExt ()) andalso
         ((not(IsSecure ())) andalso
          ((#TGE((#HCR((!CP15) : CP15)) : HCR)) andalso
           ((#M((!CPSR) : PSR)) = (BitsN.B(0x10,5))))))
      val preferred_exceptn_return = new_lr_value
    in
      if take_to_hyp
        then EnterHypMode
               (new_spsr_value,(preferred_exceptn_return,vect_offset))
      else if route_to_hyp
        then EnterHypMode
               (new_spsr_value,(preferred_exceptn_return,BitsN.B(0x14,32)))
      else ( if (#M((!CPSR) : PSR)) = (BitsN.B(0x16,5))
               then let
                      val x0 = #SCR((!CP15) : CP15)
                    in
                      CP15 :=
                      (CP15_SCR_rupd((!CP15),SCR_NS_rupd(x0,false)))
                    end
             else ()
           ; CPSR := (PSR_M_rupd((!CPSR),BitsN.B(0x13,5)))
           ; write'SPSR new_spsr_value
           ; write'R(new_lr_value,BitsN.B(0xE,4))
           ; CPSR := (PSR_I_rupd((!CPSR),true))
           ; CPSR := (PSR_IT_rupd((!CPSR),BitsN.B(0x0,8)))
           ; CPSR := (PSR_J_rupd((!CPSR),false))
           ; CPSR :=
             (PSR_T_rupd((!CPSR),#TE((#SCTLR((!CP15) : CP15)) : SCTLR)))
           ; CPSR :=
             (PSR_E_rupd((!CPSR),#EE((#SCTLR((!CP15) : CP15)) : SCTLR)))
           ; BranchTo(BitsN.+(ExcVectorBase (),vect_offset))
           )
    end
  );

fun TakeSMCException () =
  ( ITAdvance ()
  ; let
      val new_lr_value =
        if #T((!CPSR) : PSR)
          then PC ()
        else BitsN.-(PC (),BitsN.B(0x4,32))
      val new_spsr_value = (!CPSR)
      val vect_offset = BitsN.B(0x8,32)
    in
      ( if (#M((!CPSR) : PSR)) = (BitsN.B(0x16,5))
          then let
                 val x0 = #SCR((!CP15) : CP15)
               in
                 CP15 := (CP15_SCR_rupd((!CP15),SCR_NS_rupd(x0,false)))
               end
        else ()
      ; CPSR := (PSR_M_rupd((!CPSR),BitsN.B(0x16,5)))
      ; EnterMonitorMode(new_spsr_value,(new_lr_value,vect_offset))
      )
    end
  );

fun TakeHVCException () =
  ( ITAdvance ()
  ; let
      val preferred_exceptn_return =
        if #T((!CPSR) : PSR)
          then PC ()
        else BitsN.-(PC (),BitsN.B(0x4,32))
      val new_spsr_value = (!CPSR)
    in
      if (#M((!CPSR) : PSR)) = (BitsN.B(0x1A,5))
        then EnterHypMode
               (new_spsr_value,(preferred_exceptn_return,BitsN.B(0x8,32)))
      else EnterHypMode
             (new_spsr_value,(preferred_exceptn_return,BitsN.B(0x14,32)))
    end
  );

fun TakeDataAbortException () =
  let
    val new_lr_value =
      if #T((!CPSR) : PSR) then BitsN.+(PC (),BitsN.B(0x4,32)) else PC ()
    val new_spsr_value = (!CPSR)
    val vect_offset = BitsN.B(0x10,32)
    val preferred_exceptn_return = BitsN.-(new_lr_value,BitsN.B(0x8,32))
    val route_to_monitor =
      (HaveSecurityExt ()) andalso
      ((#EA((#SCR((!CP15) : CP15)) : SCR)) andalso (IsExternalAbort ()))
    val take_to_hyp =
      (HaveVirtExt ()) andalso
      ((HaveSecurityExt ()) andalso
       ((#NS((#SCR((!CP15) : CP15)) : SCR)) andalso
        ((#M((!CPSR) : PSR)) = (BitsN.B(0x1A,5)))))
    val route_to_hyp = false
  in
    if route_to_monitor
      then ( if (#M((!CPSR) : PSR)) = (BitsN.B(0x16,5))
               then let
                      val x0 = #SCR((!CP15) : CP15)
                    in
                      CP15 :=
                      (CP15_SCR_rupd((!CP15),SCR_NS_rupd(x0,false)))
                    end
             else ()
           ; EnterMonitorMode(new_spsr_value,(new_lr_value,vect_offset))
           )
    else if take_to_hyp
      then EnterHypMode
             (new_spsr_value,(preferred_exceptn_return,vect_offset))
    else if route_to_hyp
      then EnterHypMode
             (new_spsr_value,(preferred_exceptn_return,BitsN.B(0x14,32)))
    else ( if (HaveSecurityExt ()) andalso
              ((#M((!CPSR) : PSR)) = (BitsN.B(0x16,5)))
             then let
                    val x0 = #SCR((!CP15) : CP15)
                  in
                    CP15 := (CP15_SCR_rupd((!CP15),SCR_NS_rupd(x0,false)))
                  end
           else ()
         ; CPSR := (PSR_M_rupd((!CPSR),BitsN.B(0x17,5)))
         ; write'SPSR new_spsr_value
         ; write'R(new_lr_value,BitsN.B(0xE,4))
         ; CPSR := (PSR_I_rupd((!CPSR),true))
         ; if (not(HaveSecurityExt ())) orelse
              ((HaveVirtExt ()) orelse
               ((not(#NS((#SCR((!CP15) : CP15)) : SCR))) orelse
                (#AW((#SCR((!CP15) : CP15)) : SCR))))
             then CPSR := (PSR_A_rupd((!CPSR),true))
           else ()
         ; CPSR := (PSR_IT_rupd((!CPSR),BitsN.B(0x0,8)))
         ; CPSR := (PSR_J_rupd((!CPSR),false))
         ; CPSR :=
           (PSR_T_rupd((!CPSR),#TE((#SCTLR((!CP15) : CP15)) : SCTLR)))
         ; CPSR :=
           (PSR_E_rupd((!CPSR),#EE((#SCTLR((!CP15) : CP15)) : SCTLR)))
         ; BranchTo(BitsN.+(ExcVectorBase (),vect_offset))
         )
  end;

fun TakePrefetchAbortException () =
  let
    val new_lr_value =
      if #T((!CPSR) : PSR) then PC () else BitsN.-(PC (),BitsN.B(0x4,32))
    val new_spsr_value = (!CPSR)
    val vect_offset = BitsN.B(0xC,32)
    val preferred_exceptn_return = BitsN.-(new_lr_value,BitsN.B(0x4,32))
    val route_to_monitor =
      (HaveSecurityExt ()) andalso
      ((#EA((#SCR((!CP15) : CP15)) : SCR)) andalso (IsExternalAbort ()))
    val take_to_hyp =
      (HaveVirtExt ()) andalso
      ((HaveSecurityExt ()) andalso
       ((#NS((#SCR((!CP15) : CP15)) : SCR)) andalso
        ((#M((!CPSR) : PSR)) = (BitsN.B(0x1A,5)))))
    val route_to_hyp = false
  in
    if route_to_monitor
      then ( if (#M((!CPSR) : PSR)) = (BitsN.B(0x16,5))
               then let
                      val x0 = #SCR((!CP15) : CP15)
                    in
                      CP15 :=
                      (CP15_SCR_rupd((!CP15),SCR_NS_rupd(x0,false)))
                    end
             else ()
           ; EnterMonitorMode(new_spsr_value,(new_lr_value,vect_offset))
           )
    else if take_to_hyp
      then EnterHypMode
             (new_spsr_value,(preferred_exceptn_return,vect_offset))
    else if route_to_hyp
      then EnterHypMode
             (new_spsr_value,(preferred_exceptn_return,BitsN.B(0x14,32)))
    else ( if (HaveSecurityExt ()) andalso
              ((#M((!CPSR) : PSR)) = (BitsN.B(0x16,5)))
             then let
                    val x0 = #SCR((!CP15) : CP15)
                  in
                    CP15 := (CP15_SCR_rupd((!CP15),SCR_NS_rupd(x0,false)))
                  end
           else ()
         ; CPSR := (PSR_M_rupd((!CPSR),BitsN.B(0x17,5)))
         ; write'SPSR new_spsr_value
         ; write'R(new_lr_value,BitsN.B(0xE,4))
         ; CPSR := (PSR_I_rupd((!CPSR),true))
         ; if (not(HaveSecurityExt ())) orelse
              ((HaveVirtExt ()) orelse
               ((not(#NS((#SCR((!CP15) : CP15)) : SCR))) orelse
                (#AW((#SCR((!CP15) : CP15)) : SCR))))
             then CPSR := (PSR_A_rupd((!CPSR),true))
           else ()
         ; CPSR := (PSR_IT_rupd((!CPSR),BitsN.B(0x0,8)))
         ; CPSR := (PSR_J_rupd((!CPSR),false))
         ; CPSR :=
           (PSR_T_rupd((!CPSR),#TE((#SCTLR((!CP15) : CP15)) : SCTLR)))
         ; CPSR :=
           (PSR_E_rupd((!CPSR),#EE((#SCTLR((!CP15) : CP15)) : SCTLR)))
         ; BranchTo(BitsN.+(ExcVectorBase (),vect_offset))
         )
  end;

fun TakePhysicalIRQException () =
  let
    val new_lr_value =
      if #T((!CPSR) : PSR) then PC () else BitsN.-(PC (),BitsN.B(0x4,32))
    val new_spsr_value = (!CPSR)
    val vect_offset = BitsN.B(0x18,32)
    val route_to_monitor =
      (HaveSecurityExt ()) andalso (#IRQ((#SCR((!CP15) : CP15)) : SCR))
    val route_to_hyp =
      ((HaveVirtExt ()) andalso
       ((HaveSecurityExt ()) andalso
        ((not(#IRQ((#SCR((!CP15) : CP15)) : SCR))) andalso
         ((#IMO((#HCR((!CP15) : CP15)) : HCR)) andalso (not(IsSecure ())))))) orelse
      ((#M((!CPSR) : PSR)) = (BitsN.B(0x1A,5)))
  in
    if route_to_monitor
      then ( if (#M((!CPSR) : PSR)) = (BitsN.B(0x16,5))
               then let
                      val x0 = #SCR((!CP15) : CP15)
                    in
                      CP15 :=
                      (CP15_SCR_rupd((!CP15),SCR_NS_rupd(x0,false)))
                    end
             else ()
           ; EnterMonitorMode(new_spsr_value,(new_lr_value,vect_offset))
           )
    else if route_to_hyp
      then ( CP15 :=
             (CP15_HSR_rupd
                ((!CP15),
                 {EC = BitsN.B(0x0,6), IL = false, ISS = BitsN.B(0x0,25)}))
           ; let
               val preferred_exceptn_return =
                 BitsN.-(new_lr_value,BitsN.B(0x4,32))
             in
               EnterHypMode
                 (new_spsr_value,(preferred_exceptn_return,vect_offset))
             end
           )
    else ( if (#M((!CPSR) : PSR)) = (BitsN.B(0x16,5))
             then let
                    val x0 = #SCR((!CP15) : CP15)
                  in
                    CP15 := (CP15_SCR_rupd((!CP15),SCR_NS_rupd(x0,false)))
                  end
           else ()
         ; CPSR := (PSR_M_rupd((!CPSR),BitsN.B(0x12,5)))
         ; write'SPSR new_spsr_value
         ; write'R(new_lr_value,BitsN.B(0xE,4))
         ; CPSR := (PSR_I_rupd((!CPSR),true))
         ; if (not(HaveSecurityExt ())) orelse
              ((HaveVirtExt ()) orelse
               ((not(#NS((#SCR((!CP15) : CP15)) : SCR))) orelse
                (#AW((#SCR((!CP15) : CP15)) : SCR))))
             then CPSR := (PSR_A_rupd((!CPSR),true))
           else ()
         ; CPSR := (PSR_IT_rupd((!CPSR),BitsN.B(0x0,8)))
         ; CPSR := (PSR_J_rupd((!CPSR),false))
         ; CPSR :=
           (PSR_T_rupd((!CPSR),#TE((#SCTLR((!CP15) : CP15)) : SCTLR)))
         ; CPSR :=
           (PSR_E_rupd((!CPSR),#EE((#SCTLR((!CP15) : CP15)) : SCTLR)))
         ; if #VE((#SCTLR((!CP15) : CP15)) : SCTLR)
             then raise IMPLEMENTATION_DEFINED ("branch to an IRQ vector")
           else BranchTo(BitsN.+(ExcVectorBase (),vect_offset))
         )
  end;

fun TakeVirtualIRQException () =
  let
    val new_lr_value =
      if #T((!CPSR) : PSR) then PC () else BitsN.-(PC (),BitsN.B(0x4,32))
    val new_spsr_value = (!CPSR)
    val vect_offset = BitsN.B(0x18,32)
  in
    ( CPSR := (PSR_M_rupd((!CPSR),BitsN.B(0x12,5)))
    ; write'SPSR new_spsr_value
    ; write'R(new_lr_value,BitsN.B(0xE,4))
    ; CPSR := (PSR_I_rupd((!CPSR),true))
    ; CPSR := (PSR_A_rupd((!CPSR),true))
    ; CPSR := (PSR_IT_rupd((!CPSR),BitsN.B(0x0,8)))
    ; CPSR := (PSR_J_rupd((!CPSR),false))
    ; CPSR := (PSR_T_rupd((!CPSR),#TE((#SCTLR((!CP15) : CP15)) : SCTLR)))
    ; CPSR := (PSR_E_rupd((!CPSR),#EE((#SCTLR((!CP15) : CP15)) : SCTLR)))
    ; if #VE((#SCTLR((!CP15) : CP15)) : SCTLR)
        then raise IMPLEMENTATION_DEFINED ("branch to an IRQ vector")
      else BranchTo(BitsN.+(ExcVectorBase (),vect_offset))
    )
  end;

fun TakePhysicalFIQException () =
  let
    val new_lr_value =
      if #T((!CPSR) : PSR) then PC () else BitsN.-(PC (),BitsN.B(0x4,32))
    val new_spsr_value = (!CPSR)
    val vect_offset = BitsN.B(0x1C,32)
    val route_to_monitor =
      (HaveSecurityExt ()) andalso (#FIQ((#SCR((!CP15) : CP15)) : SCR))
    val route_to_hyp =
      ((HaveVirtExt ()) andalso
       ((HaveSecurityExt ()) andalso
        ((not(#FIQ((#SCR((!CP15) : CP15)) : SCR))) andalso
         ((#FMO((#HCR((!CP15) : CP15)) : HCR)) andalso (not(IsSecure ())))))) orelse
      ((#M((!CPSR) : PSR)) = (BitsN.B(0x1A,5)))
  in
    if route_to_monitor
      then ( if (#M((!CPSR) : PSR)) = (BitsN.B(0x16,5))
               then let
                      val x0 = #SCR((!CP15) : CP15)
                    in
                      CP15 :=
                      (CP15_SCR_rupd((!CP15),SCR_NS_rupd(x0,false)))
                    end
             else ()
           ; EnterMonitorMode(new_spsr_value,(new_lr_value,vect_offset))
           )
    else if route_to_hyp
      then ( CP15 :=
             (CP15_HSR_rupd
                ((!CP15),
                 {EC = BitsN.B(0x0,6), IL = false, ISS = BitsN.B(0x0,25)}))
           ; let
               val preferred_exceptn_return =
                 BitsN.-(new_lr_value,BitsN.B(0x4,32))
             in
               EnterHypMode
                 (new_spsr_value,(preferred_exceptn_return,vect_offset))
             end
           )
    else ( if (#M((!CPSR) : PSR)) = (BitsN.B(0x16,5))
             then let
                    val x0 = #SCR((!CP15) : CP15)
                  in
                    CP15 := (CP15_SCR_rupd((!CP15),SCR_NS_rupd(x0,false)))
                  end
           else ()
         ; CPSR := (PSR_M_rupd((!CPSR),BitsN.B(0x11,5)))
         ; write'SPSR new_spsr_value
         ; write'R(new_lr_value,BitsN.B(0xE,4))
         ; CPSR := (PSR_I_rupd((!CPSR),true))
         ; if (not(HaveSecurityExt ())) orelse
              ((HaveVirtExt ()) orelse
               ((not(#NS((#SCR((!CP15) : CP15)) : SCR))) orelse
                (#FW((#SCR((!CP15) : CP15)) : SCR))))
             then CPSR := (PSR_F_rupd((!CPSR),true))
           else ()
         ; if (not(HaveSecurityExt ())) orelse
              ((HaveVirtExt ()) orelse
               ((not(#NS((#SCR((!CP15) : CP15)) : SCR))) orelse
                (#AW((#SCR((!CP15) : CP15)) : SCR))))
             then CPSR := (PSR_A_rupd((!CPSR),true))
           else ()
         ; CPSR := (PSR_IT_rupd((!CPSR),BitsN.B(0x0,8)))
         ; CPSR := (PSR_J_rupd((!CPSR),false))
         ; CPSR :=
           (PSR_T_rupd((!CPSR),#TE((#SCTLR((!CP15) : CP15)) : SCTLR)))
         ; CPSR :=
           (PSR_E_rupd((!CPSR),#EE((#SCTLR((!CP15) : CP15)) : SCTLR)))
         ; if #VE((#SCTLR((!CP15) : CP15)) : SCTLR)
             then raise IMPLEMENTATION_DEFINED ("branch to an FIQ vector")
           else BranchTo(BitsN.+(ExcVectorBase (),vect_offset))
         )
  end;

fun TakeVirtualFIQException () =
  let
    val new_lr_value =
      if #T((!CPSR) : PSR) then PC () else BitsN.-(PC (),BitsN.B(0x4,32))
    val new_spsr_value = (!CPSR)
    val vect_offset = BitsN.B(0x1C,32)
  in
    ( CPSR := (PSR_M_rupd((!CPSR),BitsN.B(0x11,5)))
    ; write'SPSR new_spsr_value
    ; write'R(new_lr_value,BitsN.B(0xE,4))
    ; CPSR := (PSR_I_rupd((!CPSR),true))
    ; CPSR := (PSR_F_rupd((!CPSR),true))
    ; CPSR := (PSR_A_rupd((!CPSR),true))
    ; CPSR := (PSR_IT_rupd((!CPSR),BitsN.B(0x0,8)))
    ; CPSR := (PSR_J_rupd((!CPSR),false))
    ; CPSR := (PSR_T_rupd((!CPSR),#TE((#SCTLR((!CP15) : CP15)) : SCTLR)))
    ; CPSR := (PSR_E_rupd((!CPSR),#EE((#SCTLR((!CP15) : CP15)) : SCTLR)))
    ; if #VE((#SCTLR((!CP15) : CP15)) : SCTLR)
        then raise IMPLEMENTATION_DEFINED ("branch to an FIQ vector")
      else BranchTo(BitsN.+(ExcVectorBase (),vect_offset))
    )
  end;

fun TakeHypTrapException () =
  let
    val preferred_exceptn_return =
      if #T((!CPSR) : PSR)
        then BitsN.-(PC (),BitsN.B(0x4,32))
      else BitsN.-(PC (),BitsN.B(0x8,32))
    val new_spsr_value = (!CPSR)
  in
    EnterHypMode
      (new_spsr_value,(preferred_exceptn_return,BitsN.B(0x14,32)))
  end;

fun WriteHSR (ec,HSRString) =
  let
    val HSRValue = ref (BitsN.B(0x0,32))
  in
    ( HSRValue := (BitsN.bitFieldInsert(31,26) ((!HSRValue),ec))
    ; if (not((BitsN.bits(5,3) ec) = (BitsN.B(0x4,3)))) orelse
         ((BitsN.bit(ec,2)) andalso (BitsN.bit(HSRString,24)))
        then HSRValue :=
             (BitsN.bitFieldInsert(25,25)
                ((!HSRValue),BitsN.fromBit((ThisInstrLength ()) = 32)))
      else ()
    ; if ((BitsN.bits(5,4) ec) = (BitsN.B(0x0,2))) andalso
         (not((BitsN.bits(3,0) ec) = (BitsN.B(0x0,4))))
        then if (CurrentInstrSet ()) = InstrSet_ARM
               then ( HSRValue :=
                      (BitsN.bitFieldInsert(24,24)
                         ((!HSRValue),BitsN.fromBit true))
                    ; HSRValue :=
                      (BitsN.bitFieldInsert(23,20)
                         ((!HSRValue),CurrentCond ()))
                    )
             else ( HSRValue :=
                    (BitsN.bitFieldInsert(24,24)
                       ((!HSRValue),BitsN.fromBit false))
                  ; if BitsN.bit((!HSRValue),24)
                      then if ConditionPassed ()
                             then HSRValue :=
                                  (BitsN.bitFieldInsert(23,20)
                                     ((!HSRValue),
                                      if false
                                        then CurrentCond ()
                                      else BitsN.B(0xE,4)))
                           else HSRValue :=
                                (BitsN.bitFieldInsert(23,20)
                                   ((!HSRValue),CurrentCond ()))
                    else ()
                  ; HSRValue :=
                    (BitsN.bitFieldInsert(19,0)
                       ((!HSRValue),BitsN.bits(19,0) HSRString))
                  )
      else HSRValue :=
           (BitsN.bitFieldInsert(24,0) ((!HSRValue),HSRString))
    ; let
        val x0 = #HSR((!CP15) : CP15)
      in
        CP15 := (CP15_HSR_rupd((!CP15),write'reg'HSR(x0,(!HSRValue))))
      end
    )
  end;

fun CallSupervisor immediate =
  ( if (CurrentModeIsHyp ()) orelse
       ((HaveVirtExt ()) andalso
        ((not(IsSecure ())) andalso
         ((not(CurrentModeIsNotUser ())) andalso
          (#TGE((#HCR((!CP15) : CP15)) : HCR)))))
      then let
             val HSRString = ref (BitsN.B(0x0,25))
           in
             ( HSRString :=
               (BitsN.bitFieldInsert(15,0)
                  ((!HSRString),
                   if (CurrentCond ()) = (BitsN.B(0xE,4))
                     then immediate
                   else BitsN.B(0x0,16)))
             ; WriteHSR(BitsN.B(0x12,6),(!HSRString))
             )
           end
    else ()
  ; TakeSVCException ()
  );

fun CallHypervisor immediate =
  let
    val HSRString = BitsN.@@(immediate,BitsN.B(0x0,9))
  in
    ( WriteHSR(BitsN.B(0x12,6),HSRString); TakeHVCException () )
  end;

fun BankedRegisterAccessValid (SYSm,mode) =
  if (BitsN.bits(4,3) SYSm) = (BitsN.B(0x0,2))
    then if (BitsN.bits(2,0) SYSm) = (BitsN.B(0x7,3))
           then raise UNPREDICTABLE ("BankedRegisterAccessValid")
         else if (BitsN.bits(2,0) SYSm) = (BitsN.B(0x6,3))
           then if Set.mem(mode,[BitsN.B(0x1A,5),BitsN.B(0x1F,5)])
                  then raise UNPREDICTABLE ("BankedRegisterAccessValid")
                else ()
         else if (BitsN.bits(2,0) SYSm) = (BitsN.B(0x5,3))
           then if mode = (BitsN.B(0x1F,5))
                  then raise UNPREDICTABLE ("BankedRegisterAccessValid")
                else ()
         else if not(mode = (BitsN.B(0x11,5)))
           then raise UNPREDICTABLE ("BankedRegisterAccessValid")
         else ()
  else if (BitsN.bits(4,3) SYSm) = (BitsN.B(0x1,2))
    then if ((BitsN.bits(2,0) SYSm) = (BitsN.B(0x7,3))) orelse
            ((mode = (BitsN.B(0x11,5))) orelse
             ((#RFR((#NSACR((!CP15) : CP15)) : NSACR)) andalso
              (not(IsSecure ()))))
           then raise UNPREDICTABLE ("BankedRegisterAccessValid")
         else ()
  else if (BitsN.bits(4,3) SYSm) = (BitsN.B(0x3,2))
    then if not(BitsN.bit(SYSm,2))
           then raise UNPREDICTABLE ("BankedRegisterAccessValid")
         else if not(BitsN.bit(SYSm,1))
           then if (not(IsSecure ())) orelse (mode = (BitsN.B(0x16,5)))
                  then raise UNPREDICTABLE ("BankedRegisterAccessValid")
                else ()
         else if not(mode = (BitsN.B(0x16,5)))
           then raise UNPREDICTABLE ("BankedRegisterAccessValid")
         else ()
  else ();

fun SPSRAccessValid (SYSm,mode) =
  case SYSm of
     BitsN.B(0xE,_) =>
       if ((not(IsSecure ())) andalso
           (#RFR((#NSACR((!CP15) : CP15)) : NSACR))) orelse
          (mode = (BitsN.B(0x11,5)))
         then raise UNPREDICTABLE ("SPSRAccessValid")
       else ()
   | BitsN.B(0x10,_) =>
     if mode = (BitsN.B(0x12,5))
       then raise UNPREDICTABLE ("SPSRAccessValid")
     else ()
   | BitsN.B(0x12,_) =>
     if mode = (BitsN.B(0x13,5))
       then raise UNPREDICTABLE ("SPSRAccessValid")
     else ()
   | BitsN.B(0x14,_) =>
     if mode = (BitsN.B(0x17,5))
       then raise UNPREDICTABLE ("SPSRAccessValid")
     else ()
   | BitsN.B(0x16,_) =>
     if mode = (BitsN.B(0x1B,5))
       then raise UNPREDICTABLE ("SPSRAccessValid")
     else ()
   | BitsN.B(0x1C,_) =>
     if (mode = (BitsN.B(0x16,5))) orelse (not(IsSecure ()))
       then raise UNPREDICTABLE ("SPSRAccessValid")
     else ()
   | BitsN.B(0x1E,_) =>
     if not(mode = (BitsN.B(0x16,5)))
       then raise UNPREDICTABLE ("SPSRAccessValid")
     else ()
   | _ => raise UNPREDICTABLE ("SPSRAccessValid");

fun dfn'BranchTarget imm32 = BranchWritePC(BitsN.+(PC (),imm32));

fun dfn'BranchExchange m = BXWritePC(R m);

fun dfn'BranchLinkExchangeImmediate (targetInstrSet,imm32) =
  ( if (CurrentInstrSet ()) = InstrSet_ARM
      then write'LR(BitsN.-(PC (),BitsN.B(0x4,32)))
    else write'LR(BitsN.@@(BitsN.bits(31,1) (PC ()),BitsN.B(0x1,1)))
  ; let
      val targetAddress =
        if targetInstrSet = InstrSet_ARM
          then BitsN.+(Align 32 (PC (),4),imm32)
        else BitsN.+(PC (),imm32)
    in
      ( SelectInstrSet targetInstrSet; BranchWritePC targetAddress )
    end
  );

fun dfn'BranchLinkExchangeRegister m =
  let
    val target = R m
  in
    ( if (CurrentInstrSet ()) = InstrSet_ARM
        then let
               val next_instr_addr = BitsN.-(PC (),BitsN.B(0x4,32))
             in
               write'LR next_instr_addr
             end
      else let
             val next_instr_addr = BitsN.-(PC (),BitsN.B(0x2,32))
           in
             write'LR
               (BitsN.@@(BitsN.bits(31,1) next_instr_addr,BitsN.B(0x1,1)))
           end
    ; BXWritePC target
    )
  end;

fun dfn'CompareBranch (nonzero,(n,imm32)) =
  if not(nonzero = ((R n) = (BitsN.B(0x0,32))))
    then BranchWritePC(BitsN.+(PC (),imm32))
  else IncPC ();

fun dfn'TableBranchByte (is_tbh,(m,n)) =
  if NullCheckIfThumbEE n
    then let
           val halfwords =
             if is_tbh
               then MemU 16 (BitsN.+(R n,LSL 32 (R m,1)),2)
             else MemU 16 (BitsN.+(R n,R m),1)
         in
           BranchWritePC
             (BitsN.+
                (PC (),
                 BitsN.*
                   (BitsN.B(0x2,32),
                    BitsN.fromNat(BitsN.toNat halfwords,32))))
         end
  else ();

fun dfn'CheckArray (m,n) =
  if BitsN.<=+(R n,R m)
    then ( write'LR(BitsN.@@(BitsN.bits(31,1) (PC ()),BitsN.B(0x1,1)))
         ; write'ITSTATE(BitsN.B(0x0,8))
         ; BranchWritePC(BitsN.-(#TEEHBR((!CP14) : CP14),BitsN.B(0x8,32)))
         )
  else IncPC ();

fun dfn'HandlerBranchLink (generate_link,handler_offset) =
  ( if generate_link
      then let
             val next_instr_addr = BitsN.-(PC (),BitsN.B(0x2,32))
           in
             write'LR
               (BitsN.@@(BitsN.bits(31,1) next_instr_addr,BitsN.B(0x1,1)))
           end
    else ()
  ; BranchWritePC(BitsN.+(#TEEHBR((!CP14) : CP14),handler_offset))
  );

fun dfn'HandlerBranchLinkParameter (imm32,handler_offset) =
  ( write'R(imm32,BitsN.B(0x8,4))
  ; let
      val next_instr_addr = BitsN.-(PC (),BitsN.B(0x2,32))
    in
      ( write'LR
          (BitsN.@@(BitsN.bits(31,1) next_instr_addr,BitsN.B(0x1,1)))
      ; BranchWritePC(BitsN.+(#TEEHBR((!CP14) : CP14),handler_offset))
      )
    end
  );

fun dfn'HandlerBranchParameter (imm32,handler_offset) =
  ( write'R(imm32,BitsN.B(0x8,4))
  ; BranchWritePC(BitsN.+(#TEEHBR((!CP14) : CP14),handler_offset))
  );

fun dfn'EnterxLeavex is_enterx =
  if is_enterx
    then if CurrentModeIsHyp ()
           then TakeUndefInstrException ()
         else ( SelectInstrSet InstrSet_ThumbEE; IncPC () )
  else ( SelectInstrSet InstrSet_Thumb; IncPC () );

fun dfn'IfThen (firstcond,mask) =
  ( CPSR := (PSR_IT_rupd((!CPSR),BitsN.@@(firstcond,mask)))
  ; IncPC ()
  ; Encoding := Encoding_ARM
  );

fun dfn'CountLeadingZeroes (d,m) =
  ( write'R(BitsN.fromNat(CountLeadingZeroBits 32 (R m),32),d); IncPC () );

fun dfn'MoveHalfword (high,(d,imm16)) =
  ( if high
      then let
             val w = R d
           in
             write'R(BitsN.bitFieldInsert(31,16) (w,imm16),d)
           end
    else write'R(BitsN.zeroExtend 32 imm16,d)
  ; IncPC ()
  );

fun DataProcessing (opc,(setflags,(d,(n,(imm32,C))))) =
  let
    val rn =
      if (opc = (BitsN.B(0xD,4))) orelse
         ((opc = (BitsN.B(0xF,4))) andalso (n = (BitsN.B(0xF,4))))
        then BitsN.B(0x0,32)
      else if (Set.mem(opc,[BitsN.B(0x4,4),BitsN.B(0x2,4)])) andalso
         ((n = (BitsN.B(0xF,4))) andalso (not setflags))
        then Align 32 (PC (),4)
      else R n
    val (result,(carry,overflow)) =
      DataProcessingALU(opc,(rn,(imm32,#C((!CPSR) : PSR))))
  in
    ( if not((BitsN.bits(3,2) opc) = (BitsN.B(0x2,2)))
        then write'R(result,d)
      else ()
    ; if setflags
        then ( CPSR := (PSR_N_rupd((!CPSR),BitsN.bit(result,31)))
             ; CPSR := (PSR_Z_rupd((!CPSR),result = (BitsN.B(0x0,32))))
             ; if ArithmeticOpcode opc
                 then ( CPSR := (PSR_C_rupd((!CPSR),carry))
                      ; CPSR := (PSR_V_rupd((!CPSR),overflow))
                      )
               else CPSR := (PSR_C_rupd((!CPSR),C))
             )
      else ()
    ; IncPC ()
    )
  end;

fun DataProcessingPC (opc,(setflags,(n,imm32))) =
  let
    val rn =
      if (opc = (BitsN.B(0xD,4))) orelse
         ((opc = (BitsN.B(0xF,4))) andalso (n = (BitsN.B(0xF,4))))
        then BitsN.B(0x0,32)
      else if (Set.mem(opc,[BitsN.B(0x4,4),BitsN.B(0x2,4)])) andalso
         ((n = (BitsN.B(0xF,4))) andalso (not setflags))
        then Align 32 (PC (),4)
      else R n
    val (result,_) = DataProcessingALU(opc,(rn,(imm32,#C((!CPSR) : PSR))))
  in
    if setflags
      then if CurrentModeIsHyp ()
             then TakeUndefInstrException ()
           else if CurrentModeIsUserOrSystem ()
             then raise UNPREDICTABLE ("DataProcessingPC")
           else ( CPSRWriteByInstr(reg'PSR(SPSR ()),(BitsN.B(0xF,4),true))
                ; if ((#M((!CPSR) : PSR)) = (BitsN.B(0x1A,5))) andalso
                     ((CurrentInstrSet ()) = InstrSet_ThumbEE)
                    then raise UNPREDICTABLE ("DataProcessingPC")
                  else BranchWritePC result
                )
    else ALUWritePC result
  end;

fun dfn'Move (setflags,(negate,(d,imm12))) =
  let
    val opc =
      BitsN.concat[BitsN.B(0x3,2),BitsN.fromBit negate,BitsN.B(0x1,1)]
    val (imm32,carry) = ExpandImm_C(imm12,#C((!CPSR) : PSR))
  in
    if d = (BitsN.B(0xF,4))
      then DataProcessingPC(opc,(setflags,(BitsN.B(0xF,4),imm32)))
    else DataProcessing(opc,(setflags,(d,(BitsN.B(0xF,4),(imm32,carry)))))
  end;

fun dfn'TestCompareImmediate (op',(n,imm12)) =
  let
    val (imm32,carry) = ExpandImm_C(imm12,#C((!CPSR) : PSR))
  in
    DataProcessing
      (BitsN.@@(BitsN.B(0x2,2),op'),
       (true,(BitsN.B(0x0,4),(n,(imm32,carry)))))
  end;

fun dfn'ArithLogicImmediate (opc,(setflags,(d,(n,imm12)))) =
  let
    val (imm32,carry) = ExpandImm_C(imm12,#C((!CPSR) : PSR))
  in
    if d = (BitsN.B(0xF,4))
      then DataProcessingPC(opc,(setflags,(n,imm32)))
    else DataProcessing(opc,(setflags,(d,(n,(imm32,carry)))))
  end;

fun doRegister (opc,(setflags,(d,(n,(m,(shift_t,shift_n)))))) =
  let
    val (shifted,carry) =
      Shift_C 32 (R m,(shift_t,(shift_n,#C((!CPSR) : PSR))))
  in
    if d = (BitsN.B(0xF,4))
      then DataProcessingPC(opc,(setflags,(n,shifted)))
    else DataProcessing(opc,(setflags,(d,(n,(shifted,carry)))))
  end;

fun dfn'Register (opc,(setflags,(d,(n,(m,(shift_t,shift_n)))))) =
  doRegister(opc,(setflags,(d,(n,(m,(shift_t,shift_n))))));

fun dfn'TestCompareRegister (opc,(n,(m,(shift_t,shift_n)))) =
  doRegister
    (BitsN.@@(BitsN.B(0x2,2),opc),
     (true,(BitsN.B(0x0,4),(n,(m,(shift_t,shift_n))))));

fun dfn'ShiftImmediate (negate,(setflags,(d,(m,(shift_t,shift_n))))) =
  if negate
    then doRegister
           (BitsN.B(0xF,4),
            (setflags,(d,(BitsN.B(0xF,4),(m,(shift_t,shift_n))))))
  else doRegister
         (BitsN.B(0xD,4),
          (setflags,(d,(BitsN.B(0x0,4),(m,(shift_t,shift_n))))));

fun doRegisterShiftedRegister (opc,(setflags,(d,(n,(m,(shift_t,s)))))) =
  let
    val (shifted,carry) =
      Shift_C 32
        (R m,
         (shift_t,(BitsN.toNat(BitsN.bits(7,0) (R s)),#C((!CPSR) : PSR))))
  in
    DataProcessing(opc,(setflags,(d,(n,(shifted,carry)))))
  end;

fun dfn'RegisterShiftedRegister (opc,(setflags,(d,(n,(m,(shift_t,s)))))) =
  doRegisterShiftedRegister(opc,(setflags,(d,(n,(m,(shift_t,s))))));

fun dfn'ShiftRegister (negate,(setflags,(d,(n,(shift_t,m))))) =
  if negate
    then doRegisterShiftedRegister
           (BitsN.B(0xF,4),(setflags,(d,(BitsN.B(0xF,4),(n,(shift_t,m))))))
  else doRegisterShiftedRegister
         (BitsN.B(0xD,4),(setflags,(d,(BitsN.B(0x0,4),(n,(shift_t,m))))));

fun dfn'AddSub (sub,(d,(n,imm12))) =
  let
    val opc = if sub then BitsN.B(0x2,4) else BitsN.B(0x4,4)
    val imm32 = BitsN.zeroExtend 32 imm12
  in
    DataProcessing(opc,(false,(d,(n,(imm32,false)))))
  end;

fun dfn'SaturatingAddSubtract (opc,(d,(m,n))) =
  let
    val result = ref (BitsN.B(0x0,32))
  in
    let
      val sat = ref false
    in
      ( case opc of
           BitsN.B(0x0,_) =>
             let
               val (r,s) =
                 SignedSatQ 32
                   (IntInf.+(BitsN.toInt(R m),BitsN.toInt(R n)),32)
             in
               ( result := r; sat := s )
             end
         | BitsN.B(0x1,_) =>
           let
             val (r,s) =
               SignedSatQ 32
                 (IntInf.-(BitsN.toInt(R m),BitsN.toInt(R n)),32)
           in
             ( result := r; sat := s )
           end
         | BitsN.B(0x2,_) =>
           let
             val (doubled,sat1) =
               SignedSatQ 32 (IntInf.*(2,BitsN.toInt(R n)),32)
             val (r,sat2) =
               SignedSatQ 32
                 (IntInf.+(BitsN.toInt(R m),BitsN.toInt doubled),32)
           in
             ( result := r; sat := (sat1 orelse sat2) )
           end
         | BitsN.B(0x3,_) =>
           let
             val (doubled,sat1) =
               SignedSatQ 32 (IntInf.*(2,BitsN.toInt(R n)),32)
             val (r,sat2) =
               SignedSatQ 32
                 (IntInf.-(BitsN.toInt(R m),BitsN.toInt doubled),32)
           in
             ( result := r; sat := (sat1 orelse sat2) )
           end
         | _ => raise General.Bind
      ; write'R((!result),d)
      ; if (!sat) then CPSR := (PSR_Q_rupd((!CPSR),true)) else ()
      ; IncPC ()
      )
    end
  end;

fun dfn'Multiply32 (setflags,(d,(n,m))) =
  let
    val rn = R n
    val rm = R m
    val result = BitsN.*(rn,rm)
  in
    ( write'R(result,d)
    ; if setflags
        then ( CPSR := (PSR_N_rupd((!CPSR),BitsN.bit(result,31)))
             ; CPSR := (PSR_Z_rupd((!CPSR),result = (BitsN.B(0x0,32))))
             ; if (ArchVersion ()) = 4
                 then CPSR :=
                      (PSR_C_rupd
                         ((!CPSR),(L3.K false) (rn,(rm,#C((!CPSR) : PSR)))))
               else ()
             )
      else ()
    ; IncPC ()
    )
  end;

fun dfn'MultiplyAccumulate (setflags,(d,(n,(m,a)))) =
  let
    val rn = R n
    val rm = R m
    val ra = R a
    val result = BitsN.+(BitsN.*(rn,rm),ra)
  in
    ( write'R(result,d)
    ; if setflags
        then ( CPSR := (PSR_N_rupd((!CPSR),BitsN.bit(result,31)))
             ; CPSR := (PSR_Z_rupd((!CPSR),result = (BitsN.B(0x0,32))))
             ; if (ArchVersion ()) = 4
                 then CPSR :=
                      (PSR_C_rupd
                         ((!CPSR),
                          (L3.K false) (rn,(rm,(ra,#C((!CPSR) : PSR))))))
               else ()
             )
      else ()
    ; IncPC ()
    )
  end;

fun dfn'MultiplyLong (accumulate,(signed,(setflags,(dhi,(dlo,(n,m)))))) =
  let
    val rn = R n
    val rm = R m
    val rdhi = R dhi
    val rdlo = R dlo
    val result =
      BitsN.+
        (if signed
           then BitsN.*(BitsN.signExtend 64 rn,BitsN.signExtend 64 rm)
         else BitsN.*(BitsN.zeroExtend 64 rn,BitsN.zeroExtend 64 rm),
         if accumulate then BitsN.@@(rdhi,rdlo) else BitsN.B(0x0,64))
  in
    ( write'R(BitsN.bits(63,32) result,dhi)
    ; write'R(BitsN.bits(31,0) result,dlo)
    ; if setflags
        then ( CPSR := (PSR_N_rupd((!CPSR),BitsN.bit(result,63)))
             ; CPSR := (PSR_Z_rupd((!CPSR),result = (BitsN.B(0x0,64))))
             ; if (ArchVersion ()) = 4
                 then ( CPSR :=
                        (PSR_C_rupd
                           ((!CPSR),
                            (L3.K false)
                              (rn,(rm,(rdhi,(rdlo,#C((!CPSR) : PSR)))))))
                      ; CPSR :=
                        (PSR_V_rupd
                           ((!CPSR),
                            (L3.K false)
                              (rn,(rm,(rdhi,(rdlo,#V((!CPSR) : PSR)))))))
                      )
               else ()
             )
      else ()
    ; IncPC ()
    )
  end;

fun dfn'MultiplyAccumulateAccumulate (dhi,(dlo,(n,m))) =
  let
    val result =
      BitsN.+
        (BitsN.+
           (BitsN.*(BitsN.zeroExtend 64 (R n),BitsN.zeroExtend 64 (R m)),
            BitsN.zeroExtend 64 (R dhi)),BitsN.zeroExtend 64 (R dlo))
  in
    ( write'R(BitsN.bits(63,32) result,dhi)
    ; write'R(BitsN.bits(31,0) result,dlo)
    ; IncPC ()
    )
  end;

fun dfn'MultiplySubtract (d,(n,(m,a))) =
  ( write'R(BitsN.-(R a,BitsN.*(R m,R n)),d); IncPC () );

fun dfn'Signed16Multiply32Accumulate (m_high,(n_high,(d,(n,(m,a))))) =
  let
    val operand1 =
      if n_high then BitsN.bits(31,16) (R n) else BitsN.bits(15,0) (R n)
    val operand2 =
      if m_high then BitsN.bits(31,16) (R m) else BitsN.bits(15,0) (R m)
    val result =
      IntInf.+
        (IntInf.*(BitsN.toInt operand1,BitsN.toInt operand2),
         BitsN.toInt(R a))
    val result32 = BitsN.fromInt(result,32)
  in
    ( write'R(result32,d)
    ; if not(result = (BitsN.toInt result32))
        then CPSR := (PSR_Q_rupd((!CPSR),true))
      else ()
    ; IncPC ()
    )
  end;

fun dfn'Signed16Multiply32Result (m_high,(n_high,(d,(n,m)))) =
  let
    val operand1 =
      if n_high then BitsN.bits(31,16) (R n) else BitsN.bits(15,0) (R n)
    val operand2 =
      if m_high then BitsN.bits(31,16) (R m) else BitsN.bits(15,0) (R m)
    val result = IntInf.*(BitsN.toInt operand1,BitsN.toInt operand2)
  in
    ( write'R(BitsN.fromInt(result,32),d); IncPC () )
  end;

fun dfn'Signed16x32Multiply32Accumulate (m_high,(d,(n,(m,a)))) =
  let
    val operand2 =
      if m_high then BitsN.bits(31,16) (R m) else BitsN.bits(15,0) (R m)
    val sh16 = IntInf.pow(2,16)
    val result =
      IntInf.div
        (IntInf.+
           (IntInf.*(BitsN.toInt(R n),BitsN.toInt operand2),
            IntInf.*(BitsN.toInt(R a),sh16)),sh16)
    val result32 = BitsN.fromInt(result,32)
  in
    ( write'R(result32,d)
    ; if not(result = (BitsN.toInt result32))
        then CPSR := (PSR_Q_rupd((!CPSR),true))
      else ()
    ; IncPC ()
    )
  end;

fun dfn'Signed16x32Multiply32Result (m_high,(d,(n,m))) =
  let
    val operand2 =
      if m_high then BitsN.bits(31,16) (R m) else BitsN.bits(15,0) (R m)
    val result =
      IntInf.div
        (IntInf.*(BitsN.toInt(R n),BitsN.toInt operand2),IntInf.pow(2,16))
  in
    ( write'R(BitsN.fromInt(result,32),d); IncPC () )
  end;

fun dfn'Signed16Multiply64Accumulate (m_high,(n_high,(dhi,(dlo,(n,m))))) =
  let
    val operand1 =
      if n_high then BitsN.bits(31,16) (R n) else BitsN.bits(15,0) (R n)
    val operand2 =
      if m_high then BitsN.bits(31,16) (R m) else BitsN.bits(15,0) (R m)
    val result =
      IntInf.+
        (IntInf.*(BitsN.toInt operand1,BitsN.toInt operand2),
         BitsN.toInt(BitsN.@@(R dhi,R dlo)))
    val result64 = BitsN.fromInt(result,64)
  in
    ( write'R(BitsN.bits(63,32) result64,dhi)
    ; write'R(BitsN.bits(31,0) result64,dlo)
    ; IncPC ()
    )
  end;

fun dfn'SignedMultiplyDual (sub,(m_swap,(d,(n,(m,a))))) =
  let
    val operand2 = if m_swap then ROR 32 (R m,16) else R m
    val product1 =
      IntInf.*
        (BitsN.toInt(BitsN.bits(15,0) (R n)),
         BitsN.toInt(BitsN.bits(15,0) operand2))
    val product2 =
      IntInf.*
        (BitsN.toInt(BitsN.bits(31,16) (R n)),
         BitsN.toInt(BitsN.bits(31,16) operand2))
    val acc = if a = (BitsN.B(0xF,4)) then BitsN.B(0x0,32) else R a
    val result =
      if sub
        then IntInf.+(IntInf.-(product1,product2),BitsN.toInt acc)
      else IntInf.+(IntInf.+(product1,product2),BitsN.toInt acc)
    val result32 = BitsN.fromInt(result,32)
  in
    ( write'R(result32,d)
    ; if not(result = (BitsN.toInt result32))
        then CPSR := (PSR_Q_rupd((!CPSR),true))
      else ()
    ; IncPC ()
    )
  end;

fun dfn'SignedMultiplyLongDual (sub,(m_swap,(dhi,(dlo,(n,m))))) =
  let
    val Rn = R n
    val operand2 = if m_swap then ROR 32 (R m,16) else R m
    val product1 =
      IntInf.*
        (BitsN.toInt(BitsN.bits(15,0) Rn),
         BitsN.toInt(BitsN.bits(15,0) operand2))
    val product2 =
      IntInf.*
        (BitsN.toInt(BitsN.bits(31,16) Rn),
         BitsN.toInt(BitsN.bits(31,16) operand2))
    val acc = BitsN.@@(R dhi,R dlo)
    val result =
      if sub
        then IntInf.+(IntInf.-(product1,product2),BitsN.toInt acc)
      else IntInf.+(IntInf.+(product1,product2),BitsN.toInt acc)
    val result64 = BitsN.fromInt(result,64)
  in
    ( write'R(BitsN.bits(63,32) result64,dhi)
    ; write'R(BitsN.bits(31,0) result64,dlo)
    ; IncPC ()
    )
  end;

fun dfn'SignedMostSignificantMultiply (round,(d,(n,(m,a)))) =
  let
    val acc = if a = (BitsN.B(0xF,4)) then BitsN.B(0x0,32) else R a
    val result =
      IntInf.+
        (BitsN.toInt(BitsN.<<(BitsN.fromNat(BitsN.toNat acc,64),32)),
         IntInf.*(BitsN.toInt(R n),BitsN.toInt(R m)))
    val result = if round then IntInf.+(result,2147483648) else result
  in
    ( write'R(BitsN.bits(63,32) (BitsN.fromInt(result,64)),d); IncPC () )
  end;

fun dfn'SignedMostSignificantMultiplySubtract (round,(d,(n,(m,a)))) =
  let
    val result =
      IntInf.-
        (BitsN.toInt(BitsN.<<(BitsN.fromNat(BitsN.toNat(R a),64),32)),
         IntInf.*(BitsN.toInt(R n),BitsN.toInt(R m)))
    val result = if round then IntInf.+(result,2147483648) else result
  in
    ( write'R(BitsN.bits(63,32) (BitsN.fromInt(result,64)),d); IncPC () )
  end;

fun SignedParallelAddSub16 (op',(n,m)) =
  let
    val Rn = R n
    val Rm = R m
  in
    case op' of
       BitsN.B(0x0,_) =>
         (IntInf.+
            (BitsN.toInt(BitsN.bits(15,0) Rn),
             BitsN.toInt(BitsN.bits(15,0) Rm)),
          IntInf.+
            (BitsN.toInt(BitsN.bits(31,16) Rn),
             BitsN.toInt(BitsN.bits(31,16) Rm)))
     | BitsN.B(0x1,_) =>
       (IntInf.-
          (BitsN.toInt(BitsN.bits(15,0) Rn),
           BitsN.toInt(BitsN.bits(31,16) Rm)),
        IntInf.+
          (BitsN.toInt(BitsN.bits(31,16) Rn),
           BitsN.toInt(BitsN.bits(15,0) Rm)))
     | BitsN.B(0x2,_) =>
       (IntInf.+
          (BitsN.toInt(BitsN.bits(15,0) Rn),
           BitsN.toInt(BitsN.bits(31,16) Rm)),
        IntInf.-
          (BitsN.toInt(BitsN.bits(31,16) Rn),
           BitsN.toInt(BitsN.bits(15,0) Rm)))
     | BitsN.B(0x3,_) =>
       (IntInf.-
          (BitsN.toInt(BitsN.bits(15,0) Rn),
           BitsN.toInt(BitsN.bits(15,0) Rm)),
        IntInf.-
          (BitsN.toInt(BitsN.bits(31,16) Rn),
           BitsN.toInt(BitsN.bits(31,16) Rm)))
     | _ => raise General.Bind
  end;

fun dfn'SignedAddSub16 (op',(d,(n,m))) =
  let
    val (res1,res2) = SignedParallelAddSub16(op',(n,m))
  in
    ( write'R(BitsN.@@(BitsN.fromInt(res2,16),BitsN.fromInt(res1,16)),d)
    ; let
        val w = #GE((!CPSR) : PSR)
      in
        CPSR :=
        (PSR_GE_rupd
           ((!CPSR),
            BitsN.bitFieldInsert(1,0)
              (w,
               if IntInf.>=(res1,0)
                 then BitsN.B(0x3,2)
               else BitsN.B(0x0,2))))
      end
    ; let
        val w = #GE((!CPSR) : PSR)
      in
        CPSR :=
        (PSR_GE_rupd
           ((!CPSR),
            BitsN.bitFieldInsert(3,2)
              (w,
               if IntInf.>=(res2,0)
                 then BitsN.B(0x3,2)
               else BitsN.B(0x0,2))))
      end
    ; IncPC ()
    )
  end;

fun dfn'SignedSaturatingAddSub16 (op',(d,(n,m))) =
  let
    val (res1,res2) = SignedParallelAddSub16(op',(n,m))
  in
    ( write'R(BitsN.@@(SignedSat 16 (res2,16),SignedSat 16 (res1,16)),d)
    ; IncPC ()
    )
  end;

fun dfn'SignedHalvingAddSub16 (op',(d,(n,m))) =
  let
    val (res1,res2) = SignedParallelAddSub16(op',(n,m))
  in
    ( write'R
        (BitsN.@@
           (BitsN.fromInt(IntInf.div(res2,2),16),
            BitsN.fromInt(IntInf.div(res1,2),16)),d)
    ; IncPC ()
    )
  end;

fun SignedParallelAddSub8 (sub,(n,m)) =
  let
    val Rn = R n
    val Rm = R m
  in
    if sub
      then (IntInf.-
              (BitsN.toInt(BitsN.bits(7,0) Rn),
               BitsN.toInt(BitsN.bits(7,0) Rm)),
            (IntInf.-
               (BitsN.toInt(BitsN.bits(15,8) Rn),
                BitsN.toInt(BitsN.bits(15,8) Rm)),
             (IntInf.-
                (BitsN.toInt(BitsN.bits(23,16) Rn),
                 BitsN.toInt(BitsN.bits(23,16) Rm)),
              IntInf.-
                (BitsN.toInt(BitsN.bits(31,24) Rn),
                 BitsN.toInt(BitsN.bits(31,24) Rm)))))
    else (IntInf.+
            (BitsN.toInt(BitsN.bits(7,0) Rn),
             BitsN.toInt(BitsN.bits(7,0) Rm)),
          (IntInf.+
             (BitsN.toInt(BitsN.bits(15,8) Rn),
              BitsN.toInt(BitsN.bits(15,8) Rm)),
           (IntInf.+
              (BitsN.toInt(BitsN.bits(23,16) Rn),
               BitsN.toInt(BitsN.bits(23,16) Rm)),
            IntInf.+
              (BitsN.toInt(BitsN.bits(31,24) Rn),
               BitsN.toInt(BitsN.bits(31,24) Rm)))))
  end;

fun dfn'SignedAddSub8 (sub,(d,(n,m))) =
  let
    val (res1,(res2,(res3,res4))) = SignedParallelAddSub8(sub,(n,m))
  in
    ( write'R
        (BitsN.concat
           [BitsN.fromInt(res4,8),BitsN.fromInt(res3,8),
            BitsN.fromInt(res2,8),BitsN.fromInt(res1,8)],d)
    ; let
        val w = #GE((!CPSR) : PSR)
      in
        CPSR :=
        (PSR_GE_rupd
           ((!CPSR),
            BitsN.bitFieldInsert(0,0) (w,BitsN.fromBit(IntInf.>=(res1,0)))))
      end
    ; let
        val w = #GE((!CPSR) : PSR)
      in
        CPSR :=
        (PSR_GE_rupd
           ((!CPSR),
            BitsN.bitFieldInsert(1,1) (w,BitsN.fromBit(IntInf.>=(res2,0)))))
      end
    ; let
        val w = #GE((!CPSR) : PSR)
      in
        CPSR :=
        (PSR_GE_rupd
           ((!CPSR),
            BitsN.bitFieldInsert(2,2) (w,BitsN.fromBit(IntInf.>=(res3,0)))))
      end
    ; let
        val w = #GE((!CPSR) : PSR)
      in
        CPSR :=
        (PSR_GE_rupd
           ((!CPSR),
            BitsN.bitFieldInsert(3,3) (w,BitsN.fromBit(IntInf.>=(res4,0)))))
      end
    ; IncPC ()
    )
  end;

fun dfn'SignedSaturatingAddSub8 (sub,(d,(n,m))) =
  let
    val (res1,(res2,(res3,res4))) = SignedParallelAddSub8(sub,(n,m))
  in
    ( write'R
        (BitsN.concat
           [SignedSat 8 (res4,8),SignedSat 8 (res3,8),
            SignedSat 8 (res2,8),SignedSat 8 (res1,8)],d)
    ; IncPC ()
    )
  end;

fun dfn'SignedHalvingAddSub8 (sub,(d,(n,m))) =
  let
    val (res1,(res2,(res3,res4))) = SignedParallelAddSub8(sub,(n,m))
  in
    ( write'R
        (BitsN.concat
           [BitsN.fromInt(IntInf.div(res4,2),8),
            BitsN.fromInt(IntInf.div(res3,2),8),
            BitsN.fromInt(IntInf.div(res2,2),8),
            BitsN.fromInt(IntInf.div(res1,2),8)],d)
    ; IncPC ()
    )
  end;

fun UnsignedParallelAddSub16 (op',(n,m)) =
  let
    val Rn = R n
    val Rm = R m
  in
    case op' of
       BitsN.B(0x0,_) =>
         (IntInf.+
            (UInt 16 (BitsN.bits(15,0) Rn),UInt 16 (BitsN.bits(15,0) Rm)),
          IntInf.+
            (UInt 16 (BitsN.bits(31,16) Rn),UInt 16 (BitsN.bits(31,16) Rm)))
     | BitsN.B(0x1,_) =>
       (IntInf.-
          (UInt 16 (BitsN.bits(15,0) Rn),UInt 16 (BitsN.bits(31,16) Rm)),
        IntInf.+
          (UInt 16 (BitsN.bits(31,16) Rn),UInt 16 (BitsN.bits(15,0) Rm)))
     | BitsN.B(0x2,_) =>
       (IntInf.+
          (UInt 16 (BitsN.bits(15,0) Rn),UInt 16 (BitsN.bits(31,16) Rm)),
        IntInf.-
          (UInt 16 (BitsN.bits(31,16) Rn),UInt 16 (BitsN.bits(15,0) Rm)))
     | BitsN.B(0x3,_) =>
       (IntInf.-
          (UInt 16 (BitsN.bits(15,0) Rn),UInt 16 (BitsN.bits(15,0) Rm)),
        IntInf.-
          (UInt 16 (BitsN.bits(31,16) Rn),UInt 16 (BitsN.bits(31,16) Rm)))
     | _ => raise General.Bind
  end;

fun dfn'UnsignedAddSub16 (op',(d,(n,m))) =
  let
    val (res1,res2) = UnsignedParallelAddSub16(op',(n,m))
  in
    ( write'R(BitsN.@@(BitsN.fromInt(res2,16),BitsN.fromInt(res1,16)),d)
    ; let
        val w = #GE((!CPSR) : PSR)
      in
        CPSR :=
        (PSR_GE_rupd
           ((!CPSR),
            BitsN.bitFieldInsert(1,0)
              (w,
               if IntInf.>=
                    (res1,
                     if Set.mem(op',[BitsN.B(0x1,2),BitsN.B(0x3,2)])
                       then 0
                     else 65536)
                 then BitsN.B(0x3,2)
               else BitsN.B(0x0,2))))
      end
    ; let
        val w = #GE((!CPSR) : PSR)
      in
        CPSR :=
        (PSR_GE_rupd
           ((!CPSR),
            BitsN.bitFieldInsert(3,2)
              (w,
               if IntInf.>=
                    (res2,
                     if Set.mem(op',[BitsN.B(0x2,2),BitsN.B(0x3,2)])
                       then 0
                     else 65536)
                 then BitsN.B(0x3,2)
               else BitsN.B(0x0,2))))
      end
    ; IncPC ()
    )
  end;

fun dfn'UnsignedSaturatingAddSub16 (op',(d,(n,m))) =
  let
    val (res1,res2) = UnsignedParallelAddSub16(op',(n,m))
  in
    ( write'R
        (BitsN.@@(UnsignedSat 16 (res2,16),UnsignedSat 16 (res1,16)),d)
    ; IncPC ()
    )
  end;

fun dfn'UnsignedHalvingAddSub16 (op',(d,(n,m))) =
  let
    val (res1,res2) = UnsignedParallelAddSub16(op',(n,m))
  in
    ( write'R
        (BitsN.@@
           (BitsN.fromInt(IntInf.div(res2,2),16),
            BitsN.fromInt(IntInf.div(res1,2),16)),d)
    ; IncPC ()
    )
  end;

fun UnsignedParallelAddSub8 (sub,(n,m)) =
  let
    val Rn = R n
    val Rm = R m
  in
    if sub
      then (IntInf.-
              (UInt 8 (BitsN.bits(7,0) Rn),UInt 8 (BitsN.bits(7,0) Rm)),
            (IntInf.-
               (UInt 8 (BitsN.bits(15,8) Rn),UInt 8 (BitsN.bits(15,8) Rm)),
             (IntInf.-
                (UInt 8 (BitsN.bits(23,16) Rn),
                 UInt 8 (BitsN.bits(23,16) Rm)),
              IntInf.-
                (UInt 8 (BitsN.bits(31,24) Rn),
                 UInt 8 (BitsN.bits(31,24) Rm)))))
    else (IntInf.+
            (UInt 8 (BitsN.bits(7,0) Rn),UInt 8 (BitsN.bits(7,0) Rm)),
          (IntInf.+
             (UInt 8 (BitsN.bits(15,8) Rn),UInt 8 (BitsN.bits(15,8) Rm)),
           (IntInf.+
              (UInt 8 (BitsN.bits(23,16) Rn),UInt 8 (BitsN.bits(23,16) Rm)),
            IntInf.+
              (UInt 8 (BitsN.bits(31,24) Rn),UInt 8 (BitsN.bits(31,24) Rm)))))
  end;

fun dfn'UnsignedAddSub8 (sub,(d,(n,m))) =
  let
    val (res1,(res2,(res3,res4))) = UnsignedParallelAddSub8(sub,(n,m))
  in
    ( write'R
        (BitsN.concat
           [BitsN.fromInt(res4,8),BitsN.fromInt(res3,8),
            BitsN.fromInt(res2,8),BitsN.fromInt(res1,8)],d)
    ; let
        val ge_lim = if sub then 0 else 256
      in
        ( let
            val w = #GE((!CPSR) : PSR)
          in
            CPSR :=
            (PSR_GE_rupd
               ((!CPSR),
                BitsN.bitFieldInsert(0,0)
                  (w,BitsN.fromBit(IntInf.>=(res1,ge_lim)))))
          end
        ; let
            val w = #GE((!CPSR) : PSR)
          in
            CPSR :=
            (PSR_GE_rupd
               ((!CPSR),
                BitsN.bitFieldInsert(1,1)
                  (w,BitsN.fromBit(IntInf.>=(res2,ge_lim)))))
          end
        ; let
            val w = #GE((!CPSR) : PSR)
          in
            CPSR :=
            (PSR_GE_rupd
               ((!CPSR),
                BitsN.bitFieldInsert(2,2)
                  (w,BitsN.fromBit(IntInf.>=(res3,ge_lim)))))
          end
        ; let
            val w = #GE((!CPSR) : PSR)
          in
            CPSR :=
            (PSR_GE_rupd
               ((!CPSR),
                BitsN.bitFieldInsert(3,3)
                  (w,BitsN.fromBit(IntInf.>=(res4,ge_lim)))))
          end
        ; IncPC ()
        )
      end
    )
  end;

fun dfn'UnsignedSaturatingAddSub8 (sub,(d,(n,m))) =
  let
    val (res1,(res2,(res3,res4))) = UnsignedParallelAddSub8(sub,(n,m))
  in
    ( write'R
        (BitsN.concat
           [UnsignedSat 8 (res4,8),UnsignedSat 8 (res3,8),
            UnsignedSat 8 (res2,8),UnsignedSat 8 (res1,8)],d)
    ; IncPC ()
    )
  end;

fun dfn'UnsignedHalvingAddSub8 (sub,(d,(n,m))) =
  let
    val (res1,(res2,(res3,res4))) = UnsignedParallelAddSub8(sub,(n,m))
  in
    ( write'R
        (BitsN.concat
           [BitsN.fromInt(IntInf.div(res4,2),8),
            BitsN.fromInt(IntInf.div(res3,2),8),
            BitsN.fromInt(IntInf.div(res2,2),8),
            BitsN.fromInt(IntInf.div(res1,2),8)],d)
    ; IncPC ()
    )
  end;

fun dfn'UnsignedSumAbsoluteDifferences (d,(n,(m,a))) =
  let
    val acc = if a = (BitsN.B(0xF,4)) then BitsN.B(0x0,32) else R a
    val Rn = R n
    val Rm = R m
    val absdiff1 =
      IntInf.abs
        (IntInf.-(UInt 8 (BitsN.bits(7,0) Rn),UInt 8 (BitsN.bits(7,0) Rm)))
    val absdiff2 =
      IntInf.abs
        (IntInf.-
           (UInt 8 (BitsN.bits(15,8) Rn),UInt 8 (BitsN.bits(15,8) Rm)))
    val absdiff3 =
      IntInf.abs
        (IntInf.-
           (UInt 8 (BitsN.bits(23,16) Rn),UInt 8 (BitsN.bits(23,16) Rm)))
    val absdiff4 =
      IntInf.abs
        (IntInf.-
           (UInt 8 (BitsN.bits(31,24) Rn),UInt 8 (BitsN.bits(31,24) Rm)))
    val result =
      IntInf.+
        (IntInf.+
           (IntInf.+(IntInf.+(UInt 32 acc,absdiff1),absdiff2),absdiff3),
         absdiff4)
  in
    ( write'R(BitsN.fromInt(result,32),d); IncPC () )
  end;

fun GenerateIntegerZeroDivide () = TakeUndefInstrException ();

fun dfn'Divide (unsigned,(d,(n,m))) =
  if (R m) = (BitsN.B(0x0,32))
    then if IntegerZeroDivideTrappingEnabled ()
           then GenerateIntegerZeroDivide ()
         else ( write'R(BitsN.B(0x0,32),d); IncPC () )
  else ( write'R
           (if unsigned then BitsN.div(R n,R m) else BitsN.quot(R n,R m),d)
       ; IncPC ()
       );

fun dfn'PackHalfword (shift_t,(shift_n,(tbform,(d,(n,m))))) =
  let
    val operand2 = Shift 32 (R m,(shift_t,(shift_n,#C((!CPSR) : PSR))))
    val bot =
      if tbform then BitsN.bits(15,0) operand2 else BitsN.bits(15,0) (R n)
    val top =
      if tbform
        then BitsN.bits(31,16) (R n)
      else BitsN.bits(31,16) operand2
  in
    ( write'R(BitsN.@@(top,bot),d); IncPC () )
  end;

fun dfn'Saturate (shift_t,(shift_n,(saturate_to,(unsigned,(d,n))))) =
  let
    val operand = Shift 32 (R n,(shift_t,(shift_n,#C((!CPSR) : PSR))))
    val (result,sat) =
      if unsigned
        then UnsignedSatQ 32 (BitsN.toInt operand,saturate_to)
      else SignedSatQ 32 (BitsN.toInt operand,saturate_to)
  in
    ( write'R
        (if unsigned
           then result
         else SignExtendFrom 32 (result,saturate_to),d)
    ; if sat then CPSR := (PSR_Q_rupd((!CPSR),true)) else ()
    ; IncPC ()
    )
  end;

fun dfn'Saturate16 (saturate_to,(unsigned,(d,n))) =
  let
    val Rn = R n
    val ((result1,sat1),(result2,sat2)) =
      if unsigned
        then (UnsignedSatQ 16
                (BitsN.toInt(BitsN.bits(15,0) Rn),saturate_to),
              UnsignedSatQ 16
                (BitsN.toInt(BitsN.bits(31,16) Rn),saturate_to))
      else (SignedSatQ 16 (BitsN.toInt(BitsN.bits(15,0) Rn),saturate_to),
            SignedSatQ 16 (BitsN.toInt(BitsN.bits(31,16) Rn),saturate_to))
  in
    ( write'R
        (if unsigned
           then BitsN.@@(result2,result1)
         else BitsN.@@
                (SignExtendFrom 16 (result2,saturate_to),
                 SignExtendFrom 16 (result1,saturate_to)),d)
    ; if sat1 orelse sat2 then CPSR := (PSR_Q_rupd((!CPSR),true)) else ()
    ; IncPC ()
    )
  end;

fun dfn'ExtendByte (unsigned,(d,(n,(m,rotation)))) =
  let
    val acc = if n = (BitsN.B(0xF,4)) then BitsN.B(0x0,32) else R n
    val rotated = ROR 32 (R m,rotation)
  in
    ( write'R
        (BitsN.+(acc,Extend (8,32) (unsigned,BitsN.bits(7,0) rotated)),d)
    ; IncPC ()
    )
  end;

fun dfn'ExtendByte16 (unsigned,(d,(n,(m,rotation)))) =
  let
    val acc = if n = (BitsN.B(0xF,4)) then BitsN.B(0x0,32) else R n
    val rotated = ROR 32 (R m,rotation)
    val r1 =
      BitsN.+
        (BitsN.bits(15,0) acc,
         Extend (8,16) (unsigned,BitsN.bits(7,0) rotated))
    val r2 =
      BitsN.+
        (BitsN.bits(31,16) acc,
         Extend (8,16) (unsigned,BitsN.bits(23,16) rotated))
  in
    ( write'R(BitsN.@@(r2,r1),d); IncPC () )
  end;

fun dfn'ExtendHalfword (unsigned,(d,(n,(m,rotation)))) =
  let
    val acc = if n = (BitsN.B(0xF,4)) then BitsN.B(0x0,32) else R n
    val rotated = ROR 32 (R m,rotation)
  in
    ( write'R
        (BitsN.+(acc,Extend (16,32) (unsigned,BitsN.bits(15,0) rotated)),d)
    ; IncPC ()
    )
  end;

fun dfn'SelectBytes (d,(n,m)) =
  let
    val Rn = R n
    val Rm = R m
    val r1 =
      if BitsN.bit(#GE((!CPSR) : PSR),0)
        then BitsN.bits(7,0) Rn
      else BitsN.bits(7,0) Rm
    val r2 =
      if BitsN.bit(#GE((!CPSR) : PSR),1)
        then BitsN.bits(15,8) Rn
      else BitsN.bits(15,8) Rm
    val r3 =
      if BitsN.bit(#GE((!CPSR) : PSR),2)
        then BitsN.bits(23,16) Rn
      else BitsN.bits(23,16) Rm
    val r4 =
      if BitsN.bit(#GE((!CPSR) : PSR),3)
        then BitsN.bits(31,24) Rn
      else BitsN.bits(31,24) Rm
  in
    ( write'R(BitsN.concat[r4,r3,r2,r1],d); IncPC () )
  end;

fun dfn'ByteReverse (d,m) =
  let
    val Rm = R m
  in
    ( write'R
        (BitsN.concat
           [BitsN.bits(7,0) Rm,BitsN.bits(15,8) Rm,BitsN.bits(23,16) Rm,
            BitsN.bits(31,24) Rm],d)
    ; IncPC ()
    )
  end;

fun dfn'ByteReversePackedHalfword (d,m) =
  let
    val Rm = R m
  in
    ( write'R
        (BitsN.concat
           [BitsN.bits(23,16) Rm,BitsN.bits(31,24) Rm,BitsN.bits(7,0) Rm,
            BitsN.bits(15,8) Rm],d)
    ; IncPC ()
    )
  end;

fun dfn'ByteReverseSignedHalfword (d,m) =
  let
    val Rm = R m
  in
    ( write'R
        (BitsN.@@
           (BitsN.signExtend 24 (BitsN.bits(7,0) Rm),BitsN.bits(15,8) Rm),
         d)
    ; IncPC ()
    )
  end;

fun dfn'ReverseBits (d,m) = ( write'R(BitsN.reverse(R m),d); IncPC () );

fun dfn'BitFieldExtract (unsigned,(d,(n,(lsbit,widthminus1)))) =
  let
    val msbit = Nat.+(lsbit,widthminus1)
  in
    ( write'R
        (if unsigned
           then BitsN.resize 32 (BitsN.bits(msbit,lsbit) (R n))
         else SignExtendFrom 32
                (BitsN.resize 32 (BitsN.bits(msbit,lsbit) (R n)),
                 widthminus1),d)
    ; IncPC ()
    )
  end;

fun dfn'BitFieldClearOrInsert (d,(n,(lsbit,msbit))) =
  let
    val field =
      BitsN.toBitstring
        (if n = (BitsN.B(0xF,4)) then BitsN.B(0x0,32) else R n)
  in
    let
      val result = ref (BitsN.toBitstring(R d))
    in
      ( result :=
        (Bitstring.bitFieldInsert(msbit,lsbit)
           ((!result),Bitstring.bits(Nat.-(msbit,lsbit),0) field))
      ; write'R(BitsN.fromBitstring((!result),32),d)
      ; IncPC ()
      )
    end
  end;

fun dfn'LoadWord (add,(index,(wback,(t,(n,m))))) =
  if NullCheckIfThumbEE n
    then let
           val Rn = R n
           val offset =
             case m of
                register_form1(m,(shift_t,shift_n)) =>
                  Shift 32 (R m,(shift_t,(shift_n,#C((!CPSR) : PSR))))
              | immediate_form1 imm32 => imm32
           val offset_addr =
             if add then BitsN.+(Rn,offset) else BitsN.-(Rn,offset)
           val address = if index then offset_addr else Rn
           val data = MemU 32 (address,4)
         in
           ( if wback then write'R(offset_addr,n) else ()
           ; if t = (BitsN.B(0xF,4))
               then if Aligned 32 (address,4)
                      then LoadWritePC data
                    else raise UNPREDICTABLE ("Load")
             else ( write'R
                      (if (UnalignedSupport ()) orelse
                          (Aligned 32 (address,4))
                         then data
                       else if (!Encoding) = Encoding_ARM
                         then ROR 32
                                (data,
                                 Nat.*
                                   (8,BitsN.toNat(BitsN.bits(1,0) address)))
                       else BitsN.B(0x0,32),t)
                  ; IncPC ()
                  )
           )
         end
  else ();

fun dfn'LoadLiteral (add,(t,imm32)) =
  if NullCheckIfThumbEE(BitsN.B(0xF,4))
    then let
           val base = Align 32 (PC (),4)
           val address =
             if add then BitsN.+(base,imm32) else BitsN.-(base,imm32)
           val data = MemU 32 (address,4)
         in
           if t = (BitsN.B(0xF,4))
             then if Aligned 32 (address,4)
                    then LoadWritePC data
                  else raise UNPREDICTABLE ("LoadLiteral")
           else ( write'R
                    (if (UnalignedSupport ()) orelse
                        (Aligned 32 (address,4))
                       then data
                     else if (!Encoding) = Encoding_ARM
                       then ROR 32
                              (data,
                               Nat.*
                                 (8,BitsN.toNat(BitsN.bits(1,0) address)))
                     else BitsN.B(0x0,32),t)
                ; IncPC ()
                )
         end
  else ();

fun dfn'LoadUnprivileged (add,(postindex,(t,(n,m)))) =
  if NullCheckIfThumbEE n
    then let
           val Rn = R n
           val offset =
             case m of
                register_form1(m,(shift_t,shift_n)) =>
                  Shift 32 (R m,(shift_t,(shift_n,#C((!CPSR) : PSR))))
              | immediate_form1 imm32 => imm32
           val offset_addr =
             if add then BitsN.+(Rn,offset) else BitsN.-(Rn,offset)
           val address = if postindex then Rn else offset_addr
           val data = MemU_unpriv 32 (address,4)
         in
           ( if postindex then write'R(offset_addr,n) else ()
           ; write'R
               (if (UnalignedSupport ()) orelse (Aligned 32 (address,4))
                  then data
                else if (!Encoding) = Encoding_ARM
                  then ROR 32
                         (data,
                          Nat.*(8,BitsN.toNat(BitsN.bits(1,0) address)))
                else BitsN.B(0x0,32),t)
           ; IncPC ()
           )
         end
  else ();

fun dfn'LoadByte (unsigned,(add,(index,(wback,(t,(n,m)))))) =
  if NullCheckIfThumbEE n
    then let
           val Rn = R n
           val offset =
             case m of
                register_form1(m,(shift_t,shift_n)) =>
                  Shift 32 (R m,(shift_t,(shift_n,#C((!CPSR) : PSR))))
              | immediate_form1 imm32 => imm32
           val offset_addr =
             if add then BitsN.+(Rn,offset) else BitsN.-(Rn,offset)
           val address = if index then offset_addr else Rn
         in
           ( write'R(Extend (8,32) (unsigned,MemU 8 (address,1)),t)
           ; if wback then write'R(offset_addr,n) else ()
           ; IncPC ()
           )
         end
  else ();

fun dfn'LoadByteLiteral (unsigned,(add,(t,imm32))) =
  if NullCheckIfThumbEE(BitsN.B(0xF,4))
    then let
           val base = Align 32 (PC (),4)
           val address =
             if add then BitsN.+(base,imm32) else BitsN.-(base,imm32)
         in
           ( write'R(Extend (8,32) (unsigned,MemU 8 (address,1)),t)
           ; IncPC ()
           )
         end
  else ();

fun dfn'LoadByteUnprivileged (add,(postindex,(t,(n,m)))) =
  if NullCheckIfThumbEE n
    then let
           val Rn = R n
           val offset =
             case m of
                register_form1(m,(shift_t,shift_n)) =>
                  Shift 32 (R m,(shift_t,(shift_n,#C((!CPSR) : PSR))))
              | immediate_form1 imm32 => imm32
           val offset_addr =
             if add then BitsN.+(Rn,offset) else BitsN.-(Rn,offset)
           val address = if postindex then Rn else offset_addr
         in
           ( write'R(BitsN.zeroExtend 32 (MemU_unpriv 8 (address,1)),t)
           ; if postindex then write'R(offset_addr,n) else ()
           ; IncPC ()
           )
         end
  else ();

fun dfn'LoadSignedByteUnprivileged (add,(postindex,(t,(n,m)))) =
  if NullCheckIfThumbEE n
    then let
           val Rn = R n
           val offset =
             case m of
                register_form2 m => R m
              | immediate_form2 imm32 => imm32
           val offset_addr =
             if add then BitsN.+(Rn,offset) else BitsN.-(Rn,offset)
           val address = if postindex then Rn else offset_addr
         in
           ( write'R(BitsN.signExtend 32 (MemU_unpriv 8 (address,1)),t)
           ; if postindex then write'R(offset_addr,n) else ()
           ; IncPC ()
           )
         end
  else ();

fun dfn'LoadHalf (unsigned,(add,(index,(wback,(t,(n,m)))))) =
  if NullCheckIfThumbEE n
    then let
           val Rn = R n
           val offset =
             case m of
                register_form1(m,(shift_t,shift_n)) =>
                  Shift 32 (R m,(shift_t,(shift_n,#C((!CPSR) : PSR))))
              | immediate_form1 imm32 => imm32
           val offset_addr =
             if add then BitsN.+(Rn,offset) else BitsN.-(Rn,offset)
           val address = if index then offset_addr else Rn
           val data = MemU 16 (address,2)
         in
           ( if wback then write'R(offset_addr,n) else ()
           ; write'R
               (if (UnalignedSupport ()) orelse (Aligned 32 (address,2))
                  then Extend (16,32) (unsigned,data)
                else BitsN.B(0x0,32),t)
           ; IncPC ()
           )
         end
  else ();

fun dfn'LoadHalfLiteral (unsigned,(add,(t,imm32))) =
  if NullCheckIfThumbEE(BitsN.B(0xF,4))
    then let
           val base = Align 32 (PC (),4)
           val address =
             if add then BitsN.+(base,imm32) else BitsN.-(base,imm32)
           val data = MemU 16 (address,2)
         in
           ( write'R
               (if (UnalignedSupport ()) orelse (Aligned 32 (address,2))
                  then Extend (16,32) (unsigned,data)
                else BitsN.B(0x0,32),t)
           ; IncPC ()
           )
         end
  else ();

fun dfn'LoadHalfUnprivileged (unsigned,(add,(postindex,(t,(n,m))))) =
  if NullCheckIfThumbEE n
    then let
           val Rn = R n
           val offset =
             case m of
                register_form2 m => R m
              | immediate_form2 imm32 => imm32
           val offset_addr =
             if add then BitsN.+(Rn,offset) else BitsN.-(Rn,offset)
           val address = if postindex then Rn else offset_addr
           val data = MemU_unpriv 16 (address,2)
         in
           ( if postindex then write'R(offset_addr,n) else ()
           ; write'R
               (if (UnalignedSupport ()) orelse (Aligned 32 (address,2))
                  then Extend (16,32) (unsigned,data)
                else BitsN.B(0x0,32),t)
           ; IncPC ()
           )
         end
  else ();

fun dfn'LoadMultiple (increment,(index,(wback,(n,registers)))) =
  if NullCheckIfThumbEE n
    then let
           val Rn = R n
           val length =
             BitsN.*
               (BitsN.B(0x4,32),BitsN.fromNat(BitCount 16 registers,32))
         in
           let
             val address = ref (if increment
                then Rn
              else BitsN.-(Rn,length))
           in
             ( if index = increment
                 then address := (BitsN.+((!address),BitsN.B(0x4,32)))
               else ()
             ; L3.for
                 (0,14,
                  fn i =>
                    if BitsN.bit(registers,i)
                      then ( let
                               val x = BitsN.fromNat(i,4)
                             in
                               write'R(MemA 32 ((!address),4),x)
                             end
                           ; address :=
                             (BitsN.+((!address),BitsN.B(0x4,32)))
                           )
                    else ())
             ; if BitsN.bit(registers,15)
                 then LoadWritePC(MemA 32 ((!address),4))
               else IncPC ()
             ; if wback
                 then if BitsN.bit(registers,BitsN.toNat n)
                        then write'R(BitsN.B(0x0,32),n)
                      else write'R
                             (if increment
                                then BitsN.+(Rn,length)
                              else BitsN.-(Rn,length),n)
               else ()
             )
           end
         end
  else ();

fun dfn'LoadMultipleExceptionReturn
  (increment,(wordhigher,(wback,(n,registers)))) =
  ( if CurrentModeIsHyp () then TakeUndefInstrException () else ()
  ; if CurrentModeIsUserOrSystem ()
      then raise UNPREDICTABLE ("LoadMultipleExceptionReturn")
    else ()
  ; let
      val Rn = R n
      val length =
        BitsN.+
          (BitsN.*
             (BitsN.B(0x4,32),BitsN.fromNat(BitCount 15 registers,32)),
           BitsN.B(0x4,32))
    in
      let
        val address = ref (if increment then Rn else BitsN.-(Rn,length))
      in
        ( if wordhigher
            then address := (BitsN.+((!address),BitsN.B(0x4,32)))
          else ()
        ; L3.for
            (0,14,
             fn i =>
               if BitsN.bit(registers,i)
                 then ( let
                          val x = BitsN.fromNat(i,4)
                        in
                          write'R(MemA 32 ((!address),4),x)
                        end
                      ; address := (BitsN.+((!address),BitsN.B(0x4,32)))
                      )
               else ())
        ; let
            val new_pc_value = MemA 32 ((!address),4)
          in
            ( if wback
                then if BitsN.bit(registers,BitsN.toNat n)
                       then write'R(BitsN.B(0x0,32),n)
                     else write'R
                            (if increment
                               then BitsN.+(Rn,length)
                             else BitsN.-(Rn,length),n)
              else ()
            ; CPSRWriteByInstr(reg'PSR(SPSR ()),(BitsN.B(0xF,4),true))
            ; BranchWritePC new_pc_value
            )
          end
        )
      end
    end
  );

fun dfn'LoadMultipleUserRegisters (increment,(wordhigher,(n,registers))) =
  ( if CurrentModeIsHyp () then TakeUndefInstrException () else ()
  ; if CurrentModeIsUserOrSystem ()
      then raise UNPREDICTABLE ("LoadMultipleUserRegisters")
    else ()
  ; let
      val length =
        BitsN.*(BitsN.B(0x4,32),BitsN.fromNat(BitCount 15 registers,32))
    in
      let
        val address = ref (if increment then R n else BitsN.-(R n,length))
      in
        ( if wordhigher
            then address := (BitsN.+((!address),BitsN.B(0x4,32)))
          else ()
        ; L3.for
            (0,14,
             fn i =>
               if BitsN.bit(registers,i)
                 then ( let
                          val x = (BitsN.fromNat(i,4),BitsN.B(0x10,5))
                        in
                          write'Rmode(MemA 32 ((!address),4),x)
                        end
                      ; address := (BitsN.+((!address),BitsN.B(0x4,32)))
                      )
               else ())
        ; IncPC ()
        )
      end
    end
  );

fun dfn'LoadDual (add,(index,(wback,(t,(t2,(n,m)))))) =
  if NullCheckIfThumbEE n
    then let
           val Rn = R n
           val offset =
             case m of
                register_form2 m => R m
              | immediate_form2 imm32 => imm32
           val offset_addr =
             if add then BitsN.+(Rn,offset) else BitsN.-(Rn,offset)
           val address = if index then offset_addr else Rn
         in
           ( write'R(MemA 32 (address,4),t)
           ; write'R(MemA 32 (BitsN.+(address,BitsN.B(0x4,32)),4),t2)
           ; if wback then write'R(offset_addr,n) else ()
           ; IncPC ()
           )
         end
  else ();

fun dfn'LoadDualLiteral (add,(t,(t2,imm32))) =
  if NullCheckIfThumbEE(BitsN.B(0xF,4))
    then let
           val address =
             if add
               then BitsN.+(Align 32 (PC (),4),imm32)
             else BitsN.-(Align 32 (PC (),4),imm32)
         in
           ( write'R(MemA 32 (address,4),t)
           ; write'R(MemA 32 (BitsN.+(address,BitsN.B(0x4,32)),4),t2)
           ; IncPC ()
           )
         end
  else ();

fun dfn'LoadExclusive (t,(n,imm32)) =
  if NullCheckIfThumbEE n
    then let
           val address = BitsN.+(R n,imm32)
         in
           ( SetExclusiveMonitors(address,4)
           ; write'R(MemA 32 (address,4),t)
           ; IncPC ()
           )
         end
  else ();

fun dfn'LoadExclusiveByte (t,n) =
  if NullCheckIfThumbEE n
    then let
           val address = R n
         in
           ( SetExclusiveMonitors(address,1)
           ; write'R(BitsN.zeroExtend 32 (MemA 8 (address,1)),t)
           ; IncPC ()
           )
         end
  else ();

fun dfn'LoadExclusiveHalf (t,n) =
  if NullCheckIfThumbEE n
    then let
           val address = R n
         in
           ( SetExclusiveMonitors(address,2)
           ; write'R(BitsN.zeroExtend 32 (MemA 16 (address,2)),t)
           ; IncPC ()
           )
         end
  else ();

fun dfn'LoadExclusiveDoubleword (t,(t2,n)) =
  if NullCheckIfThumbEE n
    then let
           val address = R n
         in
           ( SetExclusiveMonitors(address,8)
           ; let
               val value = MemA 64 (address,8)
             in
               ( write'R
                   (if BigEndian ()
                      then BitsN.bits(63,32) value
                    else BitsN.bits(31,0) value,t)
               ; write'R
                   (if BigEndian ()
                      then BitsN.bits(31,0) value
                    else BitsN.bits(63,32) value,t2)
               ; IncPC ()
               )
             end
           )
         end
  else ();

fun dfn'StoreWord (add,(index,(wback,(t,(n,m))))) =
  if NullCheckIfThumbEE n
    then let
           val Rn = R n
           val offset =
             case m of
                register_form1(m,(shift_t,shift_n)) =>
                  Shift 32 (R m,(shift_t,(shift_n,#C((!CPSR) : PSR))))
              | immediate_form1 imm32 => imm32
           val offset_addr =
             if add then BitsN.+(Rn,offset) else BitsN.-(Rn,offset)
           val address = if index then offset_addr else Rn
           val data =
             if t = (BitsN.B(0xF,4)) then PCStoreValue () else R t
         in
           ( if (UnalignedSupport ()) orelse
                ((Aligned 32 (address,4)) orelse
                 ((CurrentInstrSet ()) = InstrSet_ARM))
               then let val x = (address,4) in write'MemU 32 (data,x) end
             else let
                    val x = (address,4)
                  in
                    write'MemU 32 (BitsN.B(0x0,32),x)
                  end
           ; if wback then write'R(offset_addr,n) else ()
           ; IncPC ()
           )
         end
  else ();

fun dfn'StoreUnprivileged (add,(postindex,(t,(n,m)))) =
  if NullCheckIfThumbEE n
    then let
           val Rn = R n
           val offset =
             case m of
                register_form1(m,(shift_t,shift_n)) =>
                  Shift 32 (R m,(shift_t,(shift_n,#C((!CPSR) : PSR))))
              | immediate_form1 imm32 => imm32
           val offset_addr =
             if add then BitsN.+(Rn,offset) else BitsN.-(Rn,offset)
           val address = if postindex then Rn else offset_addr
           val data =
             if t = (BitsN.B(0xF,4)) then PCStoreValue () else R t
         in
           ( if (UnalignedSupport ()) orelse
                ((Aligned 32 (address,4)) orelse
                 ((CurrentInstrSet ()) = InstrSet_ARM))
               then let
                      val x = (address,4)
                    in
                      write'MemU_unpriv 32 (data,x)
                    end
             else let
                    val x = (address,4)
                  in
                    write'MemU_unpriv 32 (BitsN.B(0x0,32),x)
                  end
           ; if postindex then write'R(offset_addr,n) else ()
           ; IncPC ()
           )
         end
  else ();

fun dfn'StoreByte (add,(index,(wback,(t,(n,m))))) =
  if NullCheckIfThumbEE n
    then let
           val Rn = R n
           val offset =
             case m of
                register_form1(m,(shift_t,shift_n)) =>
                  Shift 32 (R m,(shift_t,(shift_n,#C((!CPSR) : PSR))))
              | immediate_form1 imm32 => imm32
           val offset_addr =
             if add then BitsN.+(Rn,offset) else BitsN.-(Rn,offset)
           val address = if index then offset_addr else Rn
         in
           ( let
               val x = (address,1)
             in
               write'MemU 8 (BitsN.bits(7,0) (R t),x)
             end
           ; if wback then write'R(offset_addr,n) else ()
           ; IncPC ()
           )
         end
  else ();

fun dfn'StoreByteUnprivileged (add,(postindex,(t,(n,m)))) =
  if NullCheckIfThumbEE n
    then let
           val Rn = R n
           val offset =
             case m of
                register_form1(m,(shift_t,shift_n)) =>
                  Shift 32 (R m,(shift_t,(shift_n,#C((!CPSR) : PSR))))
              | immediate_form1 imm32 => imm32
           val offset_addr =
             if add then BitsN.+(Rn,offset) else BitsN.-(Rn,offset)
           val address = if postindex then Rn else offset_addr
         in
           ( let
               val x = (address,1)
             in
               write'MemU_unpriv 8 (BitsN.bits(7,0) (R t),x)
             end
           ; if postindex then write'R(offset_addr,n) else ()
           ; IncPC ()
           )
         end
  else ();

fun dfn'StoreHalf (add,(index,(wback,(t,(n,m))))) =
  if NullCheckIfThumbEE n
    then let
           val Rn = R n
           val offset =
             case m of
                register_form1(m,(shift_t,shift_n)) =>
                  Shift 32 (R m,(shift_t,(shift_n,#C((!CPSR) : PSR))))
              | immediate_form1 imm32 => imm32
           val offset_addr =
             if add then BitsN.+(Rn,offset) else BitsN.-(Rn,offset)
           val address = if index then offset_addr else Rn
         in
           ( if (UnalignedSupport ()) orelse (Aligned 32 (address,2))
               then let
                      val x = (address,2)
                    in
                      write'MemU 16 (BitsN.bits(15,0) (R t),x)
                    end
             else let
                    val x = (address,2)
                  in
                    write'MemU 16 (BitsN.B(0x0,16),x)
                  end
           ; if wback then write'R(offset_addr,n) else ()
           ; IncPC ()
           )
         end
  else ();

fun dfn'StoreHalfUnprivileged (add,(postindex,(t,(n,m)))) =
  if NullCheckIfThumbEE n
    then let
           val Rn = R n
           val offset =
             case m of
                register_form2 m => R m
              | immediate_form2 imm32 => imm32
           val offset_addr =
             if add then BitsN.+(Rn,offset) else BitsN.-(Rn,offset)
           val address = if postindex then Rn else offset_addr
         in
           ( if (UnalignedSupport ()) orelse (Aligned 32 (address,2))
               then let
                      val x = (address,2)
                    in
                      write'MemU_unpriv 16 (BitsN.bits(15,0) (R t),x)
                    end
             else let
                    val x = (address,2)
                  in
                    write'MemU_unpriv 16 (BitsN.B(0x0,16),x)
                  end
           ; if postindex then write'R(offset_addr,n) else ()
           ; IncPC ()
           )
         end
  else ();

fun dfn'StoreMultiple (increment,(index,(wback,(n,registers)))) =
  if NullCheckIfThumbEE n
    then let
           val Rn = R n
           val length =
             BitsN.*
               (BitsN.B(0x4,32),BitsN.fromNat(BitCount 16 registers,32))
           val lowest = LowestSetBit 16 registers
         in
           let
             val address = ref (if increment
                then Rn
              else BitsN.-(Rn,length))
           in
             ( if index = increment
                 then address := (BitsN.+((!address),BitsN.B(0x4,32)))
               else ()
             ; L3.for
                 (0,14,
                  fn i =>
                    if BitsN.bit(registers,i)
                      then ( if ((BitsN.fromNat(i,4)) = n) andalso
                                (wback andalso (not(i = lowest)))
                               then let
                                      val x = ((!address),4)
                                    in
                                      write'MemA 32 (BitsN.B(0x0,32),x)
                                    end
                             else let
                                    val x = ((!address),4)
                                  in
                                    write'MemA 32
                                      (R(BitsN.fromNat(i,4)),x)
                                  end
                           ; address :=
                             (BitsN.+((!address),BitsN.B(0x4,32)))
                           )
                    else ())
             ; if BitsN.bit(registers,15)
                 then let
                        val x = ((!address),4)
                      in
                        write'MemA 32 (PCStoreValue (),x)
                      end
               else ()
             ; if wback
                 then write'R
                        (if increment
                           then BitsN.+(Rn,length)
                         else BitsN.-(Rn,length),n)
               else ()
             ; IncPC ()
             )
           end
         end
  else ();

fun dfn'StoreMultipleUserRegisters
  (increment,(wordhigher,(n,registers))) =
  ( if CurrentModeIsHyp () then TakeUndefInstrException () else ()
  ; if CurrentModeIsUserOrSystem ()
      then raise UNPREDICTABLE ("StoreMultipleUserRegisters")
    else ()
  ; let
      val length =
        BitsN.*(BitsN.B(0x4,32),BitsN.fromNat(BitCount 16 registers,32))
    in
      let
        val address = ref (if increment then R n else BitsN.-(R n,length))
      in
        ( if wordhigher
            then address := (BitsN.+((!address),BitsN.B(0x4,32)))
          else ()
        ; L3.for
            (0,14,
             fn i =>
               if BitsN.bit(registers,i)
                 then ( let
                          val x = ((!address),4)
                        in
                          write'MemA 32
                            (Rmode(BitsN.fromNat(i,4),BitsN.B(0x10,5)),x)
                        end
                      ; address := (BitsN.+((!address),BitsN.B(0x4,32)))
                      )
               else ())
        ; if BitsN.bit(registers,15)
            then let
                   val x = ((!address),4)
                 in
                   write'MemA 32 (PCStoreValue (),x)
                 end
          else ()
        ; IncPC ()
        )
      end
    end
  );

fun dfn'StoreDual (add,(index,(wback,(t,(t2,(n,m)))))) =
  if NullCheckIfThumbEE n
    then let
           val Rn = R n
           val offset =
             case m of
                register_form2 m => R m
              | immediate_form2 imm32 => imm32
           val offset_addr =
             if add then BitsN.+(Rn,offset) else BitsN.-(Rn,offset)
           val address = if index then offset_addr else Rn
         in
           ( let val x = (address,4) in write'MemA 32 (R t,x) end
           ; let
               val x = (BitsN.+(address,BitsN.B(0x4,32)),4)
             in
               write'MemA 32 (R t2,x)
             end
           ; if wback then write'R(offset_addr,n) else ()
           ; IncPC ()
           )
         end
  else ();

fun dfn'StoreExclusive (d,(t,(n,imm32))) =
  if NullCheckIfThumbEE n
    then let
           val address = BitsN.+(R n,imm32)
         in
           ( if ExclusiveMonitorsPass(address,4)
               then ( let val x = (address,4) in write'MemA 32 (R t,x) end
                    ; write'R(BitsN.B(0x0,32),d)
                    )
             else write'R(BitsN.B(0x1,32),d)
           ; IncPC ()
           )
         end
  else ();

fun dfn'StoreExclusiveByte (d,(t,n)) =
  if NullCheckIfThumbEE n
    then let
           val address = R n
         in
           ( if ExclusiveMonitorsPass(address,1)
               then ( let
                        val x = (address,1)
                      in
                        write'MemA 8 (BitsN.bits(7,0) (R t),x)
                      end
                    ; write'R(BitsN.B(0x0,32),d)
                    )
             else write'R(BitsN.B(0x1,32),d)
           ; IncPC ()
           )
         end
  else ();

fun dfn'StoreExclusiveHalf (d,(t,n)) =
  if NullCheckIfThumbEE n
    then let
           val address = R n
         in
           ( if ExclusiveMonitorsPass(address,2)
               then ( let
                        val x = (address,2)
                      in
                        write'MemA 16 (BitsN.bits(15,0) (R t),x)
                      end
                    ; write'R(BitsN.B(0x0,32),d)
                    )
             else write'R(BitsN.B(0x1,32),d)
           ; IncPC ()
           )
         end
  else ();

fun dfn'StoreExclusiveDoubleword (d,(t,(t2,n))) =
  if NullCheckIfThumbEE n
    then let
           val address = R n
           val value =
             if BigEndian ()
               then BitsN.@@(R t,R t2)
             else BitsN.@@(R t2,R t)
         in
           ( if ExclusiveMonitorsPass(address,8)
               then ( let
                        val x = (address,8)
                      in
                        write'MemA 64 (value,x)
                      end
                    ; write'R(BitsN.B(0x0,32),d)
                    )
             else write'R(BitsN.B(0x1,32),d)
           ; IncPC ()
           )
         end
  else ();

fun dfn'ClearExclusive () =
  ( ClearExclusiveLocal(ProcessorID ()); IncPC () );

fun dfn'Swap (b,(t,(t2,n))) =
  let
    val Rn = R n
  in
    ( if b
        then let
               val data = MemA 8 (Rn,1)
             in
               ( let
                   val x = (Rn,1)
                 in
                   write'MemA 8 (BitsN.bits(7,0) (R t2),x)
                 end
               ; write'R(BitsN.zeroExtend 32 data,t)
               )
             end
      else let
             val data = MemA 32 (Rn,4)
           in
             ( let val x = (Rn,4) in write'MemA 32 (R t2,x) end
             ; write'R
                 (ROR 32 (data,Nat.*(8,BitsN.toNat(BitsN.bits(1,0) Rn))),t)
             )
           end
    ; IncPC ()
    )
  end;

fun dfn'ChangeProcessorState
  (enable,(disable,(affectA,(affectI,(affectF,changemode))))) =
  ( if CurrentModeIsNotUser ()
      then let
             val cpsr_val = ref (!CPSR)
           in
             ( if enable
                 then ( if affectA
                          then cpsr_val := (PSR_A_rupd((!cpsr_val),false))
                        else ()
                      ; if affectI
                          then cpsr_val := (PSR_I_rupd((!cpsr_val),false))
                        else ()
                      ; if affectF
                          then cpsr_val := (PSR_F_rupd((!cpsr_val),false))
                        else ()
                      )
               else ()
             ; if disable
                 then ( if affectA
                          then cpsr_val := (PSR_A_rupd((!cpsr_val),true))
                        else ()
                      ; if affectI
                          then cpsr_val := (PSR_I_rupd((!cpsr_val),true))
                        else ()
                      ; if affectF
                          then cpsr_val := (PSR_F_rupd((!cpsr_val),true))
                        else ()
                      )
               else ()
             ; case changemode of
                  Option.SOME mode =>
                    cpsr_val := (PSR_M_rupd((!cpsr_val),mode))
                | NONE => ()
             ; CPSRWriteByInstr
                 (reg'PSR (!cpsr_val),(BitsN.B(0xF,4),false))
             ; if ((#M((!CPSR) : PSR)) = (BitsN.B(0x1A,5))) andalso
                  ((CurrentInstrSet ()) = InstrSet_ThumbEE)
                 then raise UNPREDICTABLE ("ChangeProcessorState")
               else ()
             )
           end
    else ()
  ; IncPC ()
  );

fun dfn'ExceptionReturn () =
  if (CurrentModeIsUserOrSystem ()) orelse
     ((CurrentInstrSet ()) = InstrSet_ThumbEE)
    then raise UNPREDICTABLE ("ExceptionReturn")
  else let
         val new_pc_value =
           if CurrentModeIsHyp () then (!ELR_hyp) else R(BitsN.B(0xE,4))
       in
         ( CPSRWriteByInstr(reg'PSR(SPSR ()),(BitsN.B(0xF,4),true))
         ; if ((#M((!CPSR) : PSR)) = (BitsN.B(0x1A,5))) andalso
              ((CurrentInstrSet ()) = InstrSet_ThumbEE)
             then raise UNPREDICTABLE ("ExceptionReturn")
           else BranchWritePC new_pc_value
         )
       end;

fun dfn'HypervisorCall imm16 =
  if (not(HaveVirtExt ())) orelse
     ((IsSecure ()) orelse (not(CurrentModeIsNotUser ())))
    then raise UNPREDICTABLE ("HypervisorCall")
  else if not(#HCE((#SCR((!CP15) : CP15)) : SCR))
    then if CurrentModeIsHyp ()
           then raise UNPREDICTABLE ("HypervisorCall")
         else TakeUndefInstrException ()
  else CallHypervisor imm16;

fun dfn'MoveToRegisterFromSpecial (read_spsr,d) =
  ( if read_spsr
      then if CurrentModeIsUserOrSystem ()
             then raise UNPREDICTABLE ("MoveToRegisterFromSpecial")
           else write'R(reg'PSR(SPSR ()),d)
    else write'R(BitsN.&&(reg'PSR (!CPSR),BitsN.B(0xF8FF03DF,32)),d)
  ; IncPC ()
  );

fun dfn'MoveToRegisterFromBankedOrSpecial (read_spsr,(SYSm,d)) =
  if not(CurrentModeIsNotUser ())
    then raise UNPREDICTABLE ("MoveToRegisterFromBankedOrSpecial")
  else let
         val mode = #M((!CPSR) : PSR)
       in
         ( if read_spsr
             then ( SPSRAccessValid(SYSm,mode)
                  ; case SYSm of
                       BitsN.B(0xE,_) => write'R(reg'PSR (!SPSR_fiq),d)
                     | BitsN.B(0x10,_) => write'R(reg'PSR (!SPSR_irq),d)
                     | BitsN.B(0x12,_) => write'R(reg'PSR (!SPSR_svc),d)
                     | BitsN.B(0x14,_) => write'R(reg'PSR (!SPSR_abt),d)
                     | BitsN.B(0x16,_) => write'R(reg'PSR (!SPSR_und),d)
                     | BitsN.B(0x1C,_) => write'R(reg'PSR (!SPSR_mon),d)
                     | BitsN.B(0x1E,_) => write'R(reg'PSR (!SPSR_hyp),d)
                     | _ => ()
                  )
           else ( BankedRegisterAccessValid(SYSm,mode)
                ; if (BitsN.bits(4,3) SYSm) = (BitsN.B(0x0,2))
                    then let
                           val m =
                             BitsN.+
                               (BitsN.fromNat
                                  (BitsN.toNat(BitsN.bits(2,0) SYSm),4),
                                BitsN.B(0x8,4))
                         in
                           write'R(Rmode(m,BitsN.B(0x10,5)),d)
                         end
                  else if (BitsN.bits(4,3) SYSm) = (BitsN.B(0x1,2))
                    then let
                           val m =
                             BitsN.+
                               (BitsN.fromNat
                                  (BitsN.toNat(BitsN.bits(2,0) SYSm),4),
                                BitsN.B(0x8,4))
                         in
                           write'R(Rmode(m,BitsN.B(0x11,5)),d)
                         end
                  else if (BitsN.bits(4,3) SYSm) = (BitsN.B(0x3,2))
                    then if not(BitsN.bit(SYSm,1))
                           then let
                                  val m =
                                    BitsN.-
                                      (BitsN.B(0xE,4),
                                       BitsN.fromBool 4
                                         (BitsN.bit(SYSm,0)))
                                in
                                  write'R(Rmode(m,BitsN.B(0x16,5)),d)
                                end
                         else if BitsN.bit(SYSm,0)
                           then write'R
                                  (Rmode(BitsN.B(0xD,4),BitsN.B(0x1A,5)),d)
                         else write'R((!ELR_hyp),d)
                  else let
                         val targetmode = ref (BitsN.B(0x0,5))
                       in
                         ( targetmode :=
                           (BitsN.bitFieldInsert(0,0)
                              ((!targetmode),
                               BitsN.fromBit
                                 ((BitsN.bit(SYSm,2)) orelse
                                  (BitsN.bit(SYSm,1)))))
                         ; targetmode :=
                           (BitsN.bitFieldInsert(1,1)
                              ((!targetmode),BitsN.fromBit true))
                         ; targetmode :=
                           (BitsN.bitFieldInsert(2,2)
                              ((!targetmode),
                               BitsN.fromBit
                                 ((BitsN.bit(SYSm,2)) andalso
                                  (not(BitsN.bit(SYSm,1))))))
                         ; targetmode :=
                           (BitsN.bitFieldInsert(3,3)
                              ((!targetmode),
                               BitsN.fromBit
                                 ((BitsN.bit(SYSm,2)) andalso
                                  (BitsN.bit(SYSm,1)))))
                         ; targetmode :=
                           (BitsN.bitFieldInsert(4,4)
                              ((!targetmode),BitsN.fromBit true))
                         ; if mode = (!targetmode)
                             then raise UNPREDICTABLE
                                    ("MoveToRegisterFromBankedOrSpecial")
                           else let
                                  val m =
                                    BitsN.-
                                      (BitsN.B(0xE,4),
                                       BitsN.fromBool 4
                                         (BitsN.bit(SYSm,0)))
                                in
                                  write'R(Rmode(m,(!targetmode)),d)
                                end
                         )
                       end
                )
         ; IncPC ()
         )
       end;

fun dfn'MoveToSpecialFromImmediate (write_spsr,(imm32,mask)) =
  ( if write_spsr
      then SPSRWriteByInstr(imm32,mask)
    else ( CPSRWriteByInstr(imm32,(mask,false))
         ; if ((#M((!CPSR) : PSR)) = (BitsN.B(0x1A,5))) andalso
              ((CurrentInstrSet ()) = InstrSet_ThumbEE)
             then raise UNPREDICTABLE ("MoveToSpecialFromImmediate")
           else ()
         )
  ; IncPC ()
  );

fun dfn'MoveToSpecialFromRegister (write_spsr,(n,mask)) =
  ( if write_spsr
      then SPSRWriteByInstr(R n,mask)
    else ( CPSRWriteByInstr(R n,(mask,false))
         ; if ((#M((!CPSR) : PSR)) = (BitsN.B(0x1A,5))) andalso
              ((CurrentInstrSet ()) = InstrSet_ThumbEE)
             then raise UNPREDICTABLE ("MoveToSpecialFromRegister")
           else ()
         )
  ; IncPC ()
  );

fun dfn'MoveToBankedOrSpecialRegister (write_spsr,(SYSm,n)) =
  if not(CurrentModeIsNotUser ())
    then raise UNPREDICTABLE ("MoveToBankedOrSpecialRegister")
  else let
         val mode = #M((!CPSR) : PSR)
       in
         ( if write_spsr
             then ( SPSRAccessValid(SYSm,mode)
                  ; case SYSm of
                       BitsN.B(0xE,_) =>
                         SPSR_fiq := (write'reg'PSR((!SPSR_fiq),R n))
                     | BitsN.B(0x10,_) =>
                       SPSR_irq := (write'reg'PSR((!SPSR_irq),R n))
                     | BitsN.B(0x12,_) =>
                       SPSR_svc := (write'reg'PSR((!SPSR_svc),R n))
                     | BitsN.B(0x14,_) =>
                       SPSR_abt := (write'reg'PSR((!SPSR_abt),R n))
                     | BitsN.B(0x16,_) =>
                       SPSR_und := (write'reg'PSR((!SPSR_und),R n))
                     | BitsN.B(0x1C,_) =>
                       SPSR_mon := (write'reg'PSR((!SPSR_mon),R n))
                     | BitsN.B(0x1E,_) =>
                       SPSR_hyp := (write'reg'PSR((!SPSR_hyp),R n))
                     | _ => ()
                  )
           else ( BankedRegisterAccessValid(SYSm,mode)
                ; if (BitsN.bits(4,3) SYSm) = (BitsN.B(0x0,2))
                    then let
                           val m =
                             BitsN.+
                               (BitsN.fromNat
                                  (BitsN.toNat(BitsN.bits(2,0) SYSm),4),
                                BitsN.B(0x8,4))
                           val x = (m,BitsN.B(0x10,5))
                         in
                           write'Rmode(R n,x)
                         end
                  else if (BitsN.bits(4,3) SYSm) = (BitsN.B(0x1,2))
                    then let
                           val m =
                             BitsN.+
                               (BitsN.fromNat
                                  (BitsN.toNat(BitsN.bits(2,0) SYSm),4),
                                BitsN.B(0x8,4))
                           val x = (m,BitsN.B(0x11,5))
                         in
                           write'Rmode(R n,x)
                         end
                  else if (BitsN.bits(4,3) SYSm) = (BitsN.B(0x3,2))
                    then if not(BitsN.bit(SYSm,1))
                           then let
                                  val m =
                                    BitsN.-
                                      (BitsN.B(0xE,4),
                                       BitsN.fromBool 4
                                         (BitsN.bit(SYSm,0)))
                                  val x = (m,BitsN.B(0x16,5))
                                in
                                  write'Rmode(R n,x)
                                end
                         else if BitsN.bit(SYSm,0)
                           then let
                                  val x = (BitsN.B(0xD,4),BitsN.B(0x1A,5))
                                in
                                  write'Rmode(R n,x)
                                end
                         else ELR_hyp := (R n)
                  else let
                         val targetmode = ref (BitsN.B(0x0,5))
                       in
                         ( targetmode :=
                           (BitsN.bitFieldInsert(0,0)
                              ((!targetmode),
                               BitsN.fromBit
                                 ((BitsN.bit(SYSm,2)) orelse
                                  (BitsN.bit(SYSm,1)))))
                         ; targetmode :=
                           (BitsN.bitFieldInsert(1,1)
                              ((!targetmode),BitsN.fromBit true))
                         ; targetmode :=
                           (BitsN.bitFieldInsert(2,2)
                              ((!targetmode),
                               BitsN.fromBit
                                 ((BitsN.bit(SYSm,2)) andalso
                                  (not(BitsN.bit(SYSm,1))))))
                         ; targetmode :=
                           (BitsN.bitFieldInsert(3,3)
                              ((!targetmode),
                               BitsN.fromBit
                                 ((BitsN.bit(SYSm,2)) andalso
                                  (BitsN.bit(SYSm,1)))))
                         ; targetmode :=
                           (BitsN.bitFieldInsert(4,4)
                              ((!targetmode),BitsN.fromBit true))
                         ; if mode = (!targetmode)
                             then raise UNPREDICTABLE
                                    ("MoveToBankedOrSpecialRegister")
                           else let
                                  val m =
                                    BitsN.-
                                      (BitsN.B(0xE,4),
                                       BitsN.fromBool 4
                                         (BitsN.bit(SYSm,0)))
                                  val x = (m,(!targetmode))
                                in
                                  write'Rmode(R n,x)
                                end
                         )
                       end
                )
         ; IncPC ()
         )
       end;

fun dfn'ReturnFromException (increment,(wordhigher,(wback,n))) =
  if CurrentModeIsHyp ()
    then TakeUndefInstrException ()
  else if (not(CurrentModeIsNotUser ())) orelse
     ((CurrentInstrSet ()) = InstrSet_ThumbEE)
    then raise UNPREDICTABLE ("ReturnFromException")
  else let
         val Rn = R n
         val address =
           if increment then Rn else BitsN.-(Rn,BitsN.B(0x8,32))
         val address =
           if wordhigher
             then BitsN.+(address,BitsN.B(0x4,32))
           else address
       in
         ( if wback
             then write'R
                    (if increment
                       then BitsN.+(Rn,BitsN.B(0x8,32))
                     else BitsN.-(Rn,BitsN.B(0x8,32)),n)
           else ()
         ; let
             val new_pc_value = MemA 32 (address,4)
           in
             ( CPSRWriteByInstr
                 (MemA 32 (BitsN.+(address,BitsN.B(0x4,32)),4),
                  (BitsN.B(0xF,4),true))
             ; if ((#M((!CPSR) : PSR)) = (BitsN.B(0x1A,5))) andalso
                  ((#J((!CPSR) : PSR)) andalso (#T((!CPSR) : PSR)))
                 then raise UNPREDICTABLE ("ReturnFromException")
               else BranchWritePC new_pc_value
             )
           end
         )
       end;

fun dfn'SecureMonitorCall imm4 =
  if (HaveSecurityExt ()) andalso (CurrentModeIsNotUser ())
    then if (HaveVirtExt ()) andalso
            ((not(IsSecure ())) andalso
             ((not(CurrentModeIsHyp ())) andalso
              (#TSC((#HCR((!CP15) : CP15)) : HCR))))
           then let
                  val HSRString = BitsN.B(0x0,25)
                in
                  ( WriteHSR(BitsN.B(0x13,6),HSRString)
                  ; TakeHypTrapException ()
                  )
                end
         else if #SCD((#SCR((!CP15) : CP15)) : SCR)
           then if IsSecure ()
                  then raise UNPREDICTABLE ("SecureMonitorCall")
                else TakeUndefInstrException ()
         else TakeSMCException ()
  else TakeUndefInstrException ();

fun dfn'SupervisorCall imm32 = CallSupervisor(BitsN.bits(15,0) imm32);

fun dfn'StoreReturnState (increment,(wordhigher,(wback,mode))) =
  if CurrentModeIsHyp ()
    then TakeUndefInstrException ()
  else if (CurrentModeIsUserOrSystem ()) orelse
     ((CurrentInstrSet ()) = InstrSet_ThumbEE)
    then raise UNPREDICTABLE ("StoreReturnState")
  else if mode = (BitsN.B(0x1A,5))
    then raise UNPREDICTABLE ("StoreReturnState")
  else ( if not(IsSecure ())
           then if (mode = (BitsN.B(0x16,5))) orelse
                   ((mode = (BitsN.B(0x11,5))) andalso
                    (#RFR((#NSACR((!CP15) : CP15)) : NSACR)))
                  then raise UNPREDICTABLE ("StoreReturnState")
                else ()
         else ()
       ; let
           val base = Rmode(BitsN.B(0xD,4),mode)
           val address =
             if increment then base else BitsN.-(base,BitsN.B(0x8,32))
           val address =
             if wordhigher
               then BitsN.+(address,BitsN.B(0x4,32))
             else address
         in
           ( let val x = (address,4) in write'MemA 32 (LR (),x) end
           ; let
               val x = (BitsN.+(address,BitsN.B(0x4,32)),4)
             in
               write'MemA 32 (reg'PSR(SPSR ()),x)
             end
           ; if wback
               then let
                      val x = (BitsN.B(0xD,4),mode)
                    in
                      write'Rmode
                        (if increment
                           then BitsN.+(base,BitsN.B(0x8,32))
                         else BitsN.-(base,BitsN.B(0x8,32)),x)
                    end
             else ()
           ; IncPC ()
           )
         end
       );

fun dfn'Setend set_bigend =
  ( CPSR := (PSR_E_rupd((!CPSR),set_bigend)); IncPC () );

fun dfn'Undefined imm32 = TakeUndefInstrException ();

fun dfn'NoOperation () = IncPC ();

fun dfn'Breakpoint imm32 = IncPC ();

fun dfn'Debug option = IncPC ();

fun dfn'DataMemoryBarrier option = IncPC ();

fun dfn'DataSynchronizationBarrier option = IncPC ();

fun dfn'InstructionSynchronizationBarrier option = IncPC ();

fun dfn'PreloadData (add,(is_pldw,(n,m))) = IncPC ();

fun dfn'PreloadDataLiteral (add,imm32) = IncPC ();

fun dfn'PreloadInstruction (add,(n,m)) = IncPC ();

fun dfn'SendEvent () = IncPC ();

fun dfn'WaitForEvent () = IncPC ();

fun dfn'WaitForInterrupt () = IncPC ();

fun dfn'Yield () = IncPC ();

fun rec'FPSCR x =
  {AHP = BitsN.bit(x,26), C = BitsN.bit(x,29), DN = BitsN.bit(x,25),
   DZC = BitsN.bit(x,1), DZE = BitsN.bit(x,9), FZ = BitsN.bit(x,24),
   IDC = BitsN.bit(x,7), IDE = BitsN.bit(x,15), IOC = BitsN.bit(x,0),
   IOE = BitsN.bit(x,8), IXC = BitsN.bit(x,4), IXE = BitsN.bit(x,12),
   N = BitsN.bit(x,31), OFC = BitsN.bit(x,2), OFE = BitsN.bit(x,10),
   QC = BitsN.bit(x,27), RMode = BitsN.bits(23,22) x,
   UFC = BitsN.bit(x,3), UFE = BitsN.bit(x,11), V = BitsN.bit(x,28),
   Z = BitsN.bit(x,30),
   fpscr'rst =
     BitsN.concat
       [BitsN.bits(6,5) x,BitsN.bits(14,13) x,BitsN.bits(21,16) x]};

fun reg'FPSCR x =
  case x of
     {AHP = AHP, C = C, DN = DN, DZC = DZC, DZE = DZE, FZ = FZ, IDC = IDC,
      IDE = IDE, IOC = IOC, IOE = IOE, IXC = IXC, IXE = IXE, N = N,
      OFC = OFC, OFE = OFE, QC = QC, RMode = RMode, UFC = UFC, UFE = UFE,
      V = V, Z = Z, fpscr'rst = fpscr'rst} =>
       BitsN.concat
         [BitsN.fromBit N,BitsN.fromBit Z,BitsN.fromBit C,BitsN.fromBit V,
          BitsN.fromBit QC,BitsN.fromBit AHP,BitsN.fromBit DN,
          BitsN.fromBit FZ,RMode,BitsN.bits(5,0) fpscr'rst,
          BitsN.fromBit IDE,BitsN.bits(7,6) fpscr'rst,BitsN.fromBit IXE,
          BitsN.fromBit UFE,BitsN.fromBit OFE,BitsN.fromBit DZE,
          BitsN.fromBit IOE,BitsN.fromBit IDC,BitsN.bits(9,8) fpscr'rst,
          BitsN.fromBit IXC,BitsN.fromBit UFC,BitsN.fromBit OFC,
          BitsN.fromBit DZC,BitsN.fromBit IOC];

fun write'rec'FPSCR (_,x) = reg'FPSCR x;

fun write'reg'FPSCR (_,x) = rec'FPSCR x;

fun RoundingMode () =
  case #RMode((#FPSCR((!FP) : FP)) : FPSCR) of
     BitsN.B(0x0,_) => IEEEReal.TO_NEAREST
   | BitsN.B(0x1,_) => IEEEReal.TO_POSINF
   | BitsN.B(0x2,_) => IEEEReal.TO_NEGINF
   | BitsN.B(0x3,_) => IEEEReal.TO_ZERO
   | _ => raise General.Bind;

fun FPAdd32 (op1,op2) = FP32.add(RoundingMode (),(op1,op2));

fun FPSub32 (op1,op2) = FP32.sub(RoundingMode (),(op1,op2));

fun FPMul32 (op1,op2) = FP32.mul(RoundingMode (),(op1,op2));

fun FPAdd64 (op1,op2) = FP64.add(RoundingMode (),(op1,op2));

fun FPSub64 (op1,op2) = FP64.sub(RoundingMode (),(op1,op2));

fun FPMul64 (op1,op2) = FP64.mul(RoundingMode (),(op1,op2));

fun FPToFixed32 (operand,(unsigned,round_towards_zero)) =
  let
    val mode =
      if round_towards_zero then IEEEReal.TO_ZERO else RoundingMode ()
  in
    case FP32.toInt(mode,operand) of
       Option.SOME i =>
         let
           val (result,overflow) = SatQ 32 (i,(32,unsigned))
         in
           if overflow
             then raise VFP_EXCEPTION ("FPToFixed32: overflow exception")
           else result
         end
     | NONE => raise VFP_EXCEPTION ("FPToFixed32: NaN or infinity")
  end;

fun FPToFixed64 (operand,(unsigned,round_towards_zero)) =
  let
    val mode =
      if round_towards_zero then IEEEReal.TO_ZERO else RoundingMode ()
  in
    case FP64.toInt(mode,operand) of
       Option.SOME i =>
         let
           val (result,overflow) = SatQ 32 (i,(32,unsigned))
         in
           if overflow
             then raise VFP_EXCEPTION ("FPToFixed64: overflow exception")
           else result
         end
     | NONE => raise VFP_EXCEPTION ("FPToFixed64: NaN or infinity")
  end;

fun FixedToFP32 (operand,(unsigned,round_to_nearest)) =
  let
    val mode =
      if round_to_nearest then IEEEReal.TO_NEAREST else RoundingMode ()
    val int_operand =
      if unsigned
        then Nat.toInt(BitsN.toNat operand)
      else BitsN.toInt operand
  in
    FP32.fromInt(mode,int_operand)
  end;

fun FixedToFP64 (operand,(unsigned,round_to_nearest)) =
  let
    val mode =
      if round_to_nearest then IEEEReal.TO_NEAREST else RoundingMode ()
    val int_operand =
      if unsigned
        then Nat.toInt(BitsN.toNat operand)
      else BitsN.toInt operand
  in
    FP64.fromInt(mode,int_operand)
  end;

fun D n = Map.lookup(#REG((!FP) : FP),BitsN.toNat n);

fun write'D (value,n) =
  let
    val f = Map.copy(#REG((!FP) : FP))
  in
    FP := (FP_REG_rupd((!FP),Map.update(f,BitsN.toNat n,value)))
  end;

fun S n =
  if BitsN.bit(n,0)
    then BitsN.bits(63,32) (D(BitsN.div(n,BitsN.B(0x2,5))))
  else BitsN.bits(31,0) (D(BitsN.div(n,BitsN.B(0x2,5))));

fun write'S (value,n) =
  if BitsN.bit(n,0)
    then let
           val x = BitsN.div(n,BitsN.B(0x2,5))
           val w = D x
         in
           write'D(BitsN.bitFieldInsert(63,32) (w,value),x)
         end
  else let
         val x = BitsN.div(n,BitsN.B(0x2,5))
         val w = D x
       in
         write'D(BitsN.bitFieldInsert(31,0) (w,value),x)
       end;

fun VFPExpandImm (imm8,single) =
  if single
    then BitsN.zeroExtend 64
           (BitsN.concat
              [BitsN.bits(7,7) imm8,BitsN.~(BitsN.bits(6,6) imm8),
               BitsN.resize_replicate 5 (BitsN.bits(6,6) imm8,5),
               BitsN.bits(5,0) imm8,
               BitsN.resize_replicate 19 (BitsN.B(0x0,1),19)])
  else BitsN.concat
         [BitsN.bits(7,7) imm8,BitsN.~(BitsN.bits(6,6) imm8),
          BitsN.resize_replicate 8 (BitsN.bits(6,6) imm8,8),
          BitsN.bits(5,0) imm8,
          BitsN.resize_replicate 48 (BitsN.B(0x0,1),48)];

fun FPCompare32 (op1,op2) =
  if (FP32.isNan op1) orelse (FP32.isNan op2)
    then BitsN.B(0x3,4)
  else if FP32.equal(op1,op2)
    then BitsN.B(0x6,4)
  else if FP32.lessThan(op1,op2) then BitsN.B(0x8,4) else BitsN.B(0x2,4);

fun FPCompare64 (op1,op2) =
  if (FP64.isNan op1) orelse (FP64.isNan op2)
    then BitsN.B(0x3,4)
  else if FP64.equal(op1,op2)
    then BitsN.B(0x6,4)
  else if FP64.lessThan(op1,op2) then BitsN.B(0x8,4) else BitsN.B(0x2,4);

fun FPZero32 sign = BitsN.@@(sign,BitsN.B(0x0,31));

fun FPZero64 sign = BitsN.@@(sign,BitsN.B(0x0,63));

fun dfn'vmov_imm (single_register,(d,imm64)) =
  ( if single_register
      then write'S(BitsN.bits(31,0) imm64,d)
    else write'D(imm64,d)
  ; IncPC ()
  );

fun dfn'vmov (single_register,(d,m)) =
  ( if single_register then write'S(S m,d) else write'D(D m,d); IncPC () );

fun dfn'vmov_single (to_arm_register,(t,n)) =
  ( if to_arm_register then write'R(S n,t) else write'S(R t,n); IncPC () );

fun dfn'vmov_two_singles (to_arm_registers,(t,(t2,m))) =
  ( if to_arm_registers
      then ( write'R(S m,t); write'R(S(BitsN.+(m,BitsN.B(0x1,5))),t2) )
    else ( write'S(R t,m)
         ; let val x = BitsN.+(m,BitsN.B(0x1,5)) in write'S(R t2,x) end
         )
  ; IncPC ()
  );

fun dfn'vmov_double (to_arm_registers,(t,(t2,m))) =
  ( if to_arm_registers
      then ( write'R(BitsN.bits(31,0) (D m),t)
           ; write'R(BitsN.bits(63,32) (D m),t2)
           )
    else ( let
             val w = D m
           in
             write'D(BitsN.bitFieldInsert(31,0) (w,R t),m)
           end
         ; let
             val w = D m
           in
             write'D(BitsN.bitFieldInsert(63,32) (w,R t2),m)
           end
         )
  ; IncPC ()
  );

fun dfn'vabs (dp_operation,(d,m)) =
  ( if dp_operation
      then write'D(FP64.abs2008(D m),d)
    else write'S(FP32.abs2008(S m),d)
  ; IncPC ()
  );

fun dfn'vneg (dp_operation,(d,m)) =
  ( if dp_operation
      then write'D(FP64.neg2008(D m),d)
    else write'S(FP32.neg2008(S m),d)
  ; IncPC ()
  );

fun dfn'vsqrt (dp_operation,(d,m)) =
  ( if dp_operation
      then write'D(FP64.sqrt(RoundingMode (),D m),d)
    else write'S(FP32.sqrt(RoundingMode (),S m),d)
  ; IncPC ()
  );

fun dfn'vcvt_float (double_to_single,(d,m)) =
  ( if double_to_single
      then write'S(FPConvert.fp64_to_fp32(RoundingMode (),D m),d)
    else write'D(FPConvert.fp32_to_fp64(S m),d)
  ; IncPC ()
  );

fun dfn'vcvt_to_integer (dp_operation,(unsigned,(round_zero,(d,m)))) =
  ( if dp_operation
      then write'S(FPToFixed64(D m,(unsigned,round_zero)),d)
    else write'S(FPToFixed32(S m,(unsigned,round_zero)),d)
  ; IncPC ()
  );

fun dfn'vcvt_from_integer (dp_operation,(unsigned,(d,m))) =
  ( if dp_operation
      then write'D(FixedToFP64(S m,(unsigned,false)),d)
    else write'S(FixedToFP32(S m,(unsigned,false)),d)
  ; IncPC ()
  );

fun dfn'vcmp (dp_operation,(d,m_with_zero)) =
  ( if dp_operation
      then let
             val op2 =
               case m_with_zero of
                  Option.SOME m => D m
                | NONE => FPZero64(BitsN.B(0x0,1))
             val x0 = #FPSCR((!FP) : FP)
             val w = reg'FPSCR x0
           in
             FP :=
             (FP_FPSCR_rupd
                ((!FP),
                 write'reg'FPSCR
                   (x0,
                    BitsN.bitFieldInsert(31,28) (w,FPCompare64(D d,op2)))))
           end
    else let
           val op2 =
             case m_with_zero of
                Option.SOME m => S m
              | NONE => FPZero32(BitsN.B(0x0,1))
           val x0 = #FPSCR((!FP) : FP)
           val w = reg'FPSCR x0
         in
           FP :=
           (FP_FPSCR_rupd
              ((!FP),
               write'reg'FPSCR
                 (x0,BitsN.bitFieldInsert(31,28) (w,FPCompare32(S d,op2)))))
         end
  ; IncPC ()
  );

fun dfn'vmsr t =
  ( let
      val x0 = #FPSCR((!FP) : FP)
    in
      FP := (FP_FPSCR_rupd((!FP),write'reg'FPSCR(x0,R t)))
    end
  ; IncPC ()
  );

fun dfn'vmrs t =
  ( if not(t = (BitsN.B(0xF,4)))
      then write'R(reg'FPSCR(#FPSCR((!FP) : FP)),t)
    else ( CPSR := (PSR_N_rupd((!CPSR),#N((#FPSCR((!FP) : FP)) : FPSCR)))
         ; CPSR := (PSR_Z_rupd((!CPSR),#Z((#FPSCR((!FP) : FP)) : FPSCR)))
         ; CPSR := (PSR_C_rupd((!CPSR),#C((#FPSCR((!FP) : FP)) : FPSCR)))
         ; CPSR := (PSR_V_rupd((!CPSR),#V((#FPSCR((!FP) : FP)) : FPSCR)))
         )
  ; IncPC ()
  );

fun dfn'vadd (dp_operation,(d,(n,m))) =
  ( if dp_operation
      then write'D(FPAdd64(D n,D m),d)
    else write'S(FPAdd32(S n,S m),d)
  ; IncPC ()
  );

fun dfn'vsub (dp_operation,(d,(n,m))) =
  ( if dp_operation
      then write'D(FPSub64(D n,D m),d)
    else write'S(FPSub32(S n,S m),d)
  ; IncPC ()
  );

fun dfn'vmul (dp_operation,(d,(n,m))) =
  ( if dp_operation
      then write'D(FPMul64(D n,D m),d)
    else write'S(FPMul32(S n,S m),d)
  ; IncPC ()
  );

fun dfn'vdiv (dp_operation,(d,(n,m))) =
  ( if dp_operation
      then write'D(FP64.div(RoundingMode (),(D n,D m)),d)
    else write'S(FP32.div(RoundingMode (),(S n,S m)),d)
  ; IncPC ()
  );

fun dfn'vmla_vmls (dp_operation,(add,(d,(n,m)))) =
  ( if dp_operation
      then let
             val product = FPMul64(D n,D m)
             val addend = if add then product else FP64.neg2008 product
           in
             write'D(FPAdd64(D n,addend),d)
           end
    else let
           val product = FPMul32(S n,S m)
           val addend = if add then product else FP32.neg2008 product
         in
           write'S(FPAdd32(S n,addend),d)
         end
  ; IncPC ()
  );

fun dfn'vfma_vfms (dp_operation,(add,(d,(n,m)))) =
  ( if dp_operation
      then let
             val op64 = D n
             val op64 = if add then op64 else FP64.neg2008 op64
           in
             write'D(FP64.mul_add(RoundingMode (),(op64,(D m,D d))),d)
           end
    else let
           val op32 = S n
           val op32 = if add then op32 else FP32.neg2008 op32
         in
           write'S(FP32.mul_add(RoundingMode (),(op32,(S m,S d))),d)
         end
  ; IncPC ()
  );

fun dfn'vfnma_vfnms (dp_operation,(add,(d,(n,m)))) =
  ( if dp_operation
      then let
             val op64 = D n
             val op64 = if add then op64 else FP64.neg2008 op64
           in
             write'D
               (FP64.mul_add
                  (RoundingMode (),(op64,(D m,FP64.neg2008(D d)))),d)
           end
    else let
           val op32 = S n
           val op32 = if add then op32 else FP32.neg2008 op32
         in
           write'S
             (FP32.mul_add(RoundingMode (),(op32,(S m,FP32.neg2008(S d)))),
              d)
         end
  ; IncPC ()
  );

fun dfn'vneg_mul (dp_operation,(typ,(d,(n,m)))) =
  ( if dp_operation
      then let
             val product = FPMul64(D n,D m)
           in
             case typ of
                VFPNegMul_VNMLA =>
                  write'D
                    (FPAdd64(FP64.neg2008(D d),FP64.neg2008 product),d)
              | VFPNegMul_VNMLS =>
                write'D(FPAdd64(FP64.neg2008(D d),product),d)
              | VFPNegMul_VNMUL => write'D(FP64.neg2008 product,d)
           end
    else let
           val product = FPMul32(S n,S m)
         in
           case typ of
              VFPNegMul_VNMLA =>
                write'S(FPAdd32(FP32.neg2008(S d),FP32.neg2008 product),d)
            | VFPNegMul_VNMLS =>
              write'S(FPAdd32(FP32.neg2008(S d),product),d)
            | VFPNegMul_VNMUL => write'S(FP32.neg2008 product,d)
         end
  ; IncPC ()
  );

fun dfn'vldr (single_reg,(add,(d,(n,imm32)))) =
  let
    val base = if n = (BitsN.B(0xF,4)) then Align 32 (PC (),4) else R n
    val address = if add then BitsN.+(base,imm32) else BitsN.-(base,imm32)
  in
    ( if single_reg
        then write'S(MemA 32 (address,4),d)
      else let
             val word1 = MemA 32 (address,4)
             val word2 = MemA 32 (BitsN.+(address,BitsN.B(0x4,32)),4)
           in
             write'D
               (if BigEndian ()
                  then BitsN.@@(word1,word2)
                else BitsN.@@(word2,word1),d)
           end
    ; IncPC ()
    )
  end;

fun dfn'vstr (single_reg,(add,(d,(n,imm32)))) =
  let
    val address = if add then BitsN.+(R n,imm32) else BitsN.-(R n,imm32)
  in
    ( if single_reg
        then let val x = (address,4) in write'MemA 32 (S d,x) end
      else let
             val word = D d
           in
             ( let
                 val x = (address,4)
               in
                 write'MemA 32
                   (if BigEndian ()
                      then BitsN.bits(63,32) word
                    else BitsN.bits(31,0) word,x)
               end
             ; let
                 val x = (BitsN.+(address,BitsN.B(0x4,32)),4)
               in
                 write'MemA 32
                   (if BigEndian ()
                      then BitsN.bits(31,0) word
                    else BitsN.bits(63,32) word,x)
               end
             )
           end
    ; IncPC ()
    )
  end;

fun dfn'vldm (single_regs,(add,(wback,(d,(n,imm8))))) =
  let
    val imm32 = BitsN.zeroExtend 32 (BitsN.@@(imm8,BitsN.B(0x0,2)))
    val regs =
      if single_regs
        then BitsN.toNat imm8
      else Nat.div(BitsN.toNat imm8,2)
  in
    let
      val address = ref (if add then R n else BitsN.-(R n,imm32))
    in
      ( L3.for
          (0,Nat.-(regs,1),
           fn r =>
             if single_regs
               then ( let
                        val x = BitsN.+(d,BitsN.fromNat(r,5))
                      in
                        write'S(MemA 32 ((!address),4),x)
                      end
                    ; address := (BitsN.+((!address),BitsN.B(0x4,32)))
                    )
             else let
                    val word1 = MemA 32 ((!address),4)
                    val word2 =
                      MemA 32 (BitsN.+((!address),BitsN.B(0x4,32)),4)
                  in
                    ( address := (BitsN.+((!address),BitsN.B(0x8,32)))
                    ; let
                        val x = BitsN.+(d,BitsN.fromNat(r,5))
                      in
                        write'D
                          (if BigEndian ()
                             then BitsN.@@(word1,word2)
                           else BitsN.@@(word2,word1),x)
                      end
                    )
                  end)
      ; if wback
          then write'R
                 (if add then BitsN.+(R n,imm32) else BitsN.-(R n,imm32),n)
        else ()
      ; IncPC ()
      )
    end
  end;

fun dfn'vstm (single_regs,(add,(wback,(d,(n,imm8))))) =
  let
    val imm32 = BitsN.zeroExtend 32 (BitsN.@@(imm8,BitsN.B(0x0,2)))
    val regs =
      if single_regs
        then BitsN.toNat imm8
      else Nat.div(BitsN.toNat imm8,2)
  in
    let
      val address = ref (if add then R n else BitsN.-(R n,imm32))
    in
      ( L3.for
          (0,Nat.-(regs,1),
           fn r =>
             if single_regs
               then ( let
                        val x = ((!address),4)
                      in
                        write'MemA 32 (S(BitsN.+(d,BitsN.fromNat(r,5))),x)
                      end
                    ; address := (BitsN.+((!address),BitsN.B(0x4,32)))
                    )
             else let
                    val d = D(BitsN.+(d,BitsN.fromNat(r,5)))
                  in
                    ( let
                        val x = ((!address),4)
                      in
                        write'MemA 32
                          (if BigEndian ()
                             then BitsN.bits(63,32) d
                           else BitsN.bits(31,0) d,x)
                      end
                    ; let
                        val x = (BitsN.+((!address),BitsN.B(0x4,32)),4)
                      in
                        write'MemA 32
                          (if BigEndian ()
                             then BitsN.bits(31,0) d
                           else BitsN.bits(63,32) d,x)
                      end
                    ; address := (BitsN.+((!address),BitsN.B(0x8,32)))
                    )
                  end)
      ; if wback
          then write'R
                 (if add then BitsN.+(R n,imm32) else BitsN.-(R n,imm32),n)
        else ()
      ; IncPC ()
      )
    end
  end;

fun Run v0 =
  case v0 of
     ClearExclusive => dfn'ClearExclusive ()
   | NoOperation => dfn'NoOperation ()
   | Divide v152 => dfn'Divide v152
   | IfThen v153 => dfn'IfThen v153
   | Swap v154 => dfn'Swap v154
   | Undefined v155 => dfn'Undefined v155
   | Branch v1 =>
     (case v1 of
         BranchExchange v2 => dfn'BranchExchange v2
       | BranchLinkExchangeImmediate v3 =>
         dfn'BranchLinkExchangeImmediate v3
       | BranchLinkExchangeRegister v4 =>
         dfn'BranchLinkExchangeRegister v4
       | BranchTarget v5 => dfn'BranchTarget v5
       | CheckArray v6 => dfn'CheckArray v6
       | CompareBranch v7 => dfn'CompareBranch v7
       | HandlerBranchLink v8 => dfn'HandlerBranchLink v8
       | HandlerBranchLinkParameter v9 =>
         dfn'HandlerBranchLinkParameter v9
       | HandlerBranchParameter v10 => dfn'HandlerBranchParameter v10
       | TableBranchByte v11 => dfn'TableBranchByte v11)
   | Data v12 =>
     (case v12 of
         AddSub v13 => dfn'AddSub v13
       | ArithLogicImmediate v14 => dfn'ArithLogicImmediate v14
       | CountLeadingZeroes v15 => dfn'CountLeadingZeroes v15
       | Move v16 => dfn'Move v16
       | MoveHalfword v17 => dfn'MoveHalfword v17
       | Register v18 => dfn'Register v18
       | RegisterShiftedRegister v19 => dfn'RegisterShiftedRegister v19
       | ShiftImmediate v20 => dfn'ShiftImmediate v20
       | ShiftRegister v21 => dfn'ShiftRegister v21
       | TestCompareImmediate v22 => dfn'TestCompareImmediate v22
       | TestCompareRegister v23 => dfn'TestCompareRegister v23)
   | Hint v24 =>
     (case v24 of
         SendEvent => dfn'SendEvent ()
       | WaitForEvent => dfn'WaitForEvent ()
       | WaitForInterrupt => dfn'WaitForInterrupt ()
       | Yield => dfn'Yield ()
       | Breakpoint v25 => dfn'Breakpoint v25
       | DataMemoryBarrier v26 => dfn'DataMemoryBarrier v26
       | DataSynchronizationBarrier v27 =>
         dfn'DataSynchronizationBarrier v27
       | Debug v28 => dfn'Debug v28
       | InstructionSynchronizationBarrier v29 =>
         dfn'InstructionSynchronizationBarrier v29
       | PreloadData v30 => dfn'PreloadData v30
       | PreloadDataLiteral v31 => dfn'PreloadDataLiteral v31
       | PreloadInstruction v32 => dfn'PreloadInstruction v32)
   | Load v33 =>
     (case v33 of
         LoadByte v34 => dfn'LoadByte v34
       | LoadByteLiteral v35 => dfn'LoadByteLiteral v35
       | LoadByteUnprivileged v36 => dfn'LoadByteUnprivileged v36
       | LoadDual v37 => dfn'LoadDual v37
       | LoadDualLiteral v38 => dfn'LoadDualLiteral v38
       | LoadExclusive v39 => dfn'LoadExclusive v39
       | LoadExclusiveByte v40 => dfn'LoadExclusiveByte v40
       | LoadExclusiveDoubleword v41 => dfn'LoadExclusiveDoubleword v41
       | LoadExclusiveHalf v42 => dfn'LoadExclusiveHalf v42
       | LoadHalf v43 => dfn'LoadHalf v43
       | LoadHalfLiteral v44 => dfn'LoadHalfLiteral v44
       | LoadHalfUnprivileged v45 => dfn'LoadHalfUnprivileged v45
       | LoadLiteral v46 => dfn'LoadLiteral v46
       | LoadMultiple v47 => dfn'LoadMultiple v47
       | LoadMultipleExceptionReturn v48 =>
         dfn'LoadMultipleExceptionReturn v48
       | LoadMultipleUserRegisters v49 =>
         dfn'LoadMultipleUserRegisters v49
       | LoadSignedByteUnprivileged v50 =>
         dfn'LoadSignedByteUnprivileged v50
       | LoadUnprivileged v51 => dfn'LoadUnprivileged v51
       | LoadWord v52 => dfn'LoadWord v52)
   | Media v53 =>
     (case v53 of
         BitFieldClearOrInsert v54 => dfn'BitFieldClearOrInsert v54
       | BitFieldExtract v55 => dfn'BitFieldExtract v55
       | ByteReverse v56 => dfn'ByteReverse v56
       | ByteReversePackedHalfword v57 =>
         dfn'ByteReversePackedHalfword v57
       | ByteReverseSignedHalfword v58 =>
         dfn'ByteReverseSignedHalfword v58
       | ExtendByte v59 => dfn'ExtendByte v59
       | ExtendByte16 v60 => dfn'ExtendByte16 v60
       | ExtendHalfword v61 => dfn'ExtendHalfword v61
       | PackHalfword v62 => dfn'PackHalfword v62
       | ReverseBits v63 => dfn'ReverseBits v63
       | Saturate v64 => dfn'Saturate v64
       | Saturate16 v65 => dfn'Saturate16 v65
       | SaturatingAddSubtract v66 => dfn'SaturatingAddSubtract v66
       | SelectBytes v67 => dfn'SelectBytes v67)
   | Multiply v68 =>
     (case v68 of
         Multiply32 v69 => dfn'Multiply32 v69
       | MultiplyAccumulate v70 => dfn'MultiplyAccumulate v70
       | MultiplyAccumulateAccumulate v71 =>
         dfn'MultiplyAccumulateAccumulate v71
       | MultiplyLong v72 => dfn'MultiplyLong v72
       | MultiplySubtract v73 => dfn'MultiplySubtract v73
       | Signed16Multiply32Accumulate v74 =>
         dfn'Signed16Multiply32Accumulate v74
       | Signed16Multiply32Result v75 => dfn'Signed16Multiply32Result v75
       | Signed16Multiply64Accumulate v76 =>
         dfn'Signed16Multiply64Accumulate v76
       | Signed16x32Multiply32Accumulate v77 =>
         dfn'Signed16x32Multiply32Accumulate v77
       | Signed16x32Multiply32Result v78 =>
         dfn'Signed16x32Multiply32Result v78
       | SignedMostSignificantMultiply v79 =>
         dfn'SignedMostSignificantMultiply v79
       | SignedMostSignificantMultiplySubtract v80 =>
         dfn'SignedMostSignificantMultiplySubtract v80
       | SignedMultiplyDual v81 => dfn'SignedMultiplyDual v81
       | SignedMultiplyLongDual v82 => dfn'SignedMultiplyLongDual v82)
   | SIMD v83 =>
     (case v83 of
         SignedAddSub16 v84 => dfn'SignedAddSub16 v84
       | SignedAddSub8 v85 => dfn'SignedAddSub8 v85
       | SignedHalvingAddSub16 v86 => dfn'SignedHalvingAddSub16 v86
       | SignedHalvingAddSub8 v87 => dfn'SignedHalvingAddSub8 v87
       | SignedSaturatingAddSub16 v88 => dfn'SignedSaturatingAddSub16 v88
       | SignedSaturatingAddSub8 v89 => dfn'SignedSaturatingAddSub8 v89
       | UnsignedAddSub16 v90 => dfn'UnsignedAddSub16 v90
       | UnsignedAddSub8 v91 => dfn'UnsignedAddSub8 v91
       | UnsignedHalvingAddSub16 v92 => dfn'UnsignedHalvingAddSub16 v92
       | UnsignedHalvingAddSub8 v93 => dfn'UnsignedHalvingAddSub8 v93
       | UnsignedSaturatingAddSub16 v94 =>
         dfn'UnsignedSaturatingAddSub16 v94
       | UnsignedSaturatingAddSub8 v95 =>
         dfn'UnsignedSaturatingAddSub8 v95
       | UnsignedSumAbsoluteDifferences v96 =>
         dfn'UnsignedSumAbsoluteDifferences v96)
   | Store v97 =>
     (case v97 of
         StoreByte v98 => dfn'StoreByte v98
       | StoreByteUnprivileged v99 => dfn'StoreByteUnprivileged v99
       | StoreDual v100 => dfn'StoreDual v100
       | StoreExclusive v101 => dfn'StoreExclusive v101
       | StoreExclusiveByte v102 => dfn'StoreExclusiveByte v102
       | StoreExclusiveDoubleword v103 =>
         dfn'StoreExclusiveDoubleword v103
       | StoreExclusiveHalf v104 => dfn'StoreExclusiveHalf v104
       | StoreHalf v105 => dfn'StoreHalf v105
       | StoreHalfUnprivileged v106 => dfn'StoreHalfUnprivileged v106
       | StoreMultiple v107 => dfn'StoreMultiple v107
       | StoreMultipleUserRegisters v108 =>
         dfn'StoreMultipleUserRegisters v108
       | StoreUnprivileged v109 => dfn'StoreUnprivileged v109
       | StoreWord v110 => dfn'StoreWord v110)
   | System v111 =>
     (case v111 of
         ExceptionReturn => dfn'ExceptionReturn ()
       | ChangeProcessorState v112 => dfn'ChangeProcessorState v112
       | EnterxLeavex v113 => dfn'EnterxLeavex v113
       | HypervisorCall v114 => dfn'HypervisorCall v114
       | MoveToBankedOrSpecialRegister v115 =>
         dfn'MoveToBankedOrSpecialRegister v115
       | MoveToRegisterFromBankedOrSpecial v116 =>
         dfn'MoveToRegisterFromBankedOrSpecial v116
       | MoveToRegisterFromSpecial v117 =>
         dfn'MoveToRegisterFromSpecial v117
       | MoveToSpecialFromImmediate v118 =>
         dfn'MoveToSpecialFromImmediate v118
       | MoveToSpecialFromRegister v119 =>
         dfn'MoveToSpecialFromRegister v119
       | ReturnFromException v120 => dfn'ReturnFromException v120
       | SecureMonitorCall v121 => dfn'SecureMonitorCall v121
       | Setend v122 => dfn'Setend v122
       | StoreReturnState v123 => dfn'StoreReturnState v123
       | SupervisorCall v124 => dfn'SupervisorCall v124)
   | VFP v125 =>
     (case v125 of
         vabs v126 => dfn'vabs v126
       | vadd v127 => dfn'vadd v127
       | vcmp v128 => dfn'vcmp v128
       | vcvt_float v129 => dfn'vcvt_float v129
       | vcvt_from_integer v130 => dfn'vcvt_from_integer v130
       | vcvt_to_integer v131 => dfn'vcvt_to_integer v131
       | vdiv v132 => dfn'vdiv v132
       | vfma_vfms v133 => dfn'vfma_vfms v133
       | vfnma_vfnms v134 => dfn'vfnma_vfnms v134
       | vldm v135 => dfn'vldm v135
       | vldr v136 => dfn'vldr v136
       | vmla_vmls v137 => dfn'vmla_vmls v137
       | vmov v138 => dfn'vmov v138
       | vmov_double v139 => dfn'vmov_double v139
       | vmov_imm v140 => dfn'vmov_imm v140
       | vmov_single v141 => dfn'vmov_single v141
       | vmov_two_singles v142 => dfn'vmov_two_singles v142
       | vmrs v143 => dfn'vmrs v143
       | vmsr v144 => dfn'vmsr v144
       | vmul v145 => dfn'vmul v145
       | vneg v146 => dfn'vneg v146
       | vneg_mul v147 => dfn'vneg_mul v147
       | vsqrt v148 => dfn'vsqrt v148
       | vstm v149 => dfn'vstm v149
       | vstr v150 => dfn'vstr v150
       | vsub v151 => dfn'vsub v151);

fun Fetch () =
  let
    val iset = CurrentInstrSet ()
  in
    if (iset = InstrSet_ARM) orelse ((!Architecture) = ARMv4)
      then ( Encoding := Encoding_ARM
           ; ARM(MemA 32 (Map.lookup((!REG),Cast.RNameToNat RName_PC),4))
           )
    else if iset = InstrSet_Jazelle
      then BadCode("Fetch")
    else let
           val fpc = Map.lookup((!REG),Cast.RNameToNat RName_PC)
           val ireg = MemA 16 (fpc,2)
         in
           if ((BitsN.bits(15,13) ireg) = (BitsN.B(0x7,3))) andalso
              (not((BitsN.bits(12,11) ireg) = (BitsN.B(0x0,2))))
             then ( Encoding := Encoding_Thumb2
                  ; Thumb2(ireg,MemA 16 (BitsN.+(fpc,BitsN.B(0x2,32)),2))
                  )
           else ( Encoding := Encoding_Thumb
                ; if (iset = InstrSet_Thumb) orelse (not(HaveThumbEE ()))
                    then Thumb ireg
                  else ThumbEE ireg
                )
         end
  end;

fun Do (cond,defined) =
  ( CurrentCondition := cond
  ; let
      val pass = ConditionPassed ()
    in
      ( undefined := (pass andalso (not defined)); pass andalso defined )
    end
  );

fun Skip () =
  if (!undefined) then Undefined(BitsN.B(0x0,32)) else NoOperation;

fun UndefinedARM cond =
  ( CurrentCondition := cond
  ; if ConditionPassed () then Undefined(BitsN.B(0x0,32)) else NoOperation
  );

fun UndefinedThumb () = UndefinedARM(ThumbCondition ());

fun DECODE_UNPREDICTABLE (mc,s) =
  raise UNPREDICTABLE
    (String.concat
       ["Decode ",
        case mc of
           ARM opc =>
             (Bitstring.toBinString(BitsN.toBitstring opc)) ^ ("; ARM; ")
         | Thumb opc =>
           (Bitstring.toBinString(BitsN.toBitstring opc)) ^ ("; Thumb; ")
         | ThumbEE opc =>
           (Bitstring.toBinString(BitsN.toBitstring opc))
             ^
             ("; ThumbEE; ")
         | Thumb2(opc1,opc2) =>
           String.concat
             [Bitstring.toBinString(BitsN.toBitstring opc1),", ",
              Bitstring.toBinString(BitsN.toBitstring opc2),"; Thumb2; "]
         | BadCode x => x,s]);

fun DecodeHint (cond,op') =
  if ((!Architecture) = ARMv6T2) orelse
     (((BitsN.bits(7,4) op') = (BitsN.B(0xF,4))) andalso
      (((!Encoding) = Encoding_ARM) andalso ((!Architecture) = ARMv6K)))
    then NoOperation
  else if Do(cond,
        (Nat.>=(ArchVersion (),7)) orelse
        (((!Encoding) = Encoding_ARM) andalso ((!Architecture) = ARMv6K)))
    then case boolify'8 op' of
            (false,(false,(false,(false,(false,(false,(false,true))))))) =>
              Hint Yield
          | (false,(false,(false,(false,(false,(false,(true,false))))))) =>
            Hint WaitForEvent
          | (false,(false,(false,(false,(false,(false,(true,true))))))) =>
            Hint WaitForInterrupt
          | (false,(false,(false,(false,(false,(true,(false,false))))))) =>
            Hint SendEvent
          | (true,
           (true,(true,(true,(option'3,(option'2,(option'1,option'0))))))) =>
            Hint
              (Debug
                 (BitsN.fromBitstring
                    ([option'3,option'2,option'1,option'0],4)))
          | _ => NoOperation
  else Skip ();

fun DecodeParallelAdditionSubtraction (op1,(op2,(U,(Rd,(Rn,Rm))))) =
  if U = (BitsN.B(0x1,1))
    then case (op1,boolify'3 op2) of
            (BitsN.B(0x1,_),(false,(x'1,x'0))) =>
              SIMD
                (UnsignedAddSub16
                   (BitsN.fromBitstring([x'1,x'0],2),(Rd,(Rn,Rm))))
          | (BitsN.B(0x1,_),(true,(false,false))) =>
            SIMD(UnsignedAddSub8(false,(Rd,(Rn,Rm))))
          | (BitsN.B(0x1,_),(true,(true,true))) =>
            SIMD(UnsignedAddSub8(true,(Rd,(Rn,Rm))))
          | (BitsN.B(0x2,_),(false,(x'1,x'0))) =>
            SIMD
              (UnsignedSaturatingAddSub16
                 (BitsN.fromBitstring([x'1,x'0],2),(Rd,(Rn,Rm))))
          | (BitsN.B(0x2,_),(true,(false,false))) =>
            SIMD(UnsignedSaturatingAddSub8(false,(Rd,(Rn,Rm))))
          | (BitsN.B(0x2,_),(true,(true,true))) =>
            SIMD(UnsignedSaturatingAddSub8(true,(Rd,(Rn,Rm))))
          | (BitsN.B(0x3,_),(false,(x'1,x'0))) =>
            SIMD
              (UnsignedHalvingAddSub16
                 (BitsN.fromBitstring([x'1,x'0],2),(Rd,(Rn,Rm))))
          | (BitsN.B(0x3,_),(true,(false,false))) =>
            SIMD(UnsignedHalvingAddSub8(false,(Rd,(Rn,Rm))))
          | (BitsN.B(0x3,_),(true,(true,true))) =>
            SIMD(UnsignedHalvingAddSub8(true,(Rd,(Rn,Rm))))
          | _ => Undefined(BitsN.B(0x0,32))
  else case (op1,boolify'3 op2) of
          (BitsN.B(0x1,_),(false,(x'1,x'0))) =>
            SIMD
              (SignedAddSub16
                 (BitsN.fromBitstring([x'1,x'0],2),(Rd,(Rn,Rm))))
        | (BitsN.B(0x1,_),(true,(false,false))) =>
          SIMD(SignedAddSub8(false,(Rd,(Rn,Rm))))
        | (BitsN.B(0x1,_),(true,(true,true))) =>
          SIMD(SignedAddSub8(true,(Rd,(Rn,Rm))))
        | (BitsN.B(0x2,_),(false,(x'1,x'0))) =>
          SIMD
            (SignedSaturatingAddSub16
               (BitsN.fromBitstring([x'1,x'0],2),(Rd,(Rn,Rm))))
        | (BitsN.B(0x2,_),(true,(false,false))) =>
          SIMD(SignedSaturatingAddSub8(false,(Rd,(Rn,Rm))))
        | (BitsN.B(0x2,_),(true,(true,true))) =>
          SIMD(SignedSaturatingAddSub8(true,(Rd,(Rn,Rm))))
        | (BitsN.B(0x3,_),(false,(x'1,x'0))) =>
          SIMD
            (SignedHalvingAddSub16
               (BitsN.fromBitstring([x'1,x'0],2),(Rd,(Rn,Rm))))
        | (BitsN.B(0x3,_),(true,(false,false))) =>
          SIMD(SignedHalvingAddSub8(false,(Rd,(Rn,Rm))))
        | (BitsN.B(0x3,_),(true,(true,true))) =>
          SIMD(SignedHalvingAddSub8(true,(Rd,(Rn,Rm))))
        | _ => Undefined(BitsN.B(0x0,32));

fun DecodeVFP w =
  case boolify'28(BitsN.bits(27,0) w) of
     (true,
      (true,
       (false,
        (false,
         (true,
          (D'0,
           (W'0,
            (L'0,
             (Rn'3,
              (Rn'2,
               (Rn'1,
                (Rn'0,
                 (Vd'3,
                  (Vd'2,
                   (Vd'1,
                    (Vd'0,
                     (true,
                      (false,
                       (true,
                        (sz'0,
                         (imm8'7,
                          (imm8'6,
                           (imm8'5,
                            (imm8'4,(imm8'3,(imm8'2,(imm8'1,imm8'0))))))))))))))))))))))))))) =>
       let
         val imm8 =
           BitsN.fromBitstring
             ([imm8'7,imm8'6,imm8'5,imm8'4,imm8'3,imm8'2,imm8'1,imm8'0],8)
         val Vd = BitsN.fromBitstring([Vd'3,Vd'2,Vd'1,Vd'0],4)
         val Rn = BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)
         val D = BitsN.fromBitstring([D'0],1)
         val single_regs =
           (BitsN.fromBitstring([sz'0],1)) = (BitsN.B(0x0,1))
         val wback = (BitsN.fromBitstring([W'0],1)) = (BitsN.B(0x1,1))
         val (d,regs) =
           if single_regs
             then (BitsN.@@(Vd,D),BitsN.toNat imm8)
           else (BitsN.@@(D,Vd),Nat.div(BitsN.toNat imm8,2))
       in
         if (regs = 0) orelse
            ((Nat.>(Nat.+(BitsN.toNat d,regs),32)) orelse
             ((wback andalso (Rn = (BitsN.B(0xF,4)))) orelse
              ((not single_regs) andalso
               ((Nat.>(regs,16)) orelse (BitsN.bit(imm8,0))))))
           then raise UNPREDICTABLE ("DecodeVFP: vpop")
         else if (BitsN.fromBitstring([L'0],1)) = (BitsN.B(0x1,1))
           then (not((!VFPExtension) = NoVFP),
                 VFP(vldm(single_regs,(true,(wback,(d,(Rn,imm8)))))))
         else (not((!VFPExtension) = NoVFP),
               VFP(vstm(single_regs,(true,(wback,(d,(Rn,imm8)))))))
       end
   | (true,
    (true,
     (false,
      (true,
       (false,
        (D'0,
         (true,
          (L'0,
           (Rn'3,
            (Rn'2,
             (Rn'1,
              (Rn'0,
               (Vd'3,
                (Vd'2,
                 (Vd'1,
                  (Vd'0,
                   (true,
                    (false,
                     (true,
                      (sz'0,
                       (imm8'7,
                        (imm8'6,
                         (imm8'5,
                          (imm8'4,(imm8'3,(imm8'2,(imm8'1,imm8'0))))))))))))))))))))))))))) =>
     let
       val imm8 =
         BitsN.fromBitstring
           ([imm8'7,imm8'6,imm8'5,imm8'4,imm8'3,imm8'2,imm8'1,imm8'0],8)
       val Vd = BitsN.fromBitstring([Vd'3,Vd'2,Vd'1,Vd'0],4)
       val Rn = BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)
       val D = BitsN.fromBitstring([D'0],1)
       val single_regs =
         (BitsN.fromBitstring([sz'0],1)) = (BitsN.B(0x0,1))
       val wback = true
       val (d,regs) =
         if single_regs
           then (BitsN.@@(Vd,D),BitsN.toNat imm8)
         else (BitsN.@@(D,Vd),Nat.div(BitsN.toNat imm8,2))
     in
       if (regs = 0) orelse
          ((Nat.>(Nat.+(BitsN.toNat d,regs),32)) orelse
           ((wback andalso (Rn = (BitsN.B(0xF,4)))) orelse
            ((not single_regs) andalso
             ((Nat.>(regs,16)) orelse (BitsN.bit(imm8,0))))))
         then raise UNPREDICTABLE ("DecodeVFP: vpop")
       else if (BitsN.fromBitstring([L'0],1)) = (BitsN.B(0x1,1))
         then (not((!VFPExtension) = NoVFP),
               VFP(vldm(single_regs,(false,(wback,(d,(Rn,imm8)))))))
       else (not((!VFPExtension) = NoVFP),
             VFP(vstm(single_regs,(false,(wback,(d,(Rn,imm8)))))))
     end
   | (true,
    (true,
     (false,
      (true,
       (U'0,
        (D'0,
         (false,
          (L'0,
           (Rn'3,
            (Rn'2,
             (Rn'1,
              (Rn'0,
               (Vd'3,
                (Vd'2,
                 (Vd'1,
                  (Vd'0,
                   (true,
                    (false,
                     (true,
                      (sz'0,
                       (imm8'7,
                        (imm8'6,
                         (imm8'5,
                          (imm8'4,(imm8'3,(imm8'2,(imm8'1,imm8'0))))))))))))))))))))))))))) =>
     let
       val Vd = BitsN.fromBitstring([Vd'3,Vd'2,Vd'1,Vd'0],4)
       val Rn = BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)
       val D = BitsN.fromBitstring([D'0],1)
       val single_reg = (BitsN.fromBitstring([sz'0],1)) = (BitsN.B(0x0,1))
       val add = (BitsN.fromBitstring([U'0],1)) = (BitsN.B(0x1,1))
       val imm32 =
         BitsN.zeroExtend 32
           (BitsN.@@
              (BitsN.fromBitstring
                 ([imm8'7,imm8'6,imm8'5,imm8'4,imm8'3,imm8'2,imm8'1,imm8'0],
                  8),BitsN.B(0x0,2)))
       val d = if single_reg then BitsN.@@(Vd,D) else BitsN.@@(D,Vd)
     in
       if (BitsN.fromBitstring([L'0],1)) = (BitsN.B(0x1,1))
         then (not((!VFPExtension) = NoVFP),
               VFP(vldr(single_reg,(add,(d,(Rn,imm32))))))
       else (not((!VFPExtension) = NoVFP),
             VFP(vstr(single_reg,(add,(d,(Rn,imm32))))))
     end
   | (true,
    (true,
     (true,
      (false,
       (false,
        (D'0,
         (op1'1,
          (op1'0,
           (Vn'3,
            (Vn'2,
             (Vn'1,
              (Vn'0,
               (Vd'3,
                (Vd'2,
                 (Vd'1,
                  (Vd'0,
                   (true,
                    (false,
                     (true,
                      (sz'0,
                       (N'0,
                        (op2'0,(M'0,(false,(Vm'3,(Vm'2,(Vm'1,Vm'0))))))))))))))))))))))))))) =>
     let
       val Vm = BitsN.fromBitstring([Vm'3,Vm'2,Vm'1,Vm'0],4)
       val M = BitsN.fromBitstring([M'0],1)
       val op2 = BitsN.fromBitstring([op2'0],1)
       val N = BitsN.fromBitstring([N'0],1)
       val Vd = BitsN.fromBitstring([Vd'3,Vd'2,Vd'1,Vd'0],4)
       val Vn = BitsN.fromBitstring([Vn'3,Vn'2,Vn'1,Vn'0],4)
       val D = BitsN.fromBitstring([D'0],1)
       val dp_operation =
         (BitsN.fromBitstring([sz'0],1)) = (BitsN.B(0x1,1))
       val (d,(n,m)) =
         if dp_operation
           then (BitsN.@@(D,Vd),(BitsN.@@(N,Vn),BitsN.@@(M,Vm)))
         else (BitsN.@@(Vd,D),(BitsN.@@(Vn,N),BitsN.@@(Vm,M)))
       val typ =
         if op2 = (BitsN.B(0x1,1))
           then VFPNegMul_VNMLA
         else VFPNegMul_VNMLS
     in
       (not((!VFPExtension) = NoVFP),
        VFP(case BitsN.fromBitstring([op1'1,op1'0],2) of
               BitsN.B(0x0,_) =>
                 vmla_vmls
                   (dp_operation,(op2 = (BitsN.B(0x0,1)),(d,(n,m))))
             | BitsN.B(0x1,_) => vneg_mul(dp_operation,(typ,(d,(n,m))))
             | BitsN.B(0x2,_) =>
               if op2 = (BitsN.B(0x1,1))
                 then vneg_mul(dp_operation,(VFPNegMul_VNMUL,(d,(n,m))))
               else vmul(dp_operation,(d,(n,m)))
             | BitsN.B(0x3,_) =>
               if op2 = (BitsN.B(0x1,1))
                 then vsub(dp_operation,(d,(n,m)))
               else vadd(dp_operation,(d,(n,m)))
             | _ => raise General.Bind))
     end
   | (true,
    (true,
     (true,
      (false,
       (true,
        (D'0,
         (false,
          (false,
           (Vn'3,
            (Vn'2,
             (Vn'1,
              (Vn'0,
               (Vd'3,
                (Vd'2,
                 (Vd'1,
                  (Vd'0,
                   (true,
                    (false,
                     (true,
                      (sz'0,
                       (N'0,
                        (false,(M'0,(false,(Vm'3,(Vm'2,(Vm'1,Vm'0))))))))))))))))))))))))))) =>
     let
       val Vm = BitsN.fromBitstring([Vm'3,Vm'2,Vm'1,Vm'0],4)
       val M = BitsN.fromBitstring([M'0],1)
       val N = BitsN.fromBitstring([N'0],1)
       val Vd = BitsN.fromBitstring([Vd'3,Vd'2,Vd'1,Vd'0],4)
       val Vn = BitsN.fromBitstring([Vn'3,Vn'2,Vn'1,Vn'0],4)
       val D = BitsN.fromBitstring([D'0],1)
       val dp_operation =
         (BitsN.fromBitstring([sz'0],1)) = (BitsN.B(0x1,1))
       val (d,(n,m)) =
         if dp_operation
           then (BitsN.@@(D,Vd),(BitsN.@@(N,Vn),BitsN.@@(M,Vm)))
         else (BitsN.@@(Vd,D),(BitsN.@@(Vn,N),BitsN.@@(Vm,M)))
     in
       (not((!VFPExtension) = NoVFP),VFP(vdiv(dp_operation,(d,(n,m)))))
     end
   | (true,
    (true,
     (true,
      (false,
       (true,
        (D'0,
         (false,
          (true,
           (Vn'3,
            (Vn'2,
             (Vn'1,
              (Vn'0,
               (Vd'3,
                (Vd'2,
                 (Vd'1,
                  (Vd'0,
                   (true,
                    (false,
                     (true,
                      (sz'0,
                       (N'0,(op'0,(M'0,(false,(Vm'3,(Vm'2,(Vm'1,Vm'0))))))))))))))))))))))))))) =>
     let
       val Vm = BitsN.fromBitstring([Vm'3,Vm'2,Vm'1,Vm'0],4)
       val M = BitsN.fromBitstring([M'0],1)
       val N = BitsN.fromBitstring([N'0],1)
       val Vd = BitsN.fromBitstring([Vd'3,Vd'2,Vd'1,Vd'0],4)
       val Vn = BitsN.fromBitstring([Vn'3,Vn'2,Vn'1,Vn'0],4)
       val D = BitsN.fromBitstring([D'0],1)
       val dp_operation =
         (BitsN.fromBitstring([sz'0],1)) = (BitsN.B(0x1,1))
       val add = (BitsN.fromBitstring([op'0],1)) = (BitsN.B(0x0,1))
       val (d,(n,m)) =
         if dp_operation
           then (BitsN.@@(D,Vd),(BitsN.@@(N,Vn),BitsN.@@(M,Vm)))
         else (BitsN.@@(Vd,D),(BitsN.@@(Vn,N),BitsN.@@(Vm,M)))
     in
       ((!VFPExtension) = VFPv4,
        VFP(vfnma_vfnms(dp_operation,(add,(d,(n,m))))))
     end
   | (true,
    (true,
     (true,
      (false,
       (true,
        (D'0,
         (true,
          (false,
           (Vn'3,
            (Vn'2,
             (Vn'1,
              (Vn'0,
               (Vd'3,
                (Vd'2,
                 (Vd'1,
                  (Vd'0,
                   (true,
                    (false,
                     (true,
                      (sz'0,
                       (N'0,(op'0,(M'0,(false,(Vm'3,(Vm'2,(Vm'1,Vm'0))))))))))))))))))))))))))) =>
     let
       val Vm = BitsN.fromBitstring([Vm'3,Vm'2,Vm'1,Vm'0],4)
       val M = BitsN.fromBitstring([M'0],1)
       val N = BitsN.fromBitstring([N'0],1)
       val Vd = BitsN.fromBitstring([Vd'3,Vd'2,Vd'1,Vd'0],4)
       val Vn = BitsN.fromBitstring([Vn'3,Vn'2,Vn'1,Vn'0],4)
       val D = BitsN.fromBitstring([D'0],1)
       val dp_operation =
         (BitsN.fromBitstring([sz'0],1)) = (BitsN.B(0x1,1))
       val add = (BitsN.fromBitstring([op'0],1)) = (BitsN.B(0x0,1))
       val (d,(n,m)) =
         if dp_operation
           then (BitsN.@@(D,Vd),(BitsN.@@(N,Vn),BitsN.@@(M,Vm)))
         else (BitsN.@@(Vd,D),(BitsN.@@(Vn,N),BitsN.@@(Vm,M)))
     in
       ((!VFPExtension) = VFPv4,
        VFP(vfma_vfms(dp_operation,(add,(d,(n,m))))))
     end
   | (true,
    (true,
     (true,
      (false,
       (true,
        (D'0,
         (true,
          (true,
           (false,
            (false,
             (false,
              (false,
               (Vd'3,
                (Vd'2,
                 (Vd'1,
                  (Vd'0,
                   (true,
                    (false,
                     (true,
                      (sz'0,
                       (false,
                        (true,(M'0,(false,(Vm'3,(Vm'2,(Vm'1,Vm'0))))))))))))))))))))))))))) =>
     let
       val Vm = BitsN.fromBitstring([Vm'3,Vm'2,Vm'1,Vm'0],4)
       val M = BitsN.fromBitstring([M'0],1)
       val Vd = BitsN.fromBitstring([Vd'3,Vd'2,Vd'1,Vd'0],4)
       val D = BitsN.fromBitstring([D'0],1)
       val single_register =
         (BitsN.fromBitstring([sz'0],1)) = (BitsN.B(0x0,1))
       val (d,m) =
         if single_register
           then (BitsN.@@(Vd,D),BitsN.@@(Vm,M))
         else (BitsN.@@(D,Vd),BitsN.@@(M,Vm))
     in
       (not((!VFPExtension) = NoVFP),VFP(vmov(single_register,(d,m))))
     end
   | (true,
    (true,
     (true,
      (false,
       (true,
        (D'0,
         (true,
          (true,
           (false,
            (false,
             (false,
              (false,
               (Vd'3,
                (Vd'2,
                 (Vd'1,
                  (Vd'0,
                   (true,
                    (false,
                     (true,
                      (sz'0,
                       (true,
                        (true,(M'0,(false,(Vm'3,(Vm'2,(Vm'1,Vm'0))))))))))))))))))))))))))) =>
     let
       val Vm = BitsN.fromBitstring([Vm'3,Vm'2,Vm'1,Vm'0],4)
       val M = BitsN.fromBitstring([M'0],1)
       val Vd = BitsN.fromBitstring([Vd'3,Vd'2,Vd'1,Vd'0],4)
       val D = BitsN.fromBitstring([D'0],1)
       val dp_operation =
         (BitsN.fromBitstring([sz'0],1)) = (BitsN.B(0x1,1))
       val (d,m) =
         if dp_operation
           then (BitsN.@@(D,Vd),BitsN.@@(M,Vm))
         else (BitsN.@@(Vd,D),BitsN.@@(Vm,M))
     in
       (not((!VFPExtension) = NoVFP),VFP(vabs(dp_operation,(d,m))))
     end
   | (true,
    (true,
     (true,
      (false,
       (true,
        (D'0,
         (true,
          (true,
           (false,
            (false,
             (false,
              (true,
               (Vd'3,
                (Vd'2,
                 (Vd'1,
                  (Vd'0,
                   (true,
                    (false,
                     (true,
                      (sz'0,
                       (false,
                        (true,(M'0,(false,(Vm'3,(Vm'2,(Vm'1,Vm'0))))))))))))))))))))))))))) =>
     let
       val Vm = BitsN.fromBitstring([Vm'3,Vm'2,Vm'1,Vm'0],4)
       val M = BitsN.fromBitstring([M'0],1)
       val Vd = BitsN.fromBitstring([Vd'3,Vd'2,Vd'1,Vd'0],4)
       val D = BitsN.fromBitstring([D'0],1)
       val dp_operation =
         (BitsN.fromBitstring([sz'0],1)) = (BitsN.B(0x1,1))
       val (d,m) =
         if dp_operation
           then (BitsN.@@(D,Vd),BitsN.@@(M,Vm))
         else (BitsN.@@(Vd,D),BitsN.@@(Vm,M))
     in
       (not((!VFPExtension) = NoVFP),VFP(vneg(dp_operation,(d,m))))
     end
   | (true,
    (true,
     (true,
      (false,
       (true,
        (D'0,
         (true,
          (true,
           (false,
            (false,
             (false,
              (true,
               (Vd'3,
                (Vd'2,
                 (Vd'1,
                  (Vd'0,
                   (true,
                    (false,
                     (true,
                      (sz'0,
                       (true,
                        (true,(M'0,(false,(Vm'3,(Vm'2,(Vm'1,Vm'0))))))))))))))))))))))))))) =>
     let
       val Vm = BitsN.fromBitstring([Vm'3,Vm'2,Vm'1,Vm'0],4)
       val M = BitsN.fromBitstring([M'0],1)
       val Vd = BitsN.fromBitstring([Vd'3,Vd'2,Vd'1,Vd'0],4)
       val D = BitsN.fromBitstring([D'0],1)
       val dp_operation =
         (BitsN.fromBitstring([sz'0],1)) = (BitsN.B(0x1,1))
       val (d,m) =
         if dp_operation
           then (BitsN.@@(D,Vd),BitsN.@@(M,Vm))
         else (BitsN.@@(Vd,D),BitsN.@@(Vm,M))
     in
       (not((!VFPExtension) = NoVFP),VFP(vsqrt(dp_operation,(d,m))))
     end
   | (true,
    (true,
     (true,
      (false,
       (true,
        (D'0,
         (true,
          (true,
           (false,
            (true,
             (false,
              (false,
               (Vd'3,
                (Vd'2,
                 (Vd'1,
                  (Vd'0,
                   (true,
                    (false,
                     (true,
                      (sz'0,
                       (E'0,(true,(M'0,(false,(Vm'3,(Vm'2,(Vm'1,Vm'0))))))))))))))))))))))))))) =>
     let
       val Vm = BitsN.fromBitstring([Vm'3,Vm'2,Vm'1,Vm'0],4)
       val M = BitsN.fromBitstring([M'0],1)
       val Vd = BitsN.fromBitstring([Vd'3,Vd'2,Vd'1,Vd'0],4)
       val D = BitsN.fromBitstring([D'0],1)
     in
       if (BitsN.fromBitstring([E'0],1)) = (BitsN.B(0x1,1))
         then let
                val dp_operation =
                  (BitsN.fromBitstring([sz'0],1)) = (BitsN.B(0x1,1))
                val (d,m) =
                  if dp_operation
                    then (BitsN.@@(D,Vd),BitsN.@@(M,Vm))
                  else (BitsN.@@(Vd,D),BitsN.@@(Vm,M))
              in
                (not((!VFPExtension) = NoVFP),
                 VFP(vcmp(dp_operation,(d,Option.SOME m))))
              end
       else (false,Undefined(BitsN.B(0x0,32)))
     end
   | (true,
    (true,
     (true,
      (false,
       (true,
        (D'0,
         (true,
          (true,
           (false,
            (true,
             (false,
              (true,
               (Vd'3,
                (Vd'2,
                 (Vd'1,
                  (Vd'0,
                   (true,(false,(true,(sz'0,(E'0,(true,(_,(false,_)))))))))))))))))))))))) =>
     let
       val Vd = BitsN.fromBitstring([Vd'3,Vd'2,Vd'1,Vd'0],4)
       val D = BitsN.fromBitstring([D'0],1)
     in
       if (BitsN.fromBitstring([E'0],1)) = (BitsN.B(0x1,1))
         then let
                val dp_operation =
                  (BitsN.fromBitstring([sz'0],1)) = (BitsN.B(0x1,1))
                val d =
                  if dp_operation then BitsN.@@(D,Vd) else BitsN.@@(Vd,D)
              in
                (not((!VFPExtension) = NoVFP),
                 VFP(vcmp(dp_operation,(d,NONE))))
              end
       else (false,Undefined(BitsN.B(0x0,32)))
     end
   | (true,
    (true,
     (true,
      (false,
       (true,
        (D'0,
         (true,
          (true,
           (false,
            (true,
             (true,
              (true,
               (Vd'3,
                (Vd'2,
                 (Vd'1,
                  (Vd'0,
                   (true,
                    (false,
                     (true,
                      (sz'0,
                       (true,
                        (true,(M'0,(false,(Vm'3,(Vm'2,(Vm'1,Vm'0))))))))))))))))))))))))))) =>
     let
       val Vm = BitsN.fromBitstring([Vm'3,Vm'2,Vm'1,Vm'0],4)
       val M = BitsN.fromBitstring([M'0],1)
       val Vd = BitsN.fromBitstring([Vd'3,Vd'2,Vd'1,Vd'0],4)
       val D = BitsN.fromBitstring([D'0],1)
       val double_to_single =
         (BitsN.fromBitstring([sz'0],1)) = (BitsN.B(0x1,1))
       val (d,m) =
         if double_to_single
           then (BitsN.@@(Vd,D),BitsN.@@(M,Vm))
         else (BitsN.@@(D,Vd),BitsN.@@(Vm,M))
     in
       (not((!VFPExtension) = NoVFP),
        VFP(vcvt_float(double_to_single,(d,m))))
     end
   | (true,
    (true,
     (true,
      (false,
       (true,
        (D'0,
         (true,
          (true,
           (true,
            (false,
             (false,
              (false,
               (Vd'3,
                (Vd'2,
                 (Vd'1,
                  (Vd'0,
                   (true,
                    (false,
                     (true,
                      (sz'0,
                       (op'0,
                        (true,(M'0,(false,(Vm'3,(Vm'2,(Vm'1,Vm'0))))))))))))))))))))))))))) =>
     let
       val Vd = BitsN.fromBitstring([Vd'3,Vd'2,Vd'1,Vd'0],4)
       val D = BitsN.fromBitstring([D'0],1)
       val unsigned = (BitsN.fromBitstring([op'0],1)) = (BitsN.B(0x0,1))
       val dp_operation =
         (BitsN.fromBitstring([sz'0],1)) = (BitsN.B(0x1,1))
       val m =
         BitsN.@@
           (BitsN.fromBitstring([Vm'3,Vm'2,Vm'1,Vm'0],4),
            BitsN.fromBitstring([M'0],1))
       val d = if dp_operation then BitsN.@@(D,Vd) else BitsN.@@(Vd,D)
     in
       (not((!VFPExtension) = NoVFP),
        VFP(vcvt_from_integer(dp_operation,(unsigned,(d,m)))))
     end
   | (true,
    (true,
     (true,
      (false,
       (true,
        (D'0,
         (true,
          (true,
           (true,
            (true,
             (false,
              (u'0,
               (Vd'3,
                (Vd'2,
                 (Vd'1,
                  (Vd'0,
                   (true,
                    (false,
                     (true,
                      (sz'0,
                       (op'0,
                        (true,(M'0,(false,(Vm'3,(Vm'2,(Vm'1,Vm'0))))))))))))))))))))))))))) =>
     let
       val Vm = BitsN.fromBitstring([Vm'3,Vm'2,Vm'1,Vm'0],4)
       val M = BitsN.fromBitstring([M'0],1)
       val unsigned = (BitsN.fromBitstring([u'0],1)) = (BitsN.B(0x0,1))
       val round_zero = (BitsN.fromBitstring([op'0],1)) = (BitsN.B(0x1,1))
       val dp_operation =
         (BitsN.fromBitstring([sz'0],1)) = (BitsN.B(0x1,1))
       val d =
         BitsN.@@
           (BitsN.fromBitstring([Vd'3,Vd'2,Vd'1,Vd'0],4),
            BitsN.fromBitstring([D'0],1))
       val m = if dp_operation then BitsN.@@(M,Vm) else BitsN.@@(Vm,M)
     in
       (not((!VFPExtension) = NoVFP),
        VFP(vcvt_to_integer(dp_operation,(unsigned,(round_zero,(d,m))))))
     end
   | (true,
    (true,
     (true,
      (false,
       (true,
        (D'0,
         (true,
          (true,
           (imm4H'3,
            (imm4H'2,
             (imm4H'1,
              (imm4H'0,
               (Vd'3,
                (Vd'2,
                 (Vd'1,
                  (Vd'0,
                   (true,
                    (false,
                     (true,
                      (sz'0,
                       (_,
                        (false,
                         (_,(false,(imm4L'3,(imm4L'2,(imm4L'1,imm4L'0))))))))))))))))))))))))))) =>
     let
       val Vd = BitsN.fromBitstring([Vd'3,Vd'2,Vd'1,Vd'0],4)
       val D = BitsN.fromBitstring([D'0],1)
       val single_register =
         (BitsN.fromBitstring([sz'0],1)) = (BitsN.B(0x0,1))
       val imm64 =
         VFPExpandImm
           (BitsN.@@
              (BitsN.fromBitstring([imm4H'3,imm4H'2,imm4H'1,imm4H'0],4),
               BitsN.fromBitstring([imm4L'3,imm4L'2,imm4L'1,imm4L'0],4)),
            single_register)
       val d = if single_register then BitsN.@@(Vd,D) else BitsN.@@(D,Vd)
     in
       (Set.mem((!VFPExtension),[VFPv3,VFPv4]),
        VFP(vmov_imm(single_register,(d,imm64))))
     end
   | (true,
    (true,
     (true,
      (false,
       (false,
        (false,
         (false,
          (op'0,
           (Vn'3,
            (Vn'2,
             (Vn'1,
              (Vn'0,
               (Rt'3,
                (Rt'2,
                 (Rt'1,
                  (Rt'0,
                   (true,(false,(true,(false,(N'0,(_,(_,(true,_)))))))))))))))))))))))) =>
     let
       val Rt = BitsN.fromBitstring([Rt'3,Rt'2,Rt'1,Rt'0],4)
     in
       if Rt = (BitsN.B(0xF,4))
         then raise UNPREDICTABLE ("DecodeVFP: vmov_single")
       else let
              val to_arm_register =
                (BitsN.fromBitstring([op'0],1)) = (BitsN.B(0x1,1))
              val n =
                BitsN.@@
                  (BitsN.fromBitstring([Vn'3,Vn'2,Vn'1,Vn'0],4),
                   BitsN.fromBitstring([N'0],1))
            in
              (not((!VFPExtension) = NoVFP),
               VFP(vmov_single(to_arm_register,(Rt,n))))
            end
     end
   | (true,
    (true,
     (false,
      (false,
       (false,
        (true,
         (false,
          (op'0,
           (Rt2'3,
            (Rt2'2,
             (Rt2'1,
              (Rt2'0,
               (Rt'3,
                (Rt'2,
                 (Rt'1,
                  (Rt'0,
                   (true,
                    (false,
                     (true,
                      (false,
                       (false,
                        (false,(M'0,(true,(Vm'3,(Vm'2,(Vm'1,Vm'0))))))))))))))))))))))))))) =>
     let
       val Rt = BitsN.fromBitstring([Rt'3,Rt'2,Rt'1,Rt'0],4)
       val Rt2 = BitsN.fromBitstring([Rt2'3,Rt2'2,Rt2'1,Rt2'0],4)
       val m =
         BitsN.@@
           (BitsN.fromBitstring([Vm'3,Vm'2,Vm'1,Vm'0],4),
            BitsN.fromBitstring([M'0],1))
       val to_arm_registers =
         (BitsN.fromBitstring([op'0],1)) = (BitsN.B(0x1,1))
     in
       if (Rt = (BitsN.B(0xF,4))) orelse
          ((Rt2 = (BitsN.B(0xF,4))) orelse
           ((m = (BitsN.B(0x1F,5))) orelse
            (to_arm_registers andalso (Rt = Rt2))))
         then raise UNPREDICTABLE ("DecodeVFP: vmov_two_singles")
       else (not((!VFPExtension) = NoVFP),
             VFP(vmov_two_singles(to_arm_registers,(Rt,(Rt2,m)))))
     end
   | (true,
    (true,
     (false,
      (false,
       (false,
        (true,
         (false,
          (op'0,
           (Rt2'3,
            (Rt2'2,
             (Rt2'1,
              (Rt2'0,
               (Rt'3,
                (Rt'2,
                 (Rt'1,
                  (Rt'0,
                   (true,
                    (false,
                     (true,
                      (true,
                       (false,
                        (false,(M'0,(true,(Vm'3,(Vm'2,(Vm'1,Vm'0))))))))))))))))))))))))))) =>
     let
       val Rt = BitsN.fromBitstring([Rt'3,Rt'2,Rt'1,Rt'0],4)
       val Rt2 = BitsN.fromBitstring([Rt2'3,Rt2'2,Rt2'1,Rt2'0],4)
       val m =
         BitsN.@@
           (BitsN.fromBitstring([M'0],1),
            BitsN.fromBitstring([Vm'3,Vm'2,Vm'1,Vm'0],4))
       val to_arm_registers =
         (BitsN.fromBitstring([op'0],1)) = (BitsN.B(0x1,1))
     in
       if (Rt = (BitsN.B(0xF,4))) orelse
          ((Rt2 = (BitsN.B(0xF,4))) orelse
           (to_arm_registers andalso (Rt = Rt2)))
         then raise UNPREDICTABLE ("DecodeVFP: vmov_double")
       else (not((!VFPExtension) = NoVFP),
             VFP(vmov_double(to_arm_registers,(Rt,(Rt2,m)))))
     end
   | (true,
    (true,
     (true,
      (false,
       (true,
        (true,
         (true,
          (L'0,
           (false,
            (false,
             (false,
              (true,
               (Rt'3,
                (Rt'2,
                 (Rt'1,
                  (Rt'0,(true,(false,(true,(false,(_,(_,(_,(true,_)))))))))))))))))))))))) =>
     let
       val Rt = BitsN.fromBitstring([Rt'3,Rt'2,Rt'1,Rt'0],4)
     in
       if (BitsN.fromBitstring([L'0],1)) = (BitsN.B(0x1,1))
         then (not((!VFPExtension) = NoVFP),VFP(vmrs Rt))
       else if Rt = (BitsN.B(0xF,4))
         then raise UNPREDICTABLE ("DecodeVFP: msr")
       else (not((!VFPExtension) = NoVFP),VFP(vmsr Rt))
     end
   | _ => (false,Undefined(BitsN.B(0x0,32)));

fun DecodeARM w =
  let
    val mc = ARM w
    val cond = BitsN.bits(31,28) w
  in
    if cond = (BitsN.B(0xF,4))
      then case boolify'28(BitsN.bits(27,0) w) of
              (false,
               (false,
                (false,
                 (true,
                  (false,
                   (false,
                    (false,
                     (false,
                      (_,
                       (_,
                        (_,
                         (true,
                          (_,
                           (_,
                            (_,
                             (_,
                              (_,
                               (_,
                                (E'0,(_,(false,(false,(false,(false,_)))))))))))))))))))))))) =>
                (if Do(BitsN.B(0xE,4),Nat.>=(ArchVersion (),6))
                   then System
                          (Setend
                             ((BitsN.fromBitstring([E'0],1)) =
                              (BitsN.B(0x1,1))))
                 else Skip ())
            | (false,
             (false,
              (false,
               (true,
                (false,
                 (false,
                  (false,
                   (false,
                    (imod'1,
                     (imod'0,
                      (M'0,
                       (false,
                        (_,
                         (_,
                          (_,
                           (_,
                            (_,
                             (_,
                              (_,
                               (A'0,
                                (I'0,
                                 (F'0,
                                  (false,
                                   (mode'4,
                                    (mode'3,(mode'2,(mode'1,mode'0))))))))))))))))))))))))))) =>
              let
                val mode =
                  BitsN.fromBitstring
                    ([mode'4,mode'3,mode'2,mode'1,mode'0],5)
                val F = BitsN.fromBitstring([F'0],1)
                val I = BitsN.fromBitstring([I'0],1)
                val A = BitsN.fromBitstring([A'0],1)
                val M = BitsN.fromBitstring([M'0],1)
                val imod = BitsN.fromBitstring([imod'1,imod'0],2)
              in
                if Do(BitsN.B(0xE,4),Nat.>=(ArchVersion (),6))
                  then ( if ((not(mode = (BitsN.B(0x0,5)))) andalso
                             (M = (BitsN.B(0x0,1)))) orelse
                            (((BitsN.bit(imod,1)) =
                              ((BitsN.concat[A,I,F]) = (BitsN.B(0x0,3)))) orelse
                             (((imod = (BitsN.B(0x0,2))) andalso
                               (M = (BitsN.B(0x0,1)))) orelse
                              (imod = (BitsN.B(0x1,2)))))
                           then DECODE_UNPREDICTABLE
                                  (mc,"ChangeProcessorState")
                         else ()
                       ; let
                           val enable = imod = (BitsN.B(0x2,2))
                           val disable = imod = (BitsN.B(0x3,2))
                           val affectA = A = (BitsN.B(0x1,1))
                           val affectI = I = (BitsN.B(0x1,1))
                           val affectF = F = (BitsN.B(0x1,1))
                           val changemode =
                             if M = (BitsN.B(0x1,1))
                               then Option.SOME mode
                             else NONE
                         in
                           System
                             (ChangeProcessorState
                                (enable,
                                 (disable,
                                  (affectA,(affectI,(affectF,changemode))))))
                         end
                       )
                else Skip ()
              end
            | (false,
             (true,
              (false,
               (false,
                (U'0,
                 (true,
                  (false,
                   (true,
                    (Rn'3,
                     (Rn'2,
                      (Rn'1,
                       (Rn'0,
                        (_,
                         (_,
                          (_,
                           (_,
                            (imm12'11,
                             (imm12'10,
                              (imm12'9,
                               (imm12'8,
                                (imm12'7,
                                 (imm12'6,
                                  (imm12'5,
                                   (imm12'4,
                                    (imm12'3,(imm12'2,(imm12'1,imm12'0))))))))))))))))))))))))))) =>
              (if Do(BitsN.B(0xE,4),Nat.>=(ArchVersion (),7))
                 then let
                        val add =
                          (BitsN.fromBitstring([U'0],1)) =
                          (BitsN.B(0x1,1))
                        val imm32 =
                          BitsN.zeroExtend 32
                            (BitsN.fromBitstring
                               ([imm12'11,imm12'10,imm12'9,imm12'8,
                                 imm12'7,imm12'6,imm12'5,imm12'4,imm12'3,
                                 imm12'2,imm12'1,imm12'0],12))
                      in
                        Hint
                          (PreloadInstruction
                             (add,
                              (BitsN.fromBitstring
                                 ([Rn'3,Rn'2,Rn'1,Rn'0],4),
                               immediate_form1 imm32)))
                      end
               else Skip ())
            | (false,
             (true,
              (true,
               (false,
                (U'0,
                 (true,
                  (false,
                   (true,
                    (Rn'3,
                     (Rn'2,
                      (Rn'1,
                       (Rn'0,
                        (_,
                         (_,
                          (_,
                           (_,
                            (imm5'4,
                             (imm5'3,
                              (imm5'2,
                               (imm5'1,
                                (imm5'0,
                                 (typ'1,
                                  (typ'0,(false,(Rm'3,(Rm'2,(Rm'1,Rm'0))))))))))))))))))))))))))) =>
              let
                val Rm = BitsN.fromBitstring([Rm'3,Rm'2,Rm'1,Rm'0],4)
              in
                if Do(BitsN.B(0xE,4),Nat.>=(ArchVersion (),7))
                  then ( if Rm = (BitsN.B(0xF,4))
                           then DECODE_UNPREDICTABLE
                                  (mc,"PreloadInstruction (register)")
                         else ()
                       ; let
                           val add =
                             (BitsN.fromBitstring([U'0],1)) =
                             (BitsN.B(0x1,1))
                           val (shift_t,shift_n) =
                             DecodeImmShift
                               (BitsN.fromBitstring([typ'1,typ'0],2),
                                BitsN.fromBitstring
                                  ([imm5'4,imm5'3,imm5'2,imm5'1,imm5'0],5))
                           val m = register_form1(Rm,(shift_t,shift_n))
                         in
                           Hint
                             (PreloadInstruction
                                (add,
                                 (BitsN.fromBitstring
                                    ([Rn'3,Rn'2,Rn'1,Rn'0],4),m)))
                         end
                       )
                else Skip ()
              end
            | (false,
             (true,
              (false,
               (true,
                (false,
                 (true,
                  (true,
                   (true,
                    (_,
                     (_,
                      (_,
                       (_,
                        (_,
                         (_,
                          (_,
                           (_,
                            (_,
                             (_,(_,(_,(false,(false,(false,(true,_)))))))))))))))))))))))) =>
              (if Do(BitsN.B(0xE,4),
                     Set.mem((!Architecture),[ARMv6K,ARMv7_A,ARMv7_R]))
                 then ClearExclusive
               else Skip ())
            | (false,
             (true,
              (false,
               (true,
                (false,
                 (true,
                  (true,
                   (true,
                    (true,
                     (true,
                      (true,
                       (true,
                        (true,
                         (true,
                          (true,
                           (true,
                            (false,
                             (false,
                              (false,
                               (false,
                                (false,
                                 (true,
                                  (false,
                                   (false,
                                    (option'3,
                                     (option'2,(option'1,option'0))))))))))))))))))))))))))) =>
              (if Do(BitsN.B(0xE,4),Nat.>=(ArchVersion (),7))
                 then Hint
                        (DataSynchronizationBarrier
                           (BitsN.fromBitstring
                              ([option'3,option'2,option'1,option'0],4)))
               else Skip ())
            | (false,
             (true,
              (false,
               (true,
                (false,
                 (true,
                  (true,
                   (true,
                    (_,
                     (_,
                      (_,
                       (_,
                        (_,
                         (_,
                          (_,
                           (_,
                            (_,
                             (_,
                              (_,
                               (_,
                                (false,
                                 (true,
                                  (false,
                                   (true,
                                    (option'3,
                                     (option'2,(option'1,option'0))))))))))))))))))))))))))) =>
              (if Do(BitsN.B(0xE,4),Nat.>=(ArchVersion (),7))
                 then Hint
                        (DataMemoryBarrier
                           (BitsN.fromBitstring
                              ([option'3,option'2,option'1,option'0],4)))
               else Skip ())
            | (false,
             (true,
              (false,
               (true,
                (false,
                 (true,
                  (true,
                   (true,
                    (_,
                     (_,
                      (_,
                       (_,
                        (_,
                         (_,
                          (_,
                           (_,
                            (_,
                             (_,
                              (_,
                               (_,
                                (false,
                                 (true,
                                  (true,
                                   (false,
                                    (option'3,
                                     (option'2,(option'1,option'0))))))))))))))))))))))))))) =>
              (if Do(BitsN.B(0xE,4),Nat.>=(ArchVersion (),7))
                 then Hint
                        (InstructionSynchronizationBarrier
                           (BitsN.fromBitstring
                              ([option'3,option'2,option'1,option'0],4)))
               else Skip ())
            | (false,
             (true,
              (false,
               (true,
                (U'0,
                 (_,
                  (false,
                   (true,
                    (true,
                     (true,
                      (true,
                       (true,
                        (_,
                         (_,
                          (_,
                           (_,
                            (imm12'11,
                             (imm12'10,
                              (imm12'9,
                               (imm12'8,
                                (imm12'7,
                                 (imm12'6,
                                  (imm12'5,
                                   (imm12'4,
                                    (imm12'3,(imm12'2,(imm12'1,imm12'0))))))))))))))))))))))))))) =>
              (if Do(BitsN.B(0xE,4),HaveDSPSupport ())
                 then let
                        val add =
                          (BitsN.fromBitstring([U'0],1)) =
                          (BitsN.B(0x1,1))
                        val imm32 =
                          BitsN.zeroExtend 32
                            (BitsN.fromBitstring
                               ([imm12'11,imm12'10,imm12'9,imm12'8,
                                 imm12'7,imm12'6,imm12'5,imm12'4,imm12'3,
                                 imm12'2,imm12'1,imm12'0],12))
                      in
                        Hint(PreloadDataLiteral(add,imm32))
                      end
               else Skip ())
            | (false,
             (true,
              (false,
               (true,
                (U'0,
                 (R'0,
                  (false,
                   (true,
                    (Rn'3,
                     (Rn'2,
                      (Rn'1,
                       (Rn'0,
                        (_,
                         (_,
                          (_,
                           (_,
                            (imm12'11,
                             (imm12'10,
                              (imm12'9,
                               (imm12'8,
                                (imm12'7,
                                 (imm12'6,
                                  (imm12'5,
                                   (imm12'4,
                                    (imm12'3,(imm12'2,(imm12'1,imm12'0))))))))))))))))))))))))))) =>
              let
                val R = BitsN.fromBitstring([R'0],1)
              in
                if Do(BitsN.B(0xE,4),
                      ((R = (BitsN.B(0x1,1))) andalso
                       ((Nat.>=(ArchVersion (),7)) andalso
                        (Set.mem(Extension_Multiprocessing,(!Extensions))))) orelse
                      ((R = (BitsN.B(0x0,1))) andalso (HaveDSPSupport ())))
                  then let
                         val add =
                           (BitsN.fromBitstring([U'0],1)) =
                           (BitsN.B(0x1,1))
                         val is_pldw = R = (BitsN.B(0x0,1))
                         val imm32 =
                           BitsN.zeroExtend 32
                             (BitsN.fromBitstring
                                ([imm12'11,imm12'10,imm12'9,imm12'8,
                                  imm12'7,imm12'6,imm12'5,imm12'4,imm12'3,
                                  imm12'2,imm12'1,imm12'0],12))
                       in
                         Hint
                           (PreloadData
                              (add,
                               (is_pldw,
                                (BitsN.fromBitstring
                                   ([Rn'3,Rn'2,Rn'1,Rn'0],4),
                                 immediate_form1 imm32))))
                       end
                else Skip ()
              end
            | (false,
             (true,
              (true,
               (true,
                (U'0,
                 (R'0,
                  (false,
                   (true,
                    (Rn'3,
                     (Rn'2,
                      (Rn'1,
                       (Rn'0,
                        (_,
                         (_,
                          (_,
                           (_,
                            (imm5'4,
                             (imm5'3,
                              (imm5'2,
                               (imm5'1,
                                (imm5'0,
                                 (typ'1,
                                  (typ'0,(false,(Rm'3,(Rm'2,(Rm'1,Rm'0))))))))))))))))))))))))))) =>
              let
                val Rm = BitsN.fromBitstring([Rm'3,Rm'2,Rm'1,Rm'0],4)
                val Rn = BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)
                val R = BitsN.fromBitstring([R'0],1)
              in
                if Do(BitsN.B(0xE,4),
                      ((R = (BitsN.B(0x1,1))) andalso
                       ((Nat.>=(ArchVersion (),7)) andalso
                        (Set.mem(Extension_Multiprocessing,(!Extensions))))) orelse
                      ((R = (BitsN.B(0x0,1))) andalso (HaveDSPSupport ())))
                  then let
                         val is_pldw = R = (BitsN.B(0x0,1))
                       in
                         ( if (Rm = (BitsN.B(0xF,4))) orelse
                              ((Rn = (BitsN.B(0xF,4))) andalso is_pldw)
                             then DECODE_UNPREDICTABLE
                                    (mc,"PreloadData (register)")
                           else ()
                         ; let
                             val add =
                               (BitsN.fromBitstring([U'0],1)) =
                               (BitsN.B(0x1,1))
                             val (shift_t,shift_n) =
                               DecodeImmShift
                                 (BitsN.fromBitstring([typ'1,typ'0],2),
                                  BitsN.fromBitstring
                                    ([imm5'4,imm5'3,imm5'2,imm5'1,imm5'0],
                                     5))
                             val m = register_form1(Rm,(shift_t,shift_n))
                           in
                             Hint(PreloadData(add,(is_pldw,(Rn,m))))
                           end
                         )
                       end
                else Skip ()
              end
            | (true,
             (false,
              (false,
               (P'0,
                (U'0,
                 (true,
                  (W'0,
                   (false,
                    (_,
                     (_,
                      (_,
                       (_,
                        (_,
                         (_,
                          (_,
                           (_,
                            (_,
                             (_,
                              (_,
                               (_,
                                (_,
                                 (_,
                                  (_,
                                   (mode'4,
                                    (mode'3,(mode'2,(mode'1,mode'0))))))))))))))))))))))))))) =>
              let
                val U = BitsN.fromBitstring([U'0],1)
              in
                if Do(BitsN.B(0xE,4),Nat.>=(ArchVersion (),6))
                  then let
                         val wback =
                           (BitsN.fromBitstring([W'0],1)) =
                           (BitsN.B(0x1,1))
                         val increment = U = (BitsN.B(0x1,1))
                         val wordhigher =
                           (BitsN.fromBitstring([P'0],1)) = U
                       in
                         System
                           (StoreReturnState
                              (increment,
                               (wordhigher,
                                (wback,
                                 BitsN.fromBitstring
                                   ([mode'4,mode'3,mode'2,mode'1,mode'0],5)))))
                       end
                else Skip ()
              end
            | (true,
             (false,
              (false,
               (P'0,
                (U'0,(false,(W'0,(true,(Rn'3,(Rn'2,(Rn'1,(Rn'0,_)))))))))))) =>
              let
                val Rn = BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)
                val U = BitsN.fromBitstring([U'0],1)
              in
                if Do(BitsN.B(0xE,4),Nat.>=(ArchVersion (),6))
                  then ( if Rn = (BitsN.B(0xF,4))
                           then DECODE_UNPREDICTABLE
                                  (mc,"ReturnFromException")
                         else ()
                       ; let
                           val wback =
                             (BitsN.fromBitstring([W'0],1)) =
                             (BitsN.B(0x1,1))
                           val increment = U = (BitsN.B(0x1,1))
                           val wordhigher =
                             (BitsN.fromBitstring([P'0],1)) = U
                         in
                           System
                             (ReturnFromException
                                (increment,(wordhigher,(wback,Rn))))
                         end
                       )
                else Skip ()
              end
            | (true,
             (false,
              (true,
               (H'0,
                (imm24'23,
                 (imm24'22,
                  (imm24'21,
                   (imm24'20,
                    (imm24'19,
                     (imm24'18,
                      (imm24'17,
                       (imm24'16,
                        (imm24'15,
                         (imm24'14,
                          (imm24'13,
                           (imm24'12,
                            (imm24'11,
                             (imm24'10,
                              (imm24'9,
                               (imm24'8,
                                (imm24'7,
                                 (imm24'6,
                                  (imm24'5,
                                   (imm24'4,
                                    (imm24'3,(imm24'2,(imm24'1,imm24'0))))))))))))))))))))))))))) =>
              (if Do(BitsN.B(0xE,4),Nat.>=(ArchVersion (),5))
                 then let
                        val imm32 =
                          BitsN.signExtend 32
                            (BitsN.concat
                               [BitsN.fromBitstring
                                  ([imm24'23,imm24'22,imm24'21,imm24'20,
                                    imm24'19,imm24'18,imm24'17,imm24'16,
                                    imm24'15,imm24'14,imm24'13,imm24'12,
                                    imm24'11,imm24'10,imm24'9,imm24'8,
                                    imm24'7,imm24'6,imm24'5,imm24'4,
                                    imm24'3,imm24'2,imm24'1,imm24'0],24),
                                BitsN.fromBitstring([H'0],1),
                                BitsN.B(0x0,1)])
                        val targetInstrSet = InstrSet_Thumb
                      in
                        Branch
                          (BranchLinkExchangeImmediate
                             (targetInstrSet,imm32))
                      end
               else Skip ())
            | _ =>
              (if Nat.>=(ArchVersion (),5)
                 then Undefined(BitsN.B(0x0,32))
               else ( DECODE_UNPREDICTABLE(mc,"")
                    ; Branch(BranchExchange(BitsN.B(0x0,4)))
                    ))
    else case boolify'28(BitsN.bits(27,0) w) of
            (false,
             (true,
              (true,
               (true,
                (true,
                 (true,
                  (true,
                   (true,
                    (imm12'11,
                     (imm12'10,
                      (imm12'9,
                       (imm12'8,
                        (imm12'7,
                         (imm12'6,
                          (imm12'5,
                           (imm12'4,
                            (imm12'3,
                             (imm12'2,
                              (imm12'1,
                               (imm12'0,
                                (true,
                                 (true,
                                  (true,
                                   (true,(imm4'3,(imm4'2,(imm4'1,imm4'0))))))))))))))))))))))))))) =>
              let
                val imm32 =
                  BitsN.zeroExtend 32
                    (BitsN.@@
                       (BitsN.fromBitstring
                          ([imm12'11,imm12'10,imm12'9,imm12'8,imm12'7,
                            imm12'6,imm12'5,imm12'4,imm12'3,imm12'2,
                            imm12'1,imm12'0],12),
                        BitsN.fromBitstring
                          ([imm4'3,imm4'2,imm4'1,imm4'0],4)))
              in
                ( CurrentCondition := cond
                ; if ConditionPassed ()
                    then Undefined imm32
                  else NoOperation
                )
              end
          | (false,
           (false,
            (false,
             (true,
              (false,
               (R'0,
                (false,
                 (false,
                  (m1'3,
                   (m1'2,
                    (m1'1,
                     (m1'0,
                      (Rd'3,
                       (Rd'2,
                        (Rd'1,
                         (Rd'0,
                          (_,
                           (_,
                            (true,(m'0,(false,(false,(false,(false,_)))))))))))))))))))))))) =>
            let
              val Rd = BitsN.fromBitstring([Rd'3,Rd'2,Rd'1,Rd'0],4)
            in
              if Do(cond,HaveVirtExt ())
                then ( if Rd = (BitsN.B(0xF,4))
                         then DECODE_UNPREDICTABLE
                                (mc,"MoveToRegisterFromBankedOrSpecial")
                       else ()
                     ; let
                         val read_spsr =
                           (BitsN.fromBitstring([R'0],1)) =
                           (BitsN.B(0x1,1))
                         val SYSm =
                           BitsN.@@
                             (BitsN.fromBitstring([m'0],1),
                              BitsN.fromBitstring([m1'3,m1'2,m1'1,m1'0],4))
                       in
                         System
                           (MoveToRegisterFromBankedOrSpecial
                              (read_spsr,(SYSm,Rd)))
                       end
                     )
              else Skip ()
            end
          | (false,
           (false,
            (false,
             (true,
              (false,
               (R'0,
                (false,
                 (false,
                  (_,
                   (_,
                    (_,
                     (_,
                      (Rd'3,
                       (Rd'2,
                        (Rd'1,
                         (Rd'0,
                          (_,
                           (_,
                            (false,(_,(false,(false,(false,(false,_)))))))))))))))))))))))) =>
            let
              val Rd = BitsN.fromBitstring([Rd'3,Rd'2,Rd'1,Rd'0],4)
            in
              if Do(cond,true)
                then ( if Rd = (BitsN.B(0xF,4))
                         then DECODE_UNPREDICTABLE
                                (mc,"MoveToRegisterFromSpecial")
                       else ()
                     ; let
                         val read_spsr =
                           (BitsN.fromBitstring([R'0],1)) =
                           (BitsN.B(0x1,1))
                       in
                         System(MoveToRegisterFromSpecial(read_spsr,Rd))
                       end
                     )
              else Skip ()
            end
          | (false,
           (false,
            (false,
             (true,
              (false,
               (R'0,
                (true,
                 (false,
                  (m1'3,
                   (m1'2,
                    (m1'1,
                     (m1'0,
                      (_,
                       (_,
                        (_,
                         (_,
                          (_,
                           (_,
                            (true,
                             (m'0,
                              (false,
                               (false,
                                (false,(false,(Rn'3,(Rn'2,(Rn'1,Rn'0))))))))))))))))))))))))))) =>
            let
              val Rn = BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)
            in
              if Do(cond,HaveVirtExt ())
                then ( if Set.mem(Rn,[BitsN.B(0xD,4),BitsN.B(0xF,4)])
                         then DECODE_UNPREDICTABLE
                                (mc,"MoveToBankedOrSpecialRegister")
                       else ()
                     ; let
                         val write_spsr =
                           (BitsN.fromBitstring([R'0],1)) =
                           (BitsN.B(0x1,1))
                         val SYSm =
                           BitsN.@@
                             (BitsN.fromBitstring([m'0],1),
                              BitsN.fromBitstring([m1'3,m1'2,m1'1,m1'0],4))
                       in
                         System
                           (MoveToBankedOrSpecialRegister
                              (write_spsr,(SYSm,Rn)))
                       end
                     )
              else Skip ()
            end
          | (false,
           (false,
            (false,
             (true,
              (false,
               (R'0,
                (true,
                 (false,
                  (mask'3,
                   (mask'2,
                    (mask'1,
                     (mask'0,
                      (_,
                       (_,
                        (_,
                         (_,
                          (_,
                           (_,
                            (false,
                             (_,
                              (false,
                               (false,
                                (false,(false,(Rn'3,(Rn'2,(Rn'1,Rn'0))))))))))))))))))))))))))) =>
            let
              val Rn = BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)
              val mask =
                BitsN.fromBitstring([mask'3,mask'2,mask'1,mask'0],4)
            in
              if Do(cond,true)
                then ( if (Rn = (BitsN.B(0xF,4))) orelse
                          (mask = (BitsN.B(0x0,4)))
                         then DECODE_UNPREDICTABLE
                                (mc,"MoveToSpecialFromRegister")
                       else ()
                     ; let
                         val write_spsr =
                           (BitsN.fromBitstring([R'0],1)) =
                           (BitsN.B(0x1,1))
                       in
                         System
                           (MoveToSpecialFromRegister
                              (write_spsr,(Rn,mask)))
                       end
                     )
              else Skip ()
            end
          | (false,
           (false,
            (false,
             (true,
              (false,
               (false,
                (true,
                 (false,
                  (_,
                   (_,
                    (_,
                     (_,
                      (_,
                       (_,
                        (_,
                         (_,
                          (_,
                           (_,
                            (_,
                             (_,
                              (false,
                               (false,
                                (false,(true,(Rm'3,(Rm'2,(Rm'1,Rm'0))))))))))))))))))))))))))) =>
            (if Do(cond,not((!Architecture) = ARMv4))
               then Branch
                      (BranchExchange
                         (BitsN.fromBitstring([Rm'3,Rm'2,Rm'1,Rm'0],4)))
             else Skip ())
          | (false,
           (false,
            (false,
             (true,
              (false,
               (true,
                (true,
                 (false,
                  (_,
                   (_,
                    (_,
                     (_,
                      (Rd'3,
                       (Rd'2,
                        (Rd'1,
                         (Rd'0,
                          (_,
                           (_,
                            (_,
                             (_,
                              (false,
                               (false,
                                (false,(true,(Rm'3,(Rm'2,(Rm'1,Rm'0))))))))))))))))))))))))))) =>
            let
              val Rm = BitsN.fromBitstring([Rm'3,Rm'2,Rm'1,Rm'0],4)
              val Rd = BitsN.fromBitstring([Rd'3,Rd'2,Rd'1,Rd'0],4)
            in
              if Do(cond,Nat.>=(ArchVersion (),5))
                then ( if (Rd = (BitsN.B(0xF,4))) orelse
                          (Rm = (BitsN.B(0xF,4)))
                         then DECODE_UNPREDICTABLE
                                (mc,"CountLeadingZeroes")
                       else ()
                     ; Data(CountLeadingZeroes(Rd,Rm))
                     )
              else Skip ()
            end
          | (false,
           (false,
            (false,
             (true,
              (false,
               (false,
                (true,
                 (false,
                  (_,
                   (_,
                    (_,
                     (_,
                      (_,
                       (_,
                        (_,
                         (_,
                          (_,
                           (_,
                            (_,
                             (_,
                              (false,
                               (false,
                                (true,(true,(Rm'3,(Rm'2,(Rm'1,Rm'0))))))))))))))))))))))))))) =>
            let
              val Rm = BitsN.fromBitstring([Rm'3,Rm'2,Rm'1,Rm'0],4)
            in
              if Do(cond,Nat.>=(ArchVersion (),5))
                then ( if Rm = (BitsN.B(0xF,4))
                         then DECODE_UNPREDICTABLE
                                (mc,"BranchLinkExchangeRegister")
                       else ()
                     ; Branch(BranchLinkExchangeRegister Rm)
                     )
              else Skip ()
            end
          | (false,
           (false,
            (false,
             (true,
              (false,
               (opc'1,
                (opc'0,
                 (false,
                  (Rn'3,
                   (Rn'2,
                    (Rn'1,
                     (Rn'0,
                      (Rd'3,
                       (Rd'2,
                        (Rd'1,
                         (Rd'0,
                          (_,
                           (_,
                            (_,
                             (_,
                              (false,
                               (true,
                                (false,(true,(Rm'3,(Rm'2,(Rm'1,Rm'0))))))))))))))))))))))))))) =>
            let
              val Rm = BitsN.fromBitstring([Rm'3,Rm'2,Rm'1,Rm'0],4)
              val Rd = BitsN.fromBitstring([Rd'3,Rd'2,Rd'1,Rd'0],4)
              val Rn = BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)
            in
              if Do(cond,HaveDSPSupport ())
                then ( if (Rd = (BitsN.B(0xF,4))) orelse
                          ((Rn = (BitsN.B(0xF,4))) orelse
                           (Rm = (BitsN.B(0xF,4))))
                         then DECODE_UNPREDICTABLE
                                (mc,"SaturatingAddSubtract")
                       else ()
                     ; Media
                         (SaturatingAddSubtract
                            (BitsN.fromBitstring([opc'1,opc'0],2),
                             (Rd,(Rm,Rn))))
                     )
              else Skip ()
            end
          | (false,
           (false,
            (false,
             (true,
              (false,
               (false,
                (true,
                 (false,
                  (imm12'11,
                   (imm12'10,
                    (imm12'9,
                     (imm12'8,
                      (imm12'7,
                       (imm12'6,
                        (imm12'5,
                         (imm12'4,
                          (imm12'3,
                           (imm12'2,
                            (imm12'1,
                             (imm12'0,
                              (false,
                               (true,
                                (true,
                                 (true,(imm4'3,(imm4'2,(imm4'1,imm4'0))))))))))))))))))))))))))) =>
            (if Nat.>=(ArchVersion (),5)
               then ( if not(cond = (BitsN.B(0xE,4)))
                        then DECODE_UNPREDICTABLE(mc,"Breakpoint")
                      else ()
                    ; CurrentCondition := cond
                    ; let
                        val imm32 =
                          BitsN.zeroExtend 32
                            (BitsN.@@
                               (BitsN.fromBitstring
                                  ([imm12'11,imm12'10,imm12'9,imm12'8,
                                    imm12'7,imm12'6,imm12'5,imm12'4,
                                    imm12'3,imm12'2,imm12'1,imm12'0],12),
                                BitsN.fromBitstring
                                  ([imm4'3,imm4'2,imm4'1,imm4'0],4)))
                      in
                        Hint(Breakpoint imm32)
                      end
                    )
             else if Do(cond,false)
               then Undefined(BitsN.B(0x0,32))
             else NoOperation)
          | (false,
           (false,
            (false,
             (true,
              (false,
               (true,
                (false,
                 (false,
                  (imm12'11,
                   (imm12'10,
                    (imm12'9,
                     (imm12'8,
                      (imm12'7,
                       (imm12'6,
                        (imm12'5,
                         (imm12'4,
                          (imm12'3,
                           (imm12'2,
                            (imm12'1,
                             (imm12'0,
                              (false,
                               (true,
                                (true,
                                 (true,(imm4'3,(imm4'2,(imm4'1,imm4'0))))))))))))))))))))))))))) =>
            (if Do(cond,HaveVirtExt ())
               then ( if not(cond = (BitsN.B(0xE,4)))
                        then DECODE_UNPREDICTABLE(mc,"HypervisorCall")
                      else ()
                    ; let
                        val imm16 =
                          BitsN.@@
                            (BitsN.fromBitstring
                               ([imm12'11,imm12'10,imm12'9,imm12'8,
                                 imm12'7,imm12'6,imm12'5,imm12'4,imm12'3,
                                 imm12'2,imm12'1,imm12'0],12),
                             BitsN.fromBitstring
                               ([imm4'3,imm4'2,imm4'1,imm4'0],4))
                      in
                        System(HypervisorCall imm16)
                      end
                    )
             else Skip ())
          | (false,
           (false,
            (false,
             (true,
              (false,
               (true,
                (true,
                 (false,
                  (_,
                   (_,
                    (_,
                     (_,
                      (_,
                       (_,
                        (_,
                         (_,
                          (_,
                           (_,
                            (_,
                             (_,
                              (false,
                               (true,
                                (true,
                                 (true,(imm4'3,(imm4'2,(imm4'1,imm4'0))))))))))))))))))))))))))) =>
            (if Do(cond,HaveSecurityExt ())
               then System
                      (SecureMonitorCall
                         (BitsN.fromBitstring
                            ([imm4'3,imm4'2,imm4'1,imm4'0],4)))
             else Skip ())
          | (false,
           (false,
            (false,
             (true,
              (false,
               (false,
                (false,
                 (false,
                  (Rd'3,
                   (Rd'2,
                    (Rd'1,
                     (Rd'0,
                      (Ra'3,
                       (Ra'2,
                        (Ra'1,
                         (Ra'0,
                          (Rm'3,
                           (Rm'2,
                            (Rm'1,
                             (Rm'0,
                              (true,
                               (M'0,
                                (N'0,(false,(Rn'3,(Rn'2,(Rn'1,Rn'0))))))))))))))))))))))))))) =>
            let
              val Rn = BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)
              val Rm = BitsN.fromBitstring([Rm'3,Rm'2,Rm'1,Rm'0],4)
              val Ra = BitsN.fromBitstring([Ra'3,Ra'2,Ra'1,Ra'0],4)
              val Rd = BitsN.fromBitstring([Rd'3,Rd'2,Rd'1,Rd'0],4)
            in
              if Do(cond,HaveDSPSupport ())
                then ( if (Rd = (BitsN.B(0xF,4))) orelse
                          ((Rn = (BitsN.B(0xF,4))) orelse
                           ((Rm = (BitsN.B(0xF,4))) orelse
                            (Ra = (BitsN.B(0xF,4)))))
                         then DECODE_UNPREDICTABLE
                                (mc,"Signed16Multiply32Accumulate")
                       else ()
                     ; let
                         val n_high =
                           (BitsN.fromBitstring([N'0],1)) =
                           (BitsN.B(0x1,1))
                         val m_high =
                           (BitsN.fromBitstring([M'0],1)) =
                           (BitsN.B(0x1,1))
                       in
                         Multiply
                           (Signed16Multiply32Accumulate
                              (m_high,(n_high,(Rd,(Rn,(Rm,Ra))))))
                       end
                     )
              else Skip ()
            end
          | (false,
           (false,
            (false,
             (true,
              (false,
               (false,
                (true,
                 (false,
                  (Rd'3,
                   (Rd'2,
                    (Rd'1,
                     (Rd'0,
                      (Ra'3,
                       (Ra'2,
                        (Ra'1,
                         (Ra'0,
                          (Rm'3,
                           (Rm'2,
                            (Rm'1,
                             (Rm'0,
                              (true,
                               (M'0,
                                (false,(false,(Rn'3,(Rn'2,(Rn'1,Rn'0))))))))))))))))))))))))))) =>
            let
              val Rn = BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)
              val Rm = BitsN.fromBitstring([Rm'3,Rm'2,Rm'1,Rm'0],4)
              val Ra = BitsN.fromBitstring([Ra'3,Ra'2,Ra'1,Ra'0],4)
              val Rd = BitsN.fromBitstring([Rd'3,Rd'2,Rd'1,Rd'0],4)
            in
              if Do(cond,HaveDSPSupport ())
                then ( if (Rd = (BitsN.B(0xF,4))) orelse
                          ((Rn = (BitsN.B(0xF,4))) orelse
                           ((Rm = (BitsN.B(0xF,4))) orelse
                            (Ra = (BitsN.B(0xF,4)))))
                         then DECODE_UNPREDICTABLE
                                (mc,"Signed16x32Multiply32Accumulate")
                       else ()
                     ; let
                         val m_high =
                           (BitsN.fromBitstring([M'0],1)) =
                           (BitsN.B(0x1,1))
                       in
                         Multiply
                           (Signed16x32Multiply32Accumulate
                              (m_high,(Rd,(Rn,(Rm,Ra)))))
                       end
                     )
              else Skip ()
            end
          | (false,
           (false,
            (false,
             (true,
              (false,
               (false,
                (true,
                 (false,
                  (Rd'3,
                   (Rd'2,
                    (Rd'1,
                     (Rd'0,
                      (_,
                       (_,
                        (_,
                         (_,
                          (Rm'3,
                           (Rm'2,
                            (Rm'1,
                             (Rm'0,
                              (true,
                               (M'0,
                                (true,(false,(Rn'3,(Rn'2,(Rn'1,Rn'0))))))))))))))))))))))))))) =>
            let
              val Rn = BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)
              val Rm = BitsN.fromBitstring([Rm'3,Rm'2,Rm'1,Rm'0],4)
              val Rd = BitsN.fromBitstring([Rd'3,Rd'2,Rd'1,Rd'0],4)
            in
              if Do(cond,HaveDSPSupport ())
                then ( if (Rd = (BitsN.B(0xF,4))) orelse
                          ((Rn = (BitsN.B(0xF,4))) orelse
                           (Rm = (BitsN.B(0xF,4))))
                         then DECODE_UNPREDICTABLE
                                (mc,"Signed16x32Multiply32Result")
                       else ()
                     ; let
                         val m_high =
                           (BitsN.fromBitstring([M'0],1)) =
                           (BitsN.B(0x1,1))
                       in
                         Multiply
                           (Signed16x32Multiply32Result
                              (m_high,(Rd,(Rn,Rm))))
                       end
                     )
              else Skip ()
            end
          | (false,
           (false,
            (false,
             (true,
              (false,
               (true,
                (false,
                 (false,
                  (RdHi'3,
                   (RdHi'2,
                    (RdHi'1,
                     (RdHi'0,
                      (RdLo'3,
                       (RdLo'2,
                        (RdLo'1,
                         (RdLo'0,
                          (Rm'3,
                           (Rm'2,
                            (Rm'1,
                             (Rm'0,
                              (true,
                               (M'0,
                                (N'0,(false,(Rn'3,(Rn'2,(Rn'1,Rn'0))))))))))))))))))))))))))) =>
            let
              val Rn = BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)
              val Rm = BitsN.fromBitstring([Rm'3,Rm'2,Rm'1,Rm'0],4)
              val RdLo =
                BitsN.fromBitstring([RdLo'3,RdLo'2,RdLo'1,RdLo'0],4)
              val RdHi =
                BitsN.fromBitstring([RdHi'3,RdHi'2,RdHi'1,RdHi'0],4)
            in
              if Do(cond,HaveDSPSupport ())
                then ( if (RdLo = (BitsN.B(0xF,4))) orelse
                          ((RdHi = (BitsN.B(0xF,4))) orelse
                           ((Rn = (BitsN.B(0xF,4))) orelse
                            (Rm = (BitsN.B(0xF,4)))))
                         then DECODE_UNPREDICTABLE
                                (mc,"Signed16Multiply64Accumulate")
                       else ()
                     ; let
                         val n_high =
                           (BitsN.fromBitstring([N'0],1)) =
                           (BitsN.B(0x1,1))
                         val m_high =
                           (BitsN.fromBitstring([M'0],1)) =
                           (BitsN.B(0x1,1))
                       in
                         Multiply
                           (Signed16Multiply64Accumulate
                              (m_high,(n_high,(RdHi,(RdLo,(Rn,Rm))))))
                       end
                     )
              else Skip ()
            end
          | (false,
           (false,
            (false,
             (true,
              (false,
               (true,
                (true,
                 (false,
                  (Rd'3,
                   (Rd'2,
                    (Rd'1,
                     (Rd'0,
                      (_,
                       (_,
                        (_,
                         (_,
                          (Rm'3,
                           (Rm'2,
                            (Rm'1,
                             (Rm'0,
                              (true,
                               (M'0,
                                (N'0,(false,(Rn'3,(Rn'2,(Rn'1,Rn'0))))))))))))))))))))))))))) =>
            let
              val Rn = BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)
              val Rm = BitsN.fromBitstring([Rm'3,Rm'2,Rm'1,Rm'0],4)
              val Rd = BitsN.fromBitstring([Rd'3,Rd'2,Rd'1,Rd'0],4)
            in
              if Do(cond,HaveDSPSupport ())
                then ( if (Rd = (BitsN.B(0xF,4))) orelse
                          ((Rn = (BitsN.B(0xF,4))) orelse
                           (Rm = (BitsN.B(0xF,4))))
                         then DECODE_UNPREDICTABLE
                                (mc,"Signed16Multiply32Result")
                       else ()
                     ; let
                         val n_high =
                           (BitsN.fromBitstring([N'0],1)) =
                           (BitsN.B(0x1,1))
                         val m_high =
                           (BitsN.fromBitstring([M'0],1)) =
                           (BitsN.B(0x1,1))
                       in
                         Multiply
                           (Signed16Multiply32Result
                              (m_high,(n_high,(Rd,(Rn,Rm)))))
                       end
                     )
              else Skip ()
            end
          | (false,
           (false,
            (false,
             (true,
              (false,
               (true,
                (true,
                 (false,
                  (false,
                   (false,
                    (false,
                     (false,
                      (false,
                       (false,
                        (false,
                         (false,
                          (false,
                           (false,
                            (false,
                             (false,
                              (false,
                               (true,
                                (true,(false,(true,(true,(true,false))))))))))))))))))))))))))) =>
            if Do(cond,HaveVirtExt ())
              then System ExceptionReturn
            else Skip ()
          | (false,
           (false,
            (false,
             (true,
              (false,
               (_,
                (_,
                 (false,
                  (_,(_,(_,(_,(_,(_,(_,(_,(_,(_,(_,(_,(false,_))))))))))))))))))))) =>
            Undefined(BitsN.B(0x0,32))
          | (false,
           (false,
            (false,
             (opc'3,
              (opc'2,
               (opc'1,
                (opc'0,
                 (S'0,
                  (Rn'3,
                   (Rn'2,
                    (Rn'1,
                     (Rn'0,
                      (Rd'3,
                       (Rd'2,
                        (Rd'1,
                         (Rd'0,
                          (imm5'4,
                           (imm5'3,
                            (imm5'2,
                             (imm5'1,
                              (imm5'0,
                               (typ'1,
                                (typ'0,(false,(Rm'3,(Rm'2,(Rm'1,Rm'0))))))))))))))))))))))))))) =>
            let
              val Rm = BitsN.fromBitstring([Rm'3,Rm'2,Rm'1,Rm'0],4)
              val Rd = BitsN.fromBitstring([Rd'3,Rd'2,Rd'1,Rd'0],4)
              val Rn = BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)
              val opc = BitsN.fromBitstring([opc'3,opc'2,opc'1,opc'0],4)
            in
              if Do(cond,true)
                then let
                       val setflags =
                         (BitsN.fromBitstring([S'0],1)) = (BitsN.B(0x1,1))
                       val (shift_t,shift_n) =
                         DecodeImmShift
                           (BitsN.fromBitstring([typ'1,typ'0],2),
                            BitsN.fromBitstring
                              ([imm5'4,imm5'3,imm5'2,imm5'1,imm5'0],5))
                     in
                       if (BitsN.bits(3,2) opc) = (BitsN.B(0x2,2))
                         then Data
                                (TestCompareRegister
                                   (BitsN.bits(1,0) opc,
                                    (Rn,(Rm,(shift_t,shift_n)))))
                       else if Set.mem
                            (opc,[BitsN.B(0xD,4),BitsN.B(0xF,4)])
                         then Data
                                (ShiftImmediate
                                   (BitsN.bit(opc,1),
                                    (setflags,(Rd,(Rm,(shift_t,shift_n))))))
                       else Data
                              (Register
                                 (opc,
                                  (setflags,
                                   (Rd,(Rn,(Rm,(shift_t,shift_n)))))))
                     end
              else Skip ()
            end
          | (false,
           (false,
            (false,
             (opc'3,
              (opc'2,
               (opc'1,
                (opc'0,
                 (S'0,
                  (Rn'3,
                   (Rn'2,
                    (Rn'1,
                     (Rn'0,
                      (Rd'3,
                       (Rd'2,
                        (Rd'1,
                         (Rd'0,
                          (Rs'3,
                           (Rs'2,
                            (Rs'1,
                             (Rs'0,
                              (false,
                               (typ'1,
                                (typ'0,(true,(Rm'3,(Rm'2,(Rm'1,Rm'0))))))))))))))))))))))))))) =>
            let
              val Rm = BitsN.fromBitstring([Rm'3,Rm'2,Rm'1,Rm'0],4)
              val Rs = BitsN.fromBitstring([Rs'3,Rs'2,Rs'1,Rs'0],4)
              val Rd = BitsN.fromBitstring([Rd'3,Rd'2,Rd'1,Rd'0],4)
              val Rn = BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)
              val opc = BitsN.fromBitstring([opc'3,opc'2,opc'1,opc'0],4)
            in
              if Do(cond,true)
                then ( if ((Rd = (BitsN.B(0xF,4))) andalso
                           (not((BitsN.bits(3,2) opc) = (BitsN.B(0x2,2))))) orelse
                          ((Rn = (BitsN.B(0xF,4))) orelse
                           ((Rm = (BitsN.B(0xF,4))) orelse
                            (Rs = (BitsN.B(0xF,4)))))
                         then DECODE_UNPREDICTABLE
                                (mc,"RegisterShiftedRegister")
                       else ()
                     ; let
                         val setflags =
                           (BitsN.fromBitstring([S'0],1)) =
                           (BitsN.B(0x1,1))
                         val shift_t =
                           DecodeRegShift
                             (BitsN.fromBitstring([typ'1,typ'0],2))
                       in
                         if (opc = (BitsN.B(0xD,4))) orelse
                            (opc = (BitsN.B(0xF,4)))
                           then Data
                                  (ShiftRegister
                                     (BitsN.bit(opc,1),
                                      (setflags,(Rd,(Rm,(shift_t,Rs))))))
                         else Data
                                (RegisterShiftedRegister
                                   (opc,
                                    (setflags,(Rd,(Rn,(Rm,(shift_t,Rs)))))))
                       end
                     )
              else Skip ()
            end
          | (false,
           (false,
            (false,
             (false,
              (false,
               (false,
                (A'0,
                 (S'0,
                  (Rd'3,
                   (Rd'2,
                    (Rd'1,
                     (Rd'0,
                      (Ra'3,
                       (Ra'2,
                        (Ra'1,
                         (Ra'0,
                          (Rm'3,
                           (Rm'2,
                            (Rm'1,
                             (Rm'0,
                              (true,
                               (false,
                                (false,(true,(Rn'3,(Rn'2,(Rn'1,Rn'0))))))))))))))))))))))))))) =>
            let
              val Rn = BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)
              val Rm = BitsN.fromBitstring([Rm'3,Rm'2,Rm'1,Rm'0],4)
              val Ra = BitsN.fromBitstring([Ra'3,Ra'2,Ra'1,Ra'0],4)
              val Rd = BitsN.fromBitstring([Rd'3,Rd'2,Rd'1,Rd'0],4)
              val A = BitsN.fromBitstring([A'0],1)
            in
              if Do(cond,true)
                then ( if (Rd = (BitsN.B(0xF,4))) orelse
                          ((Rn = (BitsN.B(0xF,4))) orelse
                           ((Rm = (BitsN.B(0xF,4))) orelse
                            (((A = (BitsN.B(0x1,1))) andalso
                              (Ra = (BitsN.B(0xF,4)))) orelse
                             ((Nat.<(ArchVersion (),6)) andalso (Rd = Rn)))))
                         then DECODE_UNPREDICTABLE(mc,"Multiply")
                       else ()
                     ; let
                         val setflags =
                           (BitsN.fromBitstring([S'0],1)) =
                           (BitsN.B(0x1,1))
                       in
                         if A = (BitsN.B(0x1,1))
                           then Multiply
                                  (MultiplyAccumulate
                                     (setflags,(Rd,(Rn,(Rm,Ra)))))
                         else Multiply(Multiply32(setflags,(Rd,(Rn,Rm))))
                       end
                     )
              else Skip ()
            end
          | (false,
           (false,
            (false,
             (false,
              (false,
               (true,
                (false,
                 (false,
                  (RdHi'3,
                   (RdHi'2,
                    (RdHi'1,
                     (RdHi'0,
                      (RdLo'3,
                       (RdLo'2,
                        (RdLo'1,
                         (RdLo'0,
                          (Rm'3,
                           (Rm'2,
                            (Rm'1,
                             (Rm'0,
                              (true,
                               (false,
                                (false,(true,(Rn'3,(Rn'2,(Rn'1,Rn'0))))))))))))))))))))))))))) =>
            let
              val Rn = BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)
              val Rm = BitsN.fromBitstring([Rm'3,Rm'2,Rm'1,Rm'0],4)
              val RdLo =
                BitsN.fromBitstring([RdLo'3,RdLo'2,RdLo'1,RdLo'0],4)
              val RdHi =
                BitsN.fromBitstring([RdHi'3,RdHi'2,RdHi'1,RdHi'0],4)
            in
              if Do(cond,Nat.>=(ArchVersion (),6))
                then ( if (RdHi = (BitsN.B(0xF,4))) orelse
                          ((RdLo = (BitsN.B(0xF,4))) orelse
                           ((Rn = (BitsN.B(0xF,4))) orelse
                            ((Rm = (BitsN.B(0xF,4))) orelse (RdHi = RdLo))))
                         then DECODE_UNPREDICTABLE
                                (mc,"MultiplyAccumulateAccumulate")
                       else ()
                     ; Multiply
                         (MultiplyAccumulateAccumulate
                            (RdHi,(RdLo,(Rn,Rm))))
                     )
              else Skip ()
            end
          | (false,
           (false,
            (false,
             (false,
              (false,
               (true,
                (true,
                 (false,
                  (Rd'3,
                   (Rd'2,
                    (Rd'1,
                     (Rd'0,
                      (Ra'3,
                       (Ra'2,
                        (Ra'1,
                         (Ra'0,
                          (Rm'3,
                           (Rm'2,
                            (Rm'1,
                             (Rm'0,
                              (true,
                               (false,
                                (false,(true,(Rn'3,(Rn'2,(Rn'1,Rn'0))))))))))))))))))))))))))) =>
            let
              val Rn = BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)
              val Rm = BitsN.fromBitstring([Rm'3,Rm'2,Rm'1,Rm'0],4)
              val Ra = BitsN.fromBitstring([Ra'3,Ra'2,Ra'1,Ra'0],4)
              val Rd = BitsN.fromBitstring([Rd'3,Rd'2,Rd'1,Rd'0],4)
            in
              if Do(cond,HaveThumb2 ())
                then ( if (Rd = (BitsN.B(0xF,4))) orelse
                          ((Rn = (BitsN.B(0xF,4))) orelse
                           ((Rm = (BitsN.B(0xF,4))) orelse
                            (Ra = (BitsN.B(0xF,4)))))
                         then DECODE_UNPREDICTABLE(mc,"MultiplySubtract")
                       else ()
                     ; Multiply(MultiplySubtract(Rd,(Rn,(Rm,Ra))))
                     )
              else Skip ()
            end
          | (false,
           (false,
            (false,
             (false,
              (true,
               (I'0,
                (A'0,
                 (S'0,
                  (RdHi'3,
                   (RdHi'2,
                    (RdHi'1,
                     (RdHi'0,
                      (RdLo'3,
                       (RdLo'2,
                        (RdLo'1,
                         (RdLo'0,
                          (Rm'3,
                           (Rm'2,
                            (Rm'1,
                             (Rm'0,
                              (true,
                               (false,
                                (false,(true,(Rn'3,(Rn'2,(Rn'1,Rn'0))))))))))))))))))))))))))) =>
            let
              val Rn = BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)
              val Rm = BitsN.fromBitstring([Rm'3,Rm'2,Rm'1,Rm'0],4)
              val RdLo =
                BitsN.fromBitstring([RdLo'3,RdLo'2,RdLo'1,RdLo'0],4)
              val RdHi =
                BitsN.fromBitstring([RdHi'3,RdHi'2,RdHi'1,RdHi'0],4)
            in
              if Do(cond,true)
                then ( if (RdLo = (BitsN.B(0xF,4))) orelse
                          ((RdHi = (BitsN.B(0xF,4))) orelse
                           ((Rn = (BitsN.B(0xF,4))) orelse
                            ((Rm = (BitsN.B(0xF,4))) orelse
                             ((RdHi = RdLo) orelse
                              ((Nat.<(ArchVersion (),6)) andalso
                               ((RdHi = Rn) orelse (RdLo = Rn)))))))
                         then DECODE_UNPREDICTABLE(mc,"MultiplyLong")
                       else ()
                     ; let
                         val accumulate =
                           (BitsN.fromBitstring([A'0],1)) =
                           (BitsN.B(0x1,1))
                         val signed =
                           (BitsN.fromBitstring([I'0],1)) =
                           (BitsN.B(0x1,1))
                         val setflags =
                           (BitsN.fromBitstring([S'0],1)) =
                           (BitsN.B(0x1,1))
                       in
                         Multiply
                           (MultiplyLong
                              (accumulate,
                               (signed,(setflags,(RdHi,(RdLo,(Rn,Rm)))))))
                       end
                     )
              else Skip ()
            end
          | (false,
           (false,
            (false,
             (true,
              (false,
               (B'0,
                (false,
                 (false,
                  (Rn'3,
                   (Rn'2,
                    (Rn'1,
                     (Rn'0,
                      (Rt'3,
                       (Rt'2,
                        (Rt'1,
                         (Rt'0,
                          (_,
                           (_,
                            (_,
                             (_,
                              (true,
                               (false,
                                (false,
                                 (true,(Rt2'3,(Rt2'2,(Rt2'1,Rt2'0))))))))))))))))))))))))))) =>
            let
              val Rt2 = BitsN.fromBitstring([Rt2'3,Rt2'2,Rt2'1,Rt2'0],4)
              val Rt = BitsN.fromBitstring([Rt'3,Rt'2,Rt'1,Rt'0],4)
              val Rn = BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)
            in
              if Do(cond,true)
                then ( if (Rt = (BitsN.B(0xF,4))) orelse
                          ((Rt2 = (BitsN.B(0xF,4))) orelse
                           ((Rn = (BitsN.B(0xF,4))) orelse
                            ((Rn = Rt) orelse (Rn = Rt2))))
                         then DECODE_UNPREDICTABLE(mc,"Swap")
                       else ()
                     ; let
                         val b =
                           (BitsN.fromBitstring([B'0],1)) =
                           (BitsN.B(0x1,1))
                       in
                         Swap(b,(Rt,(Rt2,Rn)))
                       end
                     )
              else Skip ()
            end
          | (false,
           (false,
            (false,
             (true,
              (true,
               (false,
                (false,
                 (false,
                  (Rn'3,
                   (Rn'2,
                    (Rn'1,
                     (Rn'0,
                      (Rd'3,
                       (Rd'2,
                        (Rd'1,
                         (Rd'0,
                          (_,
                           (_,
                            (_,
                             (_,
                              (true,
                               (false,
                                (false,(true,(Rt'3,(Rt'2,(Rt'1,Rt'0))))))))))))))))))))))))))) =>
            let
              val Rt = BitsN.fromBitstring([Rt'3,Rt'2,Rt'1,Rt'0],4)
              val Rd = BitsN.fromBitstring([Rd'3,Rd'2,Rd'1,Rd'0],4)
              val Rn = BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)
            in
              if Do(cond,Nat.>=(ArchVersion (),6))
                then ( if (Rd = (BitsN.B(0xF,4))) orelse
                          ((Rt = (BitsN.B(0xF,4))) orelse
                           ((Rn = (BitsN.B(0xF,4))) orelse
                            ((Rd = Rn) orelse (Rd = Rt))))
                         then DECODE_UNPREDICTABLE(mc,"StoreExclusive")
                       else ()
                     ; Store(StoreExclusive(Rd,(Rt,(Rn,BitsN.B(0x0,32)))))
                     )
              else Skip ()
            end
          | (false,
           (false,
            (false,
             (true,
              (true,
               (false,
                (false,
                 (true,
                  (Rn'3,
                   (Rn'2,
                    (Rn'1,
                     (Rn'0,
                      (Rt'3,
                       (Rt'2,
                        (Rt'1,
                         (Rt'0,
                          (_,(_,(_,(_,(true,(false,(false,(true,_)))))))))))))))))))))))) =>
            let
              val Rt = BitsN.fromBitstring([Rt'3,Rt'2,Rt'1,Rt'0],4)
              val Rn = BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)
            in
              if Do(cond,Nat.>=(ArchVersion (),6))
                then ( if (Rt = (BitsN.B(0xF,4))) orelse
                          (Rn = (BitsN.B(0xF,4)))
                         then DECODE_UNPREDICTABLE(mc,"LoadExclusive")
                       else ()
                     ; Load(LoadExclusive(Rt,(Rn,BitsN.B(0x0,32))))
                     )
              else Skip ()
            end
          | (false,
           (false,
            (false,
             (true,
              (true,
               (false,
                (true,
                 (false,
                  (Rn'3,
                   (Rn'2,
                    (Rn'1,
                     (Rn'0,
                      (Rd'3,
                       (Rd'2,
                        (Rd'1,
                         (Rd'0,
                          (_,
                           (_,
                            (_,
                             (_,
                              (true,
                               (false,
                                (false,(true,(Rt'3,(Rt'2,(Rt'1,Rt'0))))))))))))))))))))))))))) =>
            let
              val Rt = BitsN.fromBitstring([Rt'3,Rt'2,Rt'1,Rt'0],4)
              val Rd = BitsN.fromBitstring([Rd'3,Rd'2,Rd'1,Rd'0],4)
              val Rn = BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)
            in
              if Do(cond,Set.mem((!Architecture),[ARMv6K,ARMv7_A,ARMv7_R]))
                then let
                       val Rt2 = BitsN.+(Rt,BitsN.B(0x1,4))
                     in
                       ( if (Rd = (BitsN.B(0xF,4))) orelse
                            ((BitsN.bit(Rt,0)) orelse
                             ((Rt = (BitsN.B(0xE,4))) orelse
                              ((Rn = (BitsN.B(0xF,4))) orelse
                               ((Rd = Rn) orelse
                                ((Rd = Rt) orelse (Rd = Rt2))))))
                           then DECODE_UNPREDICTABLE
                                  (mc,"StoreExclusiveDoubleword")
                         else ()
                       ; Store(StoreExclusiveDoubleword(Rd,(Rt,(Rt2,Rn))))
                       )
                     end
              else Skip ()
            end
          | (false,
           (false,
            (false,
             (true,
              (true,
               (false,
                (true,
                 (true,
                  (Rn'3,
                   (Rn'2,
                    (Rn'1,
                     (Rn'0,
                      (Rt'3,
                       (Rt'2,
                        (Rt'1,
                         (Rt'0,
                          (_,(_,(_,(_,(true,(false,(false,(true,_)))))))))))))))))))))))) =>
            let
              val Rt = BitsN.fromBitstring([Rt'3,Rt'2,Rt'1,Rt'0],4)
              val Rn = BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)
            in
              if Do(cond,Set.mem((!Architecture),[ARMv6K,ARMv7_A,ARMv7_R]))
                then let
                       val Rt2 = BitsN.+(Rt,BitsN.B(0x1,4))
                     in
                       ( if (BitsN.bit(Rt,0)) orelse
                            ((Rt = (BitsN.B(0xE,4))) orelse
                             (Rn = (BitsN.B(0xF,4))))
                           then DECODE_UNPREDICTABLE
                                  (mc,"LoadExclusiveDoubleword")
                         else ()
                       ; Load(LoadExclusiveDoubleword(Rt,(Rt2,Rn)))
                       )
                     end
              else Skip ()
            end
          | (false,
           (false,
            (false,
             (true,
              (true,
               (true,
                (false,
                 (false,
                  (Rn'3,
                   (Rn'2,
                    (Rn'1,
                     (Rn'0,
                      (Rd'3,
                       (Rd'2,
                        (Rd'1,
                         (Rd'0,
                          (_,
                           (_,
                            (_,
                             (_,
                              (true,
                               (false,
                                (false,(true,(Rt'3,(Rt'2,(Rt'1,Rt'0))))))))))))))))))))))))))) =>
            let
              val Rt = BitsN.fromBitstring([Rt'3,Rt'2,Rt'1,Rt'0],4)
              val Rd = BitsN.fromBitstring([Rd'3,Rd'2,Rd'1,Rd'0],4)
              val Rn = BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)
            in
              if Do(cond,Set.mem((!Architecture),[ARMv6K,ARMv7_A,ARMv7_R]))
                then ( if (Rd = (BitsN.B(0xF,4))) orelse
                          ((Rt = (BitsN.B(0xF,4))) orelse
                           ((Rn = (BitsN.B(0xF,4))) orelse
                            ((Rd = Rn) orelse (Rd = Rt))))
                         then DECODE_UNPREDICTABLE
                                (mc,"StoreExclusiveByte")
                       else ()
                     ; Store(StoreExclusiveByte(Rd,(Rt,Rn)))
                     )
              else Skip ()
            end
          | (false,
           (false,
            (false,
             (true,
              (true,
               (true,
                (false,
                 (true,
                  (Rn'3,
                   (Rn'2,
                    (Rn'1,
                     (Rn'0,
                      (Rt'3,
                       (Rt'2,
                        (Rt'1,
                         (Rt'0,
                          (_,(_,(_,(_,(true,(false,(false,(true,_)))))))))))))))))))))))) =>
            let
              val Rt = BitsN.fromBitstring([Rt'3,Rt'2,Rt'1,Rt'0],4)
              val Rn = BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)
            in
              if Do(cond,Set.mem((!Architecture),[ARMv6K,ARMv7_A,ARMv7_R]))
                then ( if (Rt = (BitsN.B(0xF,4))) orelse
                          (Rn = (BitsN.B(0xF,4)))
                         then DECODE_UNPREDICTABLE(mc,"LoadExclusiveByte")
                       else ()
                     ; Load(LoadExclusiveByte(Rt,Rn))
                     )
              else Skip ()
            end
          | (false,
           (false,
            (false,
             (true,
              (true,
               (true,
                (true,
                 (false,
                  (Rn'3,
                   (Rn'2,
                    (Rn'1,
                     (Rn'0,
                      (Rd'3,
                       (Rd'2,
                        (Rd'1,
                         (Rd'0,
                          (_,
                           (_,
                            (_,
                             (_,
                              (true,
                               (false,
                                (false,(true,(Rt'3,(Rt'2,(Rt'1,Rt'0))))))))))))))))))))))))))) =>
            let
              val Rt = BitsN.fromBitstring([Rt'3,Rt'2,Rt'1,Rt'0],4)
              val Rd = BitsN.fromBitstring([Rd'3,Rd'2,Rd'1,Rd'0],4)
              val Rn = BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)
            in
              if Do(cond,Set.mem((!Architecture),[ARMv6K,ARMv7_A,ARMv7_R]))
                then ( if (Rd = (BitsN.B(0xF,4))) orelse
                          ((Rt = (BitsN.B(0xF,4))) orelse
                           ((Rn = (BitsN.B(0xF,4))) orelse
                            ((Rd = Rn) orelse (Rd = Rt))))
                         then DECODE_UNPREDICTABLE
                                (mc,"StoreExclusiveHalf")
                       else ()
                     ; Store(StoreExclusiveHalf(Rd,(Rt,Rn)))
                     )
              else Skip ()
            end
          | (false,
           (false,
            (false,
             (true,
              (true,
               (true,
                (true,
                 (true,
                  (Rn'3,
                   (Rn'2,
                    (Rn'1,
                     (Rn'0,
                      (Rt'3,
                       (Rt'2,
                        (Rt'1,
                         (Rt'0,
                          (_,(_,(_,(_,(true,(false,(false,(true,_)))))))))))))))))))))))) =>
            let
              val Rt = BitsN.fromBitstring([Rt'3,Rt'2,Rt'1,Rt'0],4)
              val Rn = BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)
            in
              if Do(cond,Set.mem((!Architecture),[ARMv6K,ARMv7_A,ARMv7_R]))
                then ( if (Rt = (BitsN.B(0xF,4))) orelse
                          (Rn = (BitsN.B(0xF,4)))
                         then DECODE_UNPREDICTABLE(mc,"LoadExclusiveHalf")
                       else ()
                     ; Load(LoadExclusiveHalf(Rt,Rn))
                     )
              else Skip ()
            end
          | (false,
           (false,
            (false,
             (false,
              (U'0,
               (false,
                (true,
                 (false,
                  (Rn'3,
                   (Rn'2,
                    (Rn'1,
                     (Rn'0,
                      (Rt'3,
                       (Rt'2,
                        (Rt'1,
                         (Rt'0,
                          (_,
                           (_,
                            (_,
                             (_,
                              (true,
                               (false,
                                (true,(true,(Rm'3,(Rm'2,(Rm'1,Rm'0))))))))))))))))))))))))))) =>
            let
              val Rm = BitsN.fromBitstring([Rm'3,Rm'2,Rm'1,Rm'0],4)
              val Rt = BitsN.fromBitstring([Rt'3,Rt'2,Rt'1,Rt'0],4)
              val Rn = BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)
            in
              if Do(cond,HaveThumb2 ())
                then ( if (Rt = (BitsN.B(0xF,4))) orelse
                          ((Rn = (BitsN.B(0xF,4))) orelse
                           ((Rn = Rt) orelse (Rm = (BitsN.B(0xF,4)))))
                         then DECODE_UNPREDICTABLE
                                (mc,"StoreHalfUnprivileged")
                       else ()
                     ; let
                         val add =
                           (BitsN.fromBitstring([U'0],1)) =
                           (BitsN.B(0x1,1))
                         val postindex = true
                         val m = register_form2 Rm
                       in
                         Store
                           (StoreHalfUnprivileged
                              (add,(postindex,(Rt,(Rn,m)))))
                       end
                     )
              else Skip ()
            end
          | (false,
           (false,
            (false,
             (P'0,
              (U'0,
               (false,
                (W'0,
                 (false,
                  (Rn'3,
                   (Rn'2,
                    (Rn'1,
                     (Rn'0,
                      (Rt'3,
                       (Rt'2,
                        (Rt'1,
                         (Rt'0,
                          (_,
                           (_,
                            (_,
                             (_,
                              (true,
                               (false,
                                (true,(true,(Rm'3,(Rm'2,(Rm'1,Rm'0))))))))))))))))))))))))))) =>
            let
              val Rm = BitsN.fromBitstring([Rm'3,Rm'2,Rm'1,Rm'0],4)
              val Rt = BitsN.fromBitstring([Rt'3,Rt'2,Rt'1,Rt'0],4)
              val Rn = BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)
              val P = BitsN.fromBitstring([P'0],1)
            in
              if Do(cond,true)
                then let
                       val wback =
                         (P = (BitsN.B(0x0,1))) orelse
                         ((BitsN.fromBitstring([W'0],1)) =
                          (BitsN.B(0x1,1)))
                     in
                       ( if (Rt = (BitsN.B(0xF,4))) orelse
                            ((Rm = (BitsN.B(0xF,4))) orelse
                             ((wback andalso
                               ((Rn = (BitsN.B(0xF,4))) orelse (Rn = Rt))) orelse
                              ((Nat.<(ArchVersion (),6)) andalso
                               (wback andalso (Rm = Rn)))))
                           then DECODE_UNPREDICTABLE(mc,"StoreHalf")
                         else ()
                       ; let
                           val index = P = (BitsN.B(0x1,1))
                           val add =
                             (BitsN.fromBitstring([U'0],1)) =
                             (BitsN.B(0x1,1))
                           val (shift_t,shift_n) = (SRType_LSL,0)
                           val m = register_form1(Rm,(shift_t,shift_n))
                         in
                           Store
                             (StoreHalf(add,(index,(wback,(Rt,(Rn,m))))))
                         end
                       )
                     end
              else Skip ()
            end
          | (false,
           (false,
            (false,
             (false,
              (U'0,
               (false,
                (true,
                 (true,
                  (Rn'3,
                   (Rn'2,
                    (Rn'1,
                     (Rn'0,
                      (Rt'3,
                       (Rt'2,
                        (Rt'1,
                         (Rt'0,
                          (_,
                           (_,
                            (_,
                             (_,
                              (true,
                               (S'0,(H'0,(true,(Rm'3,(Rm'2,(Rm'1,Rm'0))))))))))))))))))))))))))) =>
            let
              val Rm = BitsN.fromBitstring([Rm'3,Rm'2,Rm'1,Rm'0],4)
              val H = BitsN.fromBitstring([H'0],1)
              val S = BitsN.fromBitstring([S'0],1)
              val Rt = BitsN.fromBitstring([Rt'3,Rt'2,Rt'1,Rt'0],4)
              val Rn = BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)
            in
              if Do(cond,
                    ((not(H = (BitsN.B(0x0,1)))) orelse
                     (S = (BitsN.B(0x1,1)))) andalso (HaveThumb2 ()))
                then ( if (Rt = (BitsN.B(0xF,4))) orelse
                          ((Rn = (BitsN.B(0xF,4))) orelse
                           ((Rn = Rt) orelse (Rm = (BitsN.B(0xF,4)))))
                         then DECODE_UNPREDICTABLE
                                (mc,"LoadHalf/Byte (unprivileged)")
                       else ()
                     ; let
                         val add =
                           (BitsN.fromBitstring([U'0],1)) =
                           (BitsN.B(0x1,1))
                         val postindex = true
                         val unsigned = S = (BitsN.B(0x0,1))
                         val m = register_form2 Rm
                       in
                         if H = (BitsN.B(0x1,1))
                           then Load
                                  (LoadHalfUnprivileged
                                     (unsigned,
                                      (add,(postindex,(Rt,(Rn,m))))))
                         else Load
                                (LoadSignedByteUnprivileged
                                   (add,(postindex,(Rt,(Rn,m)))))
                       end
                     )
              else Skip ()
            end
          | (false,
           (false,
            (false,
             (P'0,
              (U'0,
               (false,
                (W'0,
                 (true,
                  (Rn'3,
                   (Rn'2,
                    (Rn'1,
                     (Rn'0,
                      (Rt'3,
                       (Rt'2,
                        (Rt'1,
                         (Rt'0,
                          (_,
                           (_,
                            (_,
                             (_,
                              (true,
                               (S'0,(H'0,(true,(Rm'3,(Rm'2,(Rm'1,Rm'0))))))))))))))))))))))))))) =>
            let
              val Rm = BitsN.fromBitstring([Rm'3,Rm'2,Rm'1,Rm'0],4)
              val H = BitsN.fromBitstring([H'0],1)
              val S = BitsN.fromBitstring([S'0],1)
              val Rt = BitsN.fromBitstring([Rt'3,Rt'2,Rt'1,Rt'0],4)
              val Rn = BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)
              val P = BitsN.fromBitstring([P'0],1)
            in
              if Do(cond,
                    (not(H = (BitsN.B(0x0,1)))) orelse
                    (S = (BitsN.B(0x1,1))))
                then let
                       val wback =
                         (P = (BitsN.B(0x0,1))) orelse
                         ((BitsN.fromBitstring([W'0],1)) =
                          (BitsN.B(0x1,1)))
                     in
                       ( if (Rt = (BitsN.B(0xF,4))) orelse
                            ((Rm = (BitsN.B(0xF,4))) orelse
                             ((Nat.<(ArchVersion (),6)) andalso
                              (wback andalso (Rm = Rn))))
                           then DECODE_UNPREDICTABLE(mc,"LoadHalf/Byte")
                         else ()
                       ; let
                           val index = P = (BitsN.B(0x1,1))
                           val add =
                             (BitsN.fromBitstring([U'0],1)) =
                             (BitsN.B(0x1,1))
                           val (shift_t,shift_n) = (SRType_LSL,0)
                           val unsigned = S = (BitsN.B(0x0,1))
                           val m = register_form1(Rm,(shift_t,shift_n))
                         in
                           if H = (BitsN.B(0x1,1))
                             then Load
                                    (LoadHalf
                                       (unsigned,
                                        (add,(index,(wback,(Rt,(Rn,m)))))))
                           else Load
                                  (LoadByte
                                     (unsigned,
                                      (add,(index,(wback,(Rt,(Rn,m)))))))
                         end
                       )
                     end
              else Skip ()
            end
          | (false,
           (false,
            (false,
             (P'0,
              (U'0,
               (false,
                (W'0,
                 (false,
                  (Rn'3,
                   (Rn'2,
                    (Rn'1,
                     (Rn'0,
                      (Rt'3,
                       (Rt'2,
                        (Rt'1,
                         (Rt'0,
                          (_,
                           (_,
                            (_,
                             (_,
                              (true,
                               (true,
                                (S'0,(true,(Rm'3,(Rm'2,(Rm'1,Rm'0))))))))))))))))))))))))))) =>
            let
              val Rm = BitsN.fromBitstring([Rm'3,Rm'2,Rm'1,Rm'0],4)
              val Rt = BitsN.fromBitstring([Rt'3,Rt'2,Rt'1,Rt'0],4)
              val Rn = BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)
              val W = BitsN.fromBitstring([W'0],1)
              val P = BitsN.fromBitstring([P'0],1)
            in
              if Do(cond,HaveDSPSupport ())
                then let
                       val Rt2 = BitsN.+(Rt,BitsN.B(0x1,4))
                       val wback =
                         (P = (BitsN.B(0x0,1))) orelse
                         (W = (BitsN.B(0x1,1)))
                       val store =
                         (BitsN.fromBitstring([S'0],1)) = (BitsN.B(0x1,1))
                     in
                       ( if (BitsN.bit(Rt,0)) orelse
                            (((P = (BitsN.B(0x0,1))) andalso
                              (W = (BitsN.B(0x1,1)))) orelse
                             ((Rt2 = (BitsN.B(0xF,4))) orelse
                              ((Rm = (BitsN.B(0xF,4))) orelse
                               (((not store) andalso
                                 ((Rm = Rt) orelse (Rm = Rt2))) orelse
                                ((wback andalso
                                  ((Rn = (BitsN.B(0xF,4))) orelse
                                   ((Rn = Rt) orelse (Rn = Rt2)))) orelse
                                 ((Nat.<(ArchVersion (),6)) andalso
                                  (wback andalso (Rm = Rn))))))))
                           then DECODE_UNPREDICTABLE
                                  (mc,"Load/StoreDual (register)")
                         else ()
                       ; let
                           val index = P = (BitsN.B(0x1,1))
                           val add =
                             (BitsN.fromBitstring([U'0],1)) =
                             (BitsN.B(0x1,1))
                           val m = register_form2 Rm
                         in
                           if store
                             then Store
                                    (StoreDual
                                       (add,
                                        (index,(wback,(Rt,(Rt2,(Rn,m)))))))
                           else Load
                                  (LoadDual
                                     (add,
                                      (index,(wback,(Rt,(Rt2,(Rn,m)))))))
                         end
                       )
                     end
              else Skip ()
            end
          | (false,
           (false,
            (false,
             (_,
              (U'0,
               (true,
                (_,
                 (false,
                  (true,
                   (true,
                    (true,
                     (true,
                      (Rt'3,
                       (Rt'2,
                        (Rt'1,
                         (Rt'0,
                          (imm4H'3,
                           (imm4H'2,
                            (imm4H'1,
                             (imm4H'0,
                              (true,
                               (true,
                                (false,
                                 (true,
                                  (imm4L'3,(imm4L'2,(imm4L'1,imm4L'0))))))))))))))))))))))))))) =>
            let
              val Rt = BitsN.fromBitstring([Rt'3,Rt'2,Rt'1,Rt'0],4)
            in
              if Do(cond,HaveDSPSupport ())
                then let
                       val Rt2 = BitsN.+(Rt,BitsN.B(0x1,4))
                     in
                       ( if (BitsN.bit(Rt,0)) orelse
                            (Rt2 = (BitsN.B(0xF,4)))
                           then DECODE_UNPREDICTABLE
                                  (mc,"LoadDual (literal)")
                         else ()
                       ; let
                           val add =
                             (BitsN.fromBitstring([U'0],1)) =
                             (BitsN.B(0x1,1))
                           val imm32 =
                             BitsN.zeroExtend 32
                               (BitsN.@@
                                  (BitsN.fromBitstring
                                     ([imm4H'3,imm4H'2,imm4H'1,imm4H'0],4),
                                   BitsN.fromBitstring
                                     ([imm4L'3,imm4L'2,imm4L'1,imm4L'0],4)))
                         in
                           Load(LoadDualLiteral(add,(Rt,(Rt2,imm32))))
                         end
                       )
                     end
              else Skip ()
            end
          | (false,
           (false,
            (false,
             (P'0,
              (U'0,
               (true,
                (W'0,
                 (false,
                  (Rn'3,
                   (Rn'2,
                    (Rn'1,
                     (Rn'0,
                      (Rt'3,
                       (Rt'2,
                        (Rt'1,
                         (Rt'0,
                          (imm4H'3,
                           (imm4H'2,
                            (imm4H'1,
                             (imm4H'0,
                              (true,
                               (true,
                                (S'0,
                                 (true,
                                  (imm4L'3,(imm4L'2,(imm4L'1,imm4L'0))))))))))))))))))))))))))) =>
            let
              val S = BitsN.fromBitstring([S'0],1)
              val Rt = BitsN.fromBitstring([Rt'3,Rt'2,Rt'1,Rt'0],4)
              val Rn = BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)
              val W = BitsN.fromBitstring([W'0],1)
              val P = BitsN.fromBitstring([P'0],1)
            in
              if Do(cond,HaveDSPSupport ())
                then let
                       val Rt2 = BitsN.+(Rt,BitsN.B(0x1,4))
                       val wback =
                         (P = (BitsN.B(0x0,1))) orelse
                         (W = (BitsN.B(0x1,1)))
                     in
                       ( if (BitsN.bit(Rt,0)) orelse
                            (((P = (BitsN.B(0x0,1))) andalso
                              (W = (BitsN.B(0x1,1)))) orelse
                             ((wback andalso
                               (((S = (BitsN.B(0x1,1))) andalso
                                 (Rn = (BitsN.B(0xF,4)))) orelse
                                ((Rn = Rt) orelse (Rn = Rt2)))) orelse
                              (Rt2 = (BitsN.B(0xF,4)))))
                           then DECODE_UNPREDICTABLE
                                  (mc,"Load/StoreDual (immediate)")
                         else ()
                       ; let
                           val index = P = (BitsN.B(0x1,1))
                           val add =
                             (BitsN.fromBitstring([U'0],1)) =
                             (BitsN.B(0x1,1))
                           val imm32 =
                             BitsN.zeroExtend 32
                               (BitsN.@@
                                  (BitsN.fromBitstring
                                     ([imm4H'3,imm4H'2,imm4H'1,imm4H'0],4),
                                   BitsN.fromBitstring
                                     ([imm4L'3,imm4L'2,imm4L'1,imm4L'0],4)))
                           val m = immediate_form2 imm32
                         in
                           if S = (BitsN.B(0x1,1))
                             then Store
                                    (StoreDual
                                       (add,
                                        (index,(wback,(Rt,(Rt2,(Rn,m)))))))
                           else Load
                                  (LoadDual
                                     (add,
                                      (index,(wback,(Rt,(Rt2,(Rn,m)))))))
                         end
                       )
                     end
              else Skip ()
            end
          | (false,
           (false,
            (false,
             (false,
              (U'0,
               (true,
                (true,
                 (true,
                  (Rn'3,
                   (Rn'2,
                    (Rn'1,
                     (Rn'0,
                      (Rt'3,
                       (Rt'2,
                        (Rt'1,
                         (Rt'0,
                          (imm4H'3,
                           (imm4H'2,
                            (imm4H'1,
                             (imm4H'0,
                              (true,
                               (S'0,
                                (H'0,
                                 (true,
                                  (imm4L'3,(imm4L'2,(imm4L'1,imm4L'0))))))))))))))))))))))))))) =>
            let
              val H = BitsN.fromBitstring([H'0],1)
              val S = BitsN.fromBitstring([S'0],1)
              val Rt = BitsN.fromBitstring([Rt'3,Rt'2,Rt'1,Rt'0],4)
              val Rn = BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)
            in
              if Do(cond,
                    ((not(H = (BitsN.B(0x0,1)))) orelse
                     (S = (BitsN.B(0x1,1)))) andalso (HaveThumb2 ()))
                then ( if (Rt = (BitsN.B(0xF,4))) orelse
                          ((Rn = (BitsN.B(0xF,4))) orelse (Rn = Rt))
                         then DECODE_UNPREDICTABLE
                                (mc,"LoadHalf/Byte (unprivileged)")
                       else ()
                     ; let
                         val postindex = true
                         val add =
                           (BitsN.fromBitstring([U'0],1)) =
                           (BitsN.B(0x1,1))
                         val unsigned = S = (BitsN.B(0x0,1))
                         val imm32 =
                           BitsN.zeroExtend 32
                             (BitsN.@@
                                (BitsN.fromBitstring
                                   ([imm4H'3,imm4H'2,imm4H'1,imm4H'0],4),
                                 BitsN.fromBitstring
                                   ([imm4L'3,imm4L'2,imm4L'1,imm4L'0],4)))
                         val m = immediate_form2 imm32
                       in
                         if H = (BitsN.B(0x1,1))
                           then Load
                                  (LoadHalfUnprivileged
                                     (unsigned,
                                      (add,(postindex,(Rt,(Rn,m))))))
                         else Load
                                (LoadSignedByteUnprivileged
                                   (add,(postindex,(Rt,(Rn,m)))))
                       end
                     )
              else Skip ()
            end
          | (false,
           (false,
            (false,
             (_,
              (U'0,
               (true,
                (_,
                 (true,
                  (true,
                   (true,
                    (true,
                     (true,
                      (Rt'3,
                       (Rt'2,
                        (Rt'1,
                         (Rt'0,
                          (imm4H'3,
                           (imm4H'2,
                            (imm4H'1,
                             (imm4H'0,
                              (true,
                               (S'0,
                                (H'0,
                                 (true,
                                  (imm4L'3,(imm4L'2,(imm4L'1,imm4L'0))))))))))))))))))))))))))) =>
            let
              val H = BitsN.fromBitstring([H'0],1)
              val S = BitsN.fromBitstring([S'0],1)
              val Rt = BitsN.fromBitstring([Rt'3,Rt'2,Rt'1,Rt'0],4)
            in
              if Do(cond,
                    (not(H = (BitsN.B(0x0,1)))) orelse
                    (S = (BitsN.B(0x1,1))))
                then ( if Rt = (BitsN.B(0xF,4))
                         then DECODE_UNPREDICTABLE
                                (mc,"LoadHalf/Byte (literal)")
                       else ()
                     ; let
                         val add =
                           (BitsN.fromBitstring([U'0],1)) =
                           (BitsN.B(0x1,1))
                         val unsigned = S = (BitsN.B(0x0,1))
                         val imm32 =
                           BitsN.zeroExtend 32
                             (BitsN.@@
                                (BitsN.fromBitstring
                                   ([imm4H'3,imm4H'2,imm4H'1,imm4H'0],4),
                                 BitsN.fromBitstring
                                   ([imm4L'3,imm4L'2,imm4L'1,imm4L'0],4)))
                       in
                         if H = (BitsN.B(0x1,1))
                           then Load
                                  (LoadHalfLiteral
                                     (unsigned,(add,(Rt,imm32))))
                         else Load
                                (LoadByteLiteral
                                   (unsigned,(add,(Rt,imm32))))
                       end
                     )
              else Skip ()
            end
          | (false,
           (false,
            (false,
             (P'0,
              (U'0,
               (true,
                (W'0,
                 (true,
                  (Rn'3,
                   (Rn'2,
                    (Rn'1,
                     (Rn'0,
                      (Rt'3,
                       (Rt'2,
                        (Rt'1,
                         (Rt'0,
                          (imm4H'3,
                           (imm4H'2,
                            (imm4H'1,
                             (imm4H'0,
                              (true,
                               (S'0,
                                (H'0,
                                 (true,
                                  (imm4L'3,(imm4L'2,(imm4L'1,imm4L'0))))))))))))))))))))))))))) =>
            let
              val H = BitsN.fromBitstring([H'0],1)
              val S = BitsN.fromBitstring([S'0],1)
              val Rt = BitsN.fromBitstring([Rt'3,Rt'2,Rt'1,Rt'0],4)
              val Rn = BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)
              val P = BitsN.fromBitstring([P'0],1)
            in
              if Do(cond,
                    (not(H = (BitsN.B(0x0,1)))) orelse
                    (S = (BitsN.B(0x1,1))))
                then let
                       val wback =
                         (P = (BitsN.B(0x0,1))) orelse
                         ((BitsN.fromBitstring([W'0],1)) =
                          (BitsN.B(0x1,1)))
                     in
                       ( if (Rt = (BitsN.B(0xF,4))) orelse
                            (wback andalso (Rn = Rt))
                           then DECODE_UNPREDICTABLE
                                  (mc,"LoadHalf/Byte (immediate)")
                         else ()
                       ; let
                           val half = H = (BitsN.B(0x1,1))
                           val index = P = (BitsN.B(0x1,1))
                           val add =
                             (BitsN.fromBitstring([U'0],1)) =
                             (BitsN.B(0x1,1))
                           val unsigned = S = (BitsN.B(0x0,1))
                           val imm32 =
                             BitsN.zeroExtend 32
                               (BitsN.@@
                                  (BitsN.fromBitstring
                                     ([imm4H'3,imm4H'2,imm4H'1,imm4H'0],4),
                                   BitsN.fromBitstring
                                     ([imm4L'3,imm4L'2,imm4L'1,imm4L'0],4)))
                           val m = immediate_form1 imm32
                         in
                           if H = (BitsN.B(0x1,1))
                             then Load
                                    (LoadHalf
                                       (unsigned,
                                        (add,(index,(wback,(Rt,(Rn,m)))))))
                           else Load
                                  (LoadByte
                                     (unsigned,
                                      (add,(index,(wback,(Rt,(Rn,m)))))))
                         end
                       )
                     end
              else Skip ()
            end
          | (false,
           (false,
            (false,
             (false,
              (U'0,
               (true,
                (true,
                 (false,
                  (Rn'3,
                   (Rn'2,
                    (Rn'1,
                     (Rn'0,
                      (Rt'3,
                       (Rt'2,
                        (Rt'1,
                         (Rt'0,
                          (imm4H'3,
                           (imm4H'2,
                            (imm4H'1,
                             (imm4H'0,
                              (true,
                               (false,
                                (true,
                                 (true,
                                  (imm4L'3,(imm4L'2,(imm4L'1,imm4L'0))))))))))))))))))))))))))) =>
            let
              val Rt = BitsN.fromBitstring([Rt'3,Rt'2,Rt'1,Rt'0],4)
              val Rn = BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)
            in
              if Do(cond,HaveThumb2 ())
                then ( if (Rt = (BitsN.B(0xF,4))) orelse
                          ((Rn = (BitsN.B(0xF,4))) orelse (Rn = Rt))
                         then DECODE_UNPREDICTABLE
                                (mc,"StoreHalf (immediate)")
                       else ()
                     ; let
                         val add =
                           (BitsN.fromBitstring([U'0],1)) =
                           (BitsN.B(0x1,1))
                         val postindex = true
                         val imm32 =
                           BitsN.zeroExtend 32
                             (BitsN.@@
                                (BitsN.fromBitstring
                                   ([imm4H'3,imm4H'2,imm4H'1,imm4H'0],4),
                                 BitsN.fromBitstring
                                   ([imm4L'3,imm4L'2,imm4L'1,imm4L'0],4)))
                         val m = immediate_form2 imm32
                       in
                         Store
                           (StoreHalfUnprivileged
                              (add,(postindex,(Rt,(Rn,m)))))
                       end
                     )
              else Skip ()
            end
          | (false,
           (false,
            (false,
             (P'0,
              (U'0,
               (true,
                (W'0,
                 (false,
                  (Rn'3,
                   (Rn'2,
                    (Rn'1,
                     (Rn'0,
                      (Rt'3,
                       (Rt'2,
                        (Rt'1,
                         (Rt'0,
                          (imm4H'3,
                           (imm4H'2,
                            (imm4H'1,
                             (imm4H'0,
                              (true,
                               (false,
                                (true,
                                 (true,
                                  (imm4L'3,(imm4L'2,(imm4L'1,imm4L'0))))))))))))))))))))))))))) =>
            let
              val Rt = BitsN.fromBitstring([Rt'3,Rt'2,Rt'1,Rt'0],4)
              val Rn = BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)
              val P = BitsN.fromBitstring([P'0],1)
            in
              if Do(cond,true)
                then let
                       val wback =
                         (P = (BitsN.B(0x0,1))) orelse
                         ((BitsN.fromBitstring([W'0],1)) =
                          (BitsN.B(0x1,1)))
                     in
                       ( if (Rt = (BitsN.B(0xF,4))) orelse
                            (wback andalso
                             ((Rn = (BitsN.B(0xF,4))) orelse (Rn = Rt)))
                           then DECODE_UNPREDICTABLE
                                  (mc,"StoreHalf (immediate)")
                         else ()
                       ; let
                           val index = P = (BitsN.B(0x1,1))
                           val add =
                             (BitsN.fromBitstring([U'0],1)) =
                             (BitsN.B(0x1,1))
                           val imm32 =
                             BitsN.zeroExtend 32
                               (BitsN.@@
                                  (BitsN.fromBitstring
                                     ([imm4H'3,imm4H'2,imm4H'1,imm4H'0],4),
                                   BitsN.fromBitstring
                                     ([imm4L'3,imm4L'2,imm4L'1,imm4L'0],4)))
                           val m = immediate_form1 imm32
                         in
                           Store
                             (StoreHalf(add,(index,(wback,(Rt,(Rn,m))))))
                         end
                       )
                     end
              else Skip ()
            end
          | (false,
           (false,
            (true,
             (true,
              (false,
               (H'0,
                (false,
                 (false,
                  (imm4'3,
                   (imm4'2,
                    (imm4'1,
                     (imm4'0,
                      (Rd'3,
                       (Rd'2,
                        (Rd'1,
                         (Rd'0,
                          (imm12'11,
                           (imm12'10,
                            (imm12'9,
                             (imm12'8,
                              (imm12'7,
                               (imm12'6,
                                (imm12'5,
                                 (imm12'4,
                                  (imm12'3,(imm12'2,(imm12'1,imm12'0))))))))))))))))))))))))))) =>
            let
              val Rd = BitsN.fromBitstring([Rd'3,Rd'2,Rd'1,Rd'0],4)
            in
              if Do(cond,HaveThumb2 ())
                then ( if Rd = (BitsN.B(0xF,4))
                         then DECODE_UNPREDICTABLE(mc,"MoveTopHalfword")
                       else ()
                     ; let
                         val imm16 =
                           BitsN.@@
                             (BitsN.fromBitstring
                                ([imm4'3,imm4'2,imm4'1,imm4'0],4),
                              BitsN.fromBitstring
                                ([imm12'11,imm12'10,imm12'9,imm12'8,
                                  imm12'7,imm12'6,imm12'5,imm12'4,imm12'3,
                                  imm12'2,imm12'1,imm12'0],12))
                         val high =
                           (BitsN.fromBitstring([H'0],1)) =
                           (BitsN.B(0x1,1))
                       in
                         Data(MoveHalfword(high,(Rd,imm16)))
                       end
                     )
              else Skip ()
            end
          | (false,
           (false,
            (true,
             (true,
              (false,
               (false,
                (true,
                 (false,
                  (false,
                   (false,
                    (false,
                     (false,
                      (_,
                       (_,
                        (_,
                         (_,
                          (_,
                           (_,
                            (_,
                             (_,
                              (op'7,
                               (op'6,
                                (op'5,(op'4,(op'3,(op'2,(op'1,op'0))))))))))))))))))))))))))) =>
            DecodeHint
              (cond,
               BitsN.fromBitstring
                 ([op'7,op'6,op'5,op'4,op'3,op'2,op'1,op'0],8))
          | (false,
           (false,
            (true,
             (true,
              (false,
               (R'0,
                (true,
                 (false,
                  (mask'3,
                   (mask'2,
                    (mask'1,
                     (mask'0,
                      (_,
                       (_,
                        (_,
                         (_,
                          (imm12'11,
                           (imm12'10,
                            (imm12'9,
                             (imm12'8,
                              (imm12'7,
                               (imm12'6,
                                (imm12'5,
                                 (imm12'4,
                                  (imm12'3,(imm12'2,(imm12'1,imm12'0))))))))))))))))))))))))))) =>
            let
              val mask =
                BitsN.fromBitstring([mask'3,mask'2,mask'1,mask'0],4)
            in
              if Do(cond,true)
                then ( if mask = (BitsN.B(0x0,4))
                         then DECODE_UNPREDICTABLE
                                (mc,"MoveToSpecialFromImmediate")
                       else ()
                     ; let
                         val write_spsr =
                           (BitsN.fromBitstring([R'0],1)) =
                           (BitsN.B(0x1,1))
                         val imm32 =
                           ARMExpandImm
                             (BitsN.fromBitstring
                                ([imm12'11,imm12'10,imm12'9,imm12'8,
                                  imm12'7,imm12'6,imm12'5,imm12'4,imm12'3,
                                  imm12'2,imm12'1,imm12'0],12))
                       in
                         System
                           (MoveToSpecialFromImmediate
                              (write_spsr,(imm32,mask)))
                       end
                     )
              else Skip ()
            end
          | (false,
           (false,
            (true,
             (opc'3,
              (opc'2,
               (opc'1,
                (opc'0,
                 (S'0,
                  (Rn'3,
                   (Rn'2,
                    (Rn'1,
                     (Rn'0,
                      (Rd'3,
                       (Rd'2,
                        (Rd'1,
                         (Rd'0,
                          (imm12'11,
                           (imm12'10,
                            (imm12'9,
                             (imm12'8,
                              (imm12'7,
                               (imm12'6,
                                (imm12'5,
                                 (imm12'4,
                                  (imm12'3,(imm12'2,(imm12'1,imm12'0))))))))))))))))))))))))))) =>
            let
              val imm12 =
                BitsN.fromBitstring
                  ([imm12'11,imm12'10,imm12'9,imm12'8,imm12'7,imm12'6,
                    imm12'5,imm12'4,imm12'3,imm12'2,imm12'1,imm12'0],12)
              val Rd = BitsN.fromBitstring([Rd'3,Rd'2,Rd'1,Rd'0],4)
              val Rn = BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)
              val opc = BitsN.fromBitstring([opc'3,opc'2,opc'1,opc'0],4)
            in
              if Do(cond,true)
                then let
                       val setflags =
                         (BitsN.fromBitstring([S'0],1)) = (BitsN.B(0x1,1))
                     in
                       case boolify'4 opc of
                          (true,(true,(N'0,true))) =>
                            Data
                              (Move
                                 (setflags,
                                  ((not o L3.equal (BitsN.zero (1)))
                                     (BitsN.fromBitstring([N'0],1)),
                                   (Rd,imm12))))
                        | (true,(false,(op'1,op'0))) =>
                          Data
                            (TestCompareImmediate
                               (BitsN.fromBitstring([op'1,op'0],2),
                                (Rn,imm12)))
                        | _ =>
                          Data
                            (ArithLogicImmediate
                               (opc,(setflags,(Rd,(Rn,imm12)))))
                     end
              else Skip ()
            end
          | (false,
           (true,
            (false,
             (false,
              (U'0,
               (B'0,
                (true,
                 (false,
                  (Rn'3,
                   (Rn'2,
                    (Rn'1,
                     (Rn'0,
                      (Rt'3,
                       (Rt'2,
                        (Rt'1,
                         (Rt'0,
                          (imm12'11,
                           (imm12'10,
                            (imm12'9,
                             (imm12'8,
                              (imm12'7,
                               (imm12'6,
                                (imm12'5,
                                 (imm12'4,
                                  (imm12'3,(imm12'2,(imm12'1,imm12'0))))))))))))))))))))))))))) =>
            let
              val Rt = BitsN.fromBitstring([Rt'3,Rt'2,Rt'1,Rt'0],4)
              val Rn = BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)
              val B = BitsN.fromBitstring([B'0],1)
            in
              if Do(cond,true)
                then ( if ((B = (BitsN.B(0x1,1))) andalso
                           (Rt = (BitsN.B(0xF,4)))) orelse
                          ((Rn = (BitsN.B(0xF,4))) orelse (Rn = Rt))
                         then DECODE_UNPREDICTABLE
                                (mc,"StoreUnprivileged (immediate)")
                       else ()
                     ; let
                         val add =
                           (BitsN.fromBitstring([U'0],1)) =
                           (BitsN.B(0x1,1))
                         val postindex = true
                         val imm32 =
                           BitsN.zeroExtend 32
                             (BitsN.fromBitstring
                                ([imm12'11,imm12'10,imm12'9,imm12'8,
                                  imm12'7,imm12'6,imm12'5,imm12'4,imm12'3,
                                  imm12'2,imm12'1,imm12'0],12))
                         val m = immediate_form1 imm32
                       in
                         if B = (BitsN.B(0x1,1))
                           then Store
                                  (StoreByteUnprivileged
                                     (add,(postindex,(Rt,(Rn,m)))))
                         else Store
                                (StoreUnprivileged
                                   (add,(postindex,(Rt,(Rn,m)))))
                       end
                     )
              else Skip ()
            end
          | (false,
           (true,
            (false,
             (P'0,
              (U'0,
               (B'0,
                (W'0,
                 (false,
                  (Rn'3,
                   (Rn'2,
                    (Rn'1,
                     (Rn'0,
                      (Rt'3,
                       (Rt'2,
                        (Rt'1,
                         (Rt'0,
                          (imm12'11,
                           (imm12'10,
                            (imm12'9,
                             (imm12'8,
                              (imm12'7,
                               (imm12'6,
                                (imm12'5,
                                 (imm12'4,
                                  (imm12'3,(imm12'2,(imm12'1,imm12'0))))))))))))))))))))))))))) =>
            let
              val Rt = BitsN.fromBitstring([Rt'3,Rt'2,Rt'1,Rt'0],4)
              val Rn = BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)
              val B = BitsN.fromBitstring([B'0],1)
              val P = BitsN.fromBitstring([P'0],1)
            in
              if Do(cond,true)
                then let
                       val wback =
                         (P = (BitsN.B(0x0,1))) orelse
                         ((BitsN.fromBitstring([W'0],1)) =
                          (BitsN.B(0x1,1)))
                     in
                       ( if ((B = (BitsN.B(0x1,1))) andalso
                             (Rt = (BitsN.B(0xF,4)))) orelse
                            (wback andalso
                             ((Rn = (BitsN.B(0xF,4))) orelse (Rn = Rt)))
                           then DECODE_UNPREDICTABLE
                                  (mc,"Store (immediate)")
                         else ()
                       ; let
                           val add =
                             (BitsN.fromBitstring([U'0],1)) =
                             (BitsN.B(0x1,1))
                           val index = P = (BitsN.B(0x1,1))
                           val imm32 =
                             BitsN.zeroExtend 32
                               (BitsN.fromBitstring
                                  ([imm12'11,imm12'10,imm12'9,imm12'8,
                                    imm12'7,imm12'6,imm12'5,imm12'4,
                                    imm12'3,imm12'2,imm12'1,imm12'0],12))
                           val m = immediate_form1 imm32
                         in
                           if B = (BitsN.B(0x1,1))
                             then Store
                                    (StoreByte
                                       (add,(index,(wback,(Rt,(Rn,m))))))
                           else Store
                                  (StoreWord
                                     (add,(index,(wback,(Rt,(Rn,m))))))
                         end
                       )
                     end
              else Skip ()
            end
          | (false,
           (true,
            (false,
             (false,
              (U'0,
               (B'0,
                (true,
                 (true,
                  (Rn'3,
                   (Rn'2,
                    (Rn'1,
                     (Rn'0,
                      (Rt'3,
                       (Rt'2,
                        (Rt'1,
                         (Rt'0,
                          (imm12'11,
                           (imm12'10,
                            (imm12'9,
                             (imm12'8,
                              (imm12'7,
                               (imm12'6,
                                (imm12'5,
                                 (imm12'4,
                                  (imm12'3,(imm12'2,(imm12'1,imm12'0))))))))))))))))))))))))))) =>
            let
              val Rt = BitsN.fromBitstring([Rt'3,Rt'2,Rt'1,Rt'0],4)
              val Rn = BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)
            in
              if Do(cond,true)
                then ( if (Rt = (BitsN.B(0xF,4))) orelse
                          ((Rn = (BitsN.B(0xF,4))) orelse (Rn = Rt))
                         then DECODE_UNPREDICTABLE
                                (mc,"LoadUnprivileged (immediate)")
                       else ()
                     ; let
                         val add =
                           (BitsN.fromBitstring([U'0],1)) =
                           (BitsN.B(0x1,1))
                         val postindex = true
                         val imm32 =
                           BitsN.zeroExtend 32
                             (BitsN.fromBitstring
                                ([imm12'11,imm12'10,imm12'9,imm12'8,
                                  imm12'7,imm12'6,imm12'5,imm12'4,imm12'3,
                                  imm12'2,imm12'1,imm12'0],12))
                         val m = immediate_form1 imm32
                       in
                         if (BitsN.fromBitstring([B'0],1)) =
                            (BitsN.B(0x1,1))
                           then Load
                                  (LoadByteUnprivileged
                                     (add,(postindex,(Rt,(Rn,m)))))
                         else Load
                                (LoadUnprivileged
                                   (add,(postindex,(Rt,(Rn,m)))))
                       end
                     )
              else Skip ()
            end
          | (false,
           (true,
            (false,
             (_,
              (U'0,
               (B'0,
                (_,
                 (true,
                  (true,
                   (true,
                    (true,
                     (true,
                      (Rt'3,
                       (Rt'2,
                        (Rt'1,
                         (Rt'0,
                          (imm12'11,
                           (imm12'10,
                            (imm12'9,
                             (imm12'8,
                              (imm12'7,
                               (imm12'6,
                                (imm12'5,
                                 (imm12'4,
                                  (imm12'3,(imm12'2,(imm12'1,imm12'0))))))))))))))))))))))))))) =>
            let
              val Rt = BitsN.fromBitstring([Rt'3,Rt'2,Rt'1,Rt'0],4)
              val B = BitsN.fromBitstring([B'0],1)
            in
              if Do(cond,true)
                then ( if (B = (BitsN.B(0x1,1))) andalso
                          (Rt = (BitsN.B(0xF,4)))
                         then DECODE_UNPREDICTABLE
                                (mc,"LoadByte (literal)")
                       else ()
                     ; let
                         val add =
                           (BitsN.fromBitstring([U'0],1)) =
                           (BitsN.B(0x1,1))
                         val imm32 =
                           BitsN.zeroExtend 32
                             (BitsN.fromBitstring
                                ([imm12'11,imm12'10,imm12'9,imm12'8,
                                  imm12'7,imm12'6,imm12'5,imm12'4,imm12'3,
                                  imm12'2,imm12'1,imm12'0],12))
                       in
                         if B = (BitsN.B(0x1,1))
                           then Load
                                  (LoadByteLiteral(true,(add,(Rt,imm32))))
                         else Load(LoadLiteral(add,(Rt,imm32)))
                       end
                     )
              else Skip ()
            end
          | (false,
           (true,
            (false,
             (P'0,
              (U'0,
               (B'0,
                (W'0,
                 (true,
                  (Rn'3,
                   (Rn'2,
                    (Rn'1,
                     (Rn'0,
                      (Rt'3,
                       (Rt'2,
                        (Rt'1,
                         (Rt'0,
                          (imm12'11,
                           (imm12'10,
                            (imm12'9,
                             (imm12'8,
                              (imm12'7,
                               (imm12'6,
                                (imm12'5,
                                 (imm12'4,
                                  (imm12'3,(imm12'2,(imm12'1,imm12'0))))))))))))))))))))))))))) =>
            let
              val Rt = BitsN.fromBitstring([Rt'3,Rt'2,Rt'1,Rt'0],4)
              val Rn = BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)
              val B = BitsN.fromBitstring([B'0],1)
              val P = BitsN.fromBitstring([P'0],1)
            in
              if Do(cond,true)
                then let
                       val wback =
                         (P = (BitsN.B(0x0,1))) orelse
                         ((BitsN.fromBitstring([W'0],1)) =
                          (BitsN.B(0x1,1)))
                     in
                       ( if ((B = (BitsN.B(0x1,1))) andalso
                             (Rt = (BitsN.B(0xF,4)))) orelse
                            (wback andalso (Rn = Rt))
                           then DECODE_UNPREDICTABLE
                                  (mc,"LoadWord/Byte (immediate)")
                         else ()
                       ; let
                           val add =
                             (BitsN.fromBitstring([U'0],1)) =
                             (BitsN.B(0x1,1))
                           val index = P = (BitsN.B(0x1,1))
                           val imm32 =
                             BitsN.zeroExtend 32
                               (BitsN.fromBitstring
                                  ([imm12'11,imm12'10,imm12'9,imm12'8,
                                    imm12'7,imm12'6,imm12'5,imm12'4,
                                    imm12'3,imm12'2,imm12'1,imm12'0],12))
                           val m = immediate_form1 imm32
                         in
                           if B = (BitsN.B(0x1,1))
                             then Load
                                    (LoadByte
                                       (true,
                                        (add,(index,(wback,(Rt,(Rn,m)))))))
                           else Load
                                  (LoadWord
                                     (add,(index,(wback,(Rt,(Rn,m))))))
                         end
                       )
                     end
              else Skip ()
            end
          | (false,
           (true,
            (true,
             (false,
              (U'0,
               (B'0,
                (true,
                 (false,
                  (Rn'3,
                   (Rn'2,
                    (Rn'1,
                     (Rn'0,
                      (Rt'3,
                       (Rt'2,
                        (Rt'1,
                         (Rt'0,
                          (imm5'4,
                           (imm5'3,
                            (imm5'2,
                             (imm5'1,
                              (imm5'0,
                               (typ'1,
                                (typ'0,(false,(Rm'3,(Rm'2,(Rm'1,Rm'0))))))))))))))))))))))))))) =>
            let
              val Rm = BitsN.fromBitstring([Rm'3,Rm'2,Rm'1,Rm'0],4)
              val Rt = BitsN.fromBitstring([Rt'3,Rt'2,Rt'1,Rt'0],4)
              val Rn = BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)
              val B = BitsN.fromBitstring([B'0],1)
            in
              if Do(cond,true)
                then ( if ((B = (BitsN.B(0x1,1))) andalso
                           (Rt = (BitsN.B(0xF,4)))) orelse
                          ((Rn = (BitsN.B(0xF,4))) orelse
                           ((Rn = Rt) orelse
                            ((Rm = (BitsN.B(0xF,4))) orelse
                             ((Nat.<(ArchVersion (),6)) andalso (Rm = Rn)))))
                         then DECODE_UNPREDICTABLE
                                (mc,"StoreUnprivileged (regiser)")
                       else ()
                     ; let
                         val add =
                           (BitsN.fromBitstring([U'0],1)) =
                           (BitsN.B(0x1,1))
                         val postindex = true
                         val (shift_t,shift_n) =
                           DecodeImmShift
                             (BitsN.fromBitstring([typ'1,typ'0],2),
                              BitsN.fromBitstring
                                ([imm5'4,imm5'3,imm5'2,imm5'1,imm5'0],5))
                         val m = register_form1(Rm,(shift_t,shift_n))
                       in
                         if B = (BitsN.B(0x1,1))
                           then Store
                                  (StoreByteUnprivileged
                                     (add,(postindex,(Rt,(Rn,m)))))
                         else Store
                                (StoreUnprivileged
                                   (add,(postindex,(Rt,(Rn,m)))))
                       end
                     )
              else Skip ()
            end
          | (false,
           (true,
            (true,
             (P'0,
              (U'0,
               (B'0,
                (W'0,
                 (false,
                  (Rn'3,
                   (Rn'2,
                    (Rn'1,
                     (Rn'0,
                      (Rt'3,
                       (Rt'2,
                        (Rt'1,
                         (Rt'0,
                          (imm5'4,
                           (imm5'3,
                            (imm5'2,
                             (imm5'1,
                              (imm5'0,
                               (typ'1,
                                (typ'0,(false,(Rm'3,(Rm'2,(Rm'1,Rm'0))))))))))))))))))))))))))) =>
            let
              val Rm = BitsN.fromBitstring([Rm'3,Rm'2,Rm'1,Rm'0],4)
              val Rt = BitsN.fromBitstring([Rt'3,Rt'2,Rt'1,Rt'0],4)
              val Rn = BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)
              val B = BitsN.fromBitstring([B'0],1)
              val P = BitsN.fromBitstring([P'0],1)
            in
              if Do(cond,true)
                then let
                       val wback =
                         (P = (BitsN.B(0x0,1))) orelse
                         ((BitsN.fromBitstring([W'0],1)) =
                          (BitsN.B(0x1,1)))
                     in
                       ( if ((B = (BitsN.B(0x1,1))) andalso
                             (Rt = (BitsN.B(0xF,4)))) orelse
                            ((Rm = (BitsN.B(0xF,4))) orelse
                             ((wback andalso
                               ((Rn = (BitsN.B(0xF,4))) orelse (Rn = Rt))) orelse
                              ((Nat.<(ArchVersion (),6)) andalso
                               (wback andalso (Rm = Rn)))))
                           then DECODE_UNPREDICTABLE(mc,"Store (regiser)")
                         else ()
                       ; let
                           val add =
                             (BitsN.fromBitstring([U'0],1)) =
                             (BitsN.B(0x1,1))
                           val index = P = (BitsN.B(0x1,1))
                           val (shift_t,shift_n) =
                             DecodeImmShift
                               (BitsN.fromBitstring([typ'1,typ'0],2),
                                BitsN.fromBitstring
                                  ([imm5'4,imm5'3,imm5'2,imm5'1,imm5'0],5))
                           val m = register_form1(Rm,(shift_t,shift_n))
                         in
                           if B = (BitsN.B(0x1,1))
                             then Store
                                    (StoreByte
                                       (add,(index,(wback,(Rt,(Rn,m))))))
                           else Store
                                  (StoreWord
                                     (add,(index,(wback,(Rt,(Rn,m))))))
                         end
                       )
                     end
              else Skip ()
            end
          | (false,
           (true,
            (true,
             (false,
              (U'0,
               (B'0,
                (true,
                 (true,
                  (Rn'3,
                   (Rn'2,
                    (Rn'1,
                     (Rn'0,
                      (Rt'3,
                       (Rt'2,
                        (Rt'1,
                         (Rt'0,
                          (imm5'4,
                           (imm5'3,
                            (imm5'2,
                             (imm5'1,
                              (imm5'0,
                               (typ'1,
                                (typ'0,(false,(Rm'3,(Rm'2,(Rm'1,Rm'0))))))))))))))))))))))))))) =>
            let
              val Rm = BitsN.fromBitstring([Rm'3,Rm'2,Rm'1,Rm'0],4)
              val Rt = BitsN.fromBitstring([Rt'3,Rt'2,Rt'1,Rt'0],4)
              val Rn = BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)
            in
              if Do(cond,true)
                then ( if (Rt = (BitsN.B(0xF,4))) orelse
                          ((Rn = (BitsN.B(0xF,4))) orelse
                           ((Rn = Rt) orelse
                            ((Rm = (BitsN.B(0xF,4))) orelse
                             ((Nat.<(ArchVersion (),6)) andalso (Rm = Rn)))))
                         then DECODE_UNPREDICTABLE
                                (mc,"LoadUnprivileged (regiser)")
                       else ()
                     ; let
                         val add =
                           (BitsN.fromBitstring([U'0],1)) =
                           (BitsN.B(0x1,1))
                         val postindex = true
                         val (shift_t,shift_n) =
                           DecodeImmShift
                             (BitsN.fromBitstring([typ'1,typ'0],2),
                              BitsN.fromBitstring
                                ([imm5'4,imm5'3,imm5'2,imm5'1,imm5'0],5))
                         val m = register_form1(Rm,(shift_t,shift_n))
                       in
                         if (BitsN.fromBitstring([B'0],1)) =
                            (BitsN.B(0x1,1))
                           then Load
                                  (LoadByteUnprivileged
                                     (add,(postindex,(Rt,(Rn,m)))))
                         else Load
                                (LoadUnprivileged
                                   (add,(postindex,(Rt,(Rn,m)))))
                       end
                     )
              else Skip ()
            end
          | (false,
           (true,
            (true,
             (P'0,
              (U'0,
               (B'0,
                (W'0,
                 (true,
                  (Rn'3,
                   (Rn'2,
                    (Rn'1,
                     (Rn'0,
                      (Rt'3,
                       (Rt'2,
                        (Rt'1,
                         (Rt'0,
                          (imm5'4,
                           (imm5'3,
                            (imm5'2,
                             (imm5'1,
                              (imm5'0,
                               (typ'1,
                                (typ'0,(false,(Rm'3,(Rm'2,(Rm'1,Rm'0))))))))))))))))))))))))))) =>
            let
              val Rm = BitsN.fromBitstring([Rm'3,Rm'2,Rm'1,Rm'0],4)
              val Rt = BitsN.fromBitstring([Rt'3,Rt'2,Rt'1,Rt'0],4)
              val Rn = BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)
              val B = BitsN.fromBitstring([B'0],1)
              val P = BitsN.fromBitstring([P'0],1)
            in
              if Do(cond,true)
                then let
                       val wback =
                         (P = (BitsN.B(0x0,1))) orelse
                         ((BitsN.fromBitstring([W'0],1)) =
                          (BitsN.B(0x1,1)))
                     in
                       ( if ((B = (BitsN.B(0x1,1))) andalso
                             (Rt = (BitsN.B(0xF,4)))) orelse
                            ((Rm = (BitsN.B(0xF,4))) orelse
                             ((wback andalso
                               ((Rn = (BitsN.B(0xF,4))) orelse (Rn = Rt))) orelse
                              ((Nat.<(ArchVersion (),6)) andalso
                               (wback andalso (Rm = Rn)))))
                           then DECODE_UNPREDICTABLE
                                  (mc,"LoadWord/Byte (regiser)")
                         else ()
                       ; let
                           val add =
                             (BitsN.fromBitstring([U'0],1)) =
                             (BitsN.B(0x1,1))
                           val index = P = (BitsN.B(0x1,1))
                           val (shift_t,shift_n) =
                             DecodeImmShift
                               (BitsN.fromBitstring([typ'1,typ'0],2),
                                BitsN.fromBitstring
                                  ([imm5'4,imm5'3,imm5'2,imm5'1,imm5'0],5))
                           val m = register_form1(Rm,(shift_t,shift_n))
                         in
                           if B = (BitsN.B(0x1,1))
                             then Load
                                    (LoadByte
                                       (true,
                                        (add,(index,(wback,(Rt,(Rn,m)))))))
                           else Load
                                  (LoadWord
                                     (add,(index,(wback,(Rt,(Rn,m))))))
                         end
                       )
                     end
              else Skip ()
            end
          | (false,
           (true,
            (true,
             (false,
              (false,
               (U'0,
                (op1'1,
                 (op1'0,
                  (Rn'3,
                   (Rn'2,
                    (Rn'1,
                     (Rn'0,
                      (Rd'3,
                       (Rd'2,
                        (Rd'1,
                         (Rd'0,
                          (_,
                           (_,
                            (_,
                             (_,
                              (op2'2,
                               (op2'1,
                                (op2'0,(true,(Rm'3,(Rm'2,(Rm'1,Rm'0))))))))))))))))))))))))))) =>
            let
              val Rm = BitsN.fromBitstring([Rm'3,Rm'2,Rm'1,Rm'0],4)
              val Rd = BitsN.fromBitstring([Rd'3,Rd'2,Rd'1,Rd'0],4)
              val Rn = BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)
            in
              if Do(cond,Nat.>=(ArchVersion (),6))
                then ( if (Rd = (BitsN.B(0xF,4))) orelse
                          ((Rn = (BitsN.B(0xF,4))) orelse
                           (Rm = (BitsN.B(0xF,4))))
                         then DECODE_UNPREDICTABLE
                                (mc,"Parallel addition and subtraction")
                       else ()
                     ; DecodeParallelAdditionSubtraction
                         (BitsN.fromBitstring([op1'1,op1'0],2),
                          (BitsN.fromBitstring([op2'2,op2'1,op2'0],3),
                           (BitsN.fromBitstring([U'0],1),(Rd,(Rn,Rm)))))
                     )
              else Skip ()
            end
          | (false,
           (true,
            (true,
             (false,
              (true,
               (false,
                (false,
                 (false,
                  (Rn'3,
                   (Rn'2,
                    (Rn'1,
                     (Rn'0,
                      (Rd'3,
                       (Rd'2,
                        (Rd'1,
                         (Rd'0,
                          (imm5'4,
                           (imm5'3,
                            (imm5'2,
                             (imm5'1,
                              (imm5'0,
                               (tb'0,
                                (false,(true,(Rm'3,(Rm'2,(Rm'1,Rm'0))))))))))))))))))))))))))) =>
            let
              val Rm = BitsN.fromBitstring([Rm'3,Rm'2,Rm'1,Rm'0],4)
              val tb = BitsN.fromBitstring([tb'0],1)
              val Rd = BitsN.fromBitstring([Rd'3,Rd'2,Rd'1,Rd'0],4)
              val Rn = BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)
            in
              if Do(cond,Nat.>=(ArchVersion (),6))
                then ( if (Rd = (BitsN.B(0xF,4))) orelse
                          ((Rn = (BitsN.B(0xF,4))) orelse
                           (Rm = (BitsN.B(0xF,4))))
                         then DECODE_UNPREDICTABLE(mc,"PackHalfword")
                       else ()
                     ; let
                         val tbform = tb = (BitsN.B(0x1,1))
                         val (shift_t,shift_n) =
                           DecodeImmShift
                             (BitsN.@@(tb,BitsN.B(0x0,1)),
                              BitsN.fromBitstring
                                ([imm5'4,imm5'3,imm5'2,imm5'1,imm5'0],5))
                       in
                         Media
                           (PackHalfword
                              (shift_t,(shift_n,(tbform,(Rd,(Rn,Rm))))))
                       end
                     )
              else Skip ()
            end
          | (false,
           (true,
            (true,
             (false,
              (true,
               (false,
                (false,
                 (false,
                  (Rn'3,
                   (Rn'2,
                    (Rn'1,
                     (Rn'0,
                      (Rd'3,
                       (Rd'2,
                        (Rd'1,
                         (Rd'0,
                          (_,
                           (_,
                            (_,
                             (_,
                              (true,
                               (false,
                                (true,(true,(Rm'3,(Rm'2,(Rm'1,Rm'0))))))))))))))))))))))))))) =>
            let
              val Rm = BitsN.fromBitstring([Rm'3,Rm'2,Rm'1,Rm'0],4)
              val Rd = BitsN.fromBitstring([Rd'3,Rd'2,Rd'1,Rd'0],4)
              val Rn = BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)
            in
              if Do(cond,Nat.>=(ArchVersion (),6))
                then ( if (Rd = (BitsN.B(0xF,4))) orelse
                          ((Rn = (BitsN.B(0xF,4))) orelse
                           (Rm = (BitsN.B(0xF,4))))
                         then DECODE_UNPREDICTABLE(mc,"SelectBytes")
                       else ()
                     ; Media(SelectBytes(Rd,(Rn,Rm)))
                     )
              else Skip ()
            end
          | (false,
           (true,
            (true,
             (false,
              (true,
               (U'0,
                (true,
                 (sat_imm'4,
                  (sat_imm'3,
                   (sat_imm'2,
                    (sat_imm'1,
                     (sat_imm'0,
                      (Rd'3,
                       (Rd'2,
                        (Rd'1,
                         (Rd'0,
                          (imm5'4,
                           (imm5'3,
                            (imm5'2,
                             (imm5'1,
                              (imm5'0,
                               (sh'0,
                                (false,(true,(Rn'3,(Rn'2,(Rn'1,Rn'0))))))))))))))))))))))))))) =>
            let
              val Rn = BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)
              val Rd = BitsN.fromBitstring([Rd'3,Rd'2,Rd'1,Rd'0],4)
              val sat_imm =
                BitsN.fromBitstring
                  ([sat_imm'4,sat_imm'3,sat_imm'2,sat_imm'1,sat_imm'0],5)
            in
              if Do(cond,Nat.>=(ArchVersion (),6))
                then ( if (Rd = (BitsN.B(0xF,4))) orelse
                          (Rn = (BitsN.B(0xF,4)))
                         then DECODE_UNPREDICTABLE(mc,"Saturate")
                       else ()
                     ; let
                         val unsigned =
                           (BitsN.fromBitstring([U'0],1)) =
                           (BitsN.B(0x1,1))
                         val saturate_to =
                           if unsigned
                             then BitsN.toNat sat_imm
                           else Nat.+(BitsN.toNat sat_imm,1)
                         val (shift_t,shift_n) =
                           DecodeImmShift
                             (BitsN.@@
                                (BitsN.fromBitstring([sh'0],1),
                                 BitsN.B(0x0,1)),
                              BitsN.fromBitstring
                                ([imm5'4,imm5'3,imm5'2,imm5'1,imm5'0],5))
                       in
                         Media
                           (Saturate
                              (shift_t,
                               (shift_n,(saturate_to,(unsigned,(Rd,Rn))))))
                       end
                     )
              else Skip ()
            end
          | (false,
           (true,
            (true,
             (false,
              (true,
               (U'0,
                (true,
                 (false,
                  (sat_imm'3,
                   (sat_imm'2,
                    (sat_imm'1,
                     (sat_imm'0,
                      (Rd'3,
                       (Rd'2,
                        (Rd'1,
                         (Rd'0,
                          (_,
                           (_,
                            (_,
                             (_,
                              (false,
                               (false,
                                (true,(true,(Rn'3,(Rn'2,(Rn'1,Rn'0))))))))))))))))))))))))))) =>
            let
              val Rn = BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)
              val Rd = BitsN.fromBitstring([Rd'3,Rd'2,Rd'1,Rd'0],4)
              val sat_imm =
                BitsN.fromBitstring
                  ([sat_imm'3,sat_imm'2,sat_imm'1,sat_imm'0],4)
            in
              if Do(cond,Nat.>=(ArchVersion (),6))
                then ( if (Rd = (BitsN.B(0xF,4))) orelse
                          (Rn = (BitsN.B(0xF,4)))
                         then DECODE_UNPREDICTABLE(mc,"Saturate16")
                       else ()
                     ; let
                         val unsigned =
                           (BitsN.fromBitstring([U'0],1)) =
                           (BitsN.B(0x1,1))
                         val saturate_to =
                           if unsigned
                             then BitsN.toNat sat_imm
                           else Nat.+(BitsN.toNat sat_imm,1)
                       in
                         Media(Saturate16(saturate_to,(unsigned,(Rd,Rn))))
                       end
                     )
              else Skip ()
            end
          | (false,
           (true,
            (true,
             (false,
              (true,
               (U'0,
                (false,
                 (false,
                  (Rn'3,
                   (Rn'2,
                    (Rn'1,
                     (Rn'0,
                      (Rd'3,
                       (Rd'2,
                        (Rd'1,
                         (Rd'0,
                          (rotate'1,
                           (rotate'0,
                            (_,
                             (_,
                              (false,
                               (true,
                                (true,(true,(Rm'3,(Rm'2,(Rm'1,Rm'0))))))))))))))))))))))))))) =>
            let
              val Rm = BitsN.fromBitstring([Rm'3,Rm'2,Rm'1,Rm'0],4)
              val Rd = BitsN.fromBitstring([Rd'3,Rd'2,Rd'1,Rd'0],4)
            in
              if Do(cond,Nat.>=(ArchVersion (),6))
                then ( if (Rd = (BitsN.B(0xF,4))) orelse
                          (Rm = (BitsN.B(0xF,4)))
                         then DECODE_UNPREDICTABLE(mc,"ExtendByte16")
                       else ()
                     ; let
                         val unsigned =
                           (BitsN.fromBitstring([U'0],1)) =
                           (BitsN.B(0x1,1))
                         val rotation =
                           BitsN.toNat
                             (BitsN.@@
                                (BitsN.fromBitstring
                                   ([rotate'1,rotate'0],2),BitsN.B(0x0,3)))
                       in
                         Media
                           (ExtendByte16
                              (unsigned,
                               (Rd,
                                (BitsN.fromBitstring
                                   ([Rn'3,Rn'2,Rn'1,Rn'0],4),(Rm,rotation)))))
                       end
                     )
              else Skip ()
            end
          | (false,
           (true,
            (true,
             (false,
              (true,
               (U'0,
                (true,
                 (false,
                  (Rn'3,
                   (Rn'2,
                    (Rn'1,
                     (Rn'0,
                      (Rd'3,
                       (Rd'2,
                        (Rd'1,
                         (Rd'0,
                          (rotate'1,
                           (rotate'0,
                            (_,
                             (_,
                              (false,
                               (true,
                                (true,(true,(Rm'3,(Rm'2,(Rm'1,Rm'0))))))))))))))))))))))))))) =>
            let
              val Rm = BitsN.fromBitstring([Rm'3,Rm'2,Rm'1,Rm'0],4)
              val Rd = BitsN.fromBitstring([Rd'3,Rd'2,Rd'1,Rd'0],4)
            in
              if Do(cond,Nat.>=(ArchVersion (),6))
                then ( if (Rd = (BitsN.B(0xF,4))) orelse
                          (Rm = (BitsN.B(0xF,4)))
                         then DECODE_UNPREDICTABLE(mc,"ExtendByte")
                       else ()
                     ; let
                         val unsigned =
                           (BitsN.fromBitstring([U'0],1)) =
                           (BitsN.B(0x1,1))
                         val rotation =
                           BitsN.toNat
                             (BitsN.@@
                                (BitsN.fromBitstring
                                   ([rotate'1,rotate'0],2),BitsN.B(0x0,3)))
                       in
                         Media
                           (ExtendByte
                              (unsigned,
                               (Rd,
                                (BitsN.fromBitstring
                                   ([Rn'3,Rn'2,Rn'1,Rn'0],4),(Rm,rotation)))))
                       end
                     )
              else Skip ()
            end
          | (false,
           (true,
            (true,
             (false,
              (true,
               (U'0,
                (true,
                 (true,
                  (Rn'3,
                   (Rn'2,
                    (Rn'1,
                     (Rn'0,
                      (Rd'3,
                       (Rd'2,
                        (Rd'1,
                         (Rd'0,
                          (rotate'1,
                           (rotate'0,
                            (_,
                             (_,
                              (false,
                               (true,
                                (true,(true,(Rm'3,(Rm'2,(Rm'1,Rm'0))))))))))))))))))))))))))) =>
            let
              val Rm = BitsN.fromBitstring([Rm'3,Rm'2,Rm'1,Rm'0],4)
              val Rd = BitsN.fromBitstring([Rd'3,Rd'2,Rd'1,Rd'0],4)
            in
              if Do(cond,Nat.>=(ArchVersion (),6))
                then ( if (Rd = (BitsN.B(0xF,4))) orelse
                          (Rm = (BitsN.B(0xF,4)))
                         then DECODE_UNPREDICTABLE(mc,"ExtendHalfword")
                       else ()
                     ; let
                         val unsigned =
                           (BitsN.fromBitstring([U'0],1)) =
                           (BitsN.B(0x1,1))
                         val rotation =
                           BitsN.toNat
                             (BitsN.@@
                                (BitsN.fromBitstring
                                   ([rotate'1,rotate'0],2),BitsN.B(0x0,3)))
                       in
                         Media
                           (ExtendHalfword
                              (unsigned,
                               (Rd,
                                (BitsN.fromBitstring
                                   ([Rn'3,Rn'2,Rn'1,Rn'0],4),(Rm,rotation)))))
                       end
                     )
              else Skip ()
            end
          | (false,
           (true,
            (true,
             (false,
              (true,
               (false,
                (true,
                 (true,
                  (_,
                   (_,
                    (_,
                     (_,
                      (Rd'3,
                       (Rd'2,
                        (Rd'1,
                         (Rd'0,
                          (_,
                           (_,
                            (_,
                             (_,
                              (false,
                               (false,
                                (true,(true,(Rm'3,(Rm'2,(Rm'1,Rm'0))))))))))))))))))))))))))) =>
            let
              val Rm = BitsN.fromBitstring([Rm'3,Rm'2,Rm'1,Rm'0],4)
              val Rd = BitsN.fromBitstring([Rd'3,Rd'2,Rd'1,Rd'0],4)
            in
              if Do(cond,Nat.>=(ArchVersion (),6))
                then ( if (Rd = (BitsN.B(0xF,4))) orelse
                          (Rm = (BitsN.B(0xF,4)))
                         then DECODE_UNPREDICTABLE(mc,"ByteReverse")
                       else ()
                     ; Media(ByteReverse(Rd,Rm))
                     )
              else Skip ()
            end
          | (false,
           (true,
            (true,
             (false,
              (true,
               (false,
                (true,
                 (true,
                  (_,
                   (_,
                    (_,
                     (_,
                      (Rd'3,
                       (Rd'2,
                        (Rd'1,
                         (Rd'0,
                          (_,
                           (_,
                            (_,
                             (_,
                              (true,
                               (false,
                                (true,(true,(Rm'3,(Rm'2,(Rm'1,Rm'0))))))))))))))))))))))))))) =>
            let
              val Rm = BitsN.fromBitstring([Rm'3,Rm'2,Rm'1,Rm'0],4)
              val Rd = BitsN.fromBitstring([Rd'3,Rd'2,Rd'1,Rd'0],4)
            in
              if Do(cond,Nat.>=(ArchVersion (),6))
                then ( if (Rd = (BitsN.B(0xF,4))) orelse
                          (Rm = (BitsN.B(0xF,4)))
                         then DECODE_UNPREDICTABLE
                                (mc,"ByteReversePackedHalfword")
                       else ()
                     ; Media(ByteReversePackedHalfword(Rd,Rm))
                     )
              else Skip ()
            end
          | (false,
           (true,
            (true,
             (false,
              (true,
               (true,
                (true,
                 (true,
                  (_,
                   (_,
                    (_,
                     (_,
                      (Rd'3,
                       (Rd'2,
                        (Rd'1,
                         (Rd'0,
                          (_,
                           (_,
                            (_,
                             (_,
                              (true,
                               (false,
                                (true,(true,(Rm'3,(Rm'2,(Rm'1,Rm'0))))))))))))))))))))))))))) =>
            let
              val Rm = BitsN.fromBitstring([Rm'3,Rm'2,Rm'1,Rm'0],4)
              val Rd = BitsN.fromBitstring([Rd'3,Rd'2,Rd'1,Rd'0],4)
            in
              if Do(cond,Nat.>=(ArchVersion (),6))
                then ( if (Rd = (BitsN.B(0xF,4))) orelse
                          (Rm = (BitsN.B(0xF,4)))
                         then DECODE_UNPREDICTABLE
                                (mc,"ByteReverseSignedHalfword")
                       else ()
                     ; Media(ByteReverseSignedHalfword(Rd,Rm))
                     )
              else Skip ()
            end
          | (false,
           (true,
            (true,
             (false,
              (true,
               (true,
                (true,
                 (true,
                  (_,
                   (_,
                    (_,
                     (_,
                      (Rd'3,
                       (Rd'2,
                        (Rd'1,
                         (Rd'0,
                          (_,
                           (_,
                            (_,
                             (_,
                              (false,
                               (false,
                                (true,(true,(Rm'3,(Rm'2,(Rm'1,Rm'0))))))))))))))))))))))))))) =>
            let
              val Rm = BitsN.fromBitstring([Rm'3,Rm'2,Rm'1,Rm'0],4)
              val Rd = BitsN.fromBitstring([Rd'3,Rd'2,Rd'1,Rd'0],4)
            in
              if Do(cond,Nat.>=(ArchVersion (),6))
                then ( if (Rd = (BitsN.B(0xF,4))) orelse
                          (Rm = (BitsN.B(0xF,4)))
                         then DECODE_UNPREDICTABLE(mc,"ReverseBits")
                       else ()
                     ; Media(ReverseBits(Rd,Rm))
                     )
              else Skip ()
            end
          | (false,
           (true,
            (true,
             (true,
              (false,
               (false,
                (false,
                 (false,
                  (Rd'3,
                   (Rd'2,
                    (Rd'1,
                     (Rd'0,
                      (Ra'3,
                       (Ra'2,
                        (Ra'1,
                         (Ra'0,
                          (Rm'3,
                           (Rm'2,
                            (Rm'1,
                             (Rm'0,
                              (false,
                               (S'0,(M'0,(true,(Rn'3,(Rn'2,(Rn'1,Rn'0))))))))))))))))))))))))))) =>
            let
              val Rn = BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)
              val Rm = BitsN.fromBitstring([Rm'3,Rm'2,Rm'1,Rm'0],4)
              val Rd = BitsN.fromBitstring([Rd'3,Rd'2,Rd'1,Rd'0],4)
            in
              if Do(cond,Nat.>=(ArchVersion (),6))
                then ( if (Rd = (BitsN.B(0xF,4))) orelse
                          ((Rn = (BitsN.B(0xF,4))) orelse
                           (Rm = (BitsN.B(0xF,4))))
                         then DECODE_UNPREDICTABLE
                                (mc,"SignedMultiplyDual")
                       else ()
                     ; let
                         val sub =
                           (BitsN.fromBitstring([S'0],1)) =
                           (BitsN.B(0x1,1))
                         val m_swap =
                           (BitsN.fromBitstring([M'0],1)) =
                           (BitsN.B(0x1,1))
                       in
                         Multiply
                           (SignedMultiplyDual
                              (sub,
                               (m_swap,
                                (Rd,
                                 (Rn,
                                  (Rm,
                                   BitsN.fromBitstring
                                     ([Ra'3,Ra'2,Ra'1,Ra'0],4)))))))
                       end
                     )
              else Skip ()
            end
          | (false,
           (true,
            (true,
             (true,
              (false,
               (true,
                (false,
                 (false,
                  (RdHi'3,
                   (RdHi'2,
                    (RdHi'1,
                     (RdHi'0,
                      (RdLo'3,
                       (RdLo'2,
                        (RdLo'1,
                         (RdLo'0,
                          (Rm'3,
                           (Rm'2,
                            (Rm'1,
                             (Rm'0,
                              (false,
                               (S'0,(M'0,(true,(Rn'3,(Rn'2,(Rn'1,Rn'0))))))))))))))))))))))))))) =>
            let
              val Rn = BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)
              val Rm = BitsN.fromBitstring([Rm'3,Rm'2,Rm'1,Rm'0],4)
              val RdLo =
                BitsN.fromBitstring([RdLo'3,RdLo'2,RdLo'1,RdLo'0],4)
              val RdHi =
                BitsN.fromBitstring([RdHi'3,RdHi'2,RdHi'1,RdHi'0],4)
            in
              if Do(cond,Nat.>=(ArchVersion (),6))
                then ( if (RdLo = (BitsN.B(0xF,4))) orelse
                          ((RdHi = (BitsN.B(0xF,4))) orelse
                           ((Rn = (BitsN.B(0xF,4))) orelse
                            (Rm = (BitsN.B(0xF,4)))))
                         then DECODE_UNPREDICTABLE
                                (mc,"SignedMultiplyLongDual")
                       else ()
                     ; let
                         val sub =
                           (BitsN.fromBitstring([S'0],1)) =
                           (BitsN.B(0x1,1))
                         val m_swap =
                           (BitsN.fromBitstring([M'0],1)) =
                           (BitsN.B(0x1,1))
                       in
                         Multiply
                           (SignedMultiplyLongDual
                              (sub,(m_swap,(RdHi,(RdLo,(Rn,Rm))))))
                       end
                     )
              else Skip ()
            end
          | (false,
           (true,
            (true,
             (true,
              (false,
               (true,
                (false,
                 (true,
                  (Rd'3,
                   (Rd'2,
                    (Rd'1,
                     (Rd'0,
                      (Ra'3,
                       (Ra'2,
                        (Ra'1,
                         (Ra'0,
                          (Rm'3,
                           (Rm'2,
                            (Rm'1,
                             (Rm'0,
                              (false,
                               (false,
                                (R'0,(true,(Rn'3,(Rn'2,(Rn'1,Rn'0))))))))))))))))))))))))))) =>
            let
              val Rn = BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)
              val Rm = BitsN.fromBitstring([Rm'3,Rm'2,Rm'1,Rm'0],4)
              val Rd = BitsN.fromBitstring([Rd'3,Rd'2,Rd'1,Rd'0],4)
            in
              if Do(cond,Nat.>=(ArchVersion (),6))
                then ( if (Rd = (BitsN.B(0xF,4))) orelse
                          ((Rn = (BitsN.B(0xF,4))) orelse
                           (Rm = (BitsN.B(0xF,4))))
                         then DECODE_UNPREDICTABLE
                                (mc,"SignedMostSignificantMultiply")
                       else ()
                     ; let
                         val round =
                           (BitsN.fromBitstring([R'0],1)) =
                           (BitsN.B(0x1,1))
                       in
                         Multiply
                           (SignedMostSignificantMultiply
                              (round,
                               (Rd,
                                (Rn,
                                 (Rm,
                                  BitsN.fromBitstring
                                    ([Ra'3,Ra'2,Ra'1,Ra'0],4))))))
                       end
                     )
              else Skip ()
            end
          | (false,
           (true,
            (true,
             (true,
              (false,
               (true,
                (false,
                 (true,
                  (Rd'3,
                   (Rd'2,
                    (Rd'1,
                     (Rd'0,
                      (Ra'3,
                       (Ra'2,
                        (Ra'1,
                         (Ra'0,
                          (Rm'3,
                           (Rm'2,
                            (Rm'1,
                             (Rm'0,
                              (true,
                               (true,
                                (R'0,(true,(Rn'3,(Rn'2,(Rn'1,Rn'0))))))))))))))))))))))))))) =>
            let
              val Rn = BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)
              val Rm = BitsN.fromBitstring([Rm'3,Rm'2,Rm'1,Rm'0],4)
              val Ra = BitsN.fromBitstring([Ra'3,Ra'2,Ra'1,Ra'0],4)
              val Rd = BitsN.fromBitstring([Rd'3,Rd'2,Rd'1,Rd'0],4)
            in
              if Do(cond,Nat.>=(ArchVersion (),6))
                then ( if (Rd = (BitsN.B(0xF,4))) orelse
                          ((Rn = (BitsN.B(0xF,4))) orelse
                           ((Rm = (BitsN.B(0xF,4))) orelse
                            (Ra = (BitsN.B(0xF,4)))))
                         then DECODE_UNPREDICTABLE
                                (mc,
                                 "SignedMostSignificantMultiplySubtract")
                       else ()
                     ; let
                         val round =
                           (BitsN.fromBitstring([R'0],1)) =
                           (BitsN.B(0x1,1))
                       in
                         Multiply
                           (SignedMostSignificantMultiplySubtract
                              (round,(Rd,(Rn,(Rm,Ra)))))
                       end
                     )
              else Skip ()
            end
          | (false,
           (true,
            (true,
             (true,
              (true,
               (false,
                (false,
                 (false,
                  (Rd'3,
                   (Rd'2,
                    (Rd'1,
                     (Rd'0,
                      (Ra'3,
                       (Ra'2,
                        (Ra'1,
                         (Ra'0,
                          (Rm'3,
                           (Rm'2,
                            (Rm'1,
                             (Rm'0,
                              (false,
                               (false,
                                (false,(true,(Rn'3,(Rn'2,(Rn'1,Rn'0))))))))))))))))))))))))))) =>
            let
              val Rn = BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)
              val Rm = BitsN.fromBitstring([Rm'3,Rm'2,Rm'1,Rm'0],4)
              val Rd = BitsN.fromBitstring([Rd'3,Rd'2,Rd'1,Rd'0],4)
            in
              if Do(cond,Nat.>=(ArchVersion (),6))
                then ( if (Rd = (BitsN.B(0xF,4))) orelse
                          ((Rn = (BitsN.B(0xF,4))) orelse
                           (Rm = (BitsN.B(0xF,4))))
                         then DECODE_UNPREDICTABLE
                                (mc,"UnsignedSumAbsoluteDifferences")
                       else ()
                     ; SIMD
                         (UnsignedSumAbsoluteDifferences
                            (Rd,
                             (Rn,
                              (Rm,
                               BitsN.fromBitstring
                                 ([Ra'3,Ra'2,Ra'1,Ra'0],4)))))
                     )
              else Skip ()
            end
          | (false,
           (true,
            (true,
             (true,
              (true,
               (U'0,
                (true,
                 (widthm1'4,
                  (widthm1'3,
                   (widthm1'2,
                    (widthm1'1,
                     (widthm1'0,
                      (Rd'3,
                       (Rd'2,
                        (Rd'1,
                         (Rd'0,
                          (lsb'4,
                           (lsb'3,
                            (lsb'2,
                             (lsb'1,
                              (lsb'0,
                               (true,
                                (false,(true,(Rn'3,(Rn'2,(Rn'1,Rn'0))))))))))))))))))))))))))) =>
            let
              val Rn = BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)
              val Rd = BitsN.fromBitstring([Rd'3,Rd'2,Rd'1,Rd'0],4)
            in
              if Do(cond,Nat.>=(ArchVersion (),6))
                then let
                       val lsbit =
                         BitsN.toNat
                           (BitsN.fromBitstring
                              ([lsb'4,lsb'3,lsb'2,lsb'1,lsb'0],5))
                       val widthminus1 =
                         BitsN.toNat
                           (BitsN.fromBitstring
                              ([widthm1'4,widthm1'3,widthm1'2,widthm1'1,
                                widthm1'0],5))
                     in
                       ( if (Rd = (BitsN.B(0xF,4))) orelse
                            ((Rn = (BitsN.B(0xF,4))) orelse
                             (Nat.<(31,Nat.+(lsbit,widthminus1))))
                           then DECODE_UNPREDICTABLE(mc,"BitFieldExtract")
                         else ()
                       ; let
                           val unsigned =
                             (BitsN.fromBitstring([U'0],1)) =
                             (BitsN.B(0x1,1))
                         in
                           Media
                             (BitFieldExtract
                                (unsigned,(Rd,(Rn,(lsbit,widthminus1)))))
                         end
                       )
                     end
              else Skip ()
            end
          | (false,
           (true,
            (true,
             (true,
              (true,
               (true,
                (false,
                 (msb'4,
                  (msb'3,
                   (msb'2,
                    (msb'1,
                     (msb'0,
                      (Rd'3,
                       (Rd'2,
                        (Rd'1,
                         (Rd'0,
                          (lsb'4,
                           (lsb'3,
                            (lsb'2,
                             (lsb'1,
                              (lsb'0,
                               (false,
                                (false,(true,(Rn'3,(Rn'2,(Rn'1,Rn'0))))))))))))))))))))))))))) =>
            let
              val Rd = BitsN.fromBitstring([Rd'3,Rd'2,Rd'1,Rd'0],4)
            in
              if Do(cond,Nat.>=(ArchVersion (),6))
                then let
                       val lsbit =
                         BitsN.toNat
                           (BitsN.fromBitstring
                              ([lsb'4,lsb'3,lsb'2,lsb'1,lsb'0],5))
                       val msbit =
                         BitsN.toNat
                           (BitsN.fromBitstring
                              ([msb'4,msb'3,msb'2,msb'1,msb'0],5))
                     in
                       ( if (Rd = (BitsN.B(0xF,4))) orelse
                            (Nat.<(msbit,lsbit))
                           then DECODE_UNPREDICTABLE
                                  (mc,"BitFieldClearOrInsert")
                         else ()
                       ; Media
                           (BitFieldClearOrInsert
                              (Rd,
                               (BitsN.fromBitstring
                                  ([Rn'3,Rn'2,Rn'1,Rn'0],4),(lsbit,msbit))))
                       )
                     end
              else Skip ()
            end
          | (true,
           (false,
            (false,
             (P'0,
              (U'0,
               (true,
                (_,
                 (false,
                  (Rn'3,
                   (Rn'2,
                    (Rn'1,
                     (Rn'0,
                      (registers'15,
                       (registers'14,
                        (registers'13,
                         (registers'12,
                          (registers'11,
                           (registers'10,
                            (registers'9,
                             (registers'8,
                              (registers'7,
                               (registers'6,
                                (registers'5,
                                 (registers'4,
                                  (registers'3,
                                   (registers'2,(registers'1,registers'0))))))))))))))))))))))))))) =>
            let
              val registers =
                BitsN.fromBitstring
                  ([registers'15,registers'14,registers'13,registers'12,
                    registers'11,registers'10,registers'9,registers'8,
                    registers'7,registers'6,registers'5,registers'4,
                    registers'3,registers'2,registers'1,registers'0],16)
              val Rn = BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)
              val U = BitsN.fromBitstring([U'0],1)
            in
              if Do(cond,true)
                then ( if (Rn = (BitsN.B(0xF,4))) orelse
                          (Nat.<(BitCount 16 registers,1))
                         then DECODE_UNPREDICTABLE
                                (mc,"StoreMultipleUserRegisters")
                       else ()
                     ; let
                         val increment = U = (BitsN.B(0x1,1))
                         val wordhigher =
                           (BitsN.fromBitstring([P'0],1)) = U
                       in
                         Store
                           (StoreMultipleUserRegisters
                              (increment,(wordhigher,(Rn,registers))))
                       end
                     )
              else Skip ()
            end
          | (true,
           (false,
            (false,
             (P'0,
              (U'0,
               (false,
                (W'0,
                 (false,
                  (Rn'3,
                   (Rn'2,
                    (Rn'1,
                     (Rn'0,
                      (registers'15,
                       (registers'14,
                        (registers'13,
                         (registers'12,
                          (registers'11,
                           (registers'10,
                            (registers'9,
                             (registers'8,
                              (registers'7,
                               (registers'6,
                                (registers'5,
                                 (registers'4,
                                  (registers'3,
                                   (registers'2,(registers'1,registers'0))))))))))))))))))))))))))) =>
            let
              val registers =
                BitsN.fromBitstring
                  ([registers'15,registers'14,registers'13,registers'12,
                    registers'11,registers'10,registers'9,registers'8,
                    registers'7,registers'6,registers'5,registers'4,
                    registers'3,registers'2,registers'1,registers'0],16)
              val Rn = BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)
            in
              if Do(cond,true)
                then ( if (Rn = (BitsN.B(0xF,4))) orelse
                          (Nat.<(BitCount 16 registers,1))
                         then DECODE_UNPREDICTABLE(mc,"StoreMultiple")
                       else ()
                     ; let
                         val index =
                           (BitsN.fromBitstring([P'0],1)) =
                           (BitsN.B(0x1,1))
                         val increment =
                           (BitsN.fromBitstring([U'0],1)) =
                           (BitsN.B(0x1,1))
                         val wback =
                           (BitsN.fromBitstring([W'0],1)) =
                           (BitsN.B(0x1,1))
                       in
                         Store
                           (StoreMultiple
                              (increment,(index,(wback,(Rn,registers)))))
                       end
                     )
              else Skip ()
            end
          | (true,
           (false,
            (false,
             (P'0,
              (U'0,
               (true,
                (_,
                 (true,
                  (Rn'3,
                   (Rn'2,
                    (Rn'1,
                     (Rn'0,
                      (false,
                       (registers'14,
                        (registers'13,
                         (registers'12,
                          (registers'11,
                           (registers'10,
                            (registers'9,
                             (registers'8,
                              (registers'7,
                               (registers'6,
                                (registers'5,
                                 (registers'4,
                                  (registers'3,
                                   (registers'2,(registers'1,registers'0))))))))))))))))))))))))))) =>
            let
              val registers =
                BitsN.fromBitstring
                  ([registers'14,registers'13,registers'12,registers'11,
                    registers'10,registers'9,registers'8,registers'7,
                    registers'6,registers'5,registers'4,registers'3,
                    registers'2,registers'1,registers'0],15)
              val Rn = BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)
              val U = BitsN.fromBitstring([U'0],1)
            in
              if Do(cond,true)
                then ( if (Rn = (BitsN.B(0xF,4))) orelse
                          (Nat.<(BitCount 15 registers,1))
                         then DECODE_UNPREDICTABLE
                                (mc,"LoadMultipleUserRegisters")
                       else ()
                     ; let
                         val increment = U = (BitsN.B(0x1,1))
                         val wordhigher =
                           (BitsN.fromBitstring([P'0],1)) = U
                       in
                         Load
                           (LoadMultipleUserRegisters
                              (increment,(wordhigher,(Rn,registers))))
                       end
                     )
              else Skip ()
            end
          | (true,
           (false,
            (false,
             (P'0,
              (U'0,
               (true,
                (W'0,
                 (true,
                  (Rn'3,
                   (Rn'2,
                    (Rn'1,
                     (Rn'0,
                      (true,
                       (registers'14,
                        (registers'13,
                         (registers'12,
                          (registers'11,
                           (registers'10,
                            (registers'9,
                             (registers'8,
                              (registers'7,
                               (registers'6,
                                (registers'5,
                                 (registers'4,
                                  (registers'3,
                                   (registers'2,(registers'1,registers'0))))))))))))))))))))))))))) =>
            let
              val registers =
                BitsN.fromBitstring
                  ([registers'14,registers'13,registers'12,registers'11,
                    registers'10,registers'9,registers'8,registers'7,
                    registers'6,registers'5,registers'4,registers'3,
                    registers'2,registers'1,registers'0],15)
              val Rn = BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)
              val U = BitsN.fromBitstring([U'0],1)
            in
              if Do(cond,true)
                then let
                       val wback =
                         (BitsN.fromBitstring([W'0],1)) = (BitsN.B(0x1,1))
                     in
                       ( if (Rn = (BitsN.B(0xF,4))) orelse
                            (wback andalso
                             ((BitsN.bit(registers,BitsN.toNat Rn)) andalso
                              (Nat.>=(ArchVersion (),7))))
                           then DECODE_UNPREDICTABLE
                                  (mc,"LoadMultipleExceptionReturn")
                         else ()
                       ; let
                           val increment = U = (BitsN.B(0x1,1))
                           val wordhigher =
                             (BitsN.fromBitstring([P'0],1)) = U
                         in
                           Load
                             (LoadMultipleExceptionReturn
                                (increment,
                                 (wordhigher,(wback,(Rn,registers)))))
                         end
                       )
                     end
              else Skip ()
            end
          | (true,
           (false,
            (false,
             (P'0,
              (U'0,
               (false,
                (W'0,
                 (true,
                  (Rn'3,
                   (Rn'2,
                    (Rn'1,
                     (Rn'0,
                      (registers'15,
                       (registers'14,
                        (registers'13,
                         (registers'12,
                          (registers'11,
                           (registers'10,
                            (registers'9,
                             (registers'8,
                              (registers'7,
                               (registers'6,
                                (registers'5,
                                 (registers'4,
                                  (registers'3,
                                   (registers'2,(registers'1,registers'0))))))))))))))))))))))))))) =>
            let
              val registers =
                BitsN.fromBitstring
                  ([registers'15,registers'14,registers'13,registers'12,
                    registers'11,registers'10,registers'9,registers'8,
                    registers'7,registers'6,registers'5,registers'4,
                    registers'3,registers'2,registers'1,registers'0],16)
              val Rn = BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)
            in
              if Do(cond,true)
                then let
                       val wback =
                         (BitsN.fromBitstring([W'0],1)) = (BitsN.B(0x1,1))
                     in
                       ( if (Rn = (BitsN.B(0xF,4))) orelse
                            ((Nat.<(BitCount 16 registers,1)) orelse
                             (wback andalso
                              ((BitsN.bit(registers,BitsN.toNat Rn)) andalso
                               (Nat.>=(ArchVersion (),7)))))
                           then DECODE_UNPREDICTABLE(mc,"LoadMultiple")
                         else ()
                       ; let
                           val index =
                             (BitsN.fromBitstring([P'0],1)) =
                             (BitsN.B(0x1,1))
                           val increment =
                             (BitsN.fromBitstring([U'0],1)) =
                             (BitsN.B(0x1,1))
                         in
                           Load
                             (LoadMultiple
                                (increment,(index,(wback,(Rn,registers)))))
                         end
                       )
                     end
              else Skip ()
            end
          | (true,
           (false,
            (true,
             (false,
              (imm24'23,
               (imm24'22,
                (imm24'21,
                 (imm24'20,
                  (imm24'19,
                   (imm24'18,
                    (imm24'17,
                     (imm24'16,
                      (imm24'15,
                       (imm24'14,
                        (imm24'13,
                         (imm24'12,
                          (imm24'11,
                           (imm24'10,
                            (imm24'9,
                             (imm24'8,
                              (imm24'7,
                               (imm24'6,
                                (imm24'5,
                                 (imm24'4,
                                  (imm24'3,(imm24'2,(imm24'1,imm24'0))))))))))))))))))))))))))) =>
            (if Do(cond,true)
               then let
                      val imm32 =
                        BitsN.signExtend 32
                          (BitsN.@@
                             (BitsN.fromBitstring
                                ([imm24'23,imm24'22,imm24'21,imm24'20,
                                  imm24'19,imm24'18,imm24'17,imm24'16,
                                  imm24'15,imm24'14,imm24'13,imm24'12,
                                  imm24'11,imm24'10,imm24'9,imm24'8,
                                  imm24'7,imm24'6,imm24'5,imm24'4,imm24'3,
                                  imm24'2,imm24'1,imm24'0],24),
                              BitsN.B(0x0,2)))
                    in
                      Branch(BranchTarget imm32)
                    end
             else Skip ())
          | (true,
           (false,
            (true,
             (true,
              (imm24'23,
               (imm24'22,
                (imm24'21,
                 (imm24'20,
                  (imm24'19,
                   (imm24'18,
                    (imm24'17,
                     (imm24'16,
                      (imm24'15,
                       (imm24'14,
                        (imm24'13,
                         (imm24'12,
                          (imm24'11,
                           (imm24'10,
                            (imm24'9,
                             (imm24'8,
                              (imm24'7,
                               (imm24'6,
                                (imm24'5,
                                 (imm24'4,
                                  (imm24'3,(imm24'2,(imm24'1,imm24'0))))))))))))))))))))))))))) =>
            (if Do(cond,true)
               then let
                      val imm32 =
                        BitsN.signExtend 32
                          (BitsN.@@
                             (BitsN.fromBitstring
                                ([imm24'23,imm24'22,imm24'21,imm24'20,
                                  imm24'19,imm24'18,imm24'17,imm24'16,
                                  imm24'15,imm24'14,imm24'13,imm24'12,
                                  imm24'11,imm24'10,imm24'9,imm24'8,
                                  imm24'7,imm24'6,imm24'5,imm24'4,imm24'3,
                                  imm24'2,imm24'1,imm24'0],24),
                              BitsN.B(0x0,2)))
                      val targetInstrSet = InstrSet_ARM
                    in
                      Branch
                        (BranchLinkExchangeImmediate(targetInstrSet,imm32))
                    end
             else Skip ())
          | (true,
           (true,
            (true,
             (true,
              (imm24'23,
               (imm24'22,
                (imm24'21,
                 (imm24'20,
                  (imm24'19,
                   (imm24'18,
                    (imm24'17,
                     (imm24'16,
                      (imm24'15,
                       (imm24'14,
                        (imm24'13,
                         (imm24'12,
                          (imm24'11,
                           (imm24'10,
                            (imm24'9,
                             (imm24'8,
                              (imm24'7,
                               (imm24'6,
                                (imm24'5,
                                 (imm24'4,
                                  (imm24'3,(imm24'2,(imm24'1,imm24'0))))))))))))))))))))))))))) =>
            (if Do(cond,true)
               then let
                      val imm32 =
                        BitsN.signExtend 32
                          (BitsN.fromBitstring
                             ([imm24'23,imm24'22,imm24'21,imm24'20,
                               imm24'19,imm24'18,imm24'17,imm24'16,
                               imm24'15,imm24'14,imm24'13,imm24'12,
                               imm24'11,imm24'10,imm24'9,imm24'8,imm24'7,
                               imm24'6,imm24'5,imm24'4,imm24'3,imm24'2,
                               imm24'1,imm24'0],24))
                    in
                      System(SupervisorCall imm32)
                    end
             else Skip ())
          | (true,
           (true,
            (_,
             (_,
              (_,
               (_,
                (_,
                 (_,
                  (_,(_,(_,(_,(_,(_,(_,(_,(true,(false,(true,_))))))))))))))))))) =>
            let
              val (defined,i) = DecodeVFP w
            in
              if Do(cond,defined) then i else Skip ()
            end
          | _ => UndefinedARM cond
  end;

fun DecodeThumb h =
  let
    val mc = Thumb h
  in
    case boolify'16 h of
       (false,
        (false,
         (false,
          (true,
           (true,
            (false,
             (S'0,
              (Rm'2,(Rm'1,(Rm'0,(Rn'2,(Rn'1,(Rn'0,(Rd'2,(Rd'1,Rd'0))))))))))))))) =>
         (if Do(ThumbCondition (),true)
            then let
                   val d =
                     BitsN.fromNat
                       (BitsN.toNat
                          (BitsN.fromBitstring([Rd'2,Rd'1,Rd'0],3)),4)
                   val n =
                     BitsN.fromNat
                       (BitsN.toNat
                          (BitsN.fromBitstring([Rn'2,Rn'1,Rn'0],3)),4)
                   val m =
                     BitsN.fromNat
                       (BitsN.toNat
                          (BitsN.fromBitstring([Rm'2,Rm'1,Rm'0],3)),4)
                   val setflags = not(InITBlock ())
                   val (shift_t,shift_n) = (SRType_LSL,0)
                   val opc =
                     if (BitsN.fromBitstring([S'0],1)) = (BitsN.B(0x1,1))
                       then BitsN.B(0x2,4)
                     else BitsN.B(0x4,4)
                 in
                   Data
                     (Register
                        (opc,(setflags,(d,(n,(m,(shift_t,shift_n)))))))
                 end
          else Skip ())
     | (false,
      (false,
       (false,
        (true,
         (true,
          (true,
           (S'0,
            (imm3'2,
             (imm3'1,(imm3'0,(Rn'2,(Rn'1,(Rn'0,(Rd'2,(Rd'1,Rd'0))))))))))))))) =>
       (if Do(ThumbCondition (),true)
          then let
                 val d =
                   BitsN.fromNat
                     (BitsN.toNat(BitsN.fromBitstring([Rd'2,Rd'1,Rd'0],3)),
                      4)
                 val n =
                   BitsN.fromNat
                     (BitsN.toNat(BitsN.fromBitstring([Rn'2,Rn'1,Rn'0],3)),
                      4)
                 val setflags = not(InITBlock ())
                 val imm12 =
                   BitsN.zeroExtend 12
                     (BitsN.fromBitstring([imm3'2,imm3'1,imm3'0],3))
                 val opc =
                   if (BitsN.fromBitstring([S'0],1)) = (BitsN.B(0x1,1))
                     then BitsN.B(0x2,4)
                   else BitsN.B(0x4,4)
               in
                 Data(ArithLogicImmediate(opc,(setflags,(d,(n,imm12)))))
               end
        else Skip ())
     | (false,
      (false,
       (false,
        (opc'1,
         (opc'0,
          (imm5'4,
           (imm5'3,
            (imm5'2,
             (imm5'1,(imm5'0,(Rm'2,(Rm'1,(Rm'0,(Rd'2,(Rd'1,Rd'0))))))))))))))) =>
       (if Do(ThumbCondition (),true)
          then let
                 val d =
                   BitsN.fromNat
                     (BitsN.toNat(BitsN.fromBitstring([Rd'2,Rd'1,Rd'0],3)),
                      4)
                 val m =
                   BitsN.fromNat
                     (BitsN.toNat(BitsN.fromBitstring([Rm'2,Rm'1,Rm'0],3)),
                      4)
                 val setflags = not(InITBlock ())
                 val (shift_t,shift_n) =
                   DecodeImmShift
                     (BitsN.fromBitstring([opc'1,opc'0],2),
                      BitsN.fromBitstring
                        ([imm5'4,imm5'3,imm5'2,imm5'1,imm5'0],5))
               in
                 Data
                   (ShiftImmediate
                      (false,(setflags,(d,(m,(shift_t,shift_n))))))
               end
        else Skip ())
     | (false,
      (false,
       (true,
        (false,
         (false,
          (Rd'2,
           (Rd'1,
            (Rd'0,
             (imm8'7,
              (imm8'6,(imm8'5,(imm8'4,(imm8'3,(imm8'2,(imm8'1,imm8'0))))))))))))))) =>
       (if Do(ThumbCondition (),true)
          then let
                 val d =
                   BitsN.fromNat
                     (BitsN.toNat(BitsN.fromBitstring([Rd'2,Rd'1,Rd'0],3)),
                      4)
                 val imm12 =
                   BitsN.zeroExtend 12
                     (BitsN.fromBitstring
                        ([imm8'7,imm8'6,imm8'5,imm8'4,imm8'3,imm8'2,
                          imm8'1,imm8'0],8))
                 val setflags = not(InITBlock ())
                 val negate = false
               in
                 Data(Move(setflags,(negate,(d,imm12))))
               end
        else Skip ())
     | (false,
      (false,
       (true,
        (false,
         (true,
          (Rn'2,
           (Rn'1,
            (Rn'0,
             (imm8'7,
              (imm8'6,(imm8'5,(imm8'4,(imm8'3,(imm8'2,(imm8'1,imm8'0))))))))))))))) =>
       (if Do(ThumbCondition (),true)
          then let
                 val n =
                   BitsN.fromNat
                     (BitsN.toNat(BitsN.fromBitstring([Rn'2,Rn'1,Rn'0],3)),
                      4)
                 val imm12 =
                   BitsN.zeroExtend 12
                     (BitsN.fromBitstring
                        ([imm8'7,imm8'6,imm8'5,imm8'4,imm8'3,imm8'2,
                          imm8'1,imm8'0],8))
               in
                 Data(TestCompareImmediate(BitsN.B(0x2,2),(n,imm12)))
               end
        else Skip ())
     | (false,
      (false,
       (true,
        (true,
         (S'0,
          (Rdn'2,
           (Rdn'1,
            (Rdn'0,
             (imm8'7,
              (imm8'6,(imm8'5,(imm8'4,(imm8'3,(imm8'2,(imm8'1,imm8'0))))))))))))))) =>
       (if Do(ThumbCondition (),true)
          then let
                 val d =
                   BitsN.fromNat
                     (BitsN.toNat
                        (BitsN.fromBitstring([Rdn'2,Rdn'1,Rdn'0],3)),4)
                 val n = d
                 val setflags = not(InITBlock ())
                 val imm12 =
                   BitsN.zeroExtend 12
                     (BitsN.fromBitstring
                        ([imm8'7,imm8'6,imm8'5,imm8'4,imm8'3,imm8'2,
                          imm8'1,imm8'0],8))
                 val opc =
                   if (BitsN.fromBitstring([S'0],1)) = (BitsN.B(0x1,1))
                     then BitsN.B(0x2,4)
                   else BitsN.B(0x4,4)
               in
                 Data(ArithLogicImmediate(opc,(setflags,(d,(n,imm12)))))
               end
        else Skip ())
     | (false,
      (true,
       (false,
        (false,
         (false,
          (false,
           (opc'3,
            (opc'2,(opc'1,(opc'0,(Rx'2,(Rx'1,(Rx'0,(Ry'2,(Ry'1,Ry'0))))))))))))))) =>
       let
         val Ry = BitsN.fromBitstring([Ry'2,Ry'1,Ry'0],3)
         val Rx = BitsN.fromBitstring([Rx'2,Rx'1,Rx'0],3)
         val opc = BitsN.fromBitstring([opc'3,opc'2,opc'1,opc'0],4)
       in
         if Do(ThumbCondition (),true)
           then case opc of
                   BitsN.B(0x0,_) =>
                     let
                       val d = BitsN.fromNat(BitsN.toNat Ry,4)
                       val n = d
                       val m = BitsN.fromNat(BitsN.toNat Rx,4)
                       val setflags = not(InITBlock ())
                       val (shift_t,shift_n) = (SRType_LSL,0)
                     in
                       Data
                         (Register
                            (opc,(setflags,(d,(n,(m,(shift_t,shift_n)))))))
                     end
                 | BitsN.B(0x1,_) =>
                   let
                     val d = BitsN.fromNat(BitsN.toNat Ry,4)
                     val n = d
                     val m = BitsN.fromNat(BitsN.toNat Rx,4)
                     val setflags = not(InITBlock ())
                     val (shift_t,shift_n) = (SRType_LSL,0)
                   in
                     Data
                       (Register
                          (opc,(setflags,(d,(n,(m,(shift_t,shift_n)))))))
                   end
                 | BitsN.B(0x5,_) =>
                   let
                     val d = BitsN.fromNat(BitsN.toNat Ry,4)
                     val n = d
                     val m = BitsN.fromNat(BitsN.toNat Rx,4)
                     val setflags = not(InITBlock ())
                     val (shift_t,shift_n) = (SRType_LSL,0)
                   in
                     Data
                       (Register
                          (opc,(setflags,(d,(n,(m,(shift_t,shift_n)))))))
                   end
                 | BitsN.B(0x6,_) =>
                   let
                     val d = BitsN.fromNat(BitsN.toNat Ry,4)
                     val n = d
                     val m = BitsN.fromNat(BitsN.toNat Rx,4)
                     val setflags = not(InITBlock ())
                     val (shift_t,shift_n) = (SRType_LSL,0)
                   in
                     Data
                       (Register
                          (opc,(setflags,(d,(n,(m,(shift_t,shift_n)))))))
                   end
                 | BitsN.B(0xC,_) =>
                   let
                     val d = BitsN.fromNat(BitsN.toNat Ry,4)
                     val n = d
                     val m = BitsN.fromNat(BitsN.toNat Rx,4)
                     val setflags = not(InITBlock ())
                     val (shift_t,shift_n) = (SRType_LSL,0)
                   in
                     Data
                       (Register
                          (opc,(setflags,(d,(n,(m,(shift_t,shift_n)))))))
                   end
                 | BitsN.B(0xE,_) =>
                   let
                     val d = BitsN.fromNat(BitsN.toNat Ry,4)
                     val n = d
                     val m = BitsN.fromNat(BitsN.toNat Rx,4)
                     val setflags = not(InITBlock ())
                     val (shift_t,shift_n) = (SRType_LSL,0)
                   in
                     Data
                       (Register
                          (opc,(setflags,(d,(n,(m,(shift_t,shift_n)))))))
                   end
                 | BitsN.B(0x2,_) =>
                   let
                     val d = BitsN.fromNat(BitsN.toNat Ry,4)
                     val n = d
                     val m = BitsN.fromNat(BitsN.toNat Rx,4)
                     val setflags = not(InITBlock ())
                     val shift_t =
                       DecodeRegShift
                         (BitsN.fromNat
                            (BitsN.toNat(BitsN.-(opc,BitsN.B(0x2,4))),2))
                   in
                     Data
                       (ShiftRegister
                          (false,(setflags,(d,(n,(shift_t,m))))))
                   end
                 | BitsN.B(0x3,_) =>
                   let
                     val d = BitsN.fromNat(BitsN.toNat Ry,4)
                     val n = d
                     val m = BitsN.fromNat(BitsN.toNat Rx,4)
                     val setflags = not(InITBlock ())
                     val shift_t =
                       DecodeRegShift
                         (BitsN.fromNat
                            (BitsN.toNat(BitsN.-(opc,BitsN.B(0x2,4))),2))
                   in
                     Data
                       (ShiftRegister
                          (false,(setflags,(d,(n,(shift_t,m))))))
                   end
                 | BitsN.B(0x4,_) =>
                   let
                     val d = BitsN.fromNat(BitsN.toNat Ry,4)
                     val n = d
                     val m = BitsN.fromNat(BitsN.toNat Rx,4)
                     val setflags = not(InITBlock ())
                     val shift_t =
                       DecodeRegShift
                         (BitsN.fromNat
                            (BitsN.toNat(BitsN.-(opc,BitsN.B(0x2,4))),2))
                   in
                     Data
                       (ShiftRegister
                          (false,(setflags,(d,(n,(shift_t,m))))))
                   end
                 | BitsN.B(0x7,_) =>
                   let
                     val d = BitsN.fromNat(BitsN.toNat Ry,4)
                     val n = d
                     val m = BitsN.fromNat(BitsN.toNat Rx,4)
                     val setflags = not(InITBlock ())
                   in
                     Data
                       (ShiftRegister
                          (false,(setflags,(d,(n,(SRType_ROR,m))))))
                   end
                 | BitsN.B(0x8,_) =>
                   let
                     val n = BitsN.fromNat(BitsN.toNat Ry,4)
                     val m = BitsN.fromNat(BitsN.toNat Rx,4)
                     val setflags = true
                     val (shift_t,shift_n) = (SRType_LSL,0)
                   in
                     Data
                       (TestCompareRegister
                          (BitsN.bits(1,0) opc,(n,(m,(shift_t,shift_n)))))
                   end
                 | BitsN.B(0xA,_) =>
                   let
                     val n = BitsN.fromNat(BitsN.toNat Ry,4)
                     val m = BitsN.fromNat(BitsN.toNat Rx,4)
                     val setflags = true
                     val (shift_t,shift_n) = (SRType_LSL,0)
                   in
                     Data
                       (TestCompareRegister
                          (BitsN.bits(1,0) opc,(n,(m,(shift_t,shift_n)))))
                   end
                 | BitsN.B(0xB,_) =>
                   let
                     val n = BitsN.fromNat(BitsN.toNat Ry,4)
                     val m = BitsN.fromNat(BitsN.toNat Rx,4)
                     val setflags = true
                     val (shift_t,shift_n) = (SRType_LSL,0)
                   in
                     Data
                       (TestCompareRegister
                          (BitsN.bits(1,0) opc,(n,(m,(shift_t,shift_n)))))
                   end
                 | BitsN.B(0x9,_) =>
                   let
                     val d = BitsN.fromNat(BitsN.toNat Ry,4)
                     val n = BitsN.fromNat(BitsN.toNat Rx,4)
                     val setflags = not(InITBlock ())
                   in
                     Data
                       (ArithLogicImmediate
                          (BitsN.B(0x3,4),
                           (setflags,(d,(n,BitsN.B(0x0,12))))))
                   end
                 | BitsN.B(0xD,_) =>
                   let
                     val d = BitsN.fromNat(BitsN.toNat Ry,4)
                     val n = BitsN.fromNat(BitsN.toNat Rx,4)
                   in
                     ( if (Nat.<(ArchVersion (),6)) andalso (d = n)
                         then DECODE_UNPREDICTABLE(mc,"Multiply")
                       else ()
                     ; let
                         val m = d
                         val setflags = not(InITBlock ())
                       in
                         Multiply(Multiply32(setflags,(d,(n,m))))
                       end
                     )
                   end
                 | BitsN.B(0xF,_) =>
                   let
                     val d = BitsN.fromNat(BitsN.toNat Ry,4)
                     val m = BitsN.fromNat(BitsN.toNat Rx,4)
                     val setflags = not(InITBlock ())
                     val (shift_t,shift_n) = (SRType_LSL,0)
                   in
                     Data
                       (ShiftImmediate
                          (true,(setflags,(d,(m,(shift_t,shift_n))))))
                   end
                 | _ => raise General.Bind
         else Skip ()
       end
     | (false,
      (true,
       (false,
        (false,
         (false,
          (true,
           (false,
            (false,
             (DN'0,(Rm'3,(Rm'2,(Rm'1,(Rm'0,(Rdn'2,(Rdn'1,Rdn'0))))))))))))))) =>
       let
         val Rm = BitsN.fromBitstring([Rm'3,Rm'2,Rm'1,Rm'0],4)
         val DN = BitsN.fromBitstring([DN'0],1)
       in
         if Do(ThumbCondition (),
               (BitsN.msb Rm) orelse
               ((DN = (BitsN.B(0x1,1))) orelse (HaveThumb2 ())))
           then let
                  val d =
                    BitsN.@@
                      (DN,BitsN.fromBitstring([Rdn'2,Rdn'1,Rdn'0],3))
                  val n = d
                in
                  ( if ((n = (BitsN.B(0xF,4))) andalso
                        (Rm = (BitsN.B(0xF,4)))) orelse
                       ((d = (BitsN.B(0xF,4))) andalso
                        ((InITBlock ()) andalso (not(LastInITBlock ()))))
                      then DECODE_UNPREDICTABLE(mc,"ADD")
                    else ()
                  ; let
                      val setflags = false
                      val (shift_t,shift_n) = (SRType_LSL,0)
                    in
                      Data
                        (Register
                           (BitsN.B(0x4,4),
                            (setflags,(d,(n,(Rm,(shift_t,shift_n)))))))
                    end
                  )
                end
         else Skip ()
       end
     | (false,
      (true,
       (false,(false,(false,(true,(false,(true,(false,(false,_)))))))))) =>
       raise UNPREDICTABLE ("Thumb: 010001 0100 _")
     | (false,
      (true,
       (false,
        (false,
         (false,
          (true,
           (false,
            (true,(N'0,(Rm'3,(Rm'2,(Rm'1,(Rm'0,(Rn'2,(Rn'1,Rn'0))))))))))))))) =>
       let
         val Rm = BitsN.fromBitstring([Rm'3,Rm'2,Rm'1,Rm'0],4)
       in
         if Do(ThumbCondition (),true)
           then let
                  val n =
                    BitsN.@@
                      (BitsN.fromBitstring([N'0],1),
                       BitsN.fromBitstring([Rn'2,Rn'1,Rn'0],3))
                in
                  ( if ((BitsN.<+(n,BitsN.B(0x8,4))) andalso
                        (BitsN.<+(Rm,BitsN.B(0x8,4)))) orelse
                       ((n = (BitsN.B(0xF,4))) orelse
                        (Rm = (BitsN.B(0xF,4))))
                      then DECODE_UNPREDICTABLE(mc,"CMP")
                    else ()
                  ; Data
                      (TestCompareRegister
                         (BitsN.B(0x2,2),(n,(Rm,(SRType_LSL,0)))))
                  )
                end
         else Skip ()
       end
     | (false,
      (true,
       (false,
        (false,
         (false,
          (true,
           (true,
            (false,(D'0,(Rm'3,(Rm'2,(Rm'1,(Rm'0,(Rd'2,(Rd'1,Rd'0))))))))))))))) =>
       let
         val Rm = BitsN.fromBitstring([Rm'3,Rm'2,Rm'1,Rm'0],4)
         val D = BitsN.fromBitstring([D'0],1)
       in
         if Do(ThumbCondition (),
               (BitsN.msb Rm) orelse
               ((D = (BitsN.B(0x1,1))) orelse (Nat.>=(ArchVersion (),6))))
           then let
                  val d =
                    BitsN.@@(D,BitsN.fromBitstring([Rd'2,Rd'1,Rd'0],3))
                in
                  ( if (d = (BitsN.B(0xF,4))) andalso
                       ((InITBlock ()) andalso (not(LastInITBlock ())))
                      then DECODE_UNPREDICTABLE(mc,"MOV")
                    else ()
                  ; let
                      val setflags = false
                      val (shift_t,shift_n) = (SRType_LSL,0)
                    in
                      Data
                        (ShiftImmediate
                           (false,(setflags,(d,(Rm,(shift_t,shift_n))))))
                    end
                  )
                end
         else Skip ()
       end
     | (false,
      (true,
       (false,
        (false,
         (false,(true,(true,(true,(false,(Rm'3,(Rm'2,(Rm'1,(Rm'0,_))))))))))))) =>
       (if Do(ThumbCondition (),true)
          then ( if (InITBlock ()) andalso (not(LastInITBlock ()))
                   then DECODE_UNPREDICTABLE(mc,"BranchExchange")
                 else ()
               ; Branch
                   (BranchExchange
                      (BitsN.fromBitstring([Rm'3,Rm'2,Rm'1,Rm'0],4)))
               )
        else Skip ())
     | (false,
      (true,
       (false,
        (false,
         (false,(true,(true,(true,(true,(Rm'3,(Rm'2,(Rm'1,(Rm'0,_))))))))))))) =>
       let
         val Rm = BitsN.fromBitstring([Rm'3,Rm'2,Rm'1,Rm'0],4)
       in
         if Do(ThumbCondition (),Nat.>=(ArchVersion (),5))
           then ( if (Rm = (BitsN.B(0xF,4))) orelse
                     ((InITBlock ()) andalso (not(LastInITBlock ())))
                    then DECODE_UNPREDICTABLE
                           (mc,"BranchLinkExchangeRegister")
                  else ()
                ; Branch(BranchLinkExchangeRegister Rm)
                )
         else Skip ()
       end
     | (false,
      (true,
       (false,
        (false,
         (true,
          (Rt'2,
           (Rt'1,
            (Rt'0,
             (imm8'7,
              (imm8'6,(imm8'5,(imm8'4,(imm8'3,(imm8'2,(imm8'1,imm8'0))))))))))))))) =>
       (if Do(ThumbCondition (),true)
          then let
                 val add = true
                 val imm32 =
                   BitsN.zeroExtend 32
                     (BitsN.@@
                        (BitsN.fromBitstring
                           ([imm8'7,imm8'6,imm8'5,imm8'4,imm8'3,imm8'2,
                             imm8'1,imm8'0],8),BitsN.B(0x0,2)))
               in
                 Load
                   (LoadLiteral
                      (add,
                       (BitsN.fromNat
                          (BitsN.toNat
                             (BitsN.fromBitstring([Rt'2,Rt'1,Rt'0],3)),4),
                        imm32)))
               end
        else Skip ())
     | (false,
      (true,
       (false,
        (true,
         (opc'2,
          (opc'1,
           (opc'0,
            (Rm'2,(Rm'1,(Rm'0,(Rn'2,(Rn'1,(Rn'0,(Rt'2,(Rt'1,Rt'0))))))))))))))) =>
       let
         val Rt = BitsN.fromBitstring([Rt'2,Rt'1,Rt'0],3)
         val Rn = BitsN.fromBitstring([Rn'2,Rn'1,Rn'0],3)
       in
         if Do(ThumbCondition (),true)
           then let
                  val index = true
                  val add = true
                  val wback = false
                  val (shift_t,shift_n) = (SRType_LSL,0)
                  val m =
                    register_form1
                      (BitsN.fromNat
                         (BitsN.toNat
                            (BitsN.fromBitstring([Rm'2,Rm'1,Rm'0],3)),4),
                       (shift_t,shift_n))
                in
                  case BitsN.fromBitstring([opc'2,opc'1,opc'0],3) of
                     BitsN.B(0x0,_) =>
                       Store
                         (StoreWord
                            (add,
                             (index,
                              (wback,
                               (BitsN.fromNat(BitsN.toNat Rt,4),
                                (BitsN.fromNat(BitsN.toNat Rn,4),m))))))
                   | BitsN.B(0x1,_) =>
                     Store
                       (StoreHalf
                          (add,
                           (index,
                            (wback,
                             (BitsN.fromNat(BitsN.toNat Rt,4),
                              (BitsN.fromNat(BitsN.toNat Rn,4),m))))))
                   | BitsN.B(0x2,_) =>
                     Store
                       (StoreByte
                          (add,
                           (index,
                            (wback,
                             (BitsN.fromNat(BitsN.toNat Rt,4),
                              (BitsN.fromNat(BitsN.toNat Rn,4),m))))))
                   | BitsN.B(0x3,_) =>
                     Load
                       (LoadByte
                          (false,
                           (add,
                            (index,
                             (wback,
                              (BitsN.fromNat(BitsN.toNat Rt,4),
                               (BitsN.fromNat(BitsN.toNat Rn,4),m)))))))
                   | BitsN.B(0x4,_) =>
                     Load
                       (LoadWord
                          (add,
                           (index,
                            (wback,
                             (BitsN.fromNat(BitsN.toNat Rt,4),
                              (BitsN.fromNat(BitsN.toNat Rn,4),m))))))
                   | BitsN.B(0x5,_) =>
                     Load
                       (LoadHalf
                          (true,
                           (add,
                            (index,
                             (wback,
                              (BitsN.fromNat(BitsN.toNat Rt,4),
                               (BitsN.fromNat(BitsN.toNat Rn,4),m)))))))
                   | BitsN.B(0x6,_) =>
                     Load
                       (LoadByte
                          (true,
                           (add,
                            (index,
                             (wback,
                              (BitsN.fromNat(BitsN.toNat Rt,4),
                               (BitsN.fromNat(BitsN.toNat Rn,4),m)))))))
                   | BitsN.B(0x7,_) =>
                     Load
                       (LoadHalf
                          (false,
                           (add,
                            (index,
                             (wback,
                              (BitsN.fromNat(BitsN.toNat Rt,4),
                               (BitsN.fromNat(BitsN.toNat Rn,4),m)))))))
                   | _ => raise General.Bind
                end
         else Skip ()
       end
     | (false,
      (true,
       (true,
        (false,
         (L'0,
          (imm5'4,
           (imm5'3,
            (imm5'2,
             (imm5'1,(imm5'0,(Rn'2,(Rn'1,(Rn'0,(Rt'2,(Rt'1,Rt'0))))))))))))))) =>
       let
         val Rt = BitsN.fromBitstring([Rt'2,Rt'1,Rt'0],3)
         val Rn = BitsN.fromBitstring([Rn'2,Rn'1,Rn'0],3)
       in
         if Do(ThumbCondition (),true)
           then let
                  val index = true
                  val add = true
                  val wback = false
                  val imm32 =
                    BitsN.zeroExtend 32
                      (BitsN.@@
                         (BitsN.fromBitstring
                            ([imm5'4,imm5'3,imm5'2,imm5'1,imm5'0],5),
                          BitsN.B(0x0,2)))
                  val m = immediate_form1 imm32
                in
                  if (BitsN.fromBitstring([L'0],1)) = (BitsN.B(0x1,1))
                    then Load
                           (LoadWord
                              (add,
                               (index,
                                (wback,
                                 (BitsN.fromNat(BitsN.toNat Rt,4),
                                  (BitsN.fromNat(BitsN.toNat Rn,4),m))))))
                  else Store
                         (StoreWord
                            (add,
                             (index,
                              (wback,
                               (BitsN.fromNat(BitsN.toNat Rt,4),
                                (BitsN.fromNat(BitsN.toNat Rn,4),m))))))
                end
         else Skip ()
       end
     | (false,
      (true,
       (true,
        (true,
         (L'0,
          (imm5'4,
           (imm5'3,
            (imm5'2,
             (imm5'1,(imm5'0,(Rn'2,(Rn'1,(Rn'0,(Rt'2,(Rt'1,Rt'0))))))))))))))) =>
       let
         val Rt = BitsN.fromBitstring([Rt'2,Rt'1,Rt'0],3)
         val Rn = BitsN.fromBitstring([Rn'2,Rn'1,Rn'0],3)
       in
         if Do(ThumbCondition (),true)
           then let
                  val index = true
                  val add = true
                  val wback = false
                  val imm32 =
                    BitsN.zeroExtend 32
                      (BitsN.fromBitstring
                         ([imm5'4,imm5'3,imm5'2,imm5'1,imm5'0],5))
                  val m = immediate_form1 imm32
                in
                  if (BitsN.fromBitstring([L'0],1)) = (BitsN.B(0x1,1))
                    then Load
                           (LoadByte
                              (true,
                               (add,
                                (index,
                                 (wback,
                                  (BitsN.fromNat(BitsN.toNat Rt,4),
                                   (BitsN.fromNat(BitsN.toNat Rn,4),m)))))))
                  else Store
                         (StoreByte
                            (add,
                             (index,
                              (wback,
                               (BitsN.fromNat(BitsN.toNat Rt,4),
                                (BitsN.fromNat(BitsN.toNat Rn,4),m))))))
                end
         else Skip ()
       end
     | (true,
      (false,
       (false,
        (false,
         (L'0,
          (imm5'4,
           (imm5'3,
            (imm5'2,
             (imm5'1,(imm5'0,(Rn'2,(Rn'1,(Rn'0,(Rt'2,(Rt'1,Rt'0))))))))))))))) =>
       let
         val Rt = BitsN.fromBitstring([Rt'2,Rt'1,Rt'0],3)
         val Rn = BitsN.fromBitstring([Rn'2,Rn'1,Rn'0],3)
       in
         if Do(ThumbCondition (),true)
           then let
                  val index = true
                  val add = true
                  val wback = false
                  val imm32 =
                    BitsN.zeroExtend 32
                      (BitsN.@@
                         (BitsN.fromBitstring
                            ([imm5'4,imm5'3,imm5'2,imm5'1,imm5'0],5),
                          BitsN.B(0x0,1)))
                  val m = immediate_form1 imm32
                in
                  if (BitsN.fromBitstring([L'0],1)) = (BitsN.B(0x1,1))
                    then Load
                           (LoadHalf
                              (true,
                               (add,
                                (index,
                                 (wback,
                                  (BitsN.fromNat(BitsN.toNat Rt,4),
                                   (BitsN.fromNat(BitsN.toNat Rn,4),m)))))))
                  else Store
                         (StoreHalf
                            (add,
                             (index,
                              (wback,
                               (BitsN.fromNat(BitsN.toNat Rt,4),
                                (BitsN.fromNat(BitsN.toNat Rn,4),m))))))
                end
         else Skip ()
       end
     | (true,
      (false,
       (false,
        (true,
         (L'0,
          (Rt'2,
           (Rt'1,
            (Rt'0,
             (imm8'7,
              (imm8'6,(imm8'5,(imm8'4,(imm8'3,(imm8'2,(imm8'1,imm8'0))))))))))))))) =>
       let
         val Rt = BitsN.fromBitstring([Rt'2,Rt'1,Rt'0],3)
       in
         if Do(ThumbCondition (),true)
           then let
                  val index = true
                  val add = true
                  val wback = false
                  val imm32 =
                    BitsN.zeroExtend 32
                      (BitsN.@@
                         (BitsN.fromBitstring
                            ([imm8'7,imm8'6,imm8'5,imm8'4,imm8'3,imm8'2,
                              imm8'1,imm8'0],8),BitsN.B(0x0,2)))
                  val m = immediate_form1 imm32
                in
                  if (BitsN.fromBitstring([L'0],1)) = (BitsN.B(0x1,1))
                    then Load
                           (LoadWord
                              (add,
                               (index,
                                (wback,
                                 (BitsN.fromNat(BitsN.toNat Rt,4),
                                  (BitsN.B(0xD,4),m))))))
                  else Store
                         (StoreWord
                            (add,
                             (index,
                              (wback,
                               (BitsN.fromNat(BitsN.toNat Rt,4),
                                (BitsN.B(0xD,4),m))))))
                end
         else Skip ()
       end
     | (true,
      (false,
       (true,
        (false,
         (S'0,
          (Rd'2,
           (Rd'1,
            (Rd'0,
             (imm8'7,
              (imm8'6,(imm8'5,(imm8'4,(imm8'3,(imm8'2,(imm8'1,imm8'0))))))))))))))) =>
       (if Do(ThumbCondition (),true)
          then let
                 val imm12 =
                   BitsN.@@
                     (BitsN.B(0xF,4),
                      BitsN.fromBitstring
                        ([imm8'7,imm8'6,imm8'5,imm8'4,imm8'3,imm8'2,
                          imm8'1,imm8'0],8))
                 val Rn =
                   if (BitsN.fromBitstring([S'0],1)) = (BitsN.B(0x1,1))
                     then BitsN.B(0xD,4)
                   else BitsN.B(0xF,4)
               in
                 Data
                   (ArithLogicImmediate
                      (BitsN.B(0x4,4),
                       (false,
                        (BitsN.fromNat
                           (BitsN.toNat
                              (BitsN.fromBitstring([Rd'2,Rd'1,Rd'0],3)),4),
                         (Rn,imm12)))))
               end
        else Skip ())
     | (true,
      (false,
       (true,
        (true,
         (false,
          (false,
           (false,
            (false,
             (S'0,
              (imm7'6,(imm7'5,(imm7'4,(imm7'3,(imm7'2,(imm7'1,imm7'0))))))))))))))) =>
       (if Do(ThumbCondition (),true)
          then let
                 val imm12 =
                   BitsN.@@
                     (BitsN.B(0x1E,5),
                      BitsN.fromBitstring
                        ([imm7'6,imm7'5,imm7'4,imm7'3,imm7'2,imm7'1,imm7'0],
                         7))
                 val opc =
                   if (BitsN.fromBitstring([S'0],1)) = (BitsN.B(0x1,1))
                     then BitsN.B(0x2,4)
                   else BitsN.B(0x4,4)
               in
                 Data
                   (ArithLogicImmediate
                      (opc,(false,(BitsN.B(0xD,4),(BitsN.B(0xD,4),imm12)))))
               end
        else Skip ())
     | (true,
      (false,
       (true,
        (true,
         (op'0,
          (false,
           (i'0,
            (true,
             (imm5'4,
              (imm5'3,(imm5'2,(imm5'1,(imm5'0,(Rn'2,(Rn'1,Rn'0))))))))))))))) =>
       (if Do(BitsN.B(0xE,4),HaveThumb2 ())
          then ( if InITBlock ()
                   then DECODE_UNPREDICTABLE(mc,"CompareBranch")
                 else ()
               ; let
                   val imm32 =
                     BitsN.zeroExtend 32
                       (BitsN.concat
                          [BitsN.fromBitstring([i'0],1),
                           BitsN.fromBitstring
                             ([imm5'4,imm5'3,imm5'2,imm5'1,imm5'0],5),
                           BitsN.B(0x0,1)])
                   val nonzero =
                     (BitsN.fromBitstring([op'0],1)) = (BitsN.B(0x1,1))
                 in
                   Branch
                     (CompareBranch
                        (nonzero,
                         (BitsN.fromNat
                            (BitsN.toNat
                               (BitsN.fromBitstring([Rn'2,Rn'1,Rn'0],3)),4),
                          imm32)))
                 end
               )
        else Skip ())
     | (true,
      (false,
       (true,
        (true,
         (false,
          (false,
           (true,
            (false,(U'0,(false,(Rm'2,(Rm'1,(Rm'0,(Rd'2,(Rd'1,Rd'0))))))))))))))) =>
       (if Do(ThumbCondition (),Nat.>=(ArchVersion (),6))
          then let
                 val unsigned =
                   (BitsN.fromBitstring([U'0],1)) = (BitsN.B(0x1,1))
               in
                 Media
                   (ExtendHalfword
                      (unsigned,
                       (BitsN.fromNat
                          (BitsN.toNat
                             (BitsN.fromBitstring([Rd'2,Rd'1,Rd'0],3)),4),
                        (BitsN.B(0xF,4),
                         (BitsN.fromNat
                            (BitsN.toNat
                               (BitsN.fromBitstring([Rm'2,Rm'1,Rm'0],3)),4),
                          0)))))
               end
        else Skip ())
     | (true,
      (false,
       (true,
        (true,
         (false,
          (false,
           (true,
            (false,(U'0,(true,(Rm'2,(Rm'1,(Rm'0,(Rd'2,(Rd'1,Rd'0))))))))))))))) =>
       (if Do(ThumbCondition (),Nat.>=(ArchVersion (),6))
          then let
                 val unsigned =
                   (BitsN.fromBitstring([U'0],1)) = (BitsN.B(0x1,1))
               in
                 Media
                   (ExtendByte
                      (unsigned,
                       (BitsN.fromNat
                          (BitsN.toNat
                             (BitsN.fromBitstring([Rd'2,Rd'1,Rd'0],3)),4),
                        (BitsN.B(0xF,4),
                         (BitsN.fromNat
                            (BitsN.toNat
                               (BitsN.fromBitstring([Rm'2,Rm'1,Rm'0],3)),4),
                          0)))))
               end
        else Skip ())
     | (true,
      (false,
       (true,
        (true,
         (false,
          (true,
           (false,
            (M'0,
             (register_list'7,
              (register_list'6,
               (register_list'5,
                (register_list'4,
                 (register_list'3,
                  (register_list'2,(register_list'1,register_list'0))))))))))))))) =>
       (if Do(ThumbCondition (),true)
          then let
                 val registers =
                   BitsN.concat
                     [BitsN.B(0x0,1),BitsN.fromBitstring([M'0],1),
                      BitsN.B(0x0,6),
                      BitsN.fromBitstring
                        ([register_list'7,register_list'6,register_list'5,
                          register_list'4,register_list'3,register_list'2,
                          register_list'1,register_list'0],8)]
               in
                 ( if Nat.<(BitCount 16 registers,1)
                     then DECODE_UNPREDICTABLE(mc,"StoreMultiple")
                   else ()
                 ; let
                     val increment = false
                     val index = true
                     val wback = true
                   in
                     Store
                       (StoreMultiple
                          (increment,
                           (index,(wback,(BitsN.B(0xD,4),registers)))))
                   end
                 )
               end
        else Skip ())
     | (true,
      (false,
       (true,
        (true,
         (false,(true,(true,(false,(false,(true,(false,(_,(E'0,_))))))))))))) =>
       (if Do(BitsN.B(0xE,4),Nat.>=(ArchVersion (),6))
          then ( if InITBlock ()
                   then DECODE_UNPREDICTABLE(mc,"Setend")
                 else ()
               ; let
                   val set_bigend =
                     (BitsN.fromBitstring([E'0],1)) = (BitsN.B(0x1,1))
                 in
                   System(Setend set_bigend)
                 end
               )
        else Skip ())
     | (true,
      (false,
       (true,
        (true,
         (false,
          (true,
           (true,(false,(false,(true,(true,(im'0,(_,(A'0,(I'0,F'0))))))))))))))) =>
       let
         val F = BitsN.fromBitstring([F'0],1)
         val I = BitsN.fromBitstring([I'0],1)
         val A = BitsN.fromBitstring([A'0],1)
       in
         if Do(BitsN.B(0xE,4),Nat.>=(ArchVersion (),6))
           then ( if ((BitsN.concat[A,I,F]) = (BitsN.B(0x0,3))) orelse
                     (InITBlock ())
                    then DECODE_UNPREDICTABLE(mc,"ChangeProcessorState")
                  else ()
                ; let
                    val enable =
                      (BitsN.fromBitstring([im'0],1)) = (BitsN.B(0x0,1))
                    val affectA = A = (BitsN.B(0x1,1))
                    val affectI = I = (BitsN.B(0x1,1))
                    val affectF = F = (BitsN.B(0x1,1))
                  in
                    System
                      (ChangeProcessorState
                         (enable,
                          (not enable,(affectA,(affectI,(affectF,NONE))))))
                  end
                )
         else Skip ()
       end
     | (true,
      (false,
       (true,
        (true,
         (true,
          (false,
           (true,
            (false,(opc'1,(opc'0,(Rm'2,(Rm'1,(Rm'0,(Rd'2,(Rd'1,Rd'0))))))))))))))) =>
       let
         val Rd = BitsN.fromBitstring([Rd'2,Rd'1,Rd'0],3)
         val Rm = BitsN.fromBitstring([Rm'2,Rm'1,Rm'0],3)
       in
         if Do(ThumbCondition (),Nat.>=(ArchVersion (),6))
           then case BitsN.fromBitstring([opc'1,opc'0],2) of
                   BitsN.B(0x0,_) =>
                     Media
                       (ByteReverse
                          (BitsN.fromNat(BitsN.toNat Rd,4),
                           BitsN.fromNat(BitsN.toNat Rm,4)))
                 | BitsN.B(0x1,_) =>
                   Media
                     (ByteReversePackedHalfword
                        (BitsN.fromNat(BitsN.toNat Rd,4),
                         BitsN.fromNat(BitsN.toNat Rm,4)))
                 | BitsN.B(0x3,_) =>
                   Media
                     (ByteReverseSignedHalfword
                        (BitsN.fromNat(BitsN.toNat Rd,4),
                         BitsN.fromNat(BitsN.toNat Rm,4)))
                 | _ => Undefined(BitsN.B(0x0,32))
         else Skip ()
       end
     | (true,
      (false,
       (true,
        (true,
         (true,
          (true,
           (false,
            (P'0,
             (register_list'7,
              (register_list'6,
               (register_list'5,
                (register_list'4,
                 (register_list'3,
                  (register_list'2,(register_list'1,register_list'0))))))))))))))) =>
       (if Do(ThumbCondition (),true)
          then let
                 val registers =
                   BitsN.concat
                     [BitsN.fromBitstring([P'0],1),BitsN.B(0x0,7),
                      BitsN.fromBitstring
                        ([register_list'7,register_list'6,register_list'5,
                          register_list'4,register_list'3,register_list'2,
                          register_list'1,register_list'0],8)]
               in
                 ( if (Nat.<(BitCount 16 registers,1)) orelse
                      ((BitsN.bit(registers,15)) andalso
                       ((InITBlock ()) andalso (not(LastInITBlock ()))))
                     then DECODE_UNPREDICTABLE(mc,"LoadMultiple")
                   else ()
                 ; let
                     val increment = true
                     val index = false
                     val wback = true
                   in
                     Load
                       (LoadMultiple
                          (increment,
                           (index,(wback,(BitsN.B(0xD,4),registers)))))
                   end
                 )
               end
        else Skip ())
     | (true,
      (false,
       (true,
        (true,
         (true,
          (true,
           (true,
            (false,
             (imm8'7,
              (imm8'6,(imm8'5,(imm8'4,(imm8'3,(imm8'2,(imm8'1,imm8'0))))))))))))))) =>
       (if Do(BitsN.B(0xE,4),Nat.>=(ArchVersion (),5))
          then let
                 val imm32 =
                   BitsN.zeroExtend 32
                     (BitsN.fromBitstring
                        ([imm8'7,imm8'6,imm8'5,imm8'4,imm8'3,imm8'2,
                          imm8'1,imm8'0],8))
               in
                 Hint(Breakpoint imm32)
               end
        else Skip ())
     | (true,
      (false,
       (true,
        (true,
         (true,
          (true,
           (true,
            (true,
             (op'3,(op'2,(op'1,(op'0,(false,(false,(false,false))))))))))))))) =>
       DecodeHint
         (ThumbCondition (),
          BitsN.zeroExtend 8
            (BitsN.fromBitstring([op'3,op'2,op'1,op'0],4)))
     | (true,
      (false,
       (true,
        (true,
         (true,
          (true,
           (true,
            (true,
             (firstcond'3,
              (firstcond'2,
               (firstcond'1,
                (firstcond'0,(mask'3,(mask'2,(mask'1,mask'0))))))))))))))) =>
       let
         val mask = BitsN.fromBitstring([mask'3,mask'2,mask'1,mask'0],4)
         val firstcond =
           BitsN.fromBitstring
             ([firstcond'3,firstcond'2,firstcond'1,firstcond'0],4)
       in
         if Do(BitsN.B(0xE,4),HaveThumb2 ())
           then ( if (firstcond = (BitsN.B(0xF,4))) orelse
                     (((firstcond = (BitsN.B(0xE,4))) andalso
                       (not((BitCount 4 mask) = 1))) orelse (InITBlock ()))
                    then DECODE_UNPREDICTABLE(mc,"IfThen")
                  else ()
                ; IfThen(firstcond,mask)
                )
         else Skip ()
       end
     | (true,
      (true,
       (false,
        (false,
         (false,
          (Rn'2,
           (Rn'1,
            (Rn'0,
             (register_list'7,
              (register_list'6,
               (register_list'5,
                (register_list'4,
                 (register_list'3,
                  (register_list'2,(register_list'1,register_list'0))))))))))))))) =>
       (if Do(ThumbCondition (),true)
          then let
                 val registers =
                   BitsN.fromNat
                     (BitsN.toNat
                        (BitsN.fromBitstring
                           ([register_list'7,register_list'6,
                             register_list'5,register_list'4,
                             register_list'3,register_list'2,
                             register_list'1,register_list'0],8)),16)
               in
                 ( if Nat.<(BitCount 16 registers,1)
                     then DECODE_UNPREDICTABLE(mc,"StoreMultiple")
                   else ()
                 ; let
                     val increment = true
                     val index = false
                     val wback = true
                   in
                     Store
                       (StoreMultiple
                          (increment,
                           (index,
                            (wback,
                             (BitsN.fromNat
                                (BitsN.toNat
                                   (BitsN.fromBitstring
                                      ([Rn'2,Rn'1,Rn'0],3)),4),registers)))))
                   end
                 )
               end
        else Skip ())
     | (true,
      (true,
       (false,
        (false,
         (true,
          (Rn'2,
           (Rn'1,
            (Rn'0,
             (register_list'7,
              (register_list'6,
               (register_list'5,
                (register_list'4,
                 (register_list'3,
                  (register_list'2,(register_list'1,register_list'0))))))))))))))) =>
       let
         val Rn = BitsN.fromBitstring([Rn'2,Rn'1,Rn'0],3)
       in
         if Do(ThumbCondition (),true)
           then let
                  val registers =
                    BitsN.fromNat
                      (BitsN.toNat
                         (BitsN.fromBitstring
                            ([register_list'7,register_list'6,
                              register_list'5,register_list'4,
                              register_list'3,register_list'2,
                              register_list'1,register_list'0],8)),16)
                in
                  ( if Nat.<(BitCount 16 registers,1)
                      then DECODE_UNPREDICTABLE(mc,"LoadMultiple")
                    else ()
                  ; let
                      val increment = true
                      val index = false
                      val wback = not(BitsN.bit(registers,BitsN.toNat Rn))
                    in
                      Load
                        (LoadMultiple
                           (increment,
                            (index,
                             (wback,
                              (BitsN.fromNat(BitsN.toNat Rn,4),registers)))))
                    end
                  )
                end
         else Skip ()
       end
     | (true,
      (true,
       (false,
        (true,
         (true,
          (true,
           (true,
            (false,
             (imm8'7,
              (imm8'6,(imm8'5,(imm8'4,(imm8'3,(imm8'2,(imm8'1,imm8'0))))))))))))))) =>
       (if Do(ThumbCondition (),true)
          then let
                 val imm32 =
                   BitsN.zeroExtend 32
                     (BitsN.fromBitstring
                        ([imm8'7,imm8'6,imm8'5,imm8'4,imm8'3,imm8'2,
                          imm8'1,imm8'0],8))
               in
                 Undefined imm32
               end
        else Skip ())
     | (true,
      (true,
       (false,
        (true,
         (true,
          (true,
           (true,
            (true,
             (imm8'7,
              (imm8'6,(imm8'5,(imm8'4,(imm8'3,(imm8'2,(imm8'1,imm8'0))))))))))))))) =>
       (if Do(ThumbCondition (),true)
          then System
                 (SupervisorCall
                    (BitsN.zeroExtend 32
                       (BitsN.fromBitstring
                          ([imm8'7,imm8'6,imm8'5,imm8'4,imm8'3,imm8'2,
                            imm8'1,imm8'0],8))))
        else Skip ())
     | (true,
      (true,
       (false,
        (true,
         (cond'3,
          (cond'2,
           (cond'1,
            (cond'0,
             (imm8'7,
              (imm8'6,(imm8'5,(imm8'4,(imm8'3,(imm8'2,(imm8'1,imm8'0))))))))))))))) =>
       (if Do(BitsN.fromBitstring([cond'3,cond'2,cond'1,cond'0],4),true)
          then ( if InITBlock ()
                   then DECODE_UNPREDICTABLE(mc,"BranchTarget")
                 else ()
               ; let
                   val imm32 =
                     BitsN.signExtend 32
                       (BitsN.@@
                          (BitsN.fromBitstring
                             ([imm8'7,imm8'6,imm8'5,imm8'4,imm8'3,imm8'2,
                               imm8'1,imm8'0],8),BitsN.B(0x0,1)))
                 in
                   Branch(BranchTarget imm32)
                 end
               )
        else Skip ())
     | (true,
      (true,
       (true,
        (false,
         (false,
          (imm11'10,
           (imm11'9,
            (imm11'8,
             (imm11'7,
              (imm11'6,
               (imm11'5,(imm11'4,(imm11'3,(imm11'2,(imm11'1,imm11'0))))))))))))))) =>
       (if Do(ThumbCondition (),true)
          then ( if (InITBlock ()) andalso (not(LastInITBlock ()))
                   then DECODE_UNPREDICTABLE(mc,"BranchTarget")
                 else ()
               ; let
                   val imm32 =
                     BitsN.signExtend 32
                       (BitsN.@@
                          (BitsN.fromBitstring
                             ([imm11'10,imm11'9,imm11'8,imm11'7,imm11'6,
                               imm11'5,imm11'4,imm11'3,imm11'2,imm11'1,
                               imm11'0],11),BitsN.B(0x0,1)))
                 in
                   Branch(BranchTarget imm32)
                 end
               )
        else Skip ())
     | _ => UndefinedThumb ()
  end;

fun DecodeThumbEE h =
  let
    val mc = Thumb h
  in
    case boolify'16 h of
       (false,
        (true,
         (false,
          (true,
           (opc'2,
            (opc'1,
             (opc'0,
              (Rm'2,(Rm'1,(Rm'0,(Rn'2,(Rn'1,(Rn'0,(Rt'2,(Rt'1,Rt'0))))))))))))))) =>
         let
           val Rt = BitsN.fromBitstring([Rt'2,Rt'1,Rt'0],3)
           val Rn = BitsN.fromBitstring([Rn'2,Rn'1,Rn'0],3)
         in
           if Do(ThumbCondition (),true)
             then let
                    val index = true
                    val add = true
                    val wback = false
                    val m =
                      BitsN.fromNat
                        (BitsN.toNat
                           (BitsN.fromBitstring([Rm'2,Rm'1,Rm'0],3)),4)
                    val m1 = register_form1(m,(SRType_LSL,1))
                    val m2 = register_form1(m,(SRType_LSL,2))
                  in
                    case BitsN.fromBitstring([opc'2,opc'1,opc'0],3) of
                       BitsN.B(0x0,_) =>
                         Store
                           (StoreWord
                              (add,
                               (index,
                                (wback,
                                 (BitsN.fromNat(BitsN.toNat Rt,4),
                                  (BitsN.fromNat(BitsN.toNat Rn,4),m2))))))
                     | BitsN.B(0x1,_) =>
                       Store
                         (StoreHalf
                            (add,
                             (index,
                              (wback,
                               (BitsN.fromNat(BitsN.toNat Rt,4),
                                (BitsN.fromNat(BitsN.toNat Rn,4),m1))))))
                     | BitsN.B(0x4,_) =>
                       Load
                         (LoadWord
                            (add,
                             (index,
                              (wback,
                               (BitsN.fromNat(BitsN.toNat Rt,4),
                                (BitsN.fromNat(BitsN.toNat Rn,4),m2))))))
                     | BitsN.B(0x5,_) =>
                       Load
                         (LoadHalf
                            (true,
                             (add,
                              (index,
                               (wback,
                                (BitsN.fromNat(BitsN.toNat Rt,4),
                                 (BitsN.fromNat(BitsN.toNat Rn,4),m1)))))))
                     | BitsN.B(0x7,_) =>
                       Load
                         (LoadHalf
                            (false,
                             (add,
                              (index,
                               (wback,
                                (BitsN.fromNat(BitsN.toNat Rt,4),
                                 (BitsN.fromNat(BitsN.toNat Rn,4),m1)))))))
                     | _ => DecodeThumb h
                  end
           else Skip ()
         end
     | (true,
      (true,
       (false,
        (false,
         (false,
          (false,
           (false,
            (false,
             (imm3'2,
              (imm3'1,
               (imm3'0,
                (handler'4,(handler'3,(handler'2,(handler'1,handler'0))))))))))))))) =>
       (if Do(ThumbCondition (),true)
          then ( if (InITBlock ()) andalso (not(LastInITBlock ()))
                   then DECODE_UNPREDICTABLE(mc,"HandlerBranchParameter")
                 else ()
               ; let
                   val imm32 =
                     BitsN.zeroExtend 32
                       (BitsN.fromBitstring([imm3'2,imm3'1,imm3'0],3))
                   val handler_offset =
                     BitsN.zeroExtend 32
                       (BitsN.@@
                          (BitsN.fromBitstring
                             ([handler'4,handler'3,handler'2,handler'1,
                               handler'0],5),BitsN.B(0x0,5)))
                 in
                   Branch(HandlerBranchParameter(imm32,handler_offset))
                 end
               )
        else Skip ())
     | (true,(true,(false,(false,(false,(false,(false,(true,_)))))))) =>
       Undefined(BitsN.B(0x0,32))
     | (true,
      (true,
       (false,
        (false,
         (false,
          (false,
           (true,
            (L'0,
             (handler'7,
              (handler'6,
               (handler'5,
                (handler'4,(handler'3,(handler'2,(handler'1,handler'0))))))))))))))) =>
       (if Do(ThumbCondition (),true)
          then ( if (InITBlock ()) andalso (not(LastInITBlock ()))
                   then DECODE_UNPREDICTABLE(mc,"HandlerBranchLink")
                 else ()
               ; let
                   val generate_link =
                     (BitsN.fromBitstring([L'0],1)) = (BitsN.B(0x1,1))
                   val handler_offset =
                     BitsN.zeroExtend 32
                       (BitsN.@@
                          (BitsN.fromBitstring
                             ([handler'7,handler'6,handler'5,handler'4,
                               handler'3,handler'2,handler'1,handler'0],8),
                           BitsN.B(0x0,5)))
                 in
                   Branch(HandlerBranchLink(generate_link,handler_offset))
                 end
               )
        else Skip ())
     | (true,
      (true,
       (false,
        (false,
         (false,
          (true,
           (imm5'4,
            (imm5'3,
             (imm5'2,
              (imm5'1,
               (imm5'0,
                (handler'4,(handler'3,(handler'2,(handler'1,handler'0))))))))))))))) =>
       (if Do(ThumbCondition (),true)
          then ( if (InITBlock ()) andalso (not(LastInITBlock ()))
                   then DECODE_UNPREDICTABLE
                          (mc,"HandlerBranchLinkParameter")
                 else ()
               ; let
                   val imm32 =
                     BitsN.zeroExtend 32
                       (BitsN.fromBitstring
                          ([imm5'4,imm5'3,imm5'2,imm5'1,imm5'0],5))
                   val handler_offset =
                     BitsN.zeroExtend 32
                       (BitsN.@@
                          (BitsN.fromBitstring
                             ([handler'4,handler'3,handler'2,handler'1,
                               handler'0],5),BitsN.B(0x0,5)))
                 in
                   Branch
                     (HandlerBranchLinkParameter(imm32,handler_offset))
                 end
               )
        else Skip ())
     | (true,
      (true,
       (false,
        (false,
         (true,
          (false,
           (false,
            (imm3'2,
             (imm3'1,(imm3'0,(Rn'2,(Rn'1,(Rn'0,(Rt'2,(Rt'1,Rt'0))))))))))))))) =>
       (if Do(ThumbCondition (),true)
          then let
                 val index = true
                 val add = false
                 val wback = false
                 val imm32 =
                   BitsN.zeroExtend 32
                     (BitsN.@@
                        (BitsN.fromBitstring([imm3'2,imm3'1,imm3'0],3),
                         BitsN.B(0x0,2)))
                 val m = immediate_form1 imm32
               in
                 Load
                   (LoadWord
                      (add,
                       (index,
                        (wback,
                         (BitsN.fromNat
                            (BitsN.toNat
                               (BitsN.fromBitstring([Rt'2,Rt'1,Rt'0],3)),4),
                          (BitsN.fromNat
                             (BitsN.toNat
                                (BitsN.fromBitstring([Rn'2,Rn'1,Rn'0],3)),
                              4),m))))))
               end
        else Skip ())
     | (true,
      (true,
       (false,
        (false,
         (true,
          (false,
           (true,
            (false,(N'0,(Rm'3,(Rm'2,(Rm'1,(Rm'0,(Rn'2,(Rn'1,Rn'0))))))))))))))) =>
       let
         val Rm = BitsN.fromBitstring([Rm'3,Rm'2,Rm'1,Rm'0],4)
       in
         if Do(ThumbCondition (),true)
           then let
                  val n =
                    BitsN.@@
                      (BitsN.fromBitstring([N'0],1),
                       BitsN.fromBitstring([Rn'2,Rn'1,Rn'0],3))
                in
                  ( if (n = (BitsN.B(0xF,4))) orelse
                       (Set.mem(Rm,[BitsN.B(0xD,4),BitsN.B(0xF,4)]))
                      then DECODE_UNPREDICTABLE(mc,"CheckArray")
                    else ()
                  ; Branch(CheckArray(Rm,n))
                  )
                end
         else Skip ()
       end
     | (true,
      (true,
       (false,
        (false,
         (true,
          (false,
           (true,
            (true,
             (imm5'4,
              (imm5'3,(imm5'2,(imm5'1,(imm5'0,(Rt'2,(Rt'1,Rt'0))))))))))))))) =>
       (if Do(ThumbCondition (),true)
          then let
                 val index = true
                 val add = true
                 val wback = false
                 val imm32 =
                   BitsN.zeroExtend 32
                     (BitsN.@@
                        (BitsN.fromBitstring
                           ([imm5'4,imm5'3,imm5'2,imm5'1,imm5'0],5),
                         BitsN.B(0x0,2)))
                 val m = immediate_form1 imm32
               in
                 Load
                   (LoadWord
                      (add,
                       (index,
                        (wback,
                         (BitsN.fromNat
                            (BitsN.toNat
                               (BitsN.fromBitstring([Rt'2,Rt'1,Rt'0],3)),4),
                          (BitsN.B(0xA,4),m))))))
               end
        else Skip ())
     | (true,
      (true,
       (false,
        (false,
         (true,
          (true,
           (S'0,
            (imm6'5,
             (imm6'4,
              (imm6'3,(imm6'2,(imm6'1,(imm6'0,(Rt'2,(Rt'1,Rt'0))))))))))))))) =>
       let
         val Rt = BitsN.fromBitstring([Rt'2,Rt'1,Rt'0],3)
       in
         if Do(ThumbCondition (),true)
           then let
                  val index = true
                  val add = true
                  val wback = false
                  val imm32 =
                    BitsN.zeroExtend 32
                      (BitsN.@@
                         (BitsN.fromBitstring
                            ([imm6'5,imm6'4,imm6'3,imm6'2,imm6'1,imm6'0],6),
                          BitsN.B(0x0,2)))
                  val m = immediate_form1 imm32
                in
                  if (BitsN.fromBitstring([S'0],1)) = (BitsN.B(0x1,1))
                    then Store
                           (StoreWord
                              (add,
                               (index,
                                (wback,
                                 (BitsN.fromNat(BitsN.toNat Rt,4),
                                  (BitsN.B(0x9,4),m))))))
                  else Load
                         (LoadWord
                            (add,
                             (index,
                              (wback,
                               (BitsN.fromNat(BitsN.toNat Rt,4),
                                (BitsN.B(0x9,4),m))))))
                end
         else Skip ()
       end
     | (ireg'15,
      (ireg'14,
       (ireg'13,
        (ireg'12,
         (ireg'11,
          (ireg'10,
           (ireg'9,
            (ireg'8,
             (ireg'7,
              (ireg'6,(ireg'5,(ireg'4,(ireg'3,(ireg'2,(ireg'1,ireg'0))))))))))))))) =>
       DecodeThumb
         (BitsN.fromBitstring
            ([ireg'15,ireg'14,ireg'13,ireg'12,ireg'11,ireg'10,ireg'9,
              ireg'8,ireg'7,ireg'6,ireg'5,ireg'4,ireg'3,ireg'2,ireg'1,
              ireg'0],16))
  end;

fun DecodeThumb2 h =
  let
    val mc = Thumb2 h
  in
    case (boolify'16(L3.fst h),boolify'16(L3.snd h)) of
       ((true,
         (true,
          (true,
           (false,
            (true,
             (false,
              (false,
               (false,
                (true,(false,(W'0,(false,(Rn'3,(Rn'2,(Rn'1,Rn'0))))))))))))))),
        (_,
         (M'0,
          (_,
           (register_list'12,
            (register_list'11,
             (register_list'10,
              (register_list'9,
               (register_list'8,
                (register_list'7,
                 (register_list'6,
                  (register_list'5,
                   (register_list'4,
                    (register_list'3,
                     (register_list'2,(register_list'1,register_list'0)))))))))))))))) =>
         let
           val Rn = BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)
         in
           if Do(ThumbCondition (),HaveThumb2 ())
             then let
                    val registers =
                      BitsN.concat
                        [BitsN.B(0x0,1),BitsN.fromBitstring([M'0],1),
                         BitsN.B(0x0,1),
                         BitsN.fromBitstring
                           ([register_list'12,register_list'11,
                             register_list'10,register_list'9,
                             register_list'8,register_list'7,
                             register_list'6,register_list'5,
                             register_list'4,register_list'3,
                             register_list'2,register_list'1,
                             register_list'0],13)]
                    val wback =
                      (BitsN.fromBitstring([W'0],1)) = (BitsN.B(0x1,1))
                  in
                    ( if (Rn = (BitsN.B(0xF,4))) orelse
                         ((Nat.<(BitCount 16 registers,2)) orelse
                          (wback andalso
                           (BitsN.bit(registers,BitsN.toNat Rn))))
                        then DECODE_UNPREDICTABLE(mc,"StoreMultiple")
                      else ()
                    ; let
                        val index = false
                        val increment = true
                      in
                        Store
                          (StoreMultiple
                             (increment,(index,(wback,(Rn,registers)))))
                      end
                    )
                  end
           else Skip ()
         end
     | ((true,
       (true,
        (true,
         (false,
          (true,
           (false,
            (false,
             (true,(false,(false,(W'0,(false,(Rn'3,(Rn'2,(Rn'1,Rn'0))))))))))))))),
      (_,
       (M'0,
        (_,
         (register_list'12,
          (register_list'11,
           (register_list'10,
            (register_list'9,
             (register_list'8,
              (register_list'7,
               (register_list'6,
                (register_list'5,
                 (register_list'4,
                  (register_list'3,
                   (register_list'2,(register_list'1,register_list'0)))))))))))))))) =>
       let
         val Rn = BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)
       in
         if Do(ThumbCondition (),HaveThumb2 ())
           then let
                  val registers =
                    BitsN.concat
                      [BitsN.B(0x0,1),BitsN.fromBitstring([M'0],1),
                       BitsN.B(0x0,1),
                       BitsN.fromBitstring
                         ([register_list'12,register_list'11,
                           register_list'10,register_list'9,
                           register_list'8,register_list'7,
                           register_list'6,register_list'5,
                           register_list'4,register_list'3,
                           register_list'2,register_list'1,register_list'0],
                          13)]
                  val wback =
                    (BitsN.fromBitstring([W'0],1)) = (BitsN.B(0x1,1))
                in
                  ( if (Rn = (BitsN.B(0xF,4))) orelse
                       ((Nat.<(BitCount 16 registers,2)) orelse
                        (wback andalso
                         (BitsN.bit(registers,BitsN.toNat Rn))))
                      then DECODE_UNPREDICTABLE(mc,"StoreMultiple")
                    else ()
                  ; let
                      val index = true
                      val increment = false
                    in
                      Store
                        (StoreMultiple
                           (increment,(index,(wback,(Rn,registers)))))
                    end
                  )
                end
         else Skip ()
       end
     | ((true,
       (true,
        (true,
         (false,
          (true,
           (false,
            (false,
             (false,(true,(false,(W'0,(true,(Rn'3,(Rn'2,(Rn'1,Rn'0))))))))))))))),
      (P'0,
       (M'0,
        (_,
         (register_list'12,
          (register_list'11,
           (register_list'10,
            (register_list'9,
             (register_list'8,
              (register_list'7,
               (register_list'6,
                (register_list'5,
                 (register_list'4,
                  (register_list'3,
                   (register_list'2,(register_list'1,register_list'0)))))))))))))))) =>
       let
         val Rn = BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)
         val M = BitsN.fromBitstring([M'0],1)
         val P = BitsN.fromBitstring([P'0],1)
       in
         if Do(ThumbCondition (),HaveThumb2 ())
           then let
                  val registers =
                    BitsN.concat
                      [P,M,BitsN.B(0x0,1),
                       BitsN.fromBitstring
                         ([register_list'12,register_list'11,
                           register_list'10,register_list'9,
                           register_list'8,register_list'7,
                           register_list'6,register_list'5,
                           register_list'4,register_list'3,
                           register_list'2,register_list'1,register_list'0],
                          13)]
                  val wback =
                    (BitsN.fromBitstring([W'0],1)) = (BitsN.B(0x1,1))
                in
                  ( if (Rn = (BitsN.B(0xF,4))) orelse
                       ((Nat.<(BitCount 16 registers,2)) orelse
                        (((P = (BitsN.B(0x1,1))) andalso
                          (M = (BitsN.B(0x1,1)))) orelse
                         (((BitsN.bit(registers,15)) andalso
                           ((InITBlock ()) andalso (not(LastInITBlock ())))) orelse
                          (wback andalso
                           (BitsN.bit(registers,BitsN.toNat Rn))))))
                      then DECODE_UNPREDICTABLE(mc,"LoadMultiple")
                    else ()
                  ; let
                      val index = false
                      val increment = true
                    in
                      Load
                        (LoadMultiple
                           (increment,(index,(wback,(Rn,registers)))))
                    end
                  )
                end
         else Skip ()
       end
     | ((true,
       (true,
        (true,
         (false,
          (true,
           (false,
            (false,
             (true,(false,(false,(W'0,(true,(Rn'3,(Rn'2,(Rn'1,Rn'0))))))))))))))),
      (P'0,
       (M'0,
        (_,
         (register_list'12,
          (register_list'11,
           (register_list'10,
            (register_list'9,
             (register_list'8,
              (register_list'7,
               (register_list'6,
                (register_list'5,
                 (register_list'4,
                  (register_list'3,
                   (register_list'2,(register_list'1,register_list'0)))))))))))))))) =>
       let
         val Rn = BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)
         val M = BitsN.fromBitstring([M'0],1)
         val P = BitsN.fromBitstring([P'0],1)
       in
         if Do(ThumbCondition (),HaveThumb2 ())
           then let
                  val registers =
                    BitsN.concat
                      [P,M,BitsN.B(0x0,1),
                       BitsN.fromBitstring
                         ([register_list'12,register_list'11,
                           register_list'10,register_list'9,
                           register_list'8,register_list'7,
                           register_list'6,register_list'5,
                           register_list'4,register_list'3,
                           register_list'2,register_list'1,register_list'0],
                          13)]
                  val wback =
                    (BitsN.fromBitstring([W'0],1)) = (BitsN.B(0x1,1))
                in
                  ( if (Rn = (BitsN.B(0xF,4))) orelse
                       ((Nat.<(BitCount 16 registers,2)) orelse
                        (((P = (BitsN.B(0x1,1))) andalso
                          (M = (BitsN.B(0x1,1)))) orelse
                         (((BitsN.bit(registers,15)) andalso
                           ((InITBlock ()) andalso (not(LastInITBlock ())))) orelse
                          (wback andalso
                           (BitsN.bit(registers,BitsN.toNat Rn))))))
                      then DECODE_UNPREDICTABLE(mc,"LoadMultiple")
                    else ()
                  ; let
                      val index = true
                      val increment = false
                    in
                      Load
                        (LoadMultiple
                           (increment,(index,(wback,(Rn,registers)))))
                    end
                  )
                end
         else Skip ()
       end
     | ((true,
       (true,
        (true,
         (false,
          (true,(false,(false,(op'1,(op'0,(false,(W'0,(false,_)))))))))))),
      (_,
       (_,
        (_,
         (_,
          (_,
           (_,
            (_,(_,(_,(_,(_,(mode'4,(mode'3,(mode'2,(mode'1,mode'0)))))))))))))))) =>
       let
         val op' = BitsN.fromBitstring([op'1,op'0],2)
       in
         if Do(ThumbCondition (),
               (Set.mem(op',[BitsN.B(0x0,2),BitsN.B(0x3,2)])) andalso
               (HaveThumb2 ()))
           then ( if (CurrentInstrSet ()) = InstrSet_ThumbEE
                    then DECODE_UNPREDICTABLE(mc,"StoreReturnState")
                  else ()
                ; let
                    val wback =
                      (BitsN.fromBitstring([W'0],1)) = (BitsN.B(0x1,1))
                    val increment = op' = (BitsN.B(0x3,2))
                    val wordhigher = false
                  in
                    System
                      (StoreReturnState
                         (increment,
                          (wordhigher,
                           (wback,
                            BitsN.fromBitstring
                              ([mode'4,mode'3,mode'2,mode'1,mode'0],5)))))
                  end
                )
         else Skip ()
       end
     | ((true,
       (true,
        (true,
         (false,
          (true,
           (false,
            (false,
             (op'1,(op'0,(false,(W'0,(true,(Rn'3,(Rn'2,(Rn'1,Rn'0))))))))))))))),
      _) =>
       let
         val Rn = BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)
         val op' = BitsN.fromBitstring([op'1,op'0],2)
       in
         if Do(ThumbCondition (),
               (Set.mem(op',[BitsN.B(0x0,2),BitsN.B(0x3,2)])) andalso
               (HaveThumb2 ()))
           then ( if ((CurrentInstrSet ()) = InstrSet_ThumbEE) orelse
                     ((Rn = (BitsN.B(0xF,4))) orelse
                      ((InITBlock ()) andalso (not(LastInITBlock ()))))
                    then DECODE_UNPREDICTABLE(mc,"ReturnFromException")
                  else ()
                ; let
                    val wback =
                      (BitsN.fromBitstring([W'0],1)) = (BitsN.B(0x1,1))
                    val increment = op' = (BitsN.B(0x3,2))
                    val wordhigher = false
                  in
                    System
                      (ReturnFromException
                         (increment,(wordhigher,(wback,Rn))))
                  end
                )
         else Skip ()
       end
     | ((true,
       (true,
        (true,
         (false,
          (true,
           (false,
            (false,
             (false,
              (false,(true,(false,(false,(Rn'3,(Rn'2,(Rn'1,Rn'0))))))))))))))),
      (Rt'3,
       (Rt'2,
        (Rt'1,
         (Rt'0,
          (Rd'3,
           (Rd'2,
            (Rd'1,
             (Rd'0,
              (imm8'7,
               (imm8'6,(imm8'5,(imm8'4,(imm8'3,(imm8'2,(imm8'1,imm8'0)))))))))))))))) =>
       let
         val Rn = BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)
         val Rd = BitsN.fromBitstring([Rd'3,Rd'2,Rd'1,Rd'0],4)
         val Rt = BitsN.fromBitstring([Rt'3,Rt'2,Rt'1,Rt'0],4)
       in
         if Do(ThumbCondition (),HaveThumb2 ())
           then ( if (Set.mem(Rd,[BitsN.B(0xD,4),BitsN.B(0xF,4)])) orelse
                     ((Set.mem(Rt,[BitsN.B(0xD,4),BitsN.B(0xF,4)])) orelse
                      ((Rn = (BitsN.B(0xF,4))) orelse
                       ((Rd = Rn) orelse (Rd = Rt))))
                    then DECODE_UNPREDICTABLE(mc,"StoreExclusive")
                  else ()
                ; let
                    val imm32 =
                      BitsN.zeroExtend 32
                        (BitsN.@@
                           (BitsN.fromBitstring
                              ([imm8'7,imm8'6,imm8'5,imm8'4,imm8'3,imm8'2,
                                imm8'1,imm8'0],8),BitsN.B(0x0,2)))
                  in
                    Store(StoreExclusive(Rd,(Rt,(Rn,imm32))))
                  end
                )
         else Skip ()
       end
     | ((true,
       (true,
        (true,
         (false,
          (true,
           (false,
            (false,
             (false,
              (false,(true,(false,(true,(Rn'3,(Rn'2,(Rn'1,Rn'0))))))))))))))),
      (Rt'3,
       (Rt'2,
        (Rt'1,
         (Rt'0,
          (Rd'3,
           (Rd'2,
            (Rd'1,
             (Rd'0,
              (imm8'7,
               (imm8'6,(imm8'5,(imm8'4,(imm8'3,(imm8'2,(imm8'1,imm8'0)))))))))))))))) =>
       let
         val Rn = BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)
         val Rt = BitsN.fromBitstring([Rt'3,Rt'2,Rt'1,Rt'0],4)
       in
         if Do(ThumbCondition (),HaveThumb2 ())
           then ( if (Set.mem(Rt,[BitsN.B(0xD,4),BitsN.B(0xF,4)])) orelse
                     (Rn = (BitsN.B(0xF,4)))
                    then DECODE_UNPREDICTABLE(mc,"StoreExclusive")
                  else ()
                ; let
                    val imm32 =
                      BitsN.zeroExtend 32
                        (BitsN.@@
                           (BitsN.fromBitstring
                              ([imm8'7,imm8'6,imm8'5,imm8'4,imm8'3,imm8'2,
                                imm8'1,imm8'0],8),BitsN.B(0x0,2)))
                  in
                    Load(LoadExclusive(Rt,(Rn,imm32)))
                  end
                )
         else Skip ()
       end
     | ((true,
       (true,
        (true,
         (false,
          (true,
           (false,
            (false,
             (false,
              (true,(true,(false,(false,(Rn'3,(Rn'2,(Rn'1,Rn'0))))))))))))))),
      (Rt'3,
       (Rt'2,
        (Rt'1,
         (Rt'0,
          (_,
           (_,
            (_,(_,(false,(true,(false,(H'0,(Rd'3,(Rd'2,(Rd'1,Rd'0)))))))))))))))) =>
       let
         val Rn = BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)
         val Rd = BitsN.fromBitstring([Rd'3,Rd'2,Rd'1,Rd'0],4)
         val Rt = BitsN.fromBitstring([Rt'3,Rt'2,Rt'1,Rt'0],4)
       in
         if Do(ThumbCondition (),Nat.>=(ArchVersion (),7))
           then ( if (Set.mem(Rd,[BitsN.B(0xD,4),BitsN.B(0xF,4)])) orelse
                     ((Set.mem(Rt,[BitsN.B(0xD,4),BitsN.B(0xF,4)])) orelse
                      ((Rn = (BitsN.B(0xF,4))) orelse
                       ((Rd = Rn) orelse (Rd = Rt))))
                    then DECODE_UNPREDICTABLE
                           (mc,"StoreExclusive: Byte or Halfword")
                  else ()
                ; if (BitsN.fromBitstring([H'0],1)) = (BitsN.B(0x1,1))
                    then Store(StoreExclusiveHalf(Rd,(Rt,Rn)))
                  else Store(StoreExclusiveByte(Rd,(Rt,Rn)))
                )
         else Skip ()
       end
     | ((true,
       (true,
        (true,
         (false,
          (true,
           (false,
            (false,
             (false,
              (true,(true,(false,(false,(Rn'3,(Rn'2,(Rn'1,Rn'0))))))))))))))),
      (Rt'3,
       (Rt'2,
        (Rt'1,
         (Rt'0,
          (Rt2'3,
           (Rt2'2,
            (Rt2'1,
             (Rt2'0,(false,(true,(true,(true,(Rd'3,(Rd'2,(Rd'1,Rd'0)))))))))))))))) =>
       let
         val Rn = BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)
         val Rd = BitsN.fromBitstring([Rd'3,Rd'2,Rd'1,Rd'0],4)
         val Rt2 = BitsN.fromBitstring([Rt2'3,Rt2'2,Rt2'1,Rt2'0],4)
         val Rt = BitsN.fromBitstring([Rt'3,Rt'2,Rt'1,Rt'0],4)
       in
         if Do(ThumbCondition (),Nat.>=(ArchVersion (),7))
           then ( if (Set.mem(Rd,[BitsN.B(0xD,4),BitsN.B(0xF,4)])) orelse
                     ((Set.mem(Rt,[BitsN.B(0xD,4),BitsN.B(0xF,4)])) orelse
                      ((Set.mem(Rt2,[BitsN.B(0xD,4),BitsN.B(0xF,4)])) orelse
                       ((Rn = (BitsN.B(0xF,4))) orelse
                        ((Rd = Rn) orelse (Rd = Rt)))))
                    then DECODE_UNPREDICTABLE
                           (mc,"StoreExclusivDoubleword")
                  else ()
                ; Store(StoreExclusiveDoubleword(Rd,(Rt,(Rt2,Rn))))
                )
         else Skip ()
       end
     | ((true,
       (true,
        (true,
         (false,
          (true,
           (false,
            (false,
             (false,(true,(true,(false,(true,(Rn'3,(Rn'2,(Rn'1,Rn'0))))))))))))))),
      (_,
       (_,
        (_,
         (_,
          (_,
           (_,
            (_,(_,(false,(false,(false,(H'0,(Rm'3,(Rm'2,(Rm'1,Rm'0)))))))))))))))) =>
       let
         val Rn = BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)
         val Rm = BitsN.fromBitstring([Rm'3,Rm'2,Rm'1,Rm'0],4)
       in
         if Do(ThumbCondition (),HaveThumb2 ())
           then ( if (Rn = (BitsN.B(0xD,4))) orelse
                     ((Set.mem(Rm,[BitsN.B(0xD,4),BitsN.B(0xF,4)])) orelse
                      ((InITBlock ()) andalso (not(LastInITBlock ()))))
                    then DECODE_UNPREDICTABLE(mc,"TableBranchByte")
                  else ()
                ; let
                    val is_tbh =
                      (BitsN.fromBitstring([H'0],1)) = (BitsN.B(0x1,1))
                  in
                    Branch(TableBranchByte(is_tbh,(Rm,Rn)))
                  end
                )
         else Skip ()
       end
     | ((true,
       (true,
        (true,
         (false,
          (true,
           (false,
            (false,
             (false,(true,(true,(false,(true,(Rn'3,(Rn'2,(Rn'1,Rn'0))))))))))))))),
      (Rt'3,
       (Rt'2,
        (Rt'1,
         (Rt'0,
          (_,
           (_,
            (_,(_,(false,(true,(false,(H'0,(Rd'3,(Rd'2,(Rd'1,Rd'0)))))))))))))))) =>
       let
         val Rn = BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)
         val Rt = BitsN.fromBitstring([Rt'3,Rt'2,Rt'1,Rt'0],4)
       in
         if Do(ThumbCondition (),Nat.>=(ArchVersion (),7))
           then ( if (Set.mem(Rt,[BitsN.B(0xD,4),BitsN.B(0xF,4)])) orelse
                     (Rn = (BitsN.B(0xF,4)))
                    then DECODE_UNPREDICTABLE
                           (mc,"LoadExclusive: Byte or Halfword")
                  else ()
                ; if (BitsN.fromBitstring([H'0],1)) = (BitsN.B(0x1,1))
                    then Load(LoadExclusiveHalf(Rt,Rn))
                  else Load(LoadExclusiveByte(Rt,Rn))
                )
         else Skip ()
       end
     | ((true,
       (true,
        (true,
         (false,
          (true,
           (false,
            (false,
             (false,(true,(true,(false,(true,(Rn'3,(Rn'2,(Rn'1,Rn'0))))))))))))))),
      (Rt'3,
       (Rt'2,
        (Rt'1,
         (Rt'0,
          (Rt2'3,(Rt2'2,(Rt2'1,(Rt2'0,(false,(true,(true,(true,_))))))))))))) =>
       let
         val Rn = BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)
         val Rt2 = BitsN.fromBitstring([Rt2'3,Rt2'2,Rt2'1,Rt2'0],4)
         val Rt = BitsN.fromBitstring([Rt'3,Rt'2,Rt'1,Rt'0],4)
       in
         if Do(ThumbCondition (),Nat.>=(ArchVersion (),7))
           then ( if (Set.mem(Rt,[BitsN.B(0xD,4),BitsN.B(0xF,4)])) orelse
                     ((Set.mem(Rt2,[BitsN.B(0xD,4),BitsN.B(0xF,4)])) orelse
                      ((Rt = Rt2) orelse (Rn = (BitsN.B(0xF,4)))))
                    then DECODE_UNPREDICTABLE
                           (mc,"LoadExclusiveDoubleword")
                  else ()
                ; Load(LoadExclusiveDoubleword(Rt,(Rt2,Rn)))
                )
         else Skip ()
       end
     | ((true,
       (true,
        (true,
         (false,
          (true,
           (false,
            (false,
             (P'0,(U'0,(true,(W'0,(false,(Rn'3,(Rn'2,(Rn'1,Rn'0))))))))))))))),
      (Rt'3,
       (Rt'2,
        (Rt'1,
         (Rt'0,
          (Rt2'3,
           (Rt2'2,
            (Rt2'1,
             (Rt2'0,
              (imm8'7,
               (imm8'6,(imm8'5,(imm8'4,(imm8'3,(imm8'2,(imm8'1,imm8'0)))))))))))))))) =>
       let
         val Rn = BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)
         val W = BitsN.fromBitstring([W'0],1)
         val P = BitsN.fromBitstring([P'0],1)
         val Rt2 = BitsN.fromBitstring([Rt2'3,Rt2'2,Rt2'1,Rt2'0],4)
         val Rt = BitsN.fromBitstring([Rt'3,Rt'2,Rt'1,Rt'0],4)
       in
         if Do(ThumbCondition (),
               ((P = (BitsN.B(0x1,1))) orelse (W = (BitsN.B(0x1,1)))) andalso
               (HaveThumb2 ()))
           then let
                  val wback = W = (BitsN.B(0x1,1))
                in
                  ( if (wback andalso ((Rn = Rt) orelse (Rn = Rt2))) orelse
                       ((Rn = (BitsN.B(0xF,4))) orelse
                        ((Set.mem(Rt,[BitsN.B(0xD,4),BitsN.B(0xF,4)])) orelse
                         (Set.mem(Rt2,[BitsN.B(0xD,4),BitsN.B(0xF,4)]))))
                      then DECODE_UNPREDICTABLE(mc,"StoreDual")
                    else ()
                  ; let
                      val index = P = (BitsN.B(0x1,1))
                      val add =
                        (BitsN.fromBitstring([U'0],1)) = (BitsN.B(0x1,1))
                      val imm32 =
                        BitsN.zeroExtend 32
                          (BitsN.@@
                             (BitsN.fromBitstring
                                ([imm8'7,imm8'6,imm8'5,imm8'4,imm8'3,
                                  imm8'2,imm8'1,imm8'0],8),BitsN.B(0x0,2)))
                      val m = immediate_form2 imm32
                    in
                      Store
                        (StoreDual(add,(index,(wback,(Rt,(Rt2,(Rn,m)))))))
                    end
                  )
                end
         else Skip ()
       end
     | ((true,
       (true,
        (true,
         (false,
          (true,
           (false,
            (false,
             (P'0,(U'0,(true,(W'0,(true,(true,(true,(true,true))))))))))))))),
      (Rt'3,
       (Rt'2,
        (Rt'1,
         (Rt'0,
          (Rt2'3,
           (Rt2'2,
            (Rt2'1,
             (Rt2'0,
              (imm8'7,
               (imm8'6,(imm8'5,(imm8'4,(imm8'3,(imm8'2,(imm8'1,imm8'0)))))))))))))))) =>
       let
         val W = BitsN.fromBitstring([W'0],1)
         val Rt2 = BitsN.fromBitstring([Rt2'3,Rt2'2,Rt2'1,Rt2'0],4)
         val Rt = BitsN.fromBitstring([Rt'3,Rt'2,Rt'1,Rt'0],4)
       in
         if Do(ThumbCondition (),
               (((BitsN.fromBitstring([P'0],1)) = (BitsN.B(0x1,1))) orelse
                (W = (BitsN.B(0x1,1)))) andalso (HaveThumb2 ()))
           then ( if (Set.mem(Rt,[BitsN.B(0xD,4),BitsN.B(0xF,4)])) orelse
                     ((Set.mem(Rt2,[BitsN.B(0xD,4),BitsN.B(0xF,4)])) orelse
                      ((Rt = Rt2) orelse (W = (BitsN.B(0x1,1)))))
                    then DECODE_UNPREDICTABLE(mc,"LoadDual: literal")
                  else ()
                ; let
                    val imm32 =
                      BitsN.zeroExtend 32
                        (BitsN.@@
                           (BitsN.fromBitstring
                              ([imm8'7,imm8'6,imm8'5,imm8'4,imm8'3,imm8'2,
                                imm8'1,imm8'0],8),BitsN.B(0x0,2)))
                    val add =
                      (BitsN.fromBitstring([U'0],1)) = (BitsN.B(0x1,1))
                  in
                    Load(LoadDualLiteral(add,(Rt,(Rt2,imm32))))
                  end
                )
         else Skip ()
       end
     | ((true,
       (true,
        (true,
         (false,
          (true,
           (false,
            (false,
             (P'0,(U'0,(true,(W'0,(true,(Rn'3,(Rn'2,(Rn'1,Rn'0))))))))))))))),
      (Rt'3,
       (Rt'2,
        (Rt'1,
         (Rt'0,
          (Rt2'3,
           (Rt2'2,
            (Rt2'1,
             (Rt2'0,
              (imm8'7,
               (imm8'6,(imm8'5,(imm8'4,(imm8'3,(imm8'2,(imm8'1,imm8'0)))))))))))))))) =>
       let
         val Rn = BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)
         val W = BitsN.fromBitstring([W'0],1)
         val P = BitsN.fromBitstring([P'0],1)
         val Rt2 = BitsN.fromBitstring([Rt2'3,Rt2'2,Rt2'1,Rt2'0],4)
         val Rt = BitsN.fromBitstring([Rt'3,Rt'2,Rt'1,Rt'0],4)
       in
         if Do(ThumbCondition (),
               ((P = (BitsN.B(0x1,1))) orelse (W = (BitsN.B(0x1,1)))) andalso
               (HaveThumb2 ()))
           then let
                  val wback = W = (BitsN.B(0x1,1))
                in
                  ( if (wback andalso ((Rn = Rt) orelse (Rn = Rt2))) orelse
                       ((Set.mem(Rt,[BitsN.B(0xD,4),BitsN.B(0xF,4)])) orelse
                        ((Set.mem(Rt2,[BitsN.B(0xD,4),BitsN.B(0xF,4)])) orelse
                         (Rt = Rt2)))
                      then DECODE_UNPREDICTABLE(mc,"LoadDual")
                    else ()
                  ; let
                      val index = P = (BitsN.B(0x1,1))
                      val add =
                        (BitsN.fromBitstring([U'0],1)) = (BitsN.B(0x1,1))
                      val imm32 =
                        BitsN.zeroExtend 32
                          (BitsN.@@
                             (BitsN.fromBitstring
                                ([imm8'7,imm8'6,imm8'5,imm8'4,imm8'3,
                                  imm8'2,imm8'1,imm8'0],8),BitsN.B(0x0,2)))
                      val m = immediate_form2 imm32
                    in
                      Load
                        (LoadDual(add,(index,(wback,(Rt,(Rt2,(Rn,m)))))))
                    end
                  )
                end
         else Skip ()
       end
     | ((true,
       (true,
        (true,
         (false,
          (true,
           (false,
            (true,
             (op'3,(op'2,(op'1,(op'0,(S'0,(Rn'3,(Rn'2,(Rn'1,Rn'0))))))))))))))),
      (_,
       (imm3'2,
        (imm3'1,
         (imm3'0,
          (Rd'3,
           (Rd'2,
            (Rd'1,
             (Rd'0,
              (imm2'1,(imm2'0,(typ'1,(typ'0,(Rm'3,(Rm'2,(Rm'1,Rm'0)))))))))))))))) =>
       let
         val Rn = BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)
         val S = BitsN.fromBitstring([S'0],1)
         val Rm = BitsN.fromBitstring([Rm'3,Rm'2,Rm'1,Rm'0],4)
         val typ = BitsN.fromBitstring([typ'1,typ'0],2)
         val imm2 = BitsN.fromBitstring([imm2'1,imm2'0],2)
         val Rd = BitsN.fromBitstring([Rd'3,Rd'2,Rd'1,Rd'0],4)
         val imm3 = BitsN.fromBitstring([imm3'2,imm3'1,imm3'0],3)
       in
         if Do(ThumbCondition (),HaveThumb2 ())
           then let
                  val (shift_t,shift_n) =
                    DecodeImmShift(typ,BitsN.@@(imm3,imm2))
                  val setflags = S = (BitsN.B(0x1,1))
                in
                  case (BitsN.fromBitstring([op'3,op'2,op'1,op'0],4),
                   (Rn,(Rd,S))) of
                     (BitsN.B(0x0,_),(_,(BitsN.B(0xF,_),BitsN.B(0x1,_)))) =>
                       ( if (Set.mem(Rn,[BitsN.B(0xD,4),BitsN.B(0xF,4)])) orelse
                            (Set.mem(Rm,[BitsN.B(0xD,4),BitsN.B(0xF,4)]))
                           then DECODE_UNPREDICTABLE(mc,"TST (register)")
                         else ()
                       ; Data
                           (TestCompareRegister
                              (BitsN.B(0x0,2),(Rn,(Rm,(shift_t,shift_n)))))
                       )
                   | (BitsN.B(0x0,_),_) =>
                     ( if (Rd = (BitsN.B(0xD,4))) orelse
                          (((Rd = (BitsN.B(0xF,4))) andalso (not setflags)) orelse
                           ((Set.mem(Rn,[BitsN.B(0xD,4),BitsN.B(0xF,4)])) orelse
                            (Set.mem(Rm,[BitsN.B(0xD,4),BitsN.B(0xF,4)]))))
                         then DECODE_UNPREDICTABLE(mc,"AND (register)")
                       else ()
                     ; Data
                         (Register
                            (BitsN.B(0x0,4),
                             (setflags,(Rd,(Rn,(Rm,(shift_t,shift_n)))))))
                     )
                   | (BitsN.B(0x1,_),_) =>
                     ( if (Set.mem(Rd,[BitsN.B(0xD,4),BitsN.B(0xF,4)])) orelse
                          ((Set.mem(Rn,[BitsN.B(0xD,4),BitsN.B(0xF,4)])) orelse
                           (Set.mem(Rm,[BitsN.B(0xD,4),BitsN.B(0xF,4)])))
                         then DECODE_UNPREDICTABLE(mc,"BIC (register)")
                       else ()
                     ; Data
                         (Register
                            (BitsN.B(0xE,4),
                             (setflags,(Rd,(Rn,(Rm,(shift_t,shift_n)))))))
                     )
                   | (BitsN.B(0x2,_),(BitsN.B(0xF,_),_)) =>
                     ( if (typ = (BitsN.B(0x0,2))) andalso
                          ((imm3 = (BitsN.B(0x0,3))) andalso
                           (imm2 = (BitsN.B(0x0,2))))
                         then if (setflags andalso
                                  ((Set.mem
                                      (Rd,[BitsN.B(0xD,4),BitsN.B(0xF,4)])) orelse
                                   (Set.mem
                                      (Rm,[BitsN.B(0xD,4),BitsN.B(0xF,4)])))) orelse
                                 ((not setflags) andalso
                                  ((Rd = (BitsN.B(0xF,4))) orelse
                                   ((Rm = (BitsN.B(0xF,4))) orelse
                                    ((Rd = (BitsN.B(0xD,4))) andalso
                                     (Rm = (BitsN.B(0xD,4)))))))
                                then DECODE_UNPREDICTABLE
                                       (mc,"MOV (register)")
                              else ()
                       else if (Set.mem
                             (Rd,[BitsN.B(0xD,4),BitsN.B(0xF,4)])) orelse
                          (Set.mem(Rm,[BitsN.B(0xD,4),BitsN.B(0xF,4)]))
                         then DECODE_UNPREDICTABLE(mc,"SHIFT (register)")
                       else ()
                     ; Data
                         (ShiftImmediate
                            (false,(setflags,(Rd,(Rm,(shift_t,shift_n))))))
                     )
                   | (BitsN.B(0x2,_),_) =>
                     ( if (Set.mem(Rd,[BitsN.B(0xD,4),BitsN.B(0xF,4)])) orelse
                          ((Rn = (BitsN.B(0xD,4))) orelse
                           (Set.mem(Rm,[BitsN.B(0xD,4),BitsN.B(0xF,4)])))
                         then DECODE_UNPREDICTABLE(mc,"ORR (register)")
                       else ()
                     ; Data
                         (Register
                            (BitsN.B(0xC,4),
                             (setflags,(Rd,(Rn,(Rm,(shift_t,shift_n)))))))
                     )
                   | (BitsN.B(0x3,_),(BitsN.B(0xF,_),_)) =>
                     ( if (Set.mem(Rd,[BitsN.B(0xD,4),BitsN.B(0xF,4)])) orelse
                          (Set.mem(Rm,[BitsN.B(0xD,4),BitsN.B(0xF,4)]))
                         then DECODE_UNPREDICTABLE(mc,"MVN (register)")
                       else ()
                     ; Data
                         (ShiftImmediate
                            (true,(setflags,(Rd,(Rm,(shift_t,shift_n))))))
                     )
                   | (BitsN.B(0x3,_),_) =>
                     ( if (Set.mem(Rd,[BitsN.B(0xD,4),BitsN.B(0xF,4)])) orelse
                          ((Rn = (BitsN.B(0xD,4))) orelse
                           (Set.mem(Rm,[BitsN.B(0xD,4),BitsN.B(0xF,4)])))
                         then DECODE_UNPREDICTABLE(mc,"ORN (register)")
                       else ()
                     ; Data
                         (Register
                            (BitsN.B(0xF,4),
                             (setflags,(Rd,(Rn,(Rm,(shift_t,shift_n)))))))
                     )
                   | (BitsN.B(0x4,_),(_,(BitsN.B(0xF,_),BitsN.B(0x1,_)))) =>
                     ( if (Set.mem(Rn,[BitsN.B(0xD,4),BitsN.B(0xF,4)])) orelse
                          (Set.mem(Rm,[BitsN.B(0xD,4),BitsN.B(0xF,4)]))
                         then DECODE_UNPREDICTABLE(mc,"TEQ (register)")
                       else ()
                     ; Data
                         (TestCompareRegister
                            (BitsN.B(0x1,2),(Rn,(Rm,(shift_t,shift_n)))))
                     )
                   | (BitsN.B(0x4,_),_) =>
                     ( if (Rd = (BitsN.B(0xD,4))) orelse
                          (((Rd = (BitsN.B(0xF,4))) andalso (not setflags)) orelse
                           ((Set.mem(Rn,[BitsN.B(0xD,4),BitsN.B(0xF,4)])) orelse
                            (Set.mem(Rm,[BitsN.B(0xD,4),BitsN.B(0xF,4)]))))
                         then DECODE_UNPREDICTABLE(mc,"EOR (register)")
                       else ()
                     ; Data
                         (Register
                            (BitsN.B(0x1,4),
                             (setflags,(Rd,(Rn,(Rm,(shift_t,shift_n)))))))
                     )
                   | (BitsN.B(0x6,_),(_,(_,BitsN.B(0x0,_)))) =>
                     (if BitsN.bit(typ,0)
                        then Undefined(BitsN.B(0x0,32))
                      else ( if (Set.mem
                                   (Rd,[BitsN.B(0xD,4),BitsN.B(0xF,4)])) orelse
                                ((Set.mem
                                    (Rn,[BitsN.B(0xD,4),BitsN.B(0xF,4)])) orelse
                                 (Set.mem
                                    (Rm,[BitsN.B(0xD,4),BitsN.B(0xF,4)])))
                               then DECODE_UNPREDICTABLE
                                      (mc,"PackHalfword")
                             else ()
                           ; let
                               val tbform = BitsN.bit(typ,1)
                             in
                               Media
                                 (PackHalfword
                                    (shift_t,
                                     (shift_n,(tbform,(Rd,(Rn,Rm))))))
                             end
                           ))
                   | (BitsN.B(0x8,_),(_,(BitsN.B(0xF,_),BitsN.B(0x1,_)))) =>
                     ( if (Rn = (BitsN.B(0xF,4))) orelse
                          (Set.mem(Rm,[BitsN.B(0xD,4),BitsN.B(0xF,4)]))
                         then DECODE_UNPREDICTABLE(mc,"CMN (register)")
                       else ()
                     ; Data
                         (TestCompareRegister
                            (BitsN.B(0x3,2),(Rn,(Rm,(shift_t,shift_n)))))
                     )
                   | (BitsN.B(0x8,_),_) =>
                     ( if (Rd = (BitsN.B(0xD,4))) orelse
                          (((Rd = (BitsN.B(0xF,4))) andalso (not setflags)) orelse
                           ((Rn = (BitsN.B(0xF,4))) orelse
                            (Set.mem(Rm,[BitsN.B(0xD,4),BitsN.B(0xF,4)]))))
                         then DECODE_UNPREDICTABLE(mc,"ADD (register)")
                       else ()
                     ; let
                         val (shift_t,shift_n) =
                           DecodeImmShift(typ,BitsN.@@(imm3,imm2))
                       in
                         Data
                           (Register
                              (BitsN.B(0x4,4),
                               (setflags,(Rd,(Rn,(Rm,(shift_t,shift_n)))))))
                       end
                     )
                   | (BitsN.B(0xA,_),_) =>
                     ( if (Set.mem(Rd,[BitsN.B(0xD,4),BitsN.B(0xF,4)])) orelse
                          ((Set.mem(Rn,[BitsN.B(0xD,4),BitsN.B(0xF,4)])) orelse
                           (Set.mem(Rm,[BitsN.B(0xD,4),BitsN.B(0xF,4)])))
                         then DECODE_UNPREDICTABLE(mc,"ADC (register)")
                       else ()
                     ; Data
                         (Register
                            (BitsN.B(0x5,4),
                             (setflags,(Rd,(Rn,(Rm,(shift_t,shift_n)))))))
                     )
                   | (BitsN.B(0xB,_),_) =>
                     ( if (Set.mem(Rd,[BitsN.B(0xD,4),BitsN.B(0xF,4)])) orelse
                          ((Set.mem(Rn,[BitsN.B(0xD,4),BitsN.B(0xF,4)])) orelse
                           (Set.mem(Rm,[BitsN.B(0xD,4),BitsN.B(0xF,4)])))
                         then DECODE_UNPREDICTABLE(mc,"SBC (register)")
                       else ()
                     ; Data
                         (Register
                            (BitsN.B(0x6,4),
                             (setflags,(Rd,(Rn,(Rm,(shift_t,shift_n)))))))
                     )
                   | (BitsN.B(0xD,_),(_,(BitsN.B(0xF,_),BitsN.B(0x1,_)))) =>
                     ( if (Rn = (BitsN.B(0xF,4))) orelse
                          (Set.mem(Rm,[BitsN.B(0xD,4),BitsN.B(0xF,4)]))
                         then DECODE_UNPREDICTABLE(mc,"CMP (register)")
                       else ()
                     ; Data
                         (TestCompareRegister
                            (BitsN.B(0x2,2),(Rn,(Rm,(shift_t,shift_n)))))
                     )
                   | (BitsN.B(0xD,_),_) =>
                     ( if (Rd = (BitsN.B(0xD,4))) orelse
                          (((Rd = (BitsN.B(0xF,4))) andalso (not setflags)) orelse
                           ((Rn = (BitsN.B(0xF,4))) orelse
                            (Set.mem(Rm,[BitsN.B(0xD,4),BitsN.B(0xF,4)]))))
                         then DECODE_UNPREDICTABLE(mc,"SUB (register)")
                       else ()
                     ; Data
                         (Register
                            (BitsN.B(0x2,4),
                             (setflags,(Rd,(Rn,(Rm,(shift_t,shift_n)))))))
                     )
                   | (BitsN.B(0xE,_),_) =>
                     ( if (Set.mem(Rd,[BitsN.B(0xD,4),BitsN.B(0xF,4)])) orelse
                          ((Set.mem(Rn,[BitsN.B(0xD,4),BitsN.B(0xF,4)])) orelse
                           (Set.mem(Rm,[BitsN.B(0xD,4),BitsN.B(0xF,4)])))
                         then DECODE_UNPREDICTABLE(mc,"RSB (register)")
                       else ()
                     ; Data
                         (Register
                            (BitsN.B(0x3,4),
                             (setflags,(Rd,(Rn,(Rm,(shift_t,shift_n)))))))
                     )
                   | _ => Undefined(BitsN.B(0x0,32))
                end
         else Skip ()
       end
     | ((true,
       (true,
        (true,
         (true,
          (false,
           (i'0,
            (false,
             (op'3,(op'2,(op'1,(op'0,(S'0,(Rn'3,(Rn'2,(Rn'1,Rn'0))))))))))))))),
      (false,
       (imm3'2,
        (imm3'1,
         (imm3'0,
          (Rd'3,
           (Rd'2,
            (Rd'1,
             (Rd'0,
              (imm8'7,
               (imm8'6,(imm8'5,(imm8'4,(imm8'3,(imm8'2,(imm8'1,imm8'0)))))))))))))))) =>
       let
         val Rn = BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)
         val S = BitsN.fromBitstring([S'0],1)
         val Rd = BitsN.fromBitstring([Rd'3,Rd'2,Rd'1,Rd'0],4)
       in
         if Do(ThumbCondition (),HaveThumb2 ())
           then let
                  val imm12 =
                    BitsN.concat
                      [BitsN.fromBitstring([i'0],1),
                       BitsN.fromBitstring([imm3'2,imm3'1,imm3'0],3),
                       BitsN.fromBitstring
                         ([imm8'7,imm8'6,imm8'5,imm8'4,imm8'3,imm8'2,
                           imm8'1,imm8'0],8)]
                  val x = ThumbExpandImm_C(imm12,#C((!CPSR) : PSR))
                  val setflags = S = (BitsN.B(0x1,1))
                in
                  case (BitsN.fromBitstring([op'3,op'2,op'1,op'0],4),
                   (Rn,(Rd,S))) of
                     (BitsN.B(0x0,_),(_,(BitsN.B(0xF,_),BitsN.B(0x1,_)))) =>
                       ( if Set.mem(Rn,[BitsN.B(0xD,4),BitsN.B(0xF,4)])
                           then DECODE_UNPREDICTABLE(mc,"TST (immediate)")
                         else ()
                       ; Data
                           (TestCompareImmediate
                              (BitsN.B(0x0,2),(Rn,imm12)))
                       )
                   | (BitsN.B(0x0,_),_) =>
                     ( if (Rd = (BitsN.B(0xD,4))) orelse
                          (((Rd = (BitsN.B(0xF,4))) andalso (not setflags)) orelse
                           (Set.mem(Rn,[BitsN.B(0xD,4),BitsN.B(0xF,4)])))
                         then DECODE_UNPREDICTABLE(mc,"AND (immediate)")
                       else ()
                     ; Data
                         (ArithLogicImmediate
                            (BitsN.B(0x0,4),(setflags,(Rd,(Rn,imm12)))))
                     )
                   | (BitsN.B(0x1,_),_) =>
                     ( if (Set.mem(Rd,[BitsN.B(0xD,4),BitsN.B(0xF,4)])) orelse
                          (Set.mem(Rn,[BitsN.B(0xD,4),BitsN.B(0xF,4)]))
                         then DECODE_UNPREDICTABLE(mc,"BIC (immediate)")
                       else ()
                     ; Data
                         (ArithLogicImmediate
                            (BitsN.B(0xE,4),(setflags,(Rd,(Rn,imm12)))))
                     )
                   | (BitsN.B(0x2,_),(BitsN.B(0xF,_),_)) =>
                     ( if Set.mem(Rd,[BitsN.B(0xD,4),BitsN.B(0xF,4)])
                         then DECODE_UNPREDICTABLE(mc,"MOV (immediate)")
                       else ()
                     ; Data(Move(setflags,(false,(Rd,imm12))))
                     )
                   | (BitsN.B(0x2,_),_) =>
                     ( if (Set.mem(Rd,[BitsN.B(0xD,4),BitsN.B(0xF,4)])) orelse
                          (Rn = (BitsN.B(0xD,4)))
                         then DECODE_UNPREDICTABLE(mc,"ORR (immediate)")
                       else ()
                     ; Data
                         (ArithLogicImmediate
                            (BitsN.B(0xC,4),(setflags,(Rd,(Rn,imm12)))))
                     )
                   | (BitsN.B(0x3,_),(BitsN.B(0xF,_),_)) =>
                     ( if Set.mem(Rd,[BitsN.B(0xD,4),BitsN.B(0xF,4)])
                         then DECODE_UNPREDICTABLE(mc,"MVN (immediate)")
                       else ()
                     ; Data(Move(setflags,(true,(Rd,imm12))))
                     )
                   | (BitsN.B(0x3,_),_) =>
                     ( if (Set.mem(Rd,[BitsN.B(0xD,4),BitsN.B(0xF,4)])) orelse
                          (Rn = (BitsN.B(0xD,4)))
                         then DECODE_UNPREDICTABLE(mc,"ORN (immediate)")
                       else ()
                     ; Data
                         (ArithLogicImmediate
                            (BitsN.B(0xF,4),(setflags,(Rd,(Rn,imm12)))))
                     )
                   | (BitsN.B(0x4,_),(_,(BitsN.B(0xF,_),BitsN.B(0x1,_)))) =>
                     ( if Set.mem(Rn,[BitsN.B(0xD,4),BitsN.B(0xF,4)])
                         then DECODE_UNPREDICTABLE(mc,"TEQ (immediate)")
                       else ()
                     ; Data
                         (TestCompareImmediate(BitsN.B(0x1,2),(Rn,imm12)))
                     )
                   | (BitsN.B(0x4,_),_) =>
                     ( if (Rd = (BitsN.B(0xD,4))) orelse
                          (((Rd = (BitsN.B(0xF,4))) andalso (not setflags)) orelse
                           (Set.mem(Rn,[BitsN.B(0xD,4),BitsN.B(0xF,4)])))
                         then DECODE_UNPREDICTABLE(mc,"EOR (immediate)")
                       else ()
                     ; Data
                         (ArithLogicImmediate
                            (BitsN.B(0x1,4),(setflags,(Rd,(Rn,imm12)))))
                     )
                   | (BitsN.B(0x8,_),(_,(BitsN.B(0xF,_),BitsN.B(0x1,_)))) =>
                     ( if Rn = (BitsN.B(0xF,4))
                         then DECODE_UNPREDICTABLE(mc,"CMN (immediate)")
                       else ()
                     ; Data
                         (TestCompareImmediate(BitsN.B(0x3,2),(Rn,imm12)))
                     )
                   | (BitsN.B(0x8,_),_) =>
                     ( if (Rd = (BitsN.B(0xD,4))) orelse
                          (((Rd = (BitsN.B(0xF,4))) andalso (not setflags)) orelse
                           (Rn = (BitsN.B(0xF,4))))
                         then DECODE_UNPREDICTABLE(mc,"ADD (immediate)")
                       else ()
                     ; Data
                         (ArithLogicImmediate
                            (BitsN.B(0x4,4),(setflags,(Rd,(Rn,imm12)))))
                     )
                   | (BitsN.B(0xA,_),_) =>
                     ( if (Set.mem(Rd,[BitsN.B(0xD,4),BitsN.B(0xF,4)])) orelse
                          (Set.mem(Rn,[BitsN.B(0xD,4),BitsN.B(0xF,4)]))
                         then DECODE_UNPREDICTABLE(mc,"ADC (immediate)")
                       else ()
                     ; Data
                         (ArithLogicImmediate
                            (BitsN.B(0x5,4),(setflags,(Rd,(Rn,imm12)))))
                     )
                   | (BitsN.B(0xB,_),_) =>
                     ( if (Set.mem(Rd,[BitsN.B(0xD,4),BitsN.B(0xF,4)])) orelse
                          (Set.mem(Rn,[BitsN.B(0xD,4),BitsN.B(0xF,4)]))
                         then DECODE_UNPREDICTABLE(mc,"SBC (immediate)")
                       else ()
                     ; Data
                         (ArithLogicImmediate
                            (BitsN.B(0x6,4),(setflags,(Rd,(Rn,imm12)))))
                     )
                   | (BitsN.B(0xD,_),(_,(BitsN.B(0xF,_),BitsN.B(0x1,_)))) =>
                     ( if Rn = (BitsN.B(0xF,4))
                         then DECODE_UNPREDICTABLE(mc,"CMP (immediate)")
                       else ()
                     ; Data
                         (TestCompareImmediate(BitsN.B(0x2,2),(Rn,imm12)))
                     )
                   | (BitsN.B(0xD,_),_) =>
                     ( if (Rd = (BitsN.B(0xD,4))) orelse
                          (((Rd = (BitsN.B(0xF,4))) andalso (not setflags)) orelse
                           (Rn = (BitsN.B(0xF,4))))
                         then DECODE_UNPREDICTABLE(mc,"SUB (immediate)")
                       else ()
                     ; Data
                         (ArithLogicImmediate
                            (BitsN.B(0x2,4),(setflags,(Rd,(Rn,imm12)))))
                     )
                   | (BitsN.B(0xE,_),_) =>
                     ( if (Set.mem(Rd,[BitsN.B(0xD,4),BitsN.B(0xF,4)])) orelse
                          (Set.mem(Rn,[BitsN.B(0xD,4),BitsN.B(0xF,4)]))
                         then DECODE_UNPREDICTABLE(mc,"RSB (immediate)")
                       else ()
                     ; Data
                         (ArithLogicImmediate
                            (BitsN.B(0x3,4),(setflags,(Rd,(Rn,imm12)))))
                     )
                   | _ => Undefined(BitsN.B(0x0,32))
                end
         else Skip ()
       end
     | ((true,
       (true,
        (true,
         (true,
          (false,
           (i'0,
            (true,
             (false,
              (false,(false,(false,(false,(Rn'3,(Rn'2,(Rn'1,Rn'0))))))))))))))),
      (false,
       (imm3'2,
        (imm3'1,
         (imm3'0,
          (Rd'3,
           (Rd'2,
            (Rd'1,
             (Rd'0,
              (imm8'7,
               (imm8'6,(imm8'5,(imm8'4,(imm8'3,(imm8'2,(imm8'1,imm8'0)))))))))))))))) =>
       let
         val Rd = BitsN.fromBitstring([Rd'3,Rd'2,Rd'1,Rd'0],4)
       in
         if Do(ThumbCondition (),HaveThumb2 ())
           then ( if Set.mem(Rd,[BitsN.B(0xD,4),BitsN.B(0xF,4)])
                    then DECODE_UNPREDICTABLE(mc,"ADDW (immediate)")
                  else ()
                ; let
                    val imm12 =
                      BitsN.concat
                        [BitsN.fromBitstring([i'0],1),
                         BitsN.fromBitstring([imm3'2,imm3'1,imm3'0],3),
                         BitsN.fromBitstring
                           ([imm8'7,imm8'6,imm8'5,imm8'4,imm8'3,imm8'2,
                             imm8'1,imm8'0],8)]
                  in
                    Data
                      (AddSub
                         (false,
                          (Rd,
                           (BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4),
                            imm12))))
                  end
                )
         else Skip ()
       end
     | ((true,
       (true,
        (true,
         (true,
          (false,
           (i'0,
            (true,
             (false,
              (true,(false,(true,(false,(Rn'3,(Rn'2,(Rn'1,Rn'0))))))))))))))),
      (false,
       (imm3'2,
        (imm3'1,
         (imm3'0,
          (Rd'3,
           (Rd'2,
            (Rd'1,
             (Rd'0,
              (imm8'7,
               (imm8'6,(imm8'5,(imm8'4,(imm8'3,(imm8'2,(imm8'1,imm8'0)))))))))))))))) =>
       let
         val Rd = BitsN.fromBitstring([Rd'3,Rd'2,Rd'1,Rd'0],4)
       in
         if Do(ThumbCondition (),HaveThumb2 ())
           then ( if Set.mem(Rd,[BitsN.B(0xD,4),BitsN.B(0xF,4)])
                    then DECODE_UNPREDICTABLE(mc,"SUBW (immediate)")
                  else ()
                ; let
                    val imm12 =
                      BitsN.concat
                        [BitsN.fromBitstring([i'0],1),
                         BitsN.fromBitstring([imm3'2,imm3'1,imm3'0],3),
                         BitsN.fromBitstring
                           ([imm8'7,imm8'6,imm8'5,imm8'4,imm8'3,imm8'2,
                             imm8'1,imm8'0],8)]
                  in
                    Data
                      (AddSub
                         (true,
                          (Rd,
                           (BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4),
                            imm12))))
                  end
                )
         else Skip ()
       end
     | ((true,
       (true,
        (true,
         (true,
          (false,
           (i'0,
            (true,
             (false,
              (H'0,
               (true,(false,(false,(imm4'3,(imm4'2,(imm4'1,imm4'0))))))))))))))),
      (false,
       (imm3'2,
        (imm3'1,
         (imm3'0,
          (Rd'3,
           (Rd'2,
            (Rd'1,
             (Rd'0,
              (imm8'7,
               (imm8'6,(imm8'5,(imm8'4,(imm8'3,(imm8'2,(imm8'1,imm8'0)))))))))))))))) =>
       let
         val Rd = BitsN.fromBitstring([Rd'3,Rd'2,Rd'1,Rd'0],4)
       in
         if Do(ThumbCondition (),HaveThumb2 ())
           then ( if Set.mem(Rd,[BitsN.B(0xD,4),BitsN.B(0xF,4)])
                    then DECODE_UNPREDICTABLE
                           (mc,"MOVT or MOVW (immediate)")
                  else ()
                ; let
                    val imm16 =
                      BitsN.concat
                        [BitsN.fromBitstring
                           ([imm4'3,imm4'2,imm4'1,imm4'0],4),
                         BitsN.fromBitstring([i'0],1),
                         BitsN.fromBitstring([imm3'2,imm3'1,imm3'0],3),
                         BitsN.fromBitstring
                           ([imm8'7,imm8'6,imm8'5,imm8'4,imm8'3,imm8'2,
                             imm8'1,imm8'0],8)]
                    val high =
                      (BitsN.fromBitstring([H'0],1)) = (BitsN.B(0x1,1))
                  in
                    Data(MoveHalfword(high,(Rd,imm16)))
                  end
                )
         else Skip ()
       end
     | ((true,
       (true,
        (true,
         (true,
          (false,
           (_,
            (true,
             (true,(U'0,(false,(true,(false,(Rn'3,(Rn'2,(Rn'1,Rn'0))))))))))))))),
      (false,
       (false,
        (false,
         (false,
          (Rd'3,
           (Rd'2,
            (Rd'1,
             (Rd'0,
              (false,
               (false,
                (_,(_,(sat_imm'3,(sat_imm'2,(sat_imm'1,sat_imm'0)))))))))))))))) =>
       let
         val Rn = BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)
         val sat_imm =
           BitsN.fromBitstring
             ([sat_imm'3,sat_imm'2,sat_imm'1,sat_imm'0],4)
         val Rd = BitsN.fromBitstring([Rd'3,Rd'2,Rd'1,Rd'0],4)
       in
         if Do(ThumbCondition (),HaveThumb2 ())
           then ( if (Set.mem(Rd,[BitsN.B(0xD,4),BitsN.B(0xF,4)])) orelse
                     (Set.mem(Rn,[BitsN.B(0xD,4),BitsN.B(0xF,4)]))
                    then DECODE_UNPREDICTABLE(mc,"Saturate16")
                  else ()
                ; let
                    val unsigned =
                      (BitsN.fromBitstring([U'0],1)) = (BitsN.B(0x1,1))
                    val sarurate_to =
                      if unsigned
                        then BitsN.toNat sat_imm
                      else Nat.+(BitsN.toNat sat_imm,1)
                  in
                    Media(Saturate16(sarurate_to,(unsigned,(Rd,Rn))))
                  end
                )
         else Skip ()
       end
     | ((true,
       (true,
        (true,
         (true,
          (false,
           (_,
            (true,
             (true,(U'0,(false,(sh'0,(false,(Rn'3,(Rn'2,(Rn'1,Rn'0))))))))))))))),
      (false,
       (imm3'2,
        (imm3'1,
         (imm3'0,
          (Rd'3,
           (Rd'2,
            (Rd'1,
             (Rd'0,
              (imm2'1,
               (imm2'0,
                (_,
                 (sat_imm'4,(sat_imm'3,(sat_imm'2,(sat_imm'1,sat_imm'0)))))))))))))))) =>
       let
         val Rn = BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)
         val sat_imm =
           BitsN.fromBitstring
             ([sat_imm'4,sat_imm'3,sat_imm'2,sat_imm'1,sat_imm'0],5)
         val Rd = BitsN.fromBitstring([Rd'3,Rd'2,Rd'1,Rd'0],4)
       in
         if Do(ThumbCondition (),HaveThumb2 ())
           then ( if (Set.mem(Rd,[BitsN.B(0xD,4),BitsN.B(0xF,4)])) orelse
                     (Set.mem(Rn,[BitsN.B(0xD,4),BitsN.B(0xF,4)]))
                    then DECODE_UNPREDICTABLE(mc,"Saturate")
                  else ()
                ; let
                    val unsigned =
                      (BitsN.fromBitstring([U'0],1)) = (BitsN.B(0x1,1))
                    val sarurate_to =
                      if unsigned
                        then BitsN.toNat sat_imm
                      else Nat.+(BitsN.toNat sat_imm,1)
                    val (shift_t,shift_n) =
                      DecodeImmShift
                        (BitsN.@@
                           (BitsN.fromBitstring([sh'0],1),BitsN.B(0x0,1)),
                         BitsN.@@
                           (BitsN.fromBitstring([imm3'2,imm3'1,imm3'0],3),
                            BitsN.fromBitstring([imm2'1,imm2'0],2)))
                  in
                    Media
                      (Saturate
                         (shift_t,
                          (shift_n,(sarurate_to,(unsigned,(Rd,Rn))))))
                  end
                )
         else Skip ()
       end
     | ((true,
       (true,
        (true,
         (true,
          (false,
           (_,
            (true,
             (true,(U'0,(true,(false,(false,(Rn'3,(Rn'2,(Rn'1,Rn'0))))))))))))))),
      (false,
       (imm3'2,
        (imm3'1,
         (imm3'0,
          (Rd'3,
           (Rd'2,
            (Rd'1,
             (Rd'0,
              (imm2'1,
               (imm2'0,
                (_,
                 (widthm1'4,(widthm1'3,(widthm1'2,(widthm1'1,widthm1'0)))))))))))))))) =>
       let
         val Rn = BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)
         val Rd = BitsN.fromBitstring([Rd'3,Rd'2,Rd'1,Rd'0],4)
       in
         if Do(ThumbCondition (),HaveThumb2 ())
           then let
                  val widthminus1 =
                    BitsN.toNat
                      (BitsN.fromBitstring
                         ([widthm1'4,widthm1'3,widthm1'2,widthm1'1,
                           widthm1'0],5))
                  val lsbit =
                    BitsN.toNat
                      (BitsN.@@
                         (BitsN.fromBitstring([imm3'2,imm3'1,imm3'0],3),
                          BitsN.fromBitstring([imm2'1,imm2'0],2)))
                in
                  ( if (Set.mem(Rd,[BitsN.B(0xD,4),BitsN.B(0xF,4)])) orelse
                       ((Set.mem(Rn,[BitsN.B(0xD,4),BitsN.B(0xF,4)])) orelse
                        (Nat.<(31,Nat.+(lsbit,widthminus1))))
                      then DECODE_UNPREDICTABLE(mc,"BitFieldExtract")
                    else ()
                  ; let
                      val unsigned =
                        (BitsN.fromBitstring([U'0],1)) = (BitsN.B(0x1,1))
                    in
                      Media
                        (BitFieldExtract
                           (unsigned,(Rd,(Rn,(lsbit,widthminus1)))))
                    end
                  )
                end
         else Skip ()
       end
     | ((true,
       (true,
        (true,
         (true,
          (false,
           (_,
            (true,
             (true,(false,(true,(true,(false,(Rn'3,(Rn'2,(Rn'1,Rn'0))))))))))))))),
      (false,
       (imm3'2,
        (imm3'1,
         (imm3'0,
          (Rd'3,
           (Rd'2,
            (Rd'1,
             (Rd'0,
              (imm2'1,(imm2'0,(_,(msb'4,(msb'3,(msb'2,(msb'1,msb'0)))))))))))))))) =>
       let
         val Rn = BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)
         val Rd = BitsN.fromBitstring([Rd'3,Rd'2,Rd'1,Rd'0],4)
       in
         if Do(ThumbCondition (),HaveThumb2 ())
           then let
                  val msbit =
                    BitsN.toNat
                      (BitsN.fromBitstring
                         ([msb'4,msb'3,msb'2,msb'1,msb'0],5))
                  val lsbit =
                    BitsN.toNat
                      (BitsN.@@
                         (BitsN.fromBitstring([imm3'2,imm3'1,imm3'0],3),
                          BitsN.fromBitstring([imm2'1,imm2'0],2)))
                in
                  ( if (Set.mem(Rd,[BitsN.B(0xD,4),BitsN.B(0xF,4)])) orelse
                       ((Rn = (BitsN.B(0xD,4))) orelse
                        (Nat.<(msbit,lsbit)))
                      then DECODE_UNPREDICTABLE
                             (mc,"BitFieldClearOrInsert")
                    else ()
                  ; Media(BitFieldClearOrInsert(Rd,(Rn,(lsbit,msbit))))
                  )
                end
         else Skip ()
       end
     | ((true,
       (true,
        (true,
         (true,
          (false,
           (false,
            (true,
             (true,(true,(false,(false,(R'0,(Rn'3,(Rn'2,(Rn'1,Rn'0))))))))))))))),
      (true,
       (false,
        (_,(false,(m1'3,(m1'2,(m1'1,(m1'0,(_,(_,(true,(m'0,_))))))))))))) =>
       let
         val Rn = BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)
       in
         if Do(ThumbCondition (),HaveVirtExt ())
           then ( if Set.mem(Rn,[BitsN.B(0xD,4),BitsN.B(0xF,4)])
                    then DECODE_UNPREDICTABLE
                           (mc,"MoveToBankedOrSpecialRegister")
                  else ()
                ; let
                    val write_spsr =
                      (BitsN.fromBitstring([R'0],1)) = (BitsN.B(0x1,1))
                    val SYSm =
                      BitsN.@@
                        (BitsN.fromBitstring([m'0],1),
                         BitsN.fromBitstring([m1'3,m1'2,m1'1,m1'0],4))
                  in
                    System
                      (MoveToBankedOrSpecialRegister(write_spsr,(SYSm,Rn)))
                  end
                )
         else Skip ()
       end
     | ((true,
       (true,
        (true,
         (true,
          (false,
           (false,
            (true,
             (true,(true,(false,(false,(R'0,(Rn'3,(Rn'2,(Rn'1,Rn'0))))))))))))))),
      (true,
       (false,
        (_,(false,(mask'3,(mask'2,(mask'1,(mask'0,(_,(_,(false,_)))))))))))) =>
       let
         val Rn = BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)
         val mask = BitsN.fromBitstring([mask'3,mask'2,mask'1,mask'0],4)
       in
         if Do(ThumbCondition (),HaveThumb2 ())
           then ( if (mask = (BitsN.B(0x0,4))) orelse
                     (Set.mem(Rn,[BitsN.B(0xD,4),BitsN.B(0xF,4)]))
                    then DECODE_UNPREDICTABLE
                           (mc,"MoveToSpecialFromRegister")
                  else ()
                ; let
                    val write_spsr =
                      (BitsN.fromBitstring([R'0],1)) = (BitsN.B(0x1,1))
                  in
                    System
                      (MoveToSpecialFromRegister(write_spsr,(Rn,mask)))
                  end
                )
         else Skip ()
       end
     | ((true,
       (true,
        (true,
         (true,
          (false,(false,(true,(true,(true,(false,(true,(false,_)))))))))))),
      (true,
       (false,
        (_,
         (false,
          (_,
           (false,
            (false,
             (false,(op'7,(op'6,(op'5,(op'4,(op'3,(op'2,(op'1,op'0)))))))))))))))) =>
       DecodeHint
         (ThumbCondition (),
          BitsN.fromBitstring([op'7,op'6,op'5,op'4,op'3,op'2,op'1,op'0],8))
     | ((true,
       (true,
        (true,
         (true,
          (false,(false,(true,(true,(true,(false,(true,(false,_)))))))))))),
      (true,
       (false,
        (_,
         (false,
          (_,
           (imod'1,
            (imod'0,
             (M'0,
              (A'0,(I'0,(F'0,(mode'4,(mode'3,(mode'2,(mode'1,mode'0)))))))))))))))) =>
       let
         val mode =
           BitsN.fromBitstring([mode'4,mode'3,mode'2,mode'1,mode'0],5)
         val F = BitsN.fromBitstring([F'0],1)
         val I = BitsN.fromBitstring([I'0],1)
         val A = BitsN.fromBitstring([A'0],1)
         val M = BitsN.fromBitstring([M'0],1)
         val imod = BitsN.fromBitstring([imod'1,imod'0],2)
       in
         if Do(ThumbCondition (),HaveThumb2 ())
           then ( if ((not(mode = (BitsN.B(0x0,5)))) andalso
                      (M = (BitsN.B(0x0,1)))) orelse
                     (((BitsN.bit(imod,1)) =
                       ((BitsN.concat[A,I,F]) = (BitsN.B(0x0,3)))) orelse
                      ((imod = (BitsN.B(0x1,2))) orelse (InITBlock ())))
                    then DECODE_UNPREDICTABLE(mc,"ChangeProcessorState")
                  else ()
                ; let
                    val enable = imod = (BitsN.B(0x2,2))
                    val disable = imod = (BitsN.B(0x3,2))
                    val changemode =
                      if M = (BitsN.B(0x1,1))
                        then Option.SOME mode
                      else NONE
                    val affectA = A = (BitsN.B(0x1,1))
                    val affectI = I = (BitsN.B(0x1,1))
                    val affectF = F = (BitsN.B(0x1,1))
                  in
                    System
                      (ChangeProcessorState
                         (enable,
                          (disable,
                           (affectA,(affectI,(affectF,changemode))))))
                  end
                )
         else Skip ()
       end
     | ((true,
       (true,
        (true,
         (true,
          (false,(false,(true,(true,(true,(false,(true,(true,_)))))))))))),
      (true,
       (false,(_,(false,(_,(_,(_,(_,(false,(false,(false,(J'0,_))))))))))))) =>
       let
         val J = BitsN.fromBitstring([J'0],1)
       in
         if (Do(ThumbCondition (),HaveThumbEE ())) andalso
            (not(((CurrentInstrSet ()) = InstrSet_Thumb) andalso
                 (J = (BitsN.B(0x0,1)))))
           then ( if InITBlock ()
                    then DECODE_UNPREDICTABLE(mc,"EnterxLeavex")
                  else ()
                ; let
                    val is_enterx = J = (BitsN.B(0x1,1))
                  in
                    System(EnterxLeavex is_enterx)
                  end
                )
         else Skip ()
       end
     | ((true,
       (true,
        (true,
         (true,
          (false,(false,(true,(true,(true,(false,(true,(true,_)))))))))))),
      (true,
       (false,
        (_,
         (false,
          (_,
           (_,
            (_,
             (_,
              (op'3,
               (op'2,
                (op'1,(op'0,(option'3,(option'2,(option'1,option'0)))))))))))))))) =>
       let
         val option =
           BitsN.fromBitstring([option'3,option'2,option'1,option'0],4)
       in
         if Do(ThumbCondition (),HaveThumb2 ())
           then case BitsN.fromBitstring([op'3,op'2,op'1,op'0],4) of
                   BitsN.B(0x2,_) => ClearExclusive
                 | BitsN.B(0x4,_) =>
                   Hint(DataSynchronizationBarrier option)
                 | BitsN.B(0x5,_) => Hint(DataMemoryBarrier option)
                 | BitsN.B(0x6,_) =>
                   Hint(InstructionSynchronizationBarrier option)
                 | _ =>
                   (if Nat.>=(ArchVersion (),7)
                      then Undefined(BitsN.B(0x0,32))
                    else ( DECODE_UNPREDICTABLE
                             (mc,"Miscellaneous control")
                         ; Branch(BranchExchange(BitsN.B(0x0,4)))
                         ))
         else Skip ()
       end
     | ((true,
       (true,
        (true,
         (true,
          (false,(false,(true,(true,(true,(true,(false,(true,_)))))))))))),
      (true,
       (false,
        (_,
         (false,
          (_,
           (_,
            (_,
             (_,
              (imm8'7,
               (imm8'6,(imm8'5,(imm8'4,(imm8'3,(imm8'2,(imm8'1,imm8'0)))))))))))))))) =>
       let
         val imm8 =
           BitsN.fromBitstring
             ([imm8'7,imm8'6,imm8'5,imm8'4,imm8'3,imm8'2,imm8'1,imm8'0],8)
       in
         if Do(ThumbCondition (),HaveThumb2 ())
           then if (HaveVirtExt ()) andalso (imm8 = (BitsN.B(0x0,8)))
                  then System ExceptionReturn
                else ( if ((CurrentInstrSet ()) = InstrSet_ThumbEE) orelse
                          ((InITBlock ()) andalso (not(LastInITBlock ())))
                         then DECODE_UNPREDICTABLE
                                (mc,"SUBS<c> PC, LR, #0")
                       else ()
                     ; let
                         val imm12 = BitsN.zeroExtend 12 imm8
                       in
                         if CurrentModeIsHyp ()
                           then Undefined(BitsN.B(0x0,32))
                         else Data
                                (ArithLogicImmediate
                                   (BitsN.B(0x2,4),
                                    (true,
                                     (BitsN.B(0xF,4),
                                      (BitsN.B(0xE,4),imm12)))))
                       end
                     )
         else Skip ()
       end
     | ((true,
       (true,
        (true,
         (true,
          (false,
           (false,
            (true,
             (true,(true,(true,(true,(R'0,(m1'3,(m1'2,(m1'1,m1'0))))))))))))))),
      (true,
       (false,
        (_,(false,(Rd'3,(Rd'2,(Rd'1,(Rd'0,(_,(_,(true,(m'0,_))))))))))))) =>
       let
         val Rd = BitsN.fromBitstring([Rd'3,Rd'2,Rd'1,Rd'0],4)
       in
         if Do(ThumbCondition (),HaveVirtExt ())
           then ( if Set.mem(Rd,[BitsN.B(0xD,4),BitsN.B(0xF,4)])
                    then DECODE_UNPREDICTABLE
                           (mc,"MoveToRegisterFromBankedOrSpecial")
                  else ()
                ; let
                    val write_spsr =
                      (BitsN.fromBitstring([R'0],1)) = (BitsN.B(0x1,1))
                    val SYSm =
                      BitsN.@@
                        (BitsN.fromBitstring([m'0],1),
                         BitsN.fromBitstring([m1'3,m1'2,m1'1,m1'0],4))
                  in
                    System
                      (MoveToRegisterFromBankedOrSpecial
                         (write_spsr,(SYSm,Rd)))
                  end
                )
         else Skip ()
       end
     | ((true,
       (true,
        (true,
         (true,(false,(false,(true,(true,(true,(true,(true,(R'0,_)))))))))))),
      (true,
       (false,(_,(false,(Rd'3,(Rd'2,(Rd'1,(Rd'0,(_,(_,(false,_)))))))))))) =>
       let
         val Rd = BitsN.fromBitstring([Rd'3,Rd'2,Rd'1,Rd'0],4)
       in
         if Do(ThumbCondition (),HaveThumb2 ())
           then ( if Set.mem(Rd,[BitsN.B(0xD,4),BitsN.B(0xF,4)])
                    then DECODE_UNPREDICTABLE
                           (mc,"MoveToRegisterFromSpecial")
                  else ()
                ; let
                    val write_spsr =
                      (BitsN.fromBitstring([R'0],1)) = (BitsN.B(0x1,1))
                  in
                    System(MoveToRegisterFromSpecial(write_spsr,Rd))
                  end
                )
         else Skip ()
       end
     | ((true,
       (true,
        (true,
         (true,
          (false,
           (true,
            (true,
             (true,
              (true,
               (true,(true,(false,(imm4'3,(imm4'2,(imm4'1,imm4'0))))))))))))))),
      (true,
       (false,
        (false,
         (false,
          (imm12'11,
           (imm12'10,
            (imm12'9,
             (imm12'8,
              (imm12'7,
               (imm12'6,
                (imm12'5,(imm12'4,(imm12'3,(imm12'2,(imm12'1,imm12'0)))))))))))))))) =>
       (if Do(ThumbCondition (),HaveVirtExt ())
          then ( if InITBlock ()
                   then DECODE_UNPREDICTABLE(mc,"HypervisorCall")
                 else ()
               ; let
                   val imm16 =
                     BitsN.@@
                       (BitsN.fromBitstring
                          ([imm4'3,imm4'2,imm4'1,imm4'0],4),
                        BitsN.fromBitstring
                          ([imm12'11,imm12'10,imm12'9,imm12'8,imm12'7,
                            imm12'6,imm12'5,imm12'4,imm12'3,imm12'2,
                            imm12'1,imm12'0],12))
                 in
                   System(HypervisorCall imm16)
                 end
               )
        else Skip ())
     | ((true,
       (true,
        (true,
         (true,
          (false,
           (true,
            (true,
             (true,
              (true,(true,(true,(true,(imm4'3,(imm4'2,(imm4'1,imm4'0))))))))))))))),
      (true,(false,(false,(false,_))))) =>
       (if Do(ThumbCondition (),
              (HaveSecurityExt ()) andalso (not((!Architecture) = ARMv6K)))
          then ( if (InITBlock ()) andalso (not(LastInITBlock ()))
                   then DECODE_UNPREDICTABLE(mc,"SecureMonitorCall")
                 else ()
               ; System
                   (SecureMonitorCall
                      (BitsN.fromBitstring
                         ([imm4'3,imm4'2,imm4'1,imm4'0],4)))
               )
        else Skip ())
     | ((true,
       (true,
        (true,
         (true,
          (false,
           (true,
            (true,
             (true,
              (true,(true,(true,(true,(imm4'3,(imm4'2,(imm4'1,imm4'0))))))))))))))),
      (true,
       (false,
        (true,
         (false,
          (imm12'11,
           (imm12'10,
            (imm12'9,
             (imm12'8,
              (imm12'7,
               (imm12'6,
                (imm12'5,(imm12'4,(imm12'3,(imm12'2,(imm12'1,imm12'0)))))))))))))))) =>
       (if Do(ThumbCondition (),HaveThumb2 ())
          then let
                 val imm32 =
                   BitsN.zeroExtend 32
                     (BitsN.@@
                        (BitsN.fromBitstring
                           ([imm4'3,imm4'2,imm4'1,imm4'0],4),
                         BitsN.fromBitstring
                           ([imm12'11,imm12'10,imm12'9,imm12'8,imm12'7,
                             imm12'6,imm12'5,imm12'4,imm12'3,imm12'2,
                             imm12'1,imm12'0],12)))
               in
                 Undefined imm32
               end
        else Skip ())
     | ((true,
       (true,
        (true,
         (true,
          (false,
           (S'0,
            (cond'3,
             (cond'2,
              (cond'1,
               (cond'0,(imm6'5,(imm6'4,(imm6'3,(imm6'2,(imm6'1,imm6'0))))))))))))))),
      (true,
       (false,
        (J1'0,
         (false,
          (J2'0,
           (imm11'10,
            (imm11'9,
             (imm11'8,
              (imm11'7,
               (imm11'6,
                (imm11'5,(imm11'4,(imm11'3,(imm11'2,(imm11'1,imm11'0)))))))))))))))) =>
       (if Do(BitsN.fromBitstring([cond'3,cond'2,cond'1,cond'0],4),
              HaveThumb2 ())
          then ( if InITBlock ()
                   then DECODE_UNPREDICTABLE(mc,"BranchTarget")
                 else ()
               ; let
                   val imm32 =
                     BitsN.signExtend 32
                       (BitsN.concat
                          [BitsN.fromBitstring([S'0],1),
                           BitsN.fromBitstring([J2'0],1),
                           BitsN.fromBitstring([J1'0],1),
                           BitsN.fromBitstring
                             ([imm6'5,imm6'4,imm6'3,imm6'2,imm6'1,imm6'0],
                              6),
                           BitsN.fromBitstring
                             ([imm11'10,imm11'9,imm11'8,imm11'7,imm11'6,
                               imm11'5,imm11'4,imm11'3,imm11'2,imm11'1,
                               imm11'0],11),BitsN.B(0x0,1)])
                 in
                   Branch(BranchTarget imm32)
                 end
               )
        else Skip ())
     | ((true,
       (true,
        (true,
         (true,
          (false,
           (S'0,
            (imm10'9,
             (imm10'8,
              (imm10'7,
               (imm10'6,
                (imm10'5,(imm10'4,(imm10'3,(imm10'2,(imm10'1,imm10'0))))))))))))))),
      (true,
       (L'0,
        (J1'0,
         (true,
          (J2'0,
           (imm11'10,
            (imm11'9,
             (imm11'8,
              (imm11'7,
               (imm11'6,
                (imm11'5,(imm11'4,(imm11'3,(imm11'2,(imm11'1,imm11'0)))))))))))))))) =>
       let
         val S = BitsN.fromBitstring([S'0],1)
         val J2 = BitsN.fromBitstring([J2'0],1)
         val J1 = BitsN.fromBitstring([J1'0],1)
         val L = BitsN.fromBitstring([L'0],1)
       in
         if Do(ThumbCondition (),
               ((L = (BitsN.B(0x1,1))) andalso
                ((J1 = (BitsN.B(0x1,1))) andalso (J1 = J2))) orelse
               (HaveThumb2 ()))
           then ( if (InITBlock ()) andalso (not(LastInITBlock ()))
                    then DECODE_UNPREDICTABLE
                           (mc,
                            "BranchTarget or BranchLinkExchangeImmediate")
                  else ()
                ; let
                    val I1 = BitsN.~(BitsN.??(J1,S))
                    val I2 = BitsN.~(BitsN.??(J2,S))
                    val imm32 =
                      BitsN.signExtend 32
                        (BitsN.concat
                           [S,I1,I2,
                            BitsN.fromBitstring
                              ([imm10'9,imm10'8,imm10'7,imm10'6,imm10'5,
                                imm10'4,imm10'3,imm10'2,imm10'1,imm10'0],
                               10),
                            BitsN.fromBitstring
                              ([imm11'10,imm11'9,imm11'8,imm11'7,imm11'6,
                                imm11'5,imm11'4,imm11'3,imm11'2,imm11'1,
                                imm11'0],11),BitsN.B(0x0,1)])
                    val targetInstrSet = InstrSet_Thumb
                  in
                    if L = (BitsN.B(0x1,1))
                      then Branch
                             (BranchLinkExchangeImmediate
                                (targetInstrSet,imm32))
                    else Branch(BranchTarget imm32)
                  end
                )
         else Skip ()
       end
     | ((true,
       (true,
        (true,
         (true,
          (false,
           (S'0,
            (imm10H'9,
             (imm10H'8,
              (imm10H'7,
               (imm10H'6,
                (imm10H'5,
                 (imm10H'4,(imm10H'3,(imm10H'2,(imm10H'1,imm10H'0))))))))))))))),
      (true,
       (true,
        (J1'0,
         (false,
          (J2'0,
           (imm10L'9,
            (imm10L'8,
             (imm10L'7,
              (imm10L'6,
               (imm10L'5,
                (imm10L'4,(imm10L'3,(imm10L'2,(imm10L'1,(imm10L'0,H'0)))))))))))))))) =>
       let
         val S = BitsN.fromBitstring([S'0],1)
         val J2 = BitsN.fromBitstring([J2'0],1)
         val J1 = BitsN.fromBitstring([J1'0],1)
       in
         if Do(ThumbCondition (),
               (not(((CurrentInstrSet ()) = InstrSet_ThumbEE) orelse
                    ((BitsN.fromBitstring([H'0],1)) = (BitsN.B(0x1,1))))) andalso
               (if (J1 = (BitsN.B(0x1,1))) andalso (J1 = J2)
                  then Nat.>=(ArchVersion (),5)
                else HaveThumb2 ()))
           then ( if (InITBlock ()) andalso (not(LastInITBlock ()))
                    then DECODE_UNPREDICTABLE
                           (mc,"BranchLinkExchangeImmediate")
                  else ()
                ; let
                    val I1 = BitsN.~(BitsN.??(J1,S))
                    val I2 = BitsN.~(BitsN.??(J2,S))
                    val imm32 =
                      BitsN.signExtend 32
                        (BitsN.concat
                           [S,I1,I2,
                            BitsN.fromBitstring
                              ([imm10H'9,imm10H'8,imm10H'7,imm10H'6,
                                imm10H'5,imm10H'4,imm10H'3,imm10H'2,
                                imm10H'1,imm10H'0],10),
                            BitsN.fromBitstring
                              ([imm10L'9,imm10L'8,imm10L'7,imm10L'6,
                                imm10L'5,imm10L'4,imm10L'3,imm10L'2,
                                imm10L'1,imm10L'0],10),BitsN.B(0x0,2)])
                    val targetInstrSet = InstrSet_ARM
                  in
                    Branch
                      (BranchLinkExchangeImmediate(targetInstrSet,imm32))
                  end
                )
         else Skip ()
       end
     | ((true,
       (true,
        (true,
         (true,
          (true,
           (false,
            (false,
             (false,(_,(false,(true,(true,(true,(true,(true,true))))))))))))))),
      (true,(true,(true,(true,_))))) =>
       ( DECODE_UNPREDICTABLE(mc,"PreloadDataLiteral")
       ; Branch(BranchExchange(BitsN.B(0x0,4)))
       )
     | ((true,
       (true,
        (true,
         (true,
          (true,
           (false,
            (false,
             (false,(U'0,(false,(_,(true,(true,(true,(true,true))))))))))))))),
      (true,
       (true,
        (true,
         (true,
          (imm12'11,
           (imm12'10,
            (imm12'9,
             (imm12'8,
              (imm12'7,
               (imm12'6,
                (imm12'5,(imm12'4,(imm12'3,(imm12'2,(imm12'1,imm12'0)))))))))))))))) =>
       (if Do(ThumbCondition (),HaveThumb2 ())
          then let
                 val imm32 =
                   BitsN.zeroExtend 32
                     (BitsN.fromBitstring
                        ([imm12'11,imm12'10,imm12'9,imm12'8,imm12'7,
                          imm12'6,imm12'5,imm12'4,imm12'3,imm12'2,imm12'1,
                          imm12'0],12))
                 val add =
                   (BitsN.fromBitstring([U'0],1)) = (BitsN.B(0x1,1))
               in
                 Hint(PreloadDataLiteral(add,imm32))
               end
        else Skip ())
     | ((true,
       (true,
        (true,
         (true,
          (true,
           (false,
            (false,
             (true,(U'0,(false,(false,(true,(true,(true,(true,true))))))))))))))),
      (true,
       (true,
        (true,
         (true,
          (imm12'11,
           (imm12'10,
            (imm12'9,
             (imm12'8,
              (imm12'7,
               (imm12'6,
                (imm12'5,(imm12'4,(imm12'3,(imm12'2,(imm12'1,imm12'0)))))))))))))))) =>
       (if Do(ThumbCondition (),Nat.>=(ArchVersion (),7))
          then let
                 val imm32 =
                   BitsN.zeroExtend 32
                     (BitsN.fromBitstring
                        ([imm12'11,imm12'10,imm12'9,imm12'8,imm12'7,
                          imm12'6,imm12'5,imm12'4,imm12'3,imm12'2,imm12'1,
                          imm12'0],12))
                 val add =
                   (BitsN.fromBitstring([U'0],1)) = (BitsN.B(0x1,1))
                 val Rn = BitsN.B(0xF,4)
               in
                 Hint(PreloadInstruction(add,(Rn,immediate_form1 imm32)))
               end
        else Skip ())
     | ((true,
       (true,
        (true,
         (true,
          (true,
           (false,
            (false,
             (true,(true,(false,(false,(true,(Rn'3,(Rn'2,(Rn'1,Rn'0))))))))))))))),
      (true,
       (true,
        (true,
         (true,
          (imm12'11,
           (imm12'10,
            (imm12'9,
             (imm12'8,
              (imm12'7,
               (imm12'6,
                (imm12'5,(imm12'4,(imm12'3,(imm12'2,(imm12'1,imm12'0)))))))))))))))) =>
       (if Do(ThumbCondition (),Nat.>=(ArchVersion (),7))
          then let
                 val imm32 =
                   BitsN.zeroExtend 32
                     (BitsN.fromBitstring
                        ([imm12'11,imm12'10,imm12'9,imm12'8,imm12'7,
                          imm12'6,imm12'5,imm12'4,imm12'3,imm12'2,imm12'1,
                          imm12'0],12))
                 val add = true
               in
                 Hint
                   (PreloadInstruction
                      (add,
                       (BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4),
                        immediate_form1 imm32)))
               end
        else Skip ())
     | ((true,
       (true,
        (true,
         (true,
          (true,
           (false,
            (false,
             (false,(true,(false,(W'0,(true,(Rn'3,(Rn'2,(Rn'1,Rn'0))))))))))))))),
      (true,
       (true,
        (true,
         (true,
          (imm12'11,
           (imm12'10,
            (imm12'9,
             (imm12'8,
              (imm12'7,
               (imm12'6,
                (imm12'5,(imm12'4,(imm12'3,(imm12'2,(imm12'1,imm12'0)))))))))))))))) =>
       let
         val W = BitsN.fromBitstring([W'0],1)
       in
         if Do(ThumbCondition (),
               if W = (BitsN.B(0x1,1))
                 then HaveMPExt ()
               else HaveThumb2 ())
           then let
                  val imm32 =
                    BitsN.zeroExtend 32
                      (BitsN.fromBitstring
                         ([imm12'11,imm12'10,imm12'9,imm12'8,imm12'7,
                           imm12'6,imm12'5,imm12'4,imm12'3,imm12'2,
                           imm12'1,imm12'0],12))
                  val add = true
                  val is_pldw = W = (BitsN.B(0x1,1))
                in
                  Hint
                    (PreloadData
                       (add,
                        (is_pldw,
                         (BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4),
                          immediate_form1 imm32))))
                end
         else Skip ()
       end
     | ((true,
       (true,
        (true,
         (true,
          (true,
           (false,
            (false,
             (true,(_,(false,(true,(true,(true,(true,(true,true))))))))))))))),
      (true,(true,(true,(true,_))))) => NoOperation
     | ((true,
       (true,
        (true,
         (true,
          (true,
           (false,
            (false,
             (S'0,(U'0,(false,(H'0,(true,(true,(true,(true,true))))))))))))))),
      (Rt'3,
       (Rt'2,
        (Rt'1,
         (Rt'0,
          (imm12'11,
           (imm12'10,
            (imm12'9,
             (imm12'8,
              (imm12'7,
               (imm12'6,
                (imm12'5,(imm12'4,(imm12'3,(imm12'2,(imm12'1,imm12'0)))))))))))))))) =>
       let
         val Rt = BitsN.fromBitstring([Rt'3,Rt'2,Rt'1,Rt'0],4)
       in
         if Do(ThumbCondition (),HaveThumb2 ())
           then ( if Rt = (BitsN.B(0xD,4))
                    then DECODE_UNPREDICTABLE
                           (mc,"LoadByteLiteral/LoadHalfLiteral")
                  else ()
                ; let
                    val imm32 =
                      BitsN.zeroExtend 32
                        (BitsN.fromBitstring
                           ([imm12'11,imm12'10,imm12'9,imm12'8,imm12'7,
                             imm12'6,imm12'5,imm12'4,imm12'3,imm12'2,
                             imm12'1,imm12'0],12))
                    val add =
                      (BitsN.fromBitstring([U'0],1)) = (BitsN.B(0x1,1))
                    val unsigned =
                      (BitsN.fromBitstring([S'0],1)) = (BitsN.B(0x0,1))
                  in
                    if (BitsN.fromBitstring([H'0],1)) = (BitsN.B(0x1,1))
                      then Load
                             (LoadHalfLiteral(unsigned,(add,(Rt,imm32))))
                    else Load(LoadByteLiteral(unsigned,(add,(Rt,imm32))))
                  end
                )
         else Skip ()
       end
     | ((true,
       (true,
        (true,
         (true,
          (true,
           (false,
            (false,
             (false,(U'0,(true,(false,(true,(true,(true,(true,true))))))))))))))),
      (Rt'3,
       (Rt'2,
        (Rt'1,
         (Rt'0,
          (imm12'11,
           (imm12'10,
            (imm12'9,
             (imm12'8,
              (imm12'7,
               (imm12'6,
                (imm12'5,(imm12'4,(imm12'3,(imm12'2,(imm12'1,imm12'0)))))))))))))))) =>
       let
         val Rt = BitsN.fromBitstring([Rt'3,Rt'2,Rt'1,Rt'0],4)
       in
         if Do(ThumbCondition (),HaveThumb2 ())
           then ( if (Rt = (BitsN.B(0xF,4))) andalso
                     ((InITBlock ()) andalso (not(LastInITBlock ())))
                    then DECODE_UNPREDICTABLE(mc,"LoadLiteral")
                  else ()
                ; let
                    val imm32 =
                      BitsN.zeroExtend 32
                        (BitsN.fromBitstring
                           ([imm12'11,imm12'10,imm12'9,imm12'8,imm12'7,
                             imm12'6,imm12'5,imm12'4,imm12'3,imm12'2,
                             imm12'1,imm12'0],12))
                    val add =
                      (BitsN.fromBitstring([U'0],1)) = (BitsN.B(0x1,1))
                  in
                    Load(LoadLiteral(add,(Rt,imm32)))
                  end
                )
         else Skip ()
       end
     | ((true,
       (true,
        (true,
         (true,
          (true,
           (false,
            (false,
             (S'0,(true,(false,(H'0,(true,(Rn'3,(Rn'2,(Rn'1,Rn'0))))))))))))))),
      (Rt'3,
       (Rt'2,
        (Rt'1,
         (Rt'0,
          (imm12'11,
           (imm12'10,
            (imm12'9,
             (imm12'8,
              (imm12'7,
               (imm12'6,
                (imm12'5,(imm12'4,(imm12'3,(imm12'2,(imm12'1,imm12'0)))))))))))))))) =>
       let
         val Rn = BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)
         val Rt = BitsN.fromBitstring([Rt'3,Rt'2,Rt'1,Rt'0],4)
       in
         if Do(ThumbCondition (),HaveThumb2 ())
           then ( if Rt = (BitsN.B(0xD,4))
                    then DECODE_UNPREDICTABLE
                           (mc,"LoadByte/LoadHalf (immediate)")
                  else ()
                ; let
                    val add = true
                    val index = true
                    val wback = false
                    val imm32 =
                      BitsN.zeroExtend 32
                        (BitsN.fromBitstring
                           ([imm12'11,imm12'10,imm12'9,imm12'8,imm12'7,
                             imm12'6,imm12'5,imm12'4,imm12'3,imm12'2,
                             imm12'1,imm12'0],12))
                    val m = immediate_form1 imm32
                    val unsigned =
                      (BitsN.fromBitstring([S'0],1)) = (BitsN.B(0x0,1))
                  in
                    if (BitsN.fromBitstring([H'0],1)) = (BitsN.B(0x1,1))
                      then Load
                             (LoadHalf
                                (unsigned,
                                 (add,(index,(wback,(Rt,(Rn,m)))))))
                    else Load
                           (LoadByte
                              (unsigned,(add,(index,(wback,(Rt,(Rn,m)))))))
                  end
                )
         else Skip ()
       end
     | ((true,
       (true,
        (true,
         (true,
          (true,
           (false,
            (false,
             (false,(true,(true,(false,(true,(Rn'3,(Rn'2,(Rn'1,Rn'0))))))))))))))),
      (Rt'3,
       (Rt'2,
        (Rt'1,
         (Rt'0,
          (imm12'11,
           (imm12'10,
            (imm12'9,
             (imm12'8,
              (imm12'7,
               (imm12'6,
                (imm12'5,(imm12'4,(imm12'3,(imm12'2,(imm12'1,imm12'0)))))))))))))))) =>
       let
         val Rt = BitsN.fromBitstring([Rt'3,Rt'2,Rt'1,Rt'0],4)
       in
         if Do(ThumbCondition (),HaveThumb2 ())
           then ( if (Rt = (BitsN.B(0xF,4))) andalso
                     ((InITBlock ()) andalso (not(LastInITBlock ())))
                    then DECODE_UNPREDICTABLE(mc,"LoadWord")
                  else ()
                ; let
                    val add = true
                    val index = true
                    val wback = false
                    val imm32 =
                      BitsN.zeroExtend 32
                        (BitsN.fromBitstring
                           ([imm12'11,imm12'10,imm12'9,imm12'8,imm12'7,
                             imm12'6,imm12'5,imm12'4,imm12'3,imm12'2,
                             imm12'1,imm12'0],12))
                    val m = immediate_form1 imm32
                  in
                    Load
                      (LoadWord
                         (add,
                          (index,
                           (wback,
                            (Rt,
                             (BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4),
                              m))))))
                  end
                )
         else Skip ()
       end
     | ((true,
       (true,
        (true,
         (true,
          (true,
           (false,
            (false,
             (false,(false,(false,(W'0,(true,(Rn'3,(Rn'2,(Rn'1,Rn'0))))))))))))))),
      (true,
       (true,
        (true,
         (true,
          (true,
           (true,
            (false,
             (false,
              (imm8'7,
               (imm8'6,(imm8'5,(imm8'4,(imm8'3,(imm8'2,(imm8'1,imm8'0)))))))))))))))) =>
       let
         val W = BitsN.fromBitstring([W'0],1)
       in
         if Do(ThumbCondition (),
               if W = (BitsN.B(0x1,1))
                 then HaveMPExt ()
               else HaveThumb2 ())
           then let
                  val imm32 =
                    BitsN.zeroExtend 32
                      (BitsN.fromBitstring
                         ([imm8'7,imm8'6,imm8'5,imm8'4,imm8'3,imm8'2,
                           imm8'1,imm8'0],8))
                  val add = false
                  val is_pldw = W = (BitsN.B(0x1,1))
                in
                  Hint
                    (PreloadData
                       (add,
                        (is_pldw,
                         (BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4),
                          immediate_form1 imm32))))
                end
         else Skip ()
       end
     | ((true,
       (true,
        (true,
         (true,
          (true,
           (false,
            (false,
             (true,
              (false,(false,(false,(true,(Rn'3,(Rn'2,(Rn'1,Rn'0))))))))))))))),
      (true,
       (true,
        (true,
         (true,
          (true,
           (true,
            (false,
             (false,
              (imm8'7,
               (imm8'6,(imm8'5,(imm8'4,(imm8'3,(imm8'2,(imm8'1,imm8'0)))))))))))))))) =>
       (if Do(ThumbCondition (),Nat.>=(ArchVersion (),7))
          then let
                 val imm32 =
                   BitsN.zeroExtend 32
                     (BitsN.fromBitstring
                        ([imm8'7,imm8'6,imm8'5,imm8'4,imm8'3,imm8'2,
                          imm8'1,imm8'0],8))
                 val add = false
               in
                 Hint
                   (PreloadInstruction
                      (add,
                       (BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4),
                        immediate_form1 imm32)))
               end
        else Skip ())
     | ((true,
       (true,
        (true,
         (true,(true,(false,(false,(_,(false,(false,(_,(true,_)))))))))))),
      (_,(_,(_,(_,(true,(false,(_,(false,_))))))))) =>
       Undefined(BitsN.B(0x0,32))
     | ((true,
       (true,
        (true,
         (true,
          (true,
           (false,
            (false,
             (S'0,(false,(false,(H'0,(true,(Rn'3,(Rn'2,(Rn'1,Rn'0))))))))))))))),
      (Rt'3,
       (Rt'2,
        (Rt'1,
         (Rt'0,
          (true,
           (true,
            (true,
             (false,
              (imm8'7,
               (imm8'6,(imm8'5,(imm8'4,(imm8'3,(imm8'2,(imm8'1,imm8'0)))))))))))))))) =>
       let
         val Rn = BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)
         val Rt = BitsN.fromBitstring([Rt'3,Rt'2,Rt'1,Rt'0],4)
       in
         if Do(ThumbCondition (),HaveThumb2 ())
           then ( if Set.mem(Rt,[BitsN.B(0xD,4),BitsN.B(0xF,4)])
                    then DECODE_UNPREDICTABLE(mc,"LoadUnprivileged")
                  else ()
                ; let
                    val add = true
                    val postindex = false
                    val unsigned =
                      (BitsN.fromBitstring([S'0],1)) = (BitsN.B(0x0,1))
                    val imm32 =
                      BitsN.zeroExtend 32
                        (BitsN.fromBitstring
                           ([imm8'7,imm8'6,imm8'5,imm8'4,imm8'3,imm8'2,
                             imm8'1,imm8'0],8))
                    val m = immediate_form2 imm32
                  in
                    if (BitsN.fromBitstring([H'0],1)) = (BitsN.B(0x1,1))
                      then Load
                             (LoadHalfUnprivileged
                                (unsigned,(add,(postindex,(Rt,(Rn,m))))))
                    else if unsigned
                      then Load
                             (LoadByteUnprivileged
                                (add,
                                 (postindex,
                                  (Rt,(Rn,immediate_form1 imm32)))))
                    else Load
                           (LoadSignedByteUnprivileged
                              (add,(postindex,(Rt,(Rn,m)))))
                  end
                )
         else Skip ()
       end
     | ((true,
       (true,
        (true,
         (true,
          (true,(false,(false,(true,(false,(false,(true,(true,_)))))))))))),
      (true,(true,(true,(true,(true,(true,(false,(false,_))))))))) =>
       NoOperation
     | ((true,
       (true,
        (true,
         (true,
          (true,
           (false,
            (false,
             (S'0,(false,(false,(H'0,(true,(Rn'3,(Rn'2,(Rn'1,Rn'0))))))))))))))),
      (Rt'3,
       (Rt'2,
        (Rt'1,
         (Rt'0,
          (true,
           (P'0,
            (U'0,
             (W'0,
              (imm8'7,
               (imm8'6,(imm8'5,(imm8'4,(imm8'3,(imm8'2,(imm8'1,imm8'0)))))))))))))))) =>
       let
         val Rn = BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)
         val Rt = BitsN.fromBitstring([Rt'3,Rt'2,Rt'1,Rt'0],4)
       in
         if Do(ThumbCondition (),HaveThumb2 ())
           then let
                  val wback =
                    (BitsN.fromBitstring([W'0],1)) = (BitsN.B(0x1,1))
                in
                  ( if (Rt = (BitsN.B(0xD,4))) orelse
                       (((Rt = (BitsN.B(0xF,4))) andalso wback) orelse
                        (wback andalso (Rn = Rt)))
                      then DECODE_UNPREDICTABLE(mc,"Load (immediate)")
                    else ()
                  ; let
                      val add =
                        (BitsN.fromBitstring([U'0],1)) = (BitsN.B(0x1,1))
                      val index =
                        (BitsN.fromBitstring([P'0],1)) = (BitsN.B(0x1,1))
                      val unsigned =
                        (BitsN.fromBitstring([S'0],1)) = (BitsN.B(0x0,1))
                      val imm32 =
                        BitsN.zeroExtend 32
                          (BitsN.fromBitstring
                             ([imm8'7,imm8'6,imm8'5,imm8'4,imm8'3,imm8'2,
                               imm8'1,imm8'0],8))
                      val m = immediate_form1 imm32
                    in
                      if (BitsN.fromBitstring([H'0],1)) = (BitsN.B(0x1,1))
                        then Load
                               (LoadHalf
                                  (unsigned,
                                   (add,(index,(wback,(Rt,(Rn,m)))))))
                      else Load
                             (LoadByte
                                (unsigned,
                                 (add,(index,(wback,(Rt,(Rn,m)))))))
                    end
                  )
                end
         else Skip ()
       end
     | ((true,
       (true,
        (true,
         (true,
          (true,
           (false,
            (false,
             (false,
              (false,(true,(false,(true,(Rn'3,(Rn'2,(Rn'1,Rn'0))))))))))))))),
      (Rt'3,
       (Rt'2,
        (Rt'1,
         (Rt'0,
          (true,
           (true,
            (true,
             (false,
              (imm8'7,
               (imm8'6,(imm8'5,(imm8'4,(imm8'3,(imm8'2,(imm8'1,imm8'0)))))))))))))))) =>
       let
         val Rt = BitsN.fromBitstring([Rt'3,Rt'2,Rt'1,Rt'0],4)
       in
         if Do(ThumbCondition (),HaveThumb2 ())
           then ( if Set.mem(Rt,[BitsN.B(0xD,4),BitsN.B(0xF,4)])
                    then DECODE_UNPREDICTABLE(mc,"LoadUnprivileged")
                  else ()
                ; let
                    val add = true
                    val postindex = false
                    val imm32 =
                      BitsN.zeroExtend 32
                        (BitsN.fromBitstring
                           ([imm8'7,imm8'6,imm8'5,imm8'4,imm8'3,imm8'2,
                             imm8'1,imm8'0],8))
                    val m = immediate_form1 imm32
                  in
                    Load
                      (LoadUnprivileged
                         (add,
                          (postindex,
                           (Rt,
                            (BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4),
                             m)))))
                  end
                )
         else Skip ()
       end
     | ((true,
       (true,
        (true,
         (true,
          (true,
           (false,
            (false,
             (false,
              (false,(true,(false,(true,(Rn'3,(Rn'2,(Rn'1,Rn'0))))))))))))))),
      (Rt'3,
       (Rt'2,
        (Rt'1,
         (Rt'0,
          (true,
           (P'0,
            (U'0,
             (W'0,
              (imm8'7,
               (imm8'6,(imm8'5,(imm8'4,(imm8'3,(imm8'2,(imm8'1,imm8'0)))))))))))))))) =>
       let
         val Rn = BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)
         val W = BitsN.fromBitstring([W'0],1)
         val P = BitsN.fromBitstring([P'0],1)
         val Rt = BitsN.fromBitstring([Rt'3,Rt'2,Rt'1,Rt'0],4)
       in
         if Do(ThumbCondition (),
               ((P = (BitsN.B(0x1,1))) orelse (W = (BitsN.B(0x1,1)))) andalso
               (HaveThumb2 ()))
           then let
                  val wback = W = (BitsN.B(0x1,1))
                in
                  ( if (wback andalso (Rn = Rt)) orelse
                       ((Rt = (BitsN.B(0xF,4))) andalso
                        ((InITBlock ()) andalso (not(LastInITBlock ()))))
                      then DECODE_UNPREDICTABLE(mc,"LoadWord")
                    else ()
                  ; let
                      val add =
                        (BitsN.fromBitstring([U'0],1)) = (BitsN.B(0x1,1))
                      val index = P = (BitsN.B(0x1,1))
                      val imm32 =
                        BitsN.zeroExtend 32
                          (BitsN.fromBitstring
                             ([imm8'7,imm8'6,imm8'5,imm8'4,imm8'3,imm8'2,
                               imm8'1,imm8'0],8))
                      val m = immediate_form1 imm32
                    in
                      Load(LoadWord(add,(index,(wback,(Rt,(Rn,m))))))
                    end
                  )
                end
         else Skip ()
       end
     | ((true,
       (true,
        (true,
         (true,
          (true,
           (false,
            (false,
             (false,(false,(false,(W'0,(true,(Rn'3,(Rn'2,(Rn'1,Rn'0))))))))))))))),
      (true,
       (true,
        (true,
         (true,
          (false,
           (false,
            (false,
             (false,
              (false,(false,(imm2'1,(imm2'0,(Rm'3,(Rm'2,(Rm'1,Rm'0)))))))))))))))) =>
       let
         val W = BitsN.fromBitstring([W'0],1)
         val Rm = BitsN.fromBitstring([Rm'3,Rm'2,Rm'1,Rm'0],4)
       in
         if Do(ThumbCondition (),
               if W = (BitsN.B(0x1,1))
                 then HaveMPExt ()
               else HaveThumb2 ())
           then ( if Set.mem(Rm,[BitsN.B(0xD,4),BitsN.B(0xF,4)])
                    then DECODE_UNPREDICTABLE(mc,"PreloadData")
                  else ()
                ; let
                    val add = true
                    val is_pldw = W = (BitsN.B(0x1,1))
                    val (shift_t,shift_n) =
                      (SRType_LSL,
                       BitsN.toNat(BitsN.fromBitstring([imm2'1,imm2'0],2)))
                    val m = register_form1(Rm,(shift_t,shift_n))
                  in
                    Hint
                      (PreloadData
                         (add,
                          (is_pldw,
                           (BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4),m))))
                  end
                )
         else Skip ()
       end
     | ((true,
       (true,
        (true,
         (true,
          (true,
           (false,
            (false,
             (true,
              (false,(false,(false,(true,(Rn'3,(Rn'2,(Rn'1,Rn'0))))))))))))))),
      (true,
       (true,
        (true,
         (true,
          (false,
           (false,
            (false,
             (false,
              (false,(false,(imm2'1,(imm2'0,(Rm'3,(Rm'2,(Rm'1,Rm'0)))))))))))))))) =>
       let
         val Rm = BitsN.fromBitstring([Rm'3,Rm'2,Rm'1,Rm'0],4)
       in
         if Do(ThumbCondition (),Nat.>=(ArchVersion (),7))
           then ( if Set.mem(Rm,[BitsN.B(0xD,4),BitsN.B(0xF,4)])
                    then DECODE_UNPREDICTABLE(mc,"PreloadInstruction")
                  else ()
                ; let
                    val add = true
                    val (shift_t,shift_n) =
                      (SRType_LSL,
                       BitsN.toNat(BitsN.fromBitstring([imm2'1,imm2'0],2)))
                    val m = register_form1(Rm,(shift_t,shift_n))
                  in
                    Hint
                      (PreloadInstruction
                         (add,
                          (BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4),m)))
                  end
                )
         else Skip ()
       end
     | ((true,
       (true,
        (true,
         (true,
          (true,(false,(false,(true,(false,(false,(true,(true,_)))))))))))),
      (true,
       (true,
        (true,(true,(false,(false,(false,(false,(false,(false,_))))))))))) =>
       NoOperation
     | ((true,
       (true,
        (true,
         (true,
          (true,
           (false,
            (false,
             (S'0,(false,(false,(H'0,(true,(Rn'3,(Rn'2,(Rn'1,Rn'0))))))))))))))),
      (Rt'3,
       (Rt'2,
        (Rt'1,
         (Rt'0,
          (false,
           (false,
            (false,
             (false,
              (false,(false,(imm2'1,(imm2'0,(Rm'3,(Rm'2,(Rm'1,Rm'0)))))))))))))))) =>
       let
         val Rn = BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)
         val Rm = BitsN.fromBitstring([Rm'3,Rm'2,Rm'1,Rm'0],4)
         val Rt = BitsN.fromBitstring([Rt'3,Rt'2,Rt'1,Rt'0],4)
       in
         if Do(ThumbCondition (),HaveThumb2 ())
           then ( if (Rt = (BitsN.B(0xD,4))) orelse
                     (Set.mem(Rm,[BitsN.B(0xD,4),BitsN.B(0xF,4)]))
                    then DECODE_UNPREDICTABLE(mc,"Load (register)")
                  else ()
                ; let
                    val add = true
                    val index = true
                    val wback = false
                    val unsigned =
                      (BitsN.fromBitstring([S'0],1)) = (BitsN.B(0x0,1))
                    val (shift_t,shift_n) =
                      (SRType_LSL,
                       BitsN.toNat(BitsN.fromBitstring([imm2'1,imm2'0],2)))
                    val m = register_form1(Rm,(shift_t,shift_n))
                  in
                    if (BitsN.fromBitstring([H'0],1)) = (BitsN.B(0x1,1))
                      then Load
                             (LoadHalf
                                (unsigned,
                                 (add,(index,(wback,(Rt,(Rn,m)))))))
                    else Load
                           (LoadByte
                              (unsigned,(add,(index,(wback,(Rt,(Rn,m)))))))
                  end
                )
         else Skip ()
       end
     | ((true,
       (true,
        (true,
         (true,
          (true,
           (false,
            (false,
             (false,
              (false,(true,(false,(true,(Rn'3,(Rn'2,(Rn'1,Rn'0))))))))))))))),
      (Rt'3,
       (Rt'2,
        (Rt'1,
         (Rt'0,
          (false,
           (false,
            (false,
             (false,
              (false,(false,(imm2'1,(imm2'0,(Rm'3,(Rm'2,(Rm'1,Rm'0)))))))))))))))) =>
       let
         val Rm = BitsN.fromBitstring([Rm'3,Rm'2,Rm'1,Rm'0],4)
         val Rt = BitsN.fromBitstring([Rt'3,Rt'2,Rt'1,Rt'0],4)
       in
         if Do(ThumbCondition (),HaveThumb2 ())
           then ( if ((Rt = (BitsN.B(0xF,4))) andalso
                      ((InITBlock ()) andalso (not(LastInITBlock ())))) orelse
                     (Set.mem(Rm,[BitsN.B(0xD,4),BitsN.B(0xF,4)]))
                    then DECODE_UNPREDICTABLE(mc,"LoadWord")
                  else ()
                ; let
                    val add = true
                    val index = true
                    val wback = false
                    val (shift_t,shift_n) =
                      (SRType_LSL,
                       BitsN.toNat(BitsN.fromBitstring([imm2'1,imm2'0],2)))
                    val m = register_form1(Rm,(shift_t,shift_n))
                  in
                    Load
                      (LoadWord
                         (add,
                          (index,
                           (wback,
                            (Rt,
                             (BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4),
                              m))))))
                  end
                )
         else Skip ()
       end
     | ((true,
       (true,
        (true,
         (true,
          (true,
           (false,
            (false,
             (false,
              (false,(true,(false,(false,(Rn'3,(Rn'2,(Rn'1,Rn'0))))))))))))))),
      (Rt'3,
       (Rt'2,
        (Rt'1,
         (Rt'0,
          (false,
           (false,
            (false,
             (false,
              (false,(false,(imm2'1,(imm2'0,(Rm'3,(Rm'2,(Rm'1,Rm'0)))))))))))))))) =>
       let
         val Rn = BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)
         val Rm = BitsN.fromBitstring([Rm'3,Rm'2,Rm'1,Rm'0],4)
         val Rt = BitsN.fromBitstring([Rt'3,Rt'2,Rt'1,Rt'0],4)
       in
         if Do(ThumbCondition (),
               (not(Rn = (BitsN.B(0xF,4)))) andalso (HaveThumb2 ()))
           then ( if (Rt = (BitsN.B(0xF,4))) orelse
                     (Set.mem(Rm,[BitsN.B(0xD,4),BitsN.B(0xF,4)]))
                    then DECODE_UNPREDICTABLE(mc,"Store (register)")
                  else ()
                ; let
                    val add = true
                    val index = true
                    val wback = false
                    val (shift_t,shift_n) =
                      (SRType_LSL,
                       BitsN.toNat(BitsN.fromBitstring([imm2'1,imm2'0],2)))
                    val m = register_form1(Rm,(shift_t,shift_n))
                  in
                    Store(StoreWord(add,(index,(wback,(Rt,(Rn,m))))))
                  end
                )
         else Skip ()
       end
     | ((true,
       (true,
        (true,
         (true,
          (true,
           (false,
            (false,
             (false,
              (false,(false,(H'0,(false,(Rn'3,(Rn'2,(Rn'1,Rn'0))))))))))))))),
      (Rt'3,
       (Rt'2,
        (Rt'1,
         (Rt'0,
          (false,
           (false,
            (false,
             (false,
              (false,(false,(imm2'1,(imm2'0,(Rm'3,(Rm'2,(Rm'1,Rm'0)))))))))))))))) =>
       let
         val Rn = BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)
         val Rm = BitsN.fromBitstring([Rm'3,Rm'2,Rm'1,Rm'0],4)
         val Rt = BitsN.fromBitstring([Rt'3,Rt'2,Rt'1,Rt'0],4)
       in
         if Do(ThumbCondition (),
               (not(Rn = (BitsN.B(0xF,4)))) andalso (HaveThumb2 ()))
           then ( if (Set.mem(Rt,[BitsN.B(0xD,4),BitsN.B(0xF,4)])) orelse
                     (Set.mem(Rm,[BitsN.B(0xD,4),BitsN.B(0xF,4)]))
                    then DECODE_UNPREDICTABLE
                           (mc,"StoreByte/Half (register)")
                  else ()
                ; let
                    val add = true
                    val index = true
                    val wback = false
                    val (shift_t,shift_n) =
                      (SRType_LSL,
                       BitsN.toNat(BitsN.fromBitstring([imm2'1,imm2'0],2)))
                    val m = register_form1(Rm,(shift_t,shift_n))
                  in
                    if (BitsN.fromBitstring([H'0],1)) = (BitsN.B(0x1,1))
                      then Store
                             (StoreHalf(add,(index,(wback,(Rt,(Rn,m))))))
                    else Store(StoreByte(add,(index,(wback,(Rt,(Rn,m))))))
                  end
                )
         else Skip ()
       end
     | ((true,
       (true,
        (true,
         (true,
          (true,
           (false,
            (false,
             (false,
              (false,(true,(false,(false,(Rn'3,(Rn'2,(Rn'1,Rn'0))))))))))))))),
      (Rt'3,
       (Rt'2,
        (Rt'1,
         (Rt'0,
          (true,
           (true,
            (true,
             (false,
              (imm8'7,
               (imm8'6,(imm8'5,(imm8'4,(imm8'3,(imm8'2,(imm8'1,imm8'0)))))))))))))))) =>
       let
         val Rn = BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)
         val Rt = BitsN.fromBitstring([Rt'3,Rt'2,Rt'1,Rt'0],4)
       in
         if Do(ThumbCondition (),
               (not(Rn = (BitsN.B(0xF,4)))) andalso (HaveThumb2 ()))
           then ( if Set.mem(Rt,[BitsN.B(0xD,4),BitsN.B(0xF,4)])
                    then DECODE_UNPREDICTABLE(mc,"StoreUnprivileged")
                  else ()
                ; let
                    val add = true
                    val postindex = false
                    val imm32 =
                      BitsN.zeroExtend 32
                        (BitsN.fromBitstring
                           ([imm8'7,imm8'6,imm8'5,imm8'4,imm8'3,imm8'2,
                             imm8'1,imm8'0],8))
                    val m = immediate_form1 imm32
                  in
                    Store(StoreUnprivileged(add,(postindex,(Rt,(Rn,m)))))
                  end
                )
         else Skip ()
       end
     | ((true,
       (true,
        (true,
         (true,
          (true,
           (false,
            (false,
             (false,
              (false,(false,(H'0,(false,(Rn'3,(Rn'2,(Rn'1,Rn'0))))))))))))))),
      (Rt'3,
       (Rt'2,
        (Rt'1,
         (Rt'0,
          (true,
           (true,
            (true,
             (false,
              (imm8'7,
               (imm8'6,(imm8'5,(imm8'4,(imm8'3,(imm8'2,(imm8'1,imm8'0)))))))))))))))) =>
       let
         val Rn = BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)
         val Rt = BitsN.fromBitstring([Rt'3,Rt'2,Rt'1,Rt'0],4)
       in
         if Do(ThumbCondition (),
               (not(Rn = (BitsN.B(0xF,4)))) andalso (HaveThumb2 ()))
           then ( if Set.mem(Rt,[BitsN.B(0xD,4),BitsN.B(0xF,4)])
                    then DECODE_UNPREDICTABLE
                           (mc,"StoreByte/HalfUnprivileged")
                  else ()
                ; let
                    val add = true
                    val postindex = false
                    val imm32 =
                      BitsN.zeroExtend 32
                        (BitsN.fromBitstring
                           ([imm8'7,imm8'6,imm8'5,imm8'4,imm8'3,imm8'2,
                             imm8'1,imm8'0],8))
                    val m1 = immediate_form1 imm32
                    val m2 = immediate_form2 imm32
                  in
                    if (BitsN.fromBitstring([H'0],1)) = (BitsN.B(0x1,1))
                      then Store
                             (StoreHalfUnprivileged
                                (add,(postindex,(Rt,(Rn,m2)))))
                    else Store
                           (StoreByteUnprivileged
                              (add,(postindex,(Rt,(Rn,m1)))))
                  end
                )
         else Skip ()
       end
     | ((true,
       (true,
        (true,
         (true,
          (true,
           (false,
            (false,
             (false,
              (false,(true,(false,(false,(Rn'3,(Rn'2,(Rn'1,Rn'0))))))))))))))),
      (Rt'3,
       (Rt'2,
        (Rt'1,
         (Rt'0,
          (true,
           (P'0,
            (U'0,
             (W'0,
              (imm8'7,
               (imm8'6,(imm8'5,(imm8'4,(imm8'3,(imm8'2,(imm8'1,imm8'0)))))))))))))))) =>
       let
         val Rn = BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)
         val W = BitsN.fromBitstring([W'0],1)
         val P = BitsN.fromBitstring([P'0],1)
         val Rt = BitsN.fromBitstring([Rt'3,Rt'2,Rt'1,Rt'0],4)
       in
         if Do(ThumbCondition (),
               (not(Rn = (BitsN.B(0xF,4)))) andalso
               (((P = (BitsN.B(0x1,1))) orelse (W = (BitsN.B(0x1,1)))) andalso
                (HaveThumb2 ())))
           then let
                  val wback = W = (BitsN.B(0x1,1))
                in
                  ( if (Rt = (BitsN.B(0xF,4))) orelse
                       (wback andalso (Rn = Rt))
                      then DECODE_UNPREDICTABLE(mc,"Store (immediate)")
                    else ()
                  ; let
                      val add =
                        (BitsN.fromBitstring([U'0],1)) = (BitsN.B(0x1,1))
                      val index = P = (BitsN.B(0x1,1))
                      val imm32 =
                        BitsN.zeroExtend 32
                          (BitsN.fromBitstring
                             ([imm8'7,imm8'6,imm8'5,imm8'4,imm8'3,imm8'2,
                               imm8'1,imm8'0],8))
                      val m = immediate_form1 imm32
                    in
                      Store(StoreWord(add,(index,(wback,(Rt,(Rn,m))))))
                    end
                  )
                end
         else Skip ()
       end
     | ((true,
       (true,
        (true,
         (true,
          (true,
           (false,
            (false,
             (false,
              (false,(false,(H'0,(false,(Rn'3,(Rn'2,(Rn'1,Rn'0))))))))))))))),
      (Rt'3,
       (Rt'2,
        (Rt'1,
         (Rt'0,
          (true,
           (P'0,
            (U'0,
             (W'0,
              (imm8'7,
               (imm8'6,(imm8'5,(imm8'4,(imm8'3,(imm8'2,(imm8'1,imm8'0)))))))))))))))) =>
       let
         val Rn = BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)
         val W = BitsN.fromBitstring([W'0],1)
         val P = BitsN.fromBitstring([P'0],1)
         val Rt = BitsN.fromBitstring([Rt'3,Rt'2,Rt'1,Rt'0],4)
       in
         if Do(ThumbCondition (),
               (not(Rn = (BitsN.B(0xF,4)))) andalso
               (((P = (BitsN.B(0x1,1))) orelse (W = (BitsN.B(0x1,1)))) andalso
                (HaveThumb2 ())))
           then let
                  val wback = W = (BitsN.B(0x1,1))
                in
                  ( if (Set.mem(Rt,[BitsN.B(0xD,4),BitsN.B(0xF,4)])) orelse
                       (wback andalso (Rn = Rt))
                      then DECODE_UNPREDICTABLE
                             (mc,"StoreByte/Half (immediate)")
                    else ()
                  ; let
                      val add =
                        (BitsN.fromBitstring([U'0],1)) = (BitsN.B(0x1,1))
                      val index = P = (BitsN.B(0x1,1))
                      val imm32 =
                        BitsN.zeroExtend 32
                          (BitsN.fromBitstring
                             ([imm8'7,imm8'6,imm8'5,imm8'4,imm8'3,imm8'2,
                               imm8'1,imm8'0],8))
                      val m = immediate_form1 imm32
                    in
                      if (BitsN.fromBitstring([H'0],1)) = (BitsN.B(0x1,1))
                        then Store
                               (StoreHalf(add,(index,(wback,(Rt,(Rn,m))))))
                      else Store
                             (StoreByte(add,(index,(wback,(Rt,(Rn,m))))))
                    end
                  )
                end
         else Skip ()
       end
     | ((true,
       (true,
        (true,
         (true,
          (true,
           (false,
            (false,
             (false,
              (true,(true,(false,(false,(Rn'3,(Rn'2,(Rn'1,Rn'0))))))))))))))),
      (Rt'3,
       (Rt'2,
        (Rt'1,
         (Rt'0,
          (imm12'11,
           (imm12'10,
            (imm12'9,
             (imm12'8,
              (imm12'7,
               (imm12'6,
                (imm12'5,(imm12'4,(imm12'3,(imm12'2,(imm12'1,imm12'0)))))))))))))))) =>
       let
         val Rn = BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)
         val Rt = BitsN.fromBitstring([Rt'3,Rt'2,Rt'1,Rt'0],4)
       in
         if Do(ThumbCondition (),
               (not(Rn = (BitsN.B(0xF,4)))) andalso (HaveThumb2 ()))
           then ( if Rt = (BitsN.B(0xF,4))
                    then DECODE_UNPREDICTABLE(mc,"Store (immediate)")
                  else ()
                ; let
                    val add = true
                    val index = true
                    val wback = false
                    val imm32 =
                      BitsN.zeroExtend 32
                        (BitsN.fromBitstring
                           ([imm12'11,imm12'10,imm12'9,imm12'8,imm12'7,
                             imm12'6,imm12'5,imm12'4,imm12'3,imm12'2,
                             imm12'1,imm12'0],12))
                    val m = immediate_form1 imm32
                  in
                    Store(StoreWord(add,(index,(wback,(Rt,(Rn,m))))))
                  end
                )
         else Skip ()
       end
     | ((true,
       (true,
        (true,
         (true,
          (true,
           (false,
            (false,
             (false,(true,(false,(H'0,(false,(Rn'3,(Rn'2,(Rn'1,Rn'0))))))))))))))),
      (Rt'3,
       (Rt'2,
        (Rt'1,
         (Rt'0,
          (imm12'11,
           (imm12'10,
            (imm12'9,
             (imm12'8,
              (imm12'7,
               (imm12'6,
                (imm12'5,(imm12'4,(imm12'3,(imm12'2,(imm12'1,imm12'0)))))))))))))))) =>
       let
         val Rn = BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)
         val Rt = BitsN.fromBitstring([Rt'3,Rt'2,Rt'1,Rt'0],4)
       in
         if Do(ThumbCondition (),
               (not(Rn = (BitsN.B(0xF,4)))) andalso (HaveThumb2 ()))
           then ( if Set.mem(Rt,[BitsN.B(0xD,4),BitsN.B(0xF,4)])
                    then DECODE_UNPREDICTABLE
                           (mc,"StoreByte/Half (immediate)")
                  else ()
                ; let
                    val add = true
                    val index = true
                    val wback = false
                    val imm32 =
                      BitsN.zeroExtend 32
                        (BitsN.fromBitstring
                           ([imm12'11,imm12'10,imm12'9,imm12'8,imm12'7,
                             imm12'6,imm12'5,imm12'4,imm12'3,imm12'2,
                             imm12'1,imm12'0],12))
                    val m = immediate_form1 imm32
                  in
                    if (BitsN.fromBitstring([H'0],1)) = (BitsN.B(0x1,1))
                      then Store
                             (StoreHalf(add,(index,(wback,(Rt,(Rn,m))))))
                    else Store(StoreByte(add,(index,(wback,(Rt,(Rn,m))))))
                  end
                )
         else Skip ()
       end
     | ((true,
       (true,
        (true,
         (true,
          (true,
           (false,
            (true,
             (false,(false,(op'1,(op'0,(S'0,(Rn'3,(Rn'2,(Rn'1,Rn'0))))))))))))))),
      (true,
       (true,
        (true,
         (true,
          (Rd'3,
           (Rd'2,
            (Rd'1,
             (Rd'0,
              (false,(false,(false,(false,(Rm'3,(Rm'2,(Rm'1,Rm'0)))))))))))))))) =>
       let
         val Rn = BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)
         val Rm = BitsN.fromBitstring([Rm'3,Rm'2,Rm'1,Rm'0],4)
         val Rd = BitsN.fromBitstring([Rd'3,Rd'2,Rd'1,Rd'0],4)
       in
         if Do(ThumbCondition (),HaveThumb2 ())
           then ( if (Set.mem(Rd,[BitsN.B(0xD,4),BitsN.B(0xF,4)])) orelse
                     ((Set.mem(Rn,[BitsN.B(0xD,4),BitsN.B(0xF,4)])) orelse
                      (Set.mem(Rm,[BitsN.B(0xD,4),BitsN.B(0xF,4)])))
                    then DECODE_UNPREDICTABLE(mc,"Shift (register)")
                  else ()
                ; let
                    val setflags =
                      (BitsN.fromBitstring([S'0],1)) = (BitsN.B(0x1,1))
                    val shift_t =
                      DecodeRegShift(BitsN.fromBitstring([op'1,op'0],2))
                  in
                    Data
                      (ShiftRegister
                         (false,(setflags,(Rd,(Rn,(shift_t,Rm))))))
                  end
                )
         else Skip ()
       end
     | ((true,
       (true,
        (true,
         (true,
          (true,
           (false,
            (true,
             (false,(false,(op'1,(op'0,(U'0,(Rn'3,(Rn'2,(Rn'1,Rn'0))))))))))))))),
      (true,
       (true,
        (true,
         (true,
          (Rd'3,
           (Rd'2,
            (Rd'1,
             (Rd'0,
              (true,(_,(rotate'1,(rotate'0,(Rm'3,(Rm'2,(Rm'1,Rm'0)))))))))))))))) =>
       let
         val Rn = BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)
         val Rm = BitsN.fromBitstring([Rm'3,Rm'2,Rm'1,Rm'0],4)
         val Rd = BitsN.fromBitstring([Rd'3,Rd'2,Rd'1,Rd'0],4)
       in
         if Do(ThumbCondition (),HaveThumb2 ())
           then ( if (Set.mem(Rd,[BitsN.B(0xD,4),BitsN.B(0xF,4)])) orelse
                     ((Rn = (BitsN.B(0xD,4))) orelse
                      (Set.mem(Rm,[BitsN.B(0xD,4),BitsN.B(0xF,4)])))
                    then DECODE_UNPREDICTABLE(mc,"Extend (register)")
                  else ()
                ; let
                    val unsigned =
                      (BitsN.fromBitstring([U'0],1)) = (BitsN.B(0x1,1))
                    val rotation =
                      BitsN.toNat
                        (BitsN.@@
                           (BitsN.fromBitstring([rotate'1,rotate'0],2),
                            BitsN.B(0x0,3)))
                    val args = (unsigned,(Rd,(Rn,(Rm,rotation))))
                  in
                    case BitsN.fromBitstring([op'1,op'0],2) of
                       BitsN.B(0x0,_) => Media(ExtendHalfword args)
                     | BitsN.B(0x1,_) => Media(ExtendByte16 args)
                     | BitsN.B(0x2,_) => Media(ExtendByte args)
                     | BitsN.B(0x3,_) => Undefined(BitsN.B(0x0,32))
                     | _ => raise General.Bind
                  end
                )
         else Skip ()
       end
     | ((true,
       (true,
        (true,
         (true,
          (true,
           (false,
            (true,
             (false,
              (true,(op1'2,(op1'1,(op1'0,(Rn'3,(Rn'2,(Rn'1,Rn'0))))))))))))))),
      (true,
       (true,
        (true,
         (true,
          (Rd'3,
           (Rd'2,
            (Rd'1,
             (Rd'0,(false,(U'0,(op2'1,(op2'0,(Rm'3,(Rm'2,(Rm'1,Rm'0)))))))))))))))) =>
       let
         val Rn = BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)
         val Rm = BitsN.fromBitstring([Rm'3,Rm'2,Rm'1,Rm'0],4)
         val Rd = BitsN.fromBitstring([Rd'3,Rd'2,Rd'1,Rd'0],4)
       in
         if Do(ThumbCondition (),HaveThumb2 ())
           then ( if (Set.mem(Rd,[BitsN.B(0xD,4),BitsN.B(0xF,4)])) orelse
                     ((Set.mem(Rn,[BitsN.B(0xD,4),BitsN.B(0xF,4)])) orelse
                      (Set.mem(Rm,[BitsN.B(0xD,4),BitsN.B(0xF,4)])))
                    then DECODE_UNPREDICTABLE
                           (mc,"Parallel addition and subtraction")
                  else ()
                ; let
                    val opc =
                      case BitsN.fromBitstring([op1'2,op1'1,op1'0],3) of
                         BitsN.B(0x1,_) => BitsN.B(0x0,3)
                       | BitsN.B(0x2,_) => BitsN.B(0x1,3)
                       | BitsN.B(0x6,_) => BitsN.B(0x2,3)
                       | BitsN.B(0x5,_) => BitsN.B(0x3,3)
                       | BitsN.B(0x0,_) => BitsN.B(0x4,3)
                       | BitsN.B(0x4,_) => BitsN.B(0x7,3)
                       | _ => BitsN.B(0x5,3)
                  in
                    DecodeParallelAdditionSubtraction
                      (BitsN.+
                         (BitsN.fromBitstring([op2'1,op2'0],2),
                          BitsN.B(0x1,2)),
                       (opc,(BitsN.fromBitstring([U'0],1),(Rd,(Rn,Rm)))))
                  end
                )
         else Skip ()
       end
     | ((true,
       (true,
        (true,
         (true,
          (true,
           (false,
            (true,
             (false,
              (true,(false,(false,(false,(Rn'3,(Rn'2,(Rn'1,Rn'0))))))))))))))),
      (true,
       (true,
        (true,
         (true,
          (Rd'3,
           (Rd'2,
            (Rd'1,
             (Rd'0,
              (true,(false,(op2'1,(op2'0,(Rm'3,(Rm'2,(Rm'1,Rm'0)))))))))))))))) =>
       let
         val Rn = BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)
         val Rm = BitsN.fromBitstring([Rm'3,Rm'2,Rm'1,Rm'0],4)
         val Rd = BitsN.fromBitstring([Rd'3,Rd'2,Rd'1,Rd'0],4)
       in
         if Do(ThumbCondition (),HaveThumb2 ())
           then ( if (Set.mem(Rd,[BitsN.B(0xD,4),BitsN.B(0xF,4)])) orelse
                     ((Set.mem(Rn,[BitsN.B(0xD,4),BitsN.B(0xF,4)])) orelse
                      (Set.mem(Rm,[BitsN.B(0xD,4),BitsN.B(0xF,4)])))
                    then DECODE_UNPREDICTABLE(mc,"SaturatingAddSubtract")
                  else ()
                ; let
                    val opc =
                      BitsN.reverse(BitsN.fromBitstring([op2'1,op2'0],2))
                  in
                    Media(SaturatingAddSubtract(opc,(Rd,(Rm,Rn))))
                  end
                )
         else Skip ()
       end
     | ((true,
       (true,
        (true,
         (true,
          (true,
           (false,
            (true,
             (false,
              (true,(false,(false,(true,(Rn'3,(Rn'2,(Rn'1,Rn'0))))))))))))))),
      (true,
       (true,
        (true,
         (true,
          (Rd'3,
           (Rd'2,
            (Rd'1,
             (Rd'0,
              (true,(false,(op2'1,(op2'0,(Rm'3,(Rm'2,(Rm'1,Rm'0)))))))))))))))) =>
       let
         val Rm = BitsN.fromBitstring([Rm'3,Rm'2,Rm'1,Rm'0],4)
         val Rd = BitsN.fromBitstring([Rd'3,Rd'2,Rd'1,Rd'0],4)
       in
         if Do(ThumbCondition (),HaveThumb2 ())
           then ( if (not((BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)) =
                          Rm)) orelse
                     ((Set.mem(Rd,[BitsN.B(0xD,4),BitsN.B(0xF,4)])) orelse
                      (Set.mem(Rm,[BitsN.B(0xD,4),BitsN.B(0xF,4)])))
                    then DECODE_UNPREDICTABLE(mc,"Reverses")
                  else ()
                ; case BitsN.fromBitstring([op2'1,op2'0],2) of
                     BitsN.B(0x0,_) => Media(ByteReverse(Rd,Rm))
                   | BitsN.B(0x1,_) =>
                     Media(ByteReversePackedHalfword(Rd,Rm))
                   | BitsN.B(0x2,_) => Media(ReverseBits(Rd,Rm))
                   | BitsN.B(0x3,_) =>
                     Media(ByteReverseSignedHalfword(Rd,Rm))
                   | _ => raise General.Bind
                )
         else Skip ()
       end
     | ((true,
       (true,
        (true,
         (true,
          (true,
           (false,
            (true,
             (false,
              (true,(false,(true,(false,(Rn'3,(Rn'2,(Rn'1,Rn'0))))))))))))))),
      (true,
       (true,
        (true,
         (true,
          (Rd'3,
           (Rd'2,
            (Rd'1,
             (Rd'0,
              (true,(false,(false,(false,(Rm'3,(Rm'2,(Rm'1,Rm'0)))))))))))))))) =>
       let
         val Rn = BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)
         val Rm = BitsN.fromBitstring([Rm'3,Rm'2,Rm'1,Rm'0],4)
         val Rd = BitsN.fromBitstring([Rd'3,Rd'2,Rd'1,Rd'0],4)
       in
         if Do(ThumbCondition (),HaveThumb2 ())
           then ( if (Set.mem(Rd,[BitsN.B(0xD,4),BitsN.B(0xF,4)])) orelse
                     ((Set.mem(Rn,[BitsN.B(0xD,4),BitsN.B(0xF,4)])) orelse
                      (Set.mem(Rm,[BitsN.B(0xD,4),BitsN.B(0xF,4)])))
                    then DECODE_UNPREDICTABLE(mc,"SelectBytes")
                  else ()
                ; Media(SelectBytes(Rd,(Rn,Rm)))
                )
         else Skip ()
       end
     | ((true,
       (true,
        (true,
         (true,
          (true,
           (false,
            (true,
             (false,(true,(false,(true,(true,(Rn'3,(Rn'2,(Rn'1,Rn'0))))))))))))))),
      (true,
       (true,
        (true,
         (true,
          (Rd'3,
           (Rd'2,
            (Rd'1,
             (Rd'0,
              (true,(false,(false,(false,(Rm'3,(Rm'2,(Rm'1,Rm'0)))))))))))))))) =>
       let
         val Rm = BitsN.fromBitstring([Rm'3,Rm'2,Rm'1,Rm'0],4)
         val Rd = BitsN.fromBitstring([Rd'3,Rd'2,Rd'1,Rd'0],4)
       in
         if Do(ThumbCondition (),HaveThumb2 ())
           then ( if (not((BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)) =
                          Rm)) orelse
                     ((Set.mem(Rd,[BitsN.B(0xD,4),BitsN.B(0xF,4)])) orelse
                      (Set.mem(Rm,[BitsN.B(0xD,4),BitsN.B(0xF,4)])))
                    then DECODE_UNPREDICTABLE(mc,"CountLeadingZeroes")
                  else ()
                ; Data(CountLeadingZeroes(Rd,Rm))
                )
         else Skip ()
       end
     | ((true,
       (true,
        (true,
         (true,
          (true,
           (false,
            (true,
             (true,
              (false,(opc'2,(opc'1,(opc'0,(Rn'3,(Rn'2,(Rn'1,Rn'0))))))))))))))),
      (Ra'3,
       (Ra'2,
        (Ra'1,
         (Ra'0,
          (Rd'3,
           (Rd'2,
            (Rd'1,
             (Rd'0,(false,(false,(N'0,(M'0,(Rm'3,(Rm'2,(Rm'1,Rm'0)))))))))))))))) =>
       let
         val Rn = BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)
         val Rm = BitsN.fromBitstring([Rm'3,Rm'2,Rm'1,Rm'0],4)
         val Rd = BitsN.fromBitstring([Rd'3,Rd'2,Rd'1,Rd'0],4)
         val Ra = BitsN.fromBitstring([Ra'3,Ra'2,Ra'1,Ra'0],4)
       in
         if Do(ThumbCondition (),HaveThumb2 ())
           then ( if (Set.mem(Rd,[BitsN.B(0xD,4),BitsN.B(0xF,4)])) orelse
                     ((Set.mem(Rn,[BitsN.B(0xD,4),BitsN.B(0xF,4)])) orelse
                      ((Set.mem(Rm,[BitsN.B(0xD,4),BitsN.B(0xF,4)])) orelse
                       (Ra = (BitsN.B(0xD,4)))))
                    then DECODE_UNPREDICTABLE
                           (mc,"Multiplies and absolute difference")
                  else ()
                ; case (BitsN.fromBitstring([opc'2,opc'1,opc'0],3),
                   (Ra,
                    ((BitsN.fromBitstring([N'0],1)) = (BitsN.B(0x1,1)),
                     (BitsN.fromBitstring([M'0],1)) = (BitsN.B(0x1,1))))) of
                     (BitsN.B(0x0,_),(BitsN.B(0xF,_),(false,false))) =>
                       Multiply(Multiply32(false,(Rd,(Rn,Rm))))
                   | (BitsN.B(0x0,_),(_,(false,false))) =>
                     Multiply(MultiplyAccumulate(false,(Rd,(Rn,(Rm,Ra)))))
                   | (BitsN.B(0x0,_),(BitsN.B(0xF,_),(false,true))) =>
                     ( DECODE_UNPREDICTABLE(mc,"MultiplySubtract")
                     ; Branch(BranchExchange(BitsN.B(0x0,4)))
                     )
                   | (BitsN.B(0x0,_),(_,(false,true))) =>
                     Multiply(MultiplySubtract(Rd,(Rn,(Rm,Ra))))
                   | (BitsN.B(0x1,_),(BitsN.B(0xF,_),(n_high,m_high))) =>
                     Multiply
                       (Signed16Multiply32Result
                          (m_high,(n_high,(Rd,(Rn,Rm)))))
                   | (BitsN.B(0x1,_),(_,(n_high,m_high))) =>
                     Multiply
                       (Signed16Multiply32Accumulate
                          (m_high,(n_high,(Rd,(Rn,(Rm,Ra))))))
                   | (BitsN.B(0x2,_),(_,(false,m_swap))) =>
                     Multiply
                       (SignedMultiplyDual
                          (false,(m_swap,(Rd,(Rn,(Rm,Ra))))))
                   | (BitsN.B(0x3,_),(BitsN.B(0xF,_),(false,m_high))) =>
                     Multiply
                       (Signed16x32Multiply32Result(m_high,(Rd,(Rn,Rm))))
                   | (BitsN.B(0x3,_),(_,(false,m_high))) =>
                     Multiply
                       (Signed16x32Multiply32Accumulate
                          (m_high,(Rd,(Rn,(Rm,Ra)))))
                   | (BitsN.B(0x4,_),(_,(false,m_swap))) =>
                     Multiply
                       (SignedMultiplyDual
                          (true,(m_swap,(Rd,(Rn,(Rm,Ra))))))
                   | (BitsN.B(0x5,_),(_,(false,round))) =>
                     Multiply
                       (SignedMostSignificantMultiply
                          (round,(Rd,(Rn,(Rm,Ra)))))
                   | (BitsN.B(0x6,_),(BitsN.B(0xF,_),(false,_))) =>
                     ( DECODE_UNPREDICTABLE
                         (mc,"SignedMostSignificantMultiplySubtract")
                     ; Branch(BranchExchange(BitsN.B(0x0,4)))
                     )
                   | (BitsN.B(0x6,_),(_,(false,round))) =>
                     Multiply
                       (SignedMostSignificantMultiplySubtract
                          (round,(Rd,(Rn,(Rm,Ra)))))
                   | (BitsN.B(0x7,_),(_,(false,false))) =>
                     SIMD(UnsignedSumAbsoluteDifferences(Rd,(Rn,(Rm,Ra))))
                   | _ => Undefined(BitsN.B(0x0,32))
                )
         else Skip ()
       end
     | ((true,
       (true,
        (true,
         (true,
          (true,
           (false,
            (true,
             (true,(true,(false,(U'0,(true,(Rn'3,(Rn'2,(Rn'1,Rn'0))))))))))))))),
      (_,
       (_,
        (_,
         (_,
          (Rd'3,
           (Rd'2,
            (Rd'1,
             (Rd'0,(true,(true,(true,(true,(Rm'3,(Rm'2,(Rm'1,Rm'0)))))))))))))))) =>
       let
         val Rn = BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)
         val Rm = BitsN.fromBitstring([Rm'3,Rm'2,Rm'1,Rm'0],4)
         val Rd = BitsN.fromBitstring([Rd'3,Rd'2,Rd'1,Rd'0],4)
       in
         if Do(ThumbCondition (),
               (HaveVirtExt ()) orelse ((!Architecture) = ARMv7_R))
           then ( if (Set.mem(Rd,[BitsN.B(0xD,4),BitsN.B(0xF,4)])) orelse
                     ((Set.mem(Rn,[BitsN.B(0xD,4),BitsN.B(0xF,4)])) orelse
                      (Set.mem(Rm,[BitsN.B(0xD,4),BitsN.B(0xF,4)])))
                    then DECODE_UNPREDICTABLE(mc,"Divide")
                  else ()
                ; let
                    val unsigned =
                      (BitsN.fromBitstring([U'0],1)) = (BitsN.B(0x1,1))
                  in
                    Divide(unsigned,(Rd,(Rn,Rm)))
                  end
                )
         else Skip ()
       end
     | ((true,
       (true,
        (true,
         (true,
          (true,
           (false,
            (true,
             (true,
              (true,(op1'2,(op1'1,(op1'0,(Rn'3,(Rn'2,(Rn'1,Rn'0))))))))))))))),
      (RdLo'3,
       (RdLo'2,
        (RdLo'1,
         (RdLo'0,
          (RdHi'3,
           (RdHi'2,
            (RdHi'1,
             (RdHi'0,
              (op2'3,(op2'2,(op2'1,(op2'0,(Rm'3,(Rm'2,(Rm'1,Rm'0)))))))))))))))) =>
       let
         val Rn = BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)
         val Rm = BitsN.fromBitstring([Rm'3,Rm'2,Rm'1,Rm'0],4)
         val RdHi = BitsN.fromBitstring([RdHi'3,RdHi'2,RdHi'1,RdHi'0],4)
         val RdLo = BitsN.fromBitstring([RdLo'3,RdLo'2,RdLo'1,RdLo'0],4)
       in
         if Do(ThumbCondition (),HaveThumb2 ())
           then ( if (Set.mem(RdLo,[BitsN.B(0xD,4),BitsN.B(0xF,4)])) orelse
                     ((Set.mem(RdHi,[BitsN.B(0xD,4),BitsN.B(0xF,4)])) orelse
                      ((Set.mem(Rn,[BitsN.B(0xD,4),BitsN.B(0xF,4)])) orelse
                       ((Set.mem(Rm,[BitsN.B(0xD,4),BitsN.B(0xF,4)])) orelse
                        (RdHi = RdLo))))
                    then DECODE_UNPREDICTABLE
                           (mc,"Long multiply, long multiply accumulate")
                  else ()
                ; case (boolify'3
                     (BitsN.fromBitstring([op1'2,op1'1,op1'0],3)),
                   boolify'4
                     (BitsN.fromBitstring([op2'3,op2'2,op2'1,op2'0],4))) of
                     ((A'0,(U'0,false)),(false,(false,(false,false)))) =>
                       let
                         val accumulate =
                           (BitsN.fromBitstring([A'0],1)) =
                           (BitsN.B(0x1,1))
                         val signed =
                           (BitsN.fromBitstring([U'0],1)) =
                           (BitsN.B(0x0,1))
                       in
                         Multiply
                           (MultiplyLong
                              (accumulate,
                               (signed,(false,(RdHi,(RdLo,(Rn,Rm)))))))
                       end
                   | ((true,(false,false)),(true,(false,(N'0,M'0)))) =>
                     let
                       val n_high =
                         (BitsN.fromBitstring([N'0],1)) = (BitsN.B(0x1,1))
                       val m_high =
                         (BitsN.fromBitstring([M'0],1)) = (BitsN.B(0x1,1))
                     in
                       Multiply
                         (Signed16Multiply64Accumulate
                            (m_high,(n_high,(RdHi,(RdLo,(Rn,Rm))))))
                     end
                   | ((true,(false,S'0)),(true,(true,(false,M'0)))) =>
                     let
                       val sub =
                         (BitsN.fromBitstring([S'0],1)) = (BitsN.B(0x1,1))
                       val m_swap =
                         (BitsN.fromBitstring([M'0],1)) = (BitsN.B(0x1,1))
                     in
                       Multiply
                         (SignedMultiplyLongDual
                            (sub,(m_swap,(RdHi,(RdLo,(Rn,Rm))))))
                     end
                   | ((true,(true,false)),(false,(true,(true,false)))) =>
                     Multiply
                       (MultiplyAccumulateAccumulate(RdHi,(RdLo,(Rn,Rm))))
                   | _ => Undefined(BitsN.B(0x0,32))
                )
         else Skip ()
       end
     | _ => UndefinedThumb ()
  end;

fun Decode mc =
  case mc of
     ARM w => DecodeARM w
   | Thumb h => DecodeThumb h
   | ThumbEE h => DecodeThumbEE h
   | Thumb2 hs => DecodeThumb2 hs
   | BadCode s => raise UNPREDICTABLE s;

fun Next () = ( Run(Decode(Fetch ())); ITAdvance () );

fun EncodeThumbImmediate x =
  let
    val x0 = x
  in
    case boolify'32 x0 of
       (b3'7,
        (b3'6,
         (b3'5,
          (b3'4,
           (b3'3,
            (b3'2,
             (b3'1,
              (b3'0,
               (b2'7,
                (b2'6,
                 (b2'5,
                  (b2'4,
                   (b2'3,
                    (b2'2,
                     (b2'1,
                      (b2'0,
                       (b1'7,
                        (b1'6,
                         (b1'5,
                          (b1'4,
                           (b1'3,
                            (b1'2,
                             (b1'1,
                              (b1'0,
                               (b0'7,
                                (b0'6,
                                 (b0'5,(b0'4,(b0'3,(b0'2,(b0'1,b0'0))))))))))))))))))))))))))))))) =>
         let
           val b0 =
             BitsN.fromBitstring
               ([b0'7,b0'6,b0'5,b0'4,b0'3,b0'2,b0'1,b0'0],8)
           val b1 =
             BitsN.fromBitstring
               ([b1'7,b1'6,b1'5,b1'4,b1'3,b1'2,b1'1,b1'0],8)
           val b2 =
             BitsN.fromBitstring
               ([b2'7,b2'6,b2'5,b2'4,b2'3,b2'2,b2'1,b2'0],8)
           val b3 =
             BitsN.fromBitstring
               ([b3'7,b3'6,b3'5,b3'4,b3'3,b3'2,b3'1,b3'0],8)
         in
           case (b3 = (BitsN.B(0x0,8)),
            (b2 = (BitsN.B(0x0,8)),
             (b1 = (BitsN.B(0x0,8)),b0 = (BitsN.B(0x0,8))))) of
              (true,(true,(true,_))) =>
                Option.SOME(BitsN.@@(BitsN.B(0x0,4),b0))
            | (true,(false,(true,false))) =>
              if b2 = b0
                then Option.SOME(BitsN.@@(BitsN.B(0x1,4),b0))
              else NONE
            | (false,(true,(false,true))) =>
              if b3 = b1
                then Option.SOME(BitsN.@@(BitsN.B(0x2,4),b1))
              else NONE
            | (false,(false,(false,false))) =>
              if (b3 = b2) andalso ((b2 = b1) andalso (b1 = b0))
                then Option.SOME(BitsN.@@(BitsN.B(0x3,4),b0))
              else NONE
            | _ =>
              let
                val m = BitsN.toNat(BitsN.log2 x)
                val n = BitsN.#>>(x,Nat.-(Nat.+(m,1),8))
              in
                if BitsN.<+(n,BitsN.B(0x100,32))
                  then Option.SOME
                         (BitsN.@@
                            (BitsN.+
                               (BitsN.-
                                  (BitsN.B(0x1F,5),BitsN.fromNat(m,5)),
                                BitsN.B(0x8,5)),BitsN.bits(6,0) n))
                else NONE
              end
         end
  end;

fun EncodeARMImmediate_aux (n,x) =
  if (BitsN.bits(31,8) x) = (BitsN.B(0x0,24))
    then Option.SOME
           (BitsN.@@(BitsN.-(BitsN.B(0xF,4),n),BitsN.bits(7,0) x))
  else if n = (BitsN.B(0x0,4))
    then NONE
  else EncodeARMImmediate_aux(BitsN.-(n,BitsN.B(0x1,4)),BitsN.#<<(x,2));

fun EncodeARMImmediate x = EncodeARMImmediate_aux(BitsN.B(0xF,4),x);

fun EncodeImmShift (shift_t,shift_n) =
  case shift_t of
     SRType_LSL => (BitsN.B(0x0,2),BitsN.fromNat(shift_n,5))
   | SRType_LSR =>
     (BitsN.B(0x1,2),
      if shift_n = 32 then BitsN.B(0x0,5) else BitsN.fromNat(shift_n,5))
   | SRType_ASR =>
     (BitsN.B(0x2,2),
      if shift_n = 32 then BitsN.B(0x0,5) else BitsN.fromNat(shift_n,5))
   | SRType_ROR => (BitsN.B(0x3,2),BitsN.fromNat(shift_n,5))
   | SRType_RRX => (BitsN.B(0x3,2),BitsN.B(0x0,5));

fun EncodeRegShift shift_t =
  case shift_t of
     SRType_LSL => BitsN.B(0x0,2)
   | SRType_LSR => BitsN.B(0x1,2)
   | SRType_ASR => BitsN.B(0x2,2)
   | SRType_ROR => BitsN.B(0x3,2)
   | SRType_RRX => BitsN.B(0x0,2);

fun EncodeAddSubOpc opc =
  case opc of
     BitsN.B(0x0,_) => BitsN.B(0x1,3)
   | BitsN.B(0x1,_) => BitsN.B(0x2,3)
   | BitsN.B(0x2,_) => BitsN.B(0x6,3)
   | BitsN.B(0x3,_) => BitsN.B(0x5,3)
   | _ => raise General.Bind;

fun EncodeVFPImmediate (imm64,single_register) =
  if single_register
    then if ((BitsN.bits(18,0) imm64) = (BitsN.B(0x0,19))) andalso
            ((Set.mem
                (BitsN.bits(29,25) imm64,[BitsN.B(0x0,5),BitsN.B(0x1F,5)])) andalso
             ((not((BitsN.bit(imm64,25)) = (BitsN.bit(imm64,30)))) andalso
              ((BitsN.bits(63,32) imm64) = (BitsN.B(0x0,32)))))
           then Option.SOME
                  (BitsN.concat
                     [BitsN.bits(31,31) imm64,BitsN.bits(25,25) imm64,
                      BitsN.bits(24,19) imm64])
         else NONE
  else if ((BitsN.bits(47,0) imm64) = (BitsN.B(0x0,48))) andalso
     ((Set.mem(BitsN.bits(61,54) imm64,[BitsN.B(0x0,8),BitsN.B(0xFF,8)])) andalso
      (not((BitsN.bit(imm64,61)) = (BitsN.bit(imm64,62)))))
    then Option.SOME
           (BitsN.concat
              [BitsN.bits(63,63) imm64,BitsN.bits(54,54) imm64,
               BitsN.bits(53,48) imm64])
  else NONE;

fun EncodeVFPReg (d,single_register) =
  if single_register
    then (BitsN.bits(0,0) d,BitsN.bits(4,1) d)
  else (BitsN.bits(4,4) d,BitsN.bits(3,0) d);

fun e_branch (c,(ast,e)) =
  case ast of
     BranchTarget imm32 =>
       (if e = Enc_ARM
          then if (BitsN.<=(BitsN.neg(BitsN.B(0x2000000,32)),imm32)) andalso
                  ((BitsN.<=(imm32,BitsN.B(0x1FFFFFC,32))) andalso
                   (Aligned 32 (imm32,4)))
                 then let
                        val imm24 = BitsN.bits(25,2) imm32
                      in
                        ARM(BitsN.concat[c,BitsN.B(0xA,4),imm24])
                      end
               else BadCode("B: bad offset")
        else if not(Aligned 32 (imm32,2))
          then BadCode("BranchTarget: bad offset")
        else if Set.mem(c,[BitsN.B(0xE,4),BitsN.B(0xF,4)])
          then if (BitsN.<=(BitsN.neg(BitsN.B(0x800,32)),imm32)) andalso
                  ((BitsN.<=(imm32,BitsN.B(0x7FE,32))) andalso
                   (not(e = Enc_Wide)))
                 then let
                        val imm11 = BitsN.bits(11,1) imm32
                      in
                        Thumb(BitsN.@@(BitsN.B(0x1C,5),imm11))
                      end
               else if (BitsN.<=(BitsN.neg(BitsN.B(0x1000000,32)),imm32)) andalso
                  ((BitsN.<=(imm32,BitsN.B(0xFFFFFE,32))) andalso
                   (not(e = Enc_Narrow)))
                 then let
                        val S = BitsN.bits(24,24) imm32
                        val I1 = BitsN.bits(23,23) imm32
                        val I2 = BitsN.bits(22,22) imm32
                        val J1 = BitsN.fromBit(I1 = S)
                        val J2 = BitsN.fromBit(I2 = S)
                        val imm10 = BitsN.bits(21,12) imm32
                        val imm11 = BitsN.bits(11,1) imm32
                      in
                        Thumb2
                          (BitsN.concat[BitsN.B(0x1E,5),S,imm10],
                           BitsN.concat
                             [BitsN.B(0x2,2),J1,BitsN.B(0x1,1),J2,imm11])
                      end
               else BadCode("B: bad offset")
        else if (BitsN.<=(BitsN.neg(BitsN.B(0x100,32)),imm32)) andalso
           ((BitsN.<=(imm32,BitsN.B(0xFE,32))) andalso (not(e = Enc_Wide)))
          then let
                 val imm8 = BitsN.bits(8,1) imm32
               in
                 Thumb(BitsN.concat[BitsN.B(0xD,4),c,imm8])
               end
        else if (BitsN.<=(BitsN.neg(BitsN.B(0x100000,32)),imm32)) andalso
           ((BitsN.<=(imm32,BitsN.B(0xFFFFE,32))) andalso
            (not(e = Enc_Narrow)))
          then let
                 val S = BitsN.bits(20,20) imm32
                 val J2 = BitsN.bits(19,19) imm32
                 val J1 = BitsN.bits(18,18) imm32
                 val imm6 = BitsN.bits(17,12) imm32
                 val imm11 = BitsN.bits(11,1) imm32
               in
                 Thumb2
                   (BitsN.concat[BitsN.B(0x1E,5),S,c,imm6],
                    BitsN.concat
                      [BitsN.B(0x2,2),J1,BitsN.B(0x0,1),J2,imm11])
               end
        else BadCode("B: bad offset"))
   | BranchExchange Rm =>
     (if e = Enc_ARM
        then ARM(BitsN.concat[c,BitsN.B(0x12FFF1,24),Rm])
      else if not(e = Enc_Wide)
        then Thumb(BitsN.concat[BitsN.B(0x8E,9),Rm,BitsN.B(0x0,3)])
      else BadCode("no wide BX (register)"))
   | BranchLinkExchangeImmediate(targetInstrSet,imm32) =>
     (if e = Enc_ARM
        then if c = (BitsN.B(0xE,4))
               then if targetInstrSet = InstrSet_ARM
                      then if (BitsN.<=
                                 (BitsN.neg(BitsN.B(0x2000000,32)),imm32)) andalso
                              ((BitsN.<=(imm32,BitsN.B(0x1FFFFFC,32))) andalso
                               (Aligned 32 (imm32,4)))
                             then let
                                    val imm24 = BitsN.bits(25,2) imm32
                                  in
                                    ARM(BitsN.concat
                                          [c,BitsN.B(0xB,4),imm24])
                                  end
                           else BadCode("BL: bad offset")
                    else if (BitsN.<=
                          (BitsN.neg(BitsN.B(0x2000000,32)),imm32)) andalso
                       ((BitsN.<=(imm32,BitsN.B(0x1FFFFFE,32))) andalso
                        (Aligned 32 (imm32,2)))
                      then let
                             val imm24 = BitsN.bits(25,2) imm32
                             val H = BitsN.bits(1,1) imm32
                           in
                             ARM(BitsN.concat[BitsN.B(0x7D,7),H,imm24])
                           end
                    else BadCode("BLX (immediate): bad offset")
             else BadCode("BLX (immediate)")
      else if targetInstrSet = InstrSet_ARM
        then if (BitsN.<=(BitsN.neg(BitsN.B(0x1000000,32)),imm32)) andalso
                ((BitsN.<=(imm32,BitsN.B(0xFFFFFC,32))) andalso
                 ((Aligned 32 (imm32,4)) andalso (not(e = Enc_Narrow))))
               then let
                      val S = BitsN.bits(24,24) imm32
                      val I1 = BitsN.bits(23,23) imm32
                      val I2 = BitsN.bits(22,22) imm32
                      val J1 = BitsN.fromBit(I1 = S)
                      val J2 = BitsN.fromBit(I2 = S)
                      val imm10H = BitsN.bits(21,12) imm32
                      val imm10L = BitsN.bits(11,2) imm32
                    in
                      Thumb2
                        (BitsN.concat[BitsN.B(0x1E,5),S,imm10H],
                         BitsN.concat
                           [BitsN.B(0x3,2),J1,BitsN.B(0x0,1),J2,imm10L,
                            BitsN.B(0x0,1)])
                    end
             else BadCode("BLX (immediate): bad offset")
      else if (BitsN.<=(BitsN.neg(BitsN.B(0x1000000,32)),imm32)) andalso
         ((BitsN.<=(imm32,BitsN.B(0xFFFFFE,32))) andalso
          ((Aligned 32 (imm32,2)) andalso (not(e = Enc_Narrow))))
        then let
               val S = BitsN.bits(24,24) imm32
               val I1 = BitsN.bits(23,23) imm32
               val I2 = BitsN.bits(22,22) imm32
               val J1 = BitsN.fromBit(I1 = S)
               val J2 = BitsN.fromBit(I2 = S)
               val imm10 = BitsN.bits(21,12) imm32
               val imm11 = BitsN.bits(11,1) imm32
             in
               Thumb2
                 (BitsN.concat[BitsN.B(0x1E,5),S,imm10],
                  BitsN.concat[BitsN.B(0x3,2),J1,BitsN.B(0x1,1),J2,imm11])
             end
      else BadCode("BL: bad offset"))
   | BranchLinkExchangeRegister Rm =>
     (if e = Enc_ARM
        then ARM(BitsN.concat[c,BitsN.B(0x12FFF3,24),Rm])
      else if not(e = Enc_Wide)
        then Thumb(BitsN.concat[BitsN.B(0x8F,9),Rm,BitsN.B(0x0,3)])
      else BadCode("no wide BLX (register)"))
   | CompareBranch(nonzero,(n,imm32)) =>
     (if (BitsN.<=+(imm32,BitsN.B(0x7E,32))) andalso
         ((Aligned 32 (imm32,2)) andalso
          ((not(BitsN.bit(n,3))) andalso
           (Set.mem(e,[Enc_Thumb,Enc_Narrow]))))
        then let
               val op' = BitsN.fromBit nonzero
               val i = BitsN.bits(6,6) imm32
               val imm5 = BitsN.bits(5,1) imm32
               val Rn = BitsN.bits(2,0) n
             in
               Thumb
                 (BitsN.concat
                    [BitsN.B(0xB,4),op',BitsN.B(0x0,1),i,BitsN.B(0x1,1),
                     imm5,Rn])
             end
      else BadCode("CBZ"))
   | TableBranchByte(is_tbh,(Rm,Rn)) =>
     (if Set.mem(e,[Enc_Thumb,Enc_Wide])
        then let
               val H = BitsN.fromBit is_tbh
             in
               Thumb2
                 (BitsN.@@(BitsN.B(0xE8D,12),Rn),
                  BitsN.concat[BitsN.B(0x780,11),H,Rm])
             end
      else BadCode("CBZ"))
   | CheckArray(Rm,n) =>
     (if Set.mem(e,[Enc_Thumb,Enc_Narrow])
        then let
               val N = BitsN.bits(3,3) n
               val Rn = BitsN.bits(2,0) n
             in
               ThumbEE(BitsN.concat[BitsN.B(0xCA,8),N,Rm,Rn])
             end
      else BadCode("CHKA"))
   | HandlerBranchLink(generate_link,handler_offset) =>
     (if (BitsN.<=+(handler_offset,BitsN.B(0x1FE0,32))) andalso
         (((BitsN.bits(4,0) handler_offset) = (BitsN.B(0x0,5))) andalso
          (Set.mem(e,[Enc_Thumb,Enc_Narrow])))
        then let
               val L = BitsN.fromBit generate_link
               val handler = BitsN.bits(12,5) handler_offset
             in
               ThumbEE(BitsN.concat[BitsN.B(0x61,7),L,handler])
             end
      else BadCode("HB{L}"))
   | HandlerBranchLinkParameter(imm32,handler_offset) =>
     (if (BitsN.<+(imm32,BitsN.B(0x20,32))) andalso
         ((BitsN.<=+(handler_offset,BitsN.B(0x3E0,32))) andalso
          (((BitsN.bits(4,0) handler_offset) = (BitsN.B(0x0,5))) andalso
           (Set.mem(e,[Enc_Thumb,Enc_Narrow]))))
        then let
               val imm5 = BitsN.bits(4,0) imm32
               val handler = BitsN.bits(9,5) handler_offset
             in
               ThumbEE(BitsN.concat[BitsN.B(0x31,6),imm5,handler])
             end
      else BadCode("HBLP"))
   | HandlerBranchParameter(imm32,handler_offset) =>
     (if (BitsN.<+(imm32,BitsN.B(0x8,32))) andalso
         ((BitsN.<=+(handler_offset,BitsN.B(0x3E0,32))) andalso
          (((BitsN.bits(4,0) handler_offset) = (BitsN.B(0x0,5))) andalso
           (Set.mem(e,[Enc_Thumb,Enc_Narrow]))))
        then let
               val imm3 = BitsN.bits(2,0) imm32
               val handler = BitsN.bits(9,5) handler_offset
             in
               ThumbEE(BitsN.concat[BitsN.B(0xC0,8),imm3,handler])
             end
      else BadCode("CBZ"));

fun e_vfp (c,(ast,e)) =
  case ast of
     vmrs t =>
       (if e = Enc_ARM
          then ARM(BitsN.concat[c,BitsN.B(0xEF1,12),t,BitsN.B(0xA10,12)])
        else BadCode("VMRS"))
   | vmsr t =>
     (if e = Enc_ARM
        then ARM(BitsN.concat[c,BitsN.B(0xEE1,12),t,BitsN.B(0xA10,12)])
      else BadCode("VMRS"))
   | vcmp(dp_operation,(d,Option.SOME m)) =>
     (if e = Enc_ARM
        then let
               val (D,Vd) = EncodeVFPReg(d,not dp_operation)
               val (M,Vm) = EncodeVFPReg(m,not dp_operation)
             in
               ARM(BitsN.concat
                     [c,BitsN.B(0x1D,5),D,BitsN.B(0x34,6),Vd,
                      BitsN.B(0x5,3),BitsN.fromBit dp_operation,
                      BitsN.B(0x3,2),M,BitsN.B(0x0,1),Vm])
             end
      else BadCode("VCMP (register)"))
   | vcmp(dp_operation,(d,NONE)) =>
     (if e = Enc_ARM
        then let
               val (D,Vd) = EncodeVFPReg(d,not dp_operation)
             in
               ARM(BitsN.concat
                     [c,BitsN.B(0x1D,5),D,BitsN.B(0x35,6),Vd,
                      BitsN.B(0x5,3),BitsN.fromBit dp_operation,
                      BitsN.B(0xC0,8)])
             end
      else BadCode("VCMP (zero)"))
   | vcvt_float(double_to_single,(d,m)) =>
     (if e = Enc_ARM
        then let
               val (D,Vd) = EncodeVFPReg(d,double_to_single)
               val (M,Vm) = EncodeVFPReg(m,not double_to_single)
             in
               ARM(BitsN.concat
                     [c,BitsN.B(0x1D,5),D,BitsN.B(0x37,6),Vd,
                      BitsN.B(0x5,3),BitsN.fromBit double_to_single,
                      BitsN.B(0x3,2),M,BitsN.B(0x0,1),Vm])
             end
      else BadCode("VCVT (float)"))
   | vcvt_from_integer(dp_operation,(unsigned,(d,m))) =>
     (if e = Enc_ARM
        then let
               val (D,Vd) = EncodeVFPReg(d,not dp_operation)
               val (M,Vm) = EncodeVFPReg(m,true)
             in
               ARM(BitsN.concat
                     [c,BitsN.B(0x1D,5),D,BitsN.B(0x38,6),Vd,
                      BitsN.B(0x5,3),BitsN.fromBit dp_operation,
                      BitsN.fromBit(not unsigned),BitsN.B(0x1,1),M,
                      BitsN.B(0x0,1),Vm])
             end
      else BadCode("VCVT (from integer)"))
   | vcvt_to_integer(dp_operation,(unsigned,(round_zero,(d,m)))) =>
     (if e = Enc_ARM
        then let
               val (D,Vd) = EncodeVFPReg(d,true)
               val (M,Vm) = EncodeVFPReg(m,not dp_operation)
             in
               ARM(BitsN.concat
                     [c,BitsN.B(0x1D,5),D,BitsN.B(0x1E,5),
                      BitsN.fromBit(not unsigned),Vd,BitsN.B(0x5,3),
                      BitsN.fromBit dp_operation,BitsN.fromBit round_zero,
                      BitsN.B(0x1,1),M,BitsN.B(0x0,1),Vm])
             end
      else BadCode("VCVT (to integer)"))
   | vmov_imm(single_register,(d,imm64)) =>
     (if e = Enc_ARM
        then case EncodeVFPImmediate(imm64,single_register) of
                Option.SOME v'0 =>
                  (case boolify'8 v'0 of
                      (imm4H'3,
                       (imm4H'2,
                        (imm4H'1,
                         (imm4H'0,(imm4L'3,(imm4L'2,(imm4L'1,imm4L'0))))))) =>
                        let
                          val (D,Vd) = EncodeVFPReg(d,single_register)
                        in
                          ARM(BitsN.concat
                                [c,BitsN.B(0x1D,5),D,BitsN.B(0x3,2),
                                 BitsN.fromBitstring
                                   ([imm4H'3,imm4H'2,imm4H'1,imm4H'0],4),
                                 Vd,BitsN.B(0x5,3),
                                 BitsN.fromBit(not single_register),
                                 BitsN.B(0x0,4),
                                 BitsN.fromBitstring
                                   ([imm4L'3,imm4L'2,imm4L'1,imm4L'0],4)])
                        end)
              | NONE => BadCode("VMOV (immediate)")
      else BadCode("VMOV (immediate)"))
   | vmov(single_register,(d,m)) =>
     (if e = Enc_ARM
        then let
               val (D,Vd) = EncodeVFPReg(d,single_register)
               val (M,Vm) = EncodeVFPReg(m,single_register)
             in
               ARM(BitsN.concat
                     [c,BitsN.B(0x1D,5),D,BitsN.B(0x30,6),Vd,
                      BitsN.B(0x5,3),BitsN.fromBit(not single_register),
                      BitsN.B(0x1,2),M,BitsN.B(0x0,1),Vm])
             end
      else BadCode("VMOV"))
   | vmov_single(to_arm_register,(t,n)) =>
     (if e = Enc_ARM
        then let
               val (N,Vn) = EncodeVFPReg(n,true)
             in
               ARM(BitsN.concat
                     [c,BitsN.B(0x70,7),BitsN.fromBit to_arm_register,Vn,
                      t,BitsN.B(0xA,4),N,BitsN.B(0x10,7)])
             end
      else BadCode("VMOV (single)"))
   | vmov_two_singles(to_arm_registers,(t,(t2,m))) =>
     (if e = Enc_ARM
        then let
               val (M,Vm) = EncodeVFPReg(m,true)
             in
               ARM(BitsN.concat
                     [c,BitsN.B(0x62,7),BitsN.fromBit to_arm_registers,t2,
                      t,BitsN.B(0x28,6),M,BitsN.B(0x1,1),Vm])
             end
      else BadCode("VMOV (two singles)"))
   | vmov_double(to_arm_registers,(t,(t2,m))) =>
     (if e = Enc_ARM
        then let
               val (M,Vm) = EncodeVFPReg(m,false)
             in
               ARM(BitsN.concat
                     [c,BitsN.B(0x62,7),BitsN.fromBit to_arm_registers,t2,
                      t,BitsN.B(0x2C,6),M,BitsN.B(0x1,1),Vm])
             end
      else BadCode("VMOV (double)"))
   | vabs(dp_operation,(d,m)) =>
     (if e = Enc_ARM
        then let
               val (D,Vd) = EncodeVFPReg(d,not dp_operation)
               val (M,Vm) = EncodeVFPReg(m,not dp_operation)
             in
               ARM(BitsN.concat
                     [c,BitsN.B(0x1D,5),D,BitsN.B(0x30,6),Vd,
                      BitsN.B(0x5,3),BitsN.fromBit dp_operation,
                      BitsN.B(0x3,2),M,BitsN.B(0x0,1),Vm])
             end
      else BadCode("VABS"))
   | vneg(dp_operation,(d,m)) =>
     (if e = Enc_ARM
        then let
               val (D,Vd) = EncodeVFPReg(d,not dp_operation)
               val (M,Vm) = EncodeVFPReg(m,not dp_operation)
             in
               ARM(BitsN.concat
                     [c,BitsN.B(0x1D,5),D,BitsN.B(0x31,6),Vd,
                      BitsN.B(0x5,3),BitsN.fromBit dp_operation,
                      BitsN.B(0x1,2),M,BitsN.B(0x0,1),Vm])
             end
      else BadCode("VNEG"))
   | vsqrt(dp_operation,(d,m)) =>
     (if e = Enc_ARM
        then let
               val (D,Vd) = EncodeVFPReg(d,not dp_operation)
               val (M,Vm) = EncodeVFPReg(m,not dp_operation)
             in
               ARM(BitsN.concat
                     [c,BitsN.B(0x1D,5),D,BitsN.B(0x31,6),Vd,
                      BitsN.B(0x5,3),BitsN.fromBit dp_operation,
                      BitsN.B(0x3,2),M,BitsN.B(0x0,1),Vm])
             end
      else BadCode("VSQRT"))
   | vadd(dp_operation,(d,(n,m))) =>
     (if e = Enc_ARM
        then let
               val single_register = not dp_operation
               val (D,Vd) = EncodeVFPReg(d,single_register)
               val (N,Vn) = EncodeVFPReg(n,single_register)
               val (M,Vm) = EncodeVFPReg(m,single_register)
             in
               ARM(BitsN.concat
                     [c,BitsN.B(0x1C,5),D,BitsN.B(0x3,2),Vn,Vd,
                      BitsN.B(0x5,3),BitsN.fromBit dp_operation,N,
                      BitsN.B(0x0,1),M,BitsN.B(0x0,1),Vm])
             end
      else BadCode("VADD"))
   | vsub(dp_operation,(d,(n,m))) =>
     (if e = Enc_ARM
        then let
               val single_register = not dp_operation
               val (D,Vd) = EncodeVFPReg(d,single_register)
               val (N,Vn) = EncodeVFPReg(n,single_register)
               val (M,Vm) = EncodeVFPReg(m,single_register)
             in
               ARM(BitsN.concat
                     [c,BitsN.B(0x1C,5),D,BitsN.B(0x3,2),Vn,Vd,
                      BitsN.B(0x5,3),BitsN.fromBit dp_operation,N,
                      BitsN.B(0x1,1),M,BitsN.B(0x0,1),Vm])
             end
      else BadCode("VSUB"))
   | vmul(dp_operation,(d,(n,m))) =>
     (if e = Enc_ARM
        then let
               val single_register = not dp_operation
               val (D,Vd) = EncodeVFPReg(d,single_register)
               val (N,Vn) = EncodeVFPReg(n,single_register)
               val (M,Vm) = EncodeVFPReg(m,single_register)
             in
               ARM(BitsN.concat
                     [c,BitsN.B(0x1C,5),D,BitsN.B(0x2,2),Vn,Vd,
                      BitsN.B(0x5,3),BitsN.fromBit dp_operation,N,
                      BitsN.B(0x0,1),M,BitsN.B(0x0,1),Vm])
             end
      else BadCode("VMUL"))
   | vdiv(dp_operation,(d,(n,m))) =>
     (if e = Enc_ARM
        then let
               val single_register = not dp_operation
               val (D,Vd) = EncodeVFPReg(d,single_register)
               val (N,Vn) = EncodeVFPReg(n,single_register)
               val (M,Vm) = EncodeVFPReg(m,single_register)
             in
               ARM(BitsN.concat
                     [c,BitsN.B(0x1D,5),D,BitsN.B(0x0,2),Vn,Vd,
                      BitsN.B(0x5,3),BitsN.fromBit dp_operation,N,
                      BitsN.B(0x0,1),M,BitsN.B(0x0,1),Vm])
             end
      else BadCode("VDIV"))
   | vneg_mul(dp_operation,(typ,(d,(n,m)))) =>
     (if e = Enc_ARM
        then let
               val single_register = not dp_operation
               val (D,Vd) = EncodeVFPReg(d,single_register)
               val (N,Vn) = EncodeVFPReg(n,single_register)
               val (M,Vm) = EncodeVFPReg(m,single_register)
               val (op1,op2) =
                 case typ of
                    VFPNegMul_VNMUL => (BitsN.B(0x2,2),BitsN.B(0x1,1))
                  | VFPNegMul_VNMLA => (BitsN.B(0x1,2),BitsN.B(0x1,1))
                  | VFPNegMul_VNMLS => (BitsN.B(0x1,2),BitsN.B(0x0,1))
             in
               ARM(BitsN.concat
                     [c,BitsN.B(0x1C,5),D,op1,Vn,Vd,BitsN.B(0x5,3),
                      BitsN.fromBit dp_operation,N,op2,M,BitsN.B(0x0,1),Vm])
             end
      else BadCode("VNMUL"))
   | vmla_vmls(dp_operation,(add,(d,(n,m)))) =>
     (if e = Enc_ARM
        then let
               val single_register = not dp_operation
               val (D,Vd) = EncodeVFPReg(d,single_register)
               val (N,Vn) = EncodeVFPReg(n,single_register)
               val (M,Vm) = EncodeVFPReg(m,single_register)
             in
               ARM(BitsN.concat
                     [c,BitsN.B(0x1C,5),D,BitsN.B(0x0,2),Vn,Vd,
                      BitsN.B(0x5,3),BitsN.fromBit dp_operation,N,
                      BitsN.fromBit(not add),M,BitsN.B(0x0,1),Vm])
             end
      else BadCode("VMLA"))
   | vfma_vfms(dp_operation,(add,(d,(n,m)))) =>
     (if e = Enc_ARM
        then let
               val single_register = not dp_operation
               val (D,Vd) = EncodeVFPReg(d,single_register)
               val (N,Vn) = EncodeVFPReg(n,single_register)
               val (M,Vm) = EncodeVFPReg(m,single_register)
             in
               ARM(BitsN.concat
                     [c,BitsN.B(0x1D,5),D,BitsN.B(0x2,2),Vn,Vd,
                      BitsN.B(0x5,3),BitsN.fromBit dp_operation,N,
                      BitsN.fromBit(not add),M,BitsN.B(0x0,1),Vm])
             end
      else BadCode("VFMA"))
   | vfnma_vfnms(dp_operation,(add,(d,(n,m)))) =>
     (if e = Enc_ARM
        then let
               val single_register = not dp_operation
               val (D,Vd) = EncodeVFPReg(d,single_register)
               val (N,Vn) = EncodeVFPReg(n,single_register)
               val (M,Vm) = EncodeVFPReg(m,single_register)
             in
               ARM(BitsN.concat
                     [c,BitsN.B(0x1D,5),D,BitsN.B(0x1,2),Vn,Vd,
                      BitsN.B(0x5,3),BitsN.fromBit dp_operation,N,
                      BitsN.fromBit(not add),M,BitsN.B(0x0,1),Vm])
             end
      else BadCode("VFNMA"))
   | vldr(single_register,(add,(d,(n,imm32)))) =>
     (if e = Enc_ARM
        then if (not((BitsN.bits(1,0) imm32) = (BitsN.B(0x0,2)))) orelse
                (not((BitsN.bits(31,10) imm32) = (BitsN.B(0x0,22))))
               then BadCode("VLDR: bad immediate")
             else let
                    val imm8 = BitsN.bits(9,2) imm32
                    val (D,Vd) = EncodeVFPReg(d,single_register)
                  in
                    ARM(BitsN.concat
                          [c,BitsN.B(0xD,4),BitsN.fromBit add,D,
                           BitsN.B(0x1,2),n,Vd,BitsN.B(0x5,3),
                           BitsN.fromBit(not single_register),imm8])
                  end
      else BadCode("VLDR"))
   | vstr(single_register,(add,(d,(n,imm32)))) =>
     (if e = Enc_ARM
        then if (not((BitsN.bits(1,0) imm32) = (BitsN.B(0x0,2)))) orelse
                (not((BitsN.bits(31,10) imm32) = (BitsN.B(0x0,22))))
               then BadCode("VSTR: bad immediate")
             else let
                    val imm8 = BitsN.bits(9,2) imm32
                    val (D,Vd) = EncodeVFPReg(d,single_register)
                  in
                    ARM(BitsN.concat
                          [c,BitsN.B(0xD,4),BitsN.fromBit add,D,
                           BitsN.B(0x0,2),n,Vd,BitsN.B(0x5,3),
                           BitsN.fromBit(not single_register),imm8])
                  end
      else BadCode("VSTR"))
   | vldm(single_regs,(add,(wback,(d,(n,imm8))))) =>
     (if e = Enc_ARM
        then let
               val (D,Vd) = EncodeVFPReg(d,single_regs)
             in
               ARM(BitsN.concat
                     [c,BitsN.B(0x6,3),
                      if add then BitsN.B(0x1,2) else BitsN.B(0x2,2),D,
                      BitsN.fromBit wback,BitsN.B(0x1,1),n,Vd,
                      BitsN.B(0x5,3),BitsN.fromBit(not single_regs),imm8])
             end
      else BadCode("VLDM"))
   | vstm(single_regs,(add,(wback,(d,(n,imm8))))) =>
     (if e = Enc_ARM
        then let
               val (D,Vd) = EncodeVFPReg(d,single_regs)
             in
               ARM(BitsN.concat
                     [c,BitsN.B(0x6,3),
                      if add then BitsN.B(0x1,2) else BitsN.B(0x2,2),D,
                      BitsN.fromBit wback,BitsN.B(0x0,1),n,Vd,
                      BitsN.B(0x5,3),BitsN.fromBit(not single_regs),imm8])
             end
      else BadCode("VSTM"));

fun e_data (c,(ast,e)) =
  case ast of
     CountLeadingZeroes(Rd,Rm) =>
       (if e = Enc_ARM
          then ARM(BitsN.concat[c,BitsN.B(0x16F,12),Rd,BitsN.B(0xF1,8),Rm])
        else if not(e = Enc_Narrow)
          then Thumb2
                 (BitsN.@@(BitsN.B(0xFAB,12),Rm),
                  BitsN.concat[BitsN.B(0xF,4),Rd,BitsN.B(0x8,4),Rm])
        else BadCode("CLZ"))
   | MoveHalfword(high,(Rd,imm16)) =>
     let
       val H = BitsN.fromBit high
     in
       if e = Enc_ARM
         then let
                val imm4 = BitsN.bits(15,12) imm16
                val imm12 = BitsN.bits(11,0) imm16
              in
                ARM(BitsN.concat
                      [c,BitsN.B(0x6,5),H,BitsN.B(0x0,2),imm4,Rd,imm12])
              end
       else if not(e = Enc_Narrow)
         then let
                val imm4 = BitsN.bits(15,12) imm16
                val i = BitsN.bits(11,11) imm16
                val imm3 = BitsN.bits(10,8) imm16
                val imm8 = BitsN.bits(7,0) imm16
              in
                Thumb2
                  (BitsN.concat
                     [BitsN.B(0x1E,5),i,BitsN.B(0x2,2),H,BitsN.B(0x4,3),
                      imm4],BitsN.concat[BitsN.B(0x0,1),imm3,Rd,imm8])
              end
       else BadCode("MOVT/MOVW")
     end
   | Move(setflags,(negate,(d,imm12))) =>
     (if e = Enc_ARM
        then let
               val Rd = d
               val S = BitsN.fromBit setflags
               val N = BitsN.fromBit negate
             in
               ARM(BitsN.concat
                     [c,BitsN.B(0x7,5),N,BitsN.B(0x1,1),S,BitsN.B(0x0,4),
                      Rd,imm12])
             end
      else if ((BitsN.bits(11,8) imm12) = (BitsN.B(0x0,4))) andalso
         (not(negate orelse
              ((setflags = (not(c = (BitsN.B(0xE,4))))) orelse
               ((BitsN.bit(d,3)) orelse (e = Enc_Wide)))))
        then let
               val Rd = BitsN.bits(2,0) d
               val imm8 = BitsN.bits(7,0) imm12
             in
               Thumb(BitsN.concat[BitsN.B(0x4,5),Rd,imm8])
             end
      else if not(e = Enc_Narrow)
        then let
               val Rd = d
               val S = BitsN.fromBit setflags
               val i = BitsN.bits(11,11) imm12
               val imm3 = BitsN.bits(10,8) imm12
               val imm8 = BitsN.bits(7,0) imm12
               val N = BitsN.fromBit negate
             in
               Thumb2
                 (BitsN.concat
                    [BitsN.B(0x1E,5),i,BitsN.B(0x1,4),N,S,BitsN.B(0xF,4)],
                  BitsN.concat[BitsN.B(0x0,1),imm3,Rd,imm8])
             end
      else BadCode("MOV"))
   | AddSub(sub,(Rd,(Rn,imm12))) =>
     (if Set.mem(e,[Enc_Thumb,Enc_Wide])
        then let
               val i = BitsN.bits(11,11) imm12
               val imm3 = BitsN.bits(10,8) imm12
               val imm8 = BitsN.bits(7,0) imm12
               val S = BitsN.fromBit sub
             in
               Thumb2
                 (BitsN.concat
                    [BitsN.B(0x1E,5),i,BitsN.B(0x1,1),BitsN.B(0x0,1),S,
                     BitsN.B(0x0,1),S,BitsN.B(0x0,1),Rn],
                  BitsN.concat[BitsN.B(0x0,1),imm3,Rd,imm8])
             end
      else BadCode("ADDW/SUBW"))
   | TestCompareImmediate(op',(Rn,imm12)) =>
     (if e = Enc_ARM
        then ARM(BitsN.concat
                   [c,BitsN.B(0x6,5),op',BitsN.B(0x1,1),Rn,BitsN.B(0x0,4),
                    imm12])
      else if (op' = (BitsN.B(0x2,2))) andalso
         (((BitsN.bits(11,8) imm12) = (BitsN.B(0x0,4))) andalso
          (not((BitsN.bit(Rn,3)) orelse (e = Enc_Wide))))
        then let
               val n = BitsN.bits(2,0) Rn
               val imm8 = BitsN.bits(7,0) imm12
             in
               Thumb(BitsN.concat[BitsN.B(0x5,5),n,imm8])
             end
      else if not(e = Enc_Narrow)
        then let
               val i = BitsN.bits(11,11) imm12
               val imm3 = BitsN.bits(10,8) imm12
               val imm8 = BitsN.bits(7,0) imm12
               val opc =
                 case op' of
                    BitsN.B(0x0,_) => BitsN.B(0x0,4)
                  | BitsN.B(0x1,_) => BitsN.B(0x4,4)
                  | BitsN.B(0x2,_) => BitsN.B(0xD,4)
                  | BitsN.B(0x3,_) => BitsN.B(0x8,4)
                  | _ => raise General.Bind
             in
               Thumb2
                 (BitsN.concat
                    [BitsN.B(0x1E,5),i,BitsN.B(0x0,1),opc,BitsN.B(0x1,1),
                     Rn],
                  BitsN.concat[BitsN.B(0x0,1),imm3,BitsN.B(0xF,4),imm8])
             end
      else BadCode("TestCompareImmediate"))
   | ArithLogicImmediate(opc,(setflags,(d,(n,imm12)))) =>
     (if e = Enc_ARM
        then let
               val Rd = d
               val Rn = n
               val S = BitsN.fromBit setflags
             in
               ARM(BitsN.concat[c,BitsN.B(0x1,3),opc,S,Rn,Rd,imm12])
             end
      else if (Set.mem(opc,[BitsN.B(0x4,4),BitsN.B(0x2,4)])) andalso
         (((BitsN.bits(11,3) imm12) = (BitsN.B(0x0,9))) andalso
          (not((setflags = (not(c = (BitsN.B(0xE,4))))) orelse
               ((BitsN.bit(d,3)) orelse
                ((BitsN.bit(n,3)) orelse (e = Enc_Wide))))))
        then let
               val Rd = BitsN.bits(2,0) d
               val Rn = BitsN.bits(2,0) n
               val imm3 = BitsN.bits(2,0) imm12
               val S = BitsN.bits(1,1) opc
             in
               Thumb(BitsN.concat[BitsN.B(0x7,6),S,imm3,Rn,Rd])
             end
      else if (Set.mem(opc,[BitsN.B(0x4,4),BitsN.B(0x2,4)])) andalso
         ((d = n) andalso
          (((BitsN.bits(11,8) imm12) = (BitsN.B(0x0,4))) andalso
           (not((setflags = (not(c = (BitsN.B(0xE,4))))) orelse
                ((BitsN.bit(d,3)) orelse (e = Enc_Wide))))))
        then let
               val Rdn = BitsN.bits(2,0) d
               val imm8 = BitsN.bits(7,0) imm12
               val S = BitsN.bits(1,1) opc
             in
               Thumb(BitsN.concat[BitsN.B(0x3,4),S,Rdn,imm8])
             end
      else if (opc = (BitsN.B(0x3,4))) andalso
         ((imm12 = (BitsN.B(0x0,12))) andalso
          (not((setflags = (not(c = (BitsN.B(0xE,4))))) orelse
               ((BitsN.bit(d,3)) orelse
                ((BitsN.bit(n,3)) orelse (e = Enc_Wide))))))
        then let
               val Rd = BitsN.bits(2,0) d
               val Rn = BitsN.bits(2,0) n
             in
               Thumb(BitsN.concat[BitsN.B(0x109,10),Rn,Rd])
             end
      else if (opc = (BitsN.B(0x4,4))) andalso
         ((not setflags) andalso
          ((Set.mem(n,[BitsN.B(0xD,4),BitsN.B(0xF,4)])) andalso
           (((BitsN.bits(11,8) imm12) = (BitsN.B(0xF,4))) andalso
            (not((BitsN.bit(d,3)) orelse (e = Enc_Wide))))))
        then let
               val Rd = BitsN.bits(2,0) d
               val imm8 = BitsN.bits(7,0) imm12
               val S = BitsN.fromBit(n = (BitsN.B(0xD,4)))
             in
               Thumb(BitsN.concat[BitsN.B(0xA,4),S,Rd,imm8])
             end
      else if (Set.mem(opc,[BitsN.B(0x4,4),BitsN.B(0x2,4)])) andalso
         ((d = (BitsN.B(0xD,4))) andalso
          ((n = (BitsN.B(0xD,4))) andalso
           (((BitsN.bits(11,7) imm12) = (BitsN.B(0x1E,5))) andalso
            (not(setflags orelse (e = Enc_Wide))))))
        then let
               val imm7 = BitsN.bits(6,0) imm12
               val S = BitsN.bits(1,1) opc
             in
               Thumb(BitsN.concat[BitsN.B(0xB0,8),S,imm7])
             end
      else if (opc = (BitsN.B(0x2,4))) andalso
         (setflags andalso
          ((d = (BitsN.B(0xF,4))) andalso
           ((n = (BitsN.B(0xE,4))) andalso
            (((BitsN.bits(11,8) imm12) = (BitsN.B(0x0,4))) andalso
             (not(e = Enc_Narrow))))))
        then let
               val imm8 = BitsN.bits(7,0) imm12
             in
               Thumb2(BitsN.B(0xF3DF,16),BitsN.@@(BitsN.B(0x8F,8),imm8))
             end
      else if not(e = Enc_Narrow)
        then let
               val Rd = d
               val Rn = n
               val i = BitsN.bits(11,11) imm12
               val imm3 = BitsN.bits(10,8) imm12
               val imm8 = BitsN.bits(7,0) imm12
               val S = BitsN.fromBit setflags
               val op' =
                 case opc of
                    BitsN.B(0x0,_) => BitsN.B(0x0,4)
                  | BitsN.B(0xE,_) => BitsN.B(0x1,4)
                  | BitsN.B(0xC,_) => BitsN.B(0x2,4)
                  | BitsN.B(0xF,_) => BitsN.B(0x3,4)
                  | BitsN.B(0x1,_) => BitsN.B(0x4,4)
                  | BitsN.B(0x4,_) => BitsN.B(0x8,4)
                  | BitsN.B(0x5,_) => BitsN.B(0xA,4)
                  | BitsN.B(0x6,_) => BitsN.B(0xB,4)
                  | BitsN.B(0x2,_) => BitsN.B(0xD,4)
                  | BitsN.B(0x3,_) => BitsN.B(0xE,4)
                  | _ => BitsN.B(0xF,4)
             in
               if op' = (BitsN.B(0xF,4))
                 then BadCode
                        (("ArithLogicImmediate: bad opc ")
                           ^
                           (BitsN.toHexString opc))
               else Thumb2
                      (BitsN.concat
                         [BitsN.B(0x1E,5),i,BitsN.B(0x0,1),op',S,Rn],
                       BitsN.concat[BitsN.B(0x0,1),imm3,Rd,imm8])
             end
      else BadCode("ArithLogicImmediate"))
   | Register(opc,(setflags,(d,(n,(m,(shift_t,shift_n)))))) =>
     (if e = Enc_ARM
        then let
               val S = BitsN.fromBit setflags
               val Rd = d
               val Rn = n
               val Rm = m
               val (typ,imm5) = EncodeImmShift(shift_t,shift_n)
             in
               ARM(BitsN.concat
                     [c,BitsN.B(0x0,3),opc,S,Rn,Rd,imm5,typ,
                      BitsN.B(0x0,1),Rm])
             end
      else if (Set.mem(opc,[BitsN.B(0x2,4),BitsN.B(0x4,4)])) andalso
         ((shift_t = SRType_LSL) andalso
          ((shift_n = 0) andalso
           (not((setflags = (not(c = (BitsN.B(0xE,4))))) orelse
                ((BitsN.bit(d,3)) orelse
                 ((BitsN.bit(n,3)) orelse
                  ((BitsN.bit(m,3)) orelse (e = Enc_Wide))))))))
        then let
               val Rn = BitsN.bits(2,0) n
               val Rd = BitsN.bits(2,0) d
               val Rm = BitsN.bits(2,0) m
               val S = BitsN.fromBit(opc = (BitsN.B(0x2,4)))
             in
               Thumb(BitsN.concat[BitsN.B(0x6,6),S,Rm,Rn,Rd])
             end
      else if (Set.mem
            (opc,
             [BitsN.B(0x0,4),BitsN.B(0x1,4),BitsN.B(0x5,4),BitsN.B(0x6,4),
              BitsN.B(0xC,4),BitsN.B(0xE,4)])) andalso
         ((d = n) andalso
          ((shift_t = SRType_LSL) andalso
           ((shift_n = 0) andalso
            (not((setflags = (not(c = (BitsN.B(0xE,4))))) orelse
                 ((BitsN.bit(d,3)) orelse
                  ((BitsN.bit(m,3)) orelse (e = Enc_Wide))))))))
        then let
               val Rdn = BitsN.bits(2,0) d
               val Rm = BitsN.bits(2,0) m
             in
               Thumb(BitsN.concat[BitsN.B(0x10,6),opc,Rm,Rdn])
             end
      else if (opc = (BitsN.B(0x4,4))) andalso
         ((d = n) andalso
          ((not(setflags orelse (e = Enc_Wide))) andalso
           ((shift_t = SRType_LSL) andalso (shift_n = 0))))
        then let
               val DN = BitsN.bits(3,3) d
               val Rdn = BitsN.bits(2,0) d
               val Rm = m
             in
               Thumb(BitsN.concat[BitsN.B(0x44,8),DN,Rm,Rdn])
             end
      else if not(e = Enc_Narrow)
        then let
               val S = BitsN.fromBit setflags
               val Rd = d
               val Rn = n
               val Rm = m
               val (typ,imm5) = EncodeImmShift(shift_t,shift_n)
               val imm3 = BitsN.bits(4,2) imm5
               val imm2 = BitsN.bits(1,0) imm5
               val op' =
                 case opc of
                    BitsN.B(0x0,_) => BitsN.B(0x0,4)
                  | BitsN.B(0xE,_) => BitsN.B(0x1,4)
                  | BitsN.B(0xC,_) => BitsN.B(0x2,4)
                  | BitsN.B(0xF,_) => BitsN.B(0x3,4)
                  | BitsN.B(0x1,_) => BitsN.B(0x4,4)
                  | BitsN.B(0x4,_) => BitsN.B(0x8,4)
                  | BitsN.B(0x5,_) => BitsN.B(0xA,4)
                  | BitsN.B(0x6,_) => BitsN.B(0xB,4)
                  | BitsN.B(0x2,_) => BitsN.B(0xD,4)
                  | BitsN.B(0x3,_) => BitsN.B(0xE,4)
                  | _ => BitsN.B(0xF,4)
             in
               if op' = (BitsN.B(0xF,4))
                 then BadCode
                        (("Register: bad opc ") ^ (BitsN.toHexString opc))
               else Thumb2
                      (BitsN.concat[BitsN.B(0x75,7),op',S,Rn],
                       BitsN.concat[BitsN.B(0x0,1),imm3,Rd,imm2,typ,Rm])
             end
      else BadCode("Register"))
   | TestCompareRegister(opc,(n,(m,(shift_t,shift_n)))) =>
     (if e = Enc_ARM
        then let
               val Rn = n
               val Rm = m
               val (typ,imm5) = EncodeImmShift(shift_t,shift_n)
             in
               ARM(BitsN.concat
                     [c,BitsN.B(0x2,5),opc,BitsN.B(0x1,1),Rn,
                      BitsN.B(0x0,4),imm5,typ,BitsN.B(0x0,1),Rm])
             end
      else if (shift_t = SRType_LSL) andalso
         ((shift_n = 0) andalso
          (not((opc = (BitsN.B(0x1,2))) orelse
               ((BitsN.bit(n,3)) orelse
                ((BitsN.bit(m,3)) orelse (e = Enc_Wide))))))
        then let
               val Rn = BitsN.bits(2,0) n
               val Rm = BitsN.bits(2,0) m
             in
               Thumb(BitsN.concat[BitsN.B(0x42,8),opc,Rm,Rn])
             end
      else if (not(e = Enc_Wide)) andalso
         ((shift_t = SRType_LSL) andalso
          ((shift_n = 0) andalso (opc = (BitsN.B(0x2,2)))))
        then let
               val N = BitsN.bits(3,3) n
               val Rn = BitsN.bits(2,0) n
               val Rm = m
             in
               Thumb(BitsN.concat[BitsN.B(0x45,8),N,Rm,Rn])
             end
      else if not(e = Enc_Narrow)
        then let
               val Rn = n
               val Rm = m
               val (typ,imm5) = EncodeImmShift(shift_t,shift_n)
               val imm3 = BitsN.bits(4,2) imm5
               val imm2 = BitsN.bits(1,0) imm5
               val op' =
                 case opc of
                    BitsN.B(0x0,_) => BitsN.B(0x0,4)
                  | BitsN.B(0x1,_) => BitsN.B(0x4,4)
                  | BitsN.B(0x2,_) => BitsN.B(0xD,4)
                  | BitsN.B(0x3,_) => BitsN.B(0x8,4)
                  | _ => raise General.Bind
             in
               Thumb2
                 (BitsN.concat[BitsN.B(0x75,7),op',BitsN.B(0x1,1),Rn],
                  BitsN.concat
                    [BitsN.B(0x0,1),imm3,BitsN.B(0xF,4),imm2,typ,Rm])
             end
      else BadCode("TestCompareRegister"))
   | ShiftImmediate(negate,(setflags,(d,(m,(shift_t,shift_n))))) =>
     (if e = Enc_ARM
        then let
               val S = BitsN.fromBit setflags
               val Rd = d
               val Rm = m
               val N = BitsN.fromBit negate
               val (typ,imm5) = EncodeImmShift(shift_t,shift_n)
             in
               ARM(BitsN.concat
                     [c,BitsN.B(0x3,5),N,BitsN.B(0x1,1),S,BitsN.B(0x0,4),
                      Rd,imm5,typ,BitsN.B(0x0,1),Rm])
             end
      else if negate andalso
         ((shift_t = SRType_LSL) andalso
          ((shift_n = 0) andalso
           (not((setflags = (not(c = (BitsN.B(0xE,4))))) orelse
                ((BitsN.bit(m,3)) orelse
                 ((BitsN.bit(d,3)) orelse (e = Enc_Wide)))))))
        then let
               val Rm = BitsN.bits(2,0) m
               val Rd = BitsN.bits(2,0) d
             in
               Thumb(BitsN.concat[BitsN.B(0x10F,10),Rm,Rd])
             end
      else if (Set.mem(shift_t,[SRType_LSL,SRType_LSR,SRType_ASR])) andalso
         (not(negate orelse
              ((setflags = (not(c = (BitsN.B(0xE,4))))) orelse
               ((BitsN.bit(m,3)) orelse
                ((BitsN.bit(d,3)) orelse (e = Enc_Wide))))))
        then let
               val Rm = BitsN.bits(2,0) m
               val Rd = BitsN.bits(2,0) d
               val (typ,imm5) = EncodeImmShift(shift_t,shift_n)
             in
               Thumb(BitsN.concat[BitsN.B(0x0,3),typ,imm5,Rm,Rd])
             end
      else if (shift_t = SRType_LSL) andalso
         ((shift_n = 0) andalso
          (not(negate orelse
               (setflags orelse
                ((e = Enc_Wide) orelse
                 ((d = (BitsN.B(0xF,4))) andalso
                  (not(c = (BitsN.B(0xE,4))))))))))
        then let
               val D = BitsN.bits(3,3) d
               val Rd = BitsN.bits(2,0) d
               val Rm = m
             in
               Thumb(BitsN.concat[BitsN.B(0x46,8),D,Rm,Rd])
             end
      else if not(e = Enc_Narrow)
        then let
               val S = BitsN.fromBit setflags
               val Rm = m
               val Rd = d
               val (typ,imm5) = EncodeImmShift(shift_t,shift_n)
               val imm3 = BitsN.bits(4,2) imm5
               val imm2 = BitsN.bits(1,0) imm5
               val N = BitsN.fromBit negate
             in
               Thumb2
                 (BitsN.concat[BitsN.B(0x3A9,10),N,S,BitsN.B(0xF,4)],
                  BitsN.concat[BitsN.B(0x0,1),imm3,Rd,imm2,typ,Rm])
             end
      else BadCode("ShiftImmediate"))
   | RegisterShiftedRegister(_,(_,(_,(_,(_,(SRType_RRX,_)))))) =>
     BadCode("RegisterShiftedRegister: rrx")
   | RegisterShiftedRegister(opc,(setflags,(d,(n,(m,(shift_t,s)))))) =>
     (if e = Enc_ARM
        then let
               val S = BitsN.fromBit setflags
               val Rn = n
               val Rd = d
               val Rm = m
               val Rs = s
               val typ = EncodeRegShift shift_t
             in
               ARM(BitsN.concat
                     [c,BitsN.B(0x0,3),opc,S,Rn,Rd,Rs,BitsN.B(0x0,1),typ,
                      BitsN.B(0x1,1),Rm])
             end
      else BadCode("RegisterShiftedRegister"))
   | ShiftRegister(_,(_,(_,(_,(SRType_RRX,_))))) =>
     BadCode("ShiftRegister: rrx")
   | ShiftRegister(negate,(setflags,(d,(n,(shift_t,m))))) =>
     (if e = Enc_ARM
        then let
               val S = BitsN.fromBit setflags
               val N = BitsN.fromBit negate
               val Rd = d
               val Rm = n
               val Rs = m
               val typ = EncodeRegShift shift_t
             in
               ARM(BitsN.concat
                     [c,BitsN.B(0x3,5),N,BitsN.B(0x1,1),S,BitsN.B(0x0,4),
                      Rd,Rs,BitsN.B(0x0,1),typ,BitsN.B(0x1,1),Rm])
             end
      else if (d = n) andalso
         (not(negate orelse
              ((BitsN.bit(d,3)) orelse
               ((BitsN.bit(m,3)) orelse
                ((setflags = (not(c = (BitsN.B(0xE,4))))) orelse
                 (e = Enc_Wide))))))
        then let
               val Rm = BitsN.bits(2,0) m
               val Rdn = BitsN.bits(2,0) d
               val opc =
                 case shift_t of
                    SRType_LSL => BitsN.B(0x2,3)
                  | SRType_LSR => BitsN.B(0x3,3)
                  | SRType_ASR => BitsN.B(0x4,3)
                  | SRType_ROR => BitsN.B(0x7,3)
                  | _ => BitsN.B(0x0,3)
             in
               Thumb(BitsN.concat[BitsN.B(0x20,7),opc,Rm,Rdn])
             end
      else if not(negate orelse (e = Enc_Narrow))
        then let
               val S = BitsN.fromBit setflags
               val Rn = n
               val Rd = d
               val Rm = m
               val typ = EncodeRegShift shift_t
             in
               Thumb2
                 (BitsN.concat[BitsN.B(0x1F4,9),typ,S,Rn],
                  BitsN.concat[BitsN.B(0xF,4),Rd,BitsN.B(0x0,4),Rm])
             end
      else BadCode("ShiftRegister"));

fun e_media (c,(ast,e)) =
  case ast of
     SaturatingAddSubtract(opc,(Rd,(Rm,Rn))) =>
       (if e = Enc_ARM
          then ARM(BitsN.concat
                     [c,BitsN.B(0x2,5),opc,BitsN.B(0x0,1),Rn,Rd,
                      BitsN.B(0x5,8),Rm])
        else if not(e = Enc_Narrow)
          then let
                 val op2 = BitsN.reverse opc
               in
                 Thumb2
                   (BitsN.@@(BitsN.B(0xFA8,12),Rn),
                    BitsN.concat[BitsN.B(0xF,4),Rd,BitsN.B(0x2,2),op2,Rm])
               end
        else BadCode("SaturatingAddSubtract"))
   | PackHalfword(shift_t,(shift_n,(tbform,(Rd,(Rn,Rm))))) =>
     let
       val (typ,imm5) = EncodeImmShift(shift_t,shift_n)
       val tb = BitsN.bits(1,1) typ
     in
       if e = Enc_ARM
         then ARM(BitsN.concat
                    [c,BitsN.B(0x68,8),Rn,Rd,imm5,tb,BitsN.B(0x1,2),Rm])
       else if not(e = Enc_Narrow)
         then let
                val imm3 = BitsN.bits(4,2) imm5
                val imm2 = BitsN.bits(1,0) imm5
              in
                Thumb2
                  (BitsN.@@(BitsN.B(0xEAC,12),Rn),
                   BitsN.concat
                     [BitsN.B(0x0,1),imm3,Rd,imm2,tb,BitsN.B(0x0,1),Rm])
              end
       else BadCode("PackHalfword")
     end
   | Saturate(shift_t,(shift_n,(saturate_to,(unsigned,(Rd,Rn))))) =>
     let
       val (typ,imm5) = EncodeImmShift(shift_t,shift_n)
       val sh = BitsN.bits(1,1) typ
       val sat_imm =
         if unsigned
           then BitsN.fromNat(saturate_to,5)
         else BitsN.fromNat(Nat.-(saturate_to,1),5)
       val U = BitsN.fromBit unsigned
     in
       if e = Enc_ARM
         then ARM(BitsN.concat
                    [c,BitsN.B(0xD,5),U,BitsN.B(0x1,1),sat_imm,Rd,imm5,sh,
                     BitsN.B(0x1,2),Rn])
       else if not(e = Enc_Narrow)
         then let
                val imm3 = BitsN.bits(4,2) imm5
                val imm2 = BitsN.bits(1,0) imm5
              in
                Thumb2
                  (BitsN.concat
                     [BitsN.B(0xF3,8),U,BitsN.B(0x0,1),sh,BitsN.B(0x0,1),
                      Rn],
                   BitsN.concat
                     [BitsN.B(0x0,1),imm3,Rd,imm2,BitsN.B(0x0,1),sat_imm])
              end
       else BadCode("Saturate")
     end
   | Saturate16(saturate_to,(unsigned,(Rd,Rn))) =>
     let
       val sat_imm =
         if unsigned
           then BitsN.fromNat(saturate_to,4)
         else BitsN.fromNat(Nat.-(saturate_to,1),4)
       val U = BitsN.fromBit unsigned
     in
       if e = Enc_ARM
         then ARM(BitsN.concat
                    [c,BitsN.B(0xD,5),U,BitsN.B(0x2,2),sat_imm,Rd,
                     BitsN.B(0xF3,8),Rn])
       else if not(e = Enc_Narrow)
         then Thumb2
                (BitsN.concat[BitsN.B(0xF3,8),U,BitsN.B(0x2,3),Rn],
                 BitsN.concat[BitsN.B(0x0,4),Rd,BitsN.B(0x0,4),sat_imm])
       else BadCode("Saturate16")
     end
   | ExtendByte(unsigned,(d,(Rn,(m,rotation)))) =>
     let
       val rot = BitsN.fromNat(rotation,5)
       val rotate = BitsN.bits(4,3) rot
       val U = BitsN.fromBit unsigned
     in
       if e = Enc_ARM
         then let
                val Rd = d
                val Rm = m
              in
                ARM(BitsN.concat
                      [c,BitsN.B(0xD,5),U,BitsN.B(0x2,2),Rn,Rd,rotate,
                       BitsN.B(0x7,6),Rm])
              end
       else if (Rn = (BitsN.B(0xF,4))) andalso
          ((rotation = 0) andalso
           (not((BitsN.bit(d,3)) orelse
                ((BitsN.bit(m,3)) orelse (e = Enc_Wide)))))
         then let
                val Rd = BitsN.bits(2,0) d
                val Rm = BitsN.bits(2,0) m
              in
                Thumb
                  (BitsN.concat[BitsN.B(0xB2,8),U,BitsN.B(0x1,1),Rm,Rd])
              end
       else if not(e = Enc_Narrow)
         then let
                val Rd = d
                val Rm = m
              in
                Thumb2
                  (BitsN.concat[BitsN.B(0x7D2,11),U,Rn],
                   BitsN.concat
                     [BitsN.B(0xF,4),Rd,BitsN.B(0x2,2),rotate,Rm])
              end
       else BadCode("ExtendByte")
     end
   | ExtendHalfword(unsigned,(d,(Rn,(m,rotation)))) =>
     let
       val rot = BitsN.fromNat(rotation,5)
       val rotate = BitsN.bits(4,3) rot
       val U = BitsN.fromBit unsigned
     in
       if e = Enc_ARM
         then let
                val Rd = d
                val Rm = m
              in
                ARM(BitsN.concat
                      [c,BitsN.B(0xD,5),U,BitsN.B(0x3,2),Rn,Rd,rotate,
                       BitsN.B(0x7,6),Rm])
              end
       else if (Rn = (BitsN.B(0xF,4))) andalso
          ((rotation = 0) andalso
           (not((BitsN.bit(d,3)) orelse
                ((BitsN.bit(m,3)) orelse (e = Enc_Wide)))))
         then let
                val Rd = BitsN.bits(2,0) d
                val Rm = BitsN.bits(2,0) m
              in
                Thumb
                  (BitsN.concat[BitsN.B(0xB2,8),U,BitsN.B(0x0,1),Rm,Rd])
              end
       else if not(e = Enc_Narrow)
         then let
                val Rd = d
                val Rm = m
              in
                Thumb2
                  (BitsN.concat[BitsN.B(0x7D0,11),U,Rn],
                   BitsN.concat
                     [BitsN.B(0xF,4),Rd,BitsN.B(0x2,2),rotate,Rm])
              end
       else BadCode("ExtendHalfword")
     end
   | ExtendByte16(unsigned,(Rd,(Rn,(Rm,rotation)))) =>
     let
       val rot = BitsN.fromNat(rotation,5)
       val rotate = BitsN.bits(4,3) rot
       val U = BitsN.fromBit unsigned
     in
       if e = Enc_ARM
         then ARM(BitsN.concat
                    [c,BitsN.B(0xD,5),U,BitsN.B(0x0,2),Rn,Rd,rotate,
                     BitsN.B(0x7,6),Rm])
       else if not(e = Enc_Narrow)
         then Thumb2
                (BitsN.concat[BitsN.B(0x7D1,11),U,Rn],
                 BitsN.concat[BitsN.B(0xF,4),Rd,BitsN.B(0x2,2),rotate,Rm])
       else BadCode("ExtendByte16")
     end
   | SelectBytes(Rd,(Rn,Rm)) =>
     (if e = Enc_ARM
        then ARM(BitsN.concat[c,BitsN.B(0x68,8),Rn,Rd,BitsN.B(0xFB,8),Rm])
      else if not(e = Enc_Narrow)
        then Thumb2
               (BitsN.@@(BitsN.B(0xFAA,12),Rn),
                BitsN.concat[BitsN.B(0xF,4),Rd,BitsN.B(0x8,4),Rm])
      else BadCode("SelectBytes"))
   | ByteReverse(d,m) =>
     (if e = Enc_ARM
        then let
               val Rd = d
               val Rm = m
             in
               ARM(BitsN.concat[c,BitsN.B(0x6BF,12),Rd,BitsN.B(0xF3,8),Rm])
             end
      else if not((BitsN.bit(d,3)) orelse
             ((BitsN.bit(m,3)) orelse (e = Enc_Wide)))
        then let
               val Rd = BitsN.bits(2,0) d
               val Rm = BitsN.bits(2,0) m
             in
               Thumb(BitsN.concat[BitsN.B(0x2E8,10),Rm,Rd])
             end
      else if not(e = Enc_Narrow)
        then let
               val Rd = d
               val Rm = m
             in
               Thumb2
                 (BitsN.@@(BitsN.B(0xFA9,12),Rm),
                  BitsN.concat[BitsN.B(0xF,4),Rd,BitsN.B(0x8,4),Rm])
             end
      else BadCode("ByteReverse"))
   | ByteReversePackedHalfword(d,m) =>
     (if e = Enc_ARM
        then let
               val Rd = d
               val Rm = m
             in
               ARM(BitsN.concat[c,BitsN.B(0x6BF,12),Rd,BitsN.B(0xFB,8),Rm])
             end
      else if not((BitsN.bit(d,3)) orelse
             ((BitsN.bit(m,3)) orelse (e = Enc_Wide)))
        then let
               val Rd = BitsN.bits(2,0) d
               val Rm = BitsN.bits(2,0) m
             in
               Thumb(BitsN.concat[BitsN.B(0x2E9,10),Rm,Rd])
             end
      else if not(e = Enc_Narrow)
        then let
               val Rd = d
               val Rm = m
             in
               Thumb2
                 (BitsN.@@(BitsN.B(0xFA9,12),Rm),
                  BitsN.concat[BitsN.B(0xF,4),Rd,BitsN.B(0x9,4),Rm])
             end
      else BadCode("ByteReversePackedHalfword"))
   | ByteReverseSignedHalfword(d,m) =>
     (if e = Enc_ARM
        then let
               val Rd = d
               val Rm = m
             in
               ARM(BitsN.concat[c,BitsN.B(0x6FF,12),Rd,BitsN.B(0xFB,8),Rm])
             end
      else if not((BitsN.bit(d,3)) orelse
             ((BitsN.bit(m,3)) orelse (e = Enc_Wide)))
        then let
               val Rd = BitsN.bits(2,0) d
               val Rm = BitsN.bits(2,0) m
             in
               Thumb(BitsN.concat[BitsN.B(0x2EB,10),Rm,Rd])
             end
      else if not(e = Enc_Narrow)
        then let
               val Rd = d
               val Rm = m
             in
               Thumb2
                 (BitsN.@@(BitsN.B(0xFA9,12),Rm),
                  BitsN.concat[BitsN.B(0xF,4),Rd,BitsN.B(0xB,4),Rm])
             end
      else BadCode("ByteReverseSignedHalfword"))
   | ReverseBits(Rd,Rm) =>
     (if e = Enc_ARM
        then ARM(BitsN.concat[c,BitsN.B(0x6FF,12),Rd,BitsN.B(0xF3,8),Rm])
      else if not(e = Enc_Narrow)
        then Thumb2
               (BitsN.@@(BitsN.B(0xFA9,12),Rm),
                BitsN.concat[BitsN.B(0xF,4),Rd,BitsN.B(0xA,4),Rm])
      else BadCode("ReverseBits"))
   | BitFieldExtract(unsigned,(Rd,(Rn,(lsbit,widthminus1)))) =>
     let
       val U = BitsN.fromBit unsigned
       val lsb = BitsN.fromNat(lsbit,5)
       val widthm1 = BitsN.fromNat(widthminus1,5)
     in
       if e = Enc_ARM
         then ARM(BitsN.concat
                    [c,BitsN.B(0xF,5),U,BitsN.B(0x1,1),widthm1,Rd,lsb,
                     BitsN.B(0x5,3),Rn])
       else if not(e = Enc_Narrow)
         then let
                val imm3 = BitsN.bits(4,2) lsb
                val imm2 = BitsN.bits(1,0) lsb
              in
                Thumb2
                  (BitsN.concat[BitsN.B(0xF3,8),U,BitsN.B(0x4,3),Rn],
                   BitsN.concat
                     [BitsN.B(0x0,1),imm3,Rd,imm2,BitsN.B(0x0,1),widthm1])
              end
       else BadCode("BitFieldExtract")
     end
   | BitFieldClearOrInsert(Rd,(Rn,(lsbit,msbit))) =>
     let
       val lsb = BitsN.fromNat(lsbit,5)
       val msb = BitsN.fromNat(msbit,5)
     in
       if e = Enc_ARM
         then ARM(BitsN.concat
                    [c,BitsN.B(0x3E,7),msb,Rd,lsb,BitsN.B(0x1,3),Rn])
       else if not(e = Enc_Narrow)
         then let
                val imm3 = BitsN.bits(4,2) lsb
                val imm2 = BitsN.bits(1,0) lsb
              in
                Thumb2
                  (BitsN.@@(BitsN.B(0xF36,12),Rn),
                   BitsN.concat
                     [BitsN.B(0x0,1),imm3,Rd,imm2,BitsN.B(0x0,1),msb])
              end
       else BadCode("BitFieldClearOrInsert")
     end;

fun e_hint (c,(ast,e)) =
  case ast of
     Breakpoint imm32 =>
       (if e = Enc_ARM
          then let
                 val imm12 = BitsN.bits(15,4) imm32
                 val imm4 = BitsN.bits(3,0) imm32
               in
                 ARM(BitsN.concat
                       [c,BitsN.B(0x12,8),imm12,BitsN.B(0x7,4),imm4])
               end
        else if not(e = Enc_Wide)
          then let
                 val imm8 = BitsN.bits(7,0) imm32
               in
                 Thumb(BitsN.@@(BitsN.B(0xBE,8),imm8))
               end
        else BadCode("Breakpoint"))
   | Debug option =>
     (if e = Enc_ARM
        then ARM(BitsN.concat[c,BitsN.B(0x320F0F,24),option])
      else if not(e = Enc_Narrow)
        then Thumb2(BitsN.B(0xF3AF,16),BitsN.@@(BitsN.B(0x80F,12),option))
      else BadCode("Debug"))
   | DataMemoryBarrier option =>
     (if e = Enc_ARM
        then if c = (BitsN.B(0xE,4))
               then ARM(BitsN.@@(BitsN.B(0xF57FF05,28),option))
             else BadCode("DataMemoryBarrier")
      else if not(e = Enc_Narrow)
        then Thumb2(BitsN.B(0xF3BF,16),BitsN.@@(BitsN.B(0x8F5,12),option))
      else BadCode("DataMemoryBarrier"))
   | DataSynchronizationBarrier option =>
     (if e = Enc_ARM
        then if c = (BitsN.B(0xE,4))
               then ARM(BitsN.@@(BitsN.B(0xF57FF04,28),option))
             else BadCode("DataSynchronizationBarrier")
      else if not(e = Enc_Narrow)
        then Thumb2(BitsN.B(0xF3BF,16),BitsN.@@(BitsN.B(0x8F4,12),option))
      else BadCode("DataSynchronizationBarrier"))
   | InstructionSynchronizationBarrier option =>
     (if e = Enc_ARM
        then if c = (BitsN.B(0xE,4))
               then ARM(BitsN.@@(BitsN.B(0xF57FF06,28),option))
             else BadCode("InstructionSynchronizationBarrier")
      else if not(e = Enc_Narrow)
        then Thumb2(BitsN.B(0xF3BF,16),BitsN.@@(BitsN.B(0x8F6,12),option))
      else BadCode("InstructionSynchronizationBarrier"))
   | SendEvent =>
     if e = Enc_ARM
       then ARM(BitsN.@@(c,BitsN.B(0x320F004,28)))
     else if e = Enc_Wide
       then Thumb2(BitsN.B(0xF3AF,16),BitsN.B(0x8004,16))
     else Thumb(BitsN.B(0xBF40,16))
   | WaitForEvent =>
     if e = Enc_ARM
       then ARM(BitsN.@@(c,BitsN.B(0x320F002,28)))
     else if e = Enc_Wide
       then Thumb2(BitsN.B(0xF3AF,16),BitsN.B(0x8002,16))
     else Thumb(BitsN.B(0xBF20,16))
   | WaitForInterrupt =>
     if e = Enc_ARM
       then ARM(BitsN.@@(c,BitsN.B(0x320F003,28)))
     else if e = Enc_Wide
       then Thumb2(BitsN.B(0xF3AF,16),BitsN.B(0x8003,16))
     else Thumb(BitsN.B(0xBF30,16))
   | Yield =>
     if e = Enc_ARM
       then ARM(BitsN.@@(c,BitsN.B(0x320F001,28)))
     else if e = Enc_Wide
       then Thumb2(BitsN.B(0xF3AF,16),BitsN.B(0x8001,16))
     else Thumb(BitsN.B(0xBF10,16))
   | PreloadData(add,(is_pldw,(Rn,immediate_form1 imm32))) =>
     (if e = Enc_ARM
        then let
               val U = BitsN.fromBit add
               val R = BitsN.fromBit(not is_pldw)
               val imm12 = BitsN.bits(11,0) imm32
             in
               ARM(BitsN.concat
                     [BitsN.B(0xF5,8),U,R,BitsN.B(0x1,2),Rn,
                      BitsN.B(0xF,4),imm12])
             end
      else if not(e = Enc_Narrow)
        then let
               val W = BitsN.fromBit is_pldw
             in
               if add
                 then let
                        val imm12 = BitsN.bits(11,0) imm32
                      in
                        Thumb2
                          (BitsN.concat
                             [BitsN.B(0x3E2,10),W,BitsN.B(0x1,1),Rn],
                           BitsN.@@(BitsN.B(0xF,4),imm12))
                      end
               else let
                      val imm8 = BitsN.bits(7,0) imm32
                    in
                      Thumb2
                        (BitsN.concat
                           [BitsN.B(0x3E0,10),W,BitsN.B(0x1,1),Rn],
                         BitsN.@@(BitsN.B(0xFC,8),imm8))
                    end
             end
      else BadCode("PreloadData"))
   | PreloadData(add,(is_pldw,(Rn,register_form1(Rm,(shift_t,shift_n))))) =>
     (if e = Enc_ARM
        then if c = (BitsN.B(0xE,4))
               then let
                      val U = BitsN.fromBit add
                      val R = BitsN.fromBit(not is_pldw)
                      val (typ,imm5) = EncodeImmShift(shift_t,shift_n)
                    in
                      ARM(BitsN.concat
                            [BitsN.B(0xF7,8),U,R,BitsN.B(0x1,2),Rn,
                             BitsN.B(0xF,4),imm5,typ,BitsN.B(0x0,1),Rm])
                    end
             else BadCode("PreloadData")
      else if (not(e = Enc_Narrow)) andalso
         (add andalso (shift_t = SRType_LSL))
        then let
               val W = BitsN.fromBit is_pldw
               val imm2 = BitsN.fromNat(shift_n,2)
             in
               Thumb2
                 (BitsN.concat[BitsN.B(0x3E0,10),W,BitsN.B(0x1,1),Rn],
                  BitsN.concat[BitsN.B(0x3C0,10),imm2,Rm])
             end
      else BadCode("PreloadData"))
   | PreloadDataLiteral(add,imm32) =>
     let
       val imm12 = BitsN.bits(11,0) imm32
       val U = BitsN.fromBit add
     in
       if e = Enc_ARM
         then if c = (BitsN.B(0xE,4))
                then ARM(BitsN.concat
                           [BitsN.B(0xF5,8),U,BitsN.B(0x5FF,11),imm12])
              else BadCode("PreloadDataLiteral")
       else if not(e = Enc_Narrow)
         then Thumb2
                (BitsN.concat[BitsN.B(0xF8,8),U,BitsN.B(0x1F,7)],
                 BitsN.@@(BitsN.B(0xF,4),imm12))
       else BadCode("PreloadDataLiteral")
     end
   | PreloadInstruction(add,(Rn,immediate_form1 imm32)) =>
     let
       val U = BitsN.fromBit add
       val imm12 = BitsN.bits(11,0) imm32
     in
       if e = Enc_ARM
         then if c = (BitsN.B(0xE,4))
                then ARM(BitsN.concat
                           [BitsN.B(0xF4,8),U,BitsN.B(0x5,3),Rn,
                            BitsN.B(0xF,4),imm12])
              else BadCode("PreloadInstruction")
       else if not(e = Enc_Narrow)
         then if Rn = (BitsN.B(0xF,4))
                then Thumb2
                       (BitsN.concat[BitsN.B(0xF9,8),U,BitsN.B(0x1F,7)],
                        BitsN.@@(BitsN.B(0xF,4),imm12))
              else if add
                then Thumb2
                       (BitsN.@@(BitsN.B(0xF99,12),Rn),
                        BitsN.@@(BitsN.B(0xF,4),imm12))
              else let
                     val imm8 = BitsN.bits(7,0) imm32
                   in
                     Thumb2
                       (BitsN.@@(BitsN.B(0xF91,12),Rn),
                        BitsN.@@(BitsN.B(0xFC,8),imm8))
                   end
       else BadCode("PreloadInstruction")
     end
   | PreloadInstruction(add,(Rn,register_form1(Rm,(shift_t,shift_n)))) =>
     (if e = Enc_ARM
        then let
               val U = BitsN.fromBit add
               val (typ,imm5) = EncodeImmShift(shift_t,shift_n)
             in
               ARM(BitsN.concat
                     [BitsN.B(0xF6,8),U,BitsN.B(0x5,3),Rn,BitsN.B(0xF,4),
                      imm5,typ,BitsN.B(0x0,1),Rm])
             end
      else if (not(e = Enc_Narrow)) andalso
         (add andalso (shift_t = SRType_LSL))
        then let
               val imm2 = BitsN.fromNat(shift_n,2)
             in
               Thumb2
                 (BitsN.@@(BitsN.B(0xF91,12),Rn),
                  BitsN.concat[BitsN.B(0x3C0,10),imm2,Rm])
             end
      else BadCode("PreloadInstruction (register)"));

fun e_system (c,(ast,e)) =
  case ast of
     EnterxLeavex is_enterx =>
       (if Set.mem(e,[Enc_Thumb,Enc_Wide])
          then let
                 val J = BitsN.fromBit is_enterx
               in
                 Thumb2
                   (BitsN.B(0xF3BF,16),
                    BitsN.concat[BitsN.B(0x478,11),J,BitsN.B(0xF,4)])
               end
        else BadCode("EnterxLeavex"))
   | ChangeProcessorState(true,(true,_)) =>
     BadCode("ChangeProcessorState")
   | ChangeProcessorState
     (enable,(disable,(affectA,(affectI,(affectF,changemode))))) =>
     let
       val A = BitsN.fromBit affectA
       val I = BitsN.fromBit affectI
       val F = BitsN.fromBit affectF
       val (M,mode) =
         case changemode of
            Option.SOME mode => (BitsN.B(0x1,1),mode)
          | NONE => (BitsN.B(0x0,1),BitsN.B(0x0,5))
     in
       if e = Enc_ARM
         then if c = (BitsN.B(0xE,4))
                then let
                       val imod =
                         BitsN.@@
                           (BitsN.fromBit(enable orelse disable),
                            BitsN.fromBit disable)
                     in
                       ARM(BitsN.concat
                             [BitsN.B(0xF10,12),imod,M,BitsN.B(0x0,8),A,I,
                              F,BitsN.B(0x0,1),mode])
                     end
              else BadCode("ChangeProcessorState")
       else if (not(e = Enc_Wide)) andalso (M = (BitsN.B(0x0,1)))
         then let
                val im = BitsN.fromBit(not enable)
                val A = BitsN.fromBit affectA
                val I = BitsN.fromBit affectI
                val F = BitsN.fromBit affectF
              in
                Thumb
                  (BitsN.concat[BitsN.B(0x5B3,11),im,BitsN.B(0x0,1),A,I,F])
              end
       else if not(e = Enc_Narrow)
         then let
                val imod =
                  BitsN.@@
                    (BitsN.fromBit(enable orelse disable),
                     BitsN.fromBit disable)
              in
                Thumb2
                  (BitsN.B(0xF3AF,16),
                   BitsN.concat[BitsN.B(0x10,5),imod,M,A,I,F,mode])
              end
       else BadCode("ChangeProcessorState")
     end
   | ExceptionReturn =>
     if e = Enc_ARM
       then ARM(BitsN.@@(c,BitsN.B(0x160006E,28)))
     else if not(e = Enc_Narrow)
       then Thumb2(BitsN.B(0xF3DE,16),BitsN.B(0x8F00,16))
     else BadCode("ExceptionReturn")
   | HypervisorCall imm16 =>
     (if e = Enc_ARM
        then let
               val imm12 = BitsN.bits(15,4) imm16
               val imm4 = BitsN.bits(3,0) imm16
             in
               ARM(BitsN.concat
                     [c,BitsN.B(0x14,8),imm12,BitsN.B(0x7,4),imm4])
             end
      else if not(e = Enc_Narrow)
        then let
               val imm4 = BitsN.bits(15,12) imm16
               val imm12 = BitsN.bits(11,0) imm16
             in
               Thumb2
                 (BitsN.@@(BitsN.B(0xF7E,12),imm4),
                  BitsN.@@(BitsN.B(0x8,4),imm12))
             end
      else BadCode("HypervisorCall"))
   | MoveToRegisterFromSpecial(read_spsr,Rd) =>
     let
       val R = BitsN.fromBit read_spsr
     in
       if e = Enc_ARM
         then ARM(BitsN.concat
                    [c,BitsN.B(0x2,5),R,BitsN.B(0xF,6),Rd,BitsN.B(0x0,12)])
       else if not(e = Enc_Narrow)
         then Thumb2
                (BitsN.concat[BitsN.B(0x79F,11),R,BitsN.B(0xF,4)],
                 BitsN.concat[BitsN.B(0x8,4),Rd,BitsN.B(0x0,8)])
       else BadCode("MoveToRegisterFromSpecial")
     end
   | MoveToRegisterFromBankedOrSpecial(read_spsr,(SYSm,Rd)) =>
     let
       val R = BitsN.fromBit read_spsr
       val m = BitsN.bits(4,4) SYSm
       val m1 = BitsN.bits(3,0) SYSm
     in
       if e = Enc_ARM
         then ARM(BitsN.concat
                    [c,BitsN.B(0x2,5),R,BitsN.B(0x0,2),m1,Rd,
                     BitsN.B(0x1,3),m,BitsN.B(0x0,8)])
       else if not(e = Enc_Narrow)
         then Thumb2
                (BitsN.concat[BitsN.B(0x79F,11),R,m1],
                 BitsN.concat
                   [BitsN.B(0x8,4),Rd,BitsN.B(0x1,3),m,BitsN.B(0x0,4)])
       else BadCode("MoveToRegisterFromBankedOrSpecial")
     end
   | MoveToSpecialFromImmediate(write_spsr,(imm32,mask)) =>
     (if e = Enc_ARM
        then let
               val R = BitsN.fromBit write_spsr
             in
               case EncodeARMImmediate imm32 of
                  Option.SOME imm12 =>
                    ARM(BitsN.concat
                          [c,BitsN.B(0x6,5),R,BitsN.B(0x2,2),mask,
                           BitsN.B(0xF,4),imm12])
                | NONE => BadCode("MoveToSpecialFromImmediate")
             end
      else BadCode("MoveToSpecialFromImmediate"))
   | MoveToSpecialFromRegister(write_spsr,(Rn,mask)) =>
     let
       val R = BitsN.fromBit write_spsr
     in
       if e = Enc_ARM
         then ARM(BitsN.concat
                    [c,BitsN.B(0x2,5),R,BitsN.B(0x2,2),mask,
                     BitsN.B(0xF00,12),Rn])
       else if not(e = Enc_Narrow)
         then Thumb2
                (BitsN.concat[BitsN.B(0x79C,11),R,Rn],
                 BitsN.concat[BitsN.B(0x8,4),mask,BitsN.B(0x0,8)])
       else BadCode("MoveToSpecialFromRegister")
     end
   | MoveToBankedOrSpecialRegister(write_spsr,(SYSm,Rn)) =>
     let
       val R = BitsN.fromBit write_spsr
       val m = BitsN.bits(4,4) SYSm
       val m1 = BitsN.bits(3,0) SYSm
     in
       if e = Enc_ARM
         then ARM(BitsN.concat
                    [c,BitsN.B(0x2,5),R,BitsN.B(0x2,2),m1,BitsN.B(0x79,7),
                     m,BitsN.B(0x0,4),Rn])
       else if not(e = Enc_Narrow)
         then Thumb2
                (BitsN.concat[BitsN.B(0x79C,11),R,Rn],
                 BitsN.concat
                   [BitsN.B(0x8,4),m1,BitsN.B(0x1,3),m,BitsN.B(0x0,4)])
       else BadCode("MoveToBankedOrSpecialRegister")
     end
   | ReturnFromException(increment,(wordhigher,(wback,Rn))) =>
     let
       val W = BitsN.fromBit wback
       val U = BitsN.fromBit increment
     in
       if e = Enc_ARM
         then if c = (BitsN.B(0xE,4))
                then let
                       val P = if wordhigher then U else BitsN.~ U
                     in
                       ARM(BitsN.concat
                             [BitsN.B(0x7C,7),P,U,BitsN.B(0x0,1),W,
                              BitsN.B(0x1,1),Rn,BitsN.B(0xA00,16)])
                     end
              else BadCode("ReturnFromException")
       else if not(wordhigher orelse (e = Enc_Narrow))
         then Thumb2
                (BitsN.concat
                   [BitsN.B(0x74,7),U,U,BitsN.B(0x0,1),W,BitsN.B(0x1,1),Rn],
                 BitsN.B(0xC000,16))
       else BadCode("ReturnFromException")
     end
   | SecureMonitorCall imm4 =>
     (if e = Enc_ARM
        then ARM(BitsN.concat[c,BitsN.B(0x160007,24),imm4])
      else if not(e = Enc_Narrow)
        then Thumb2(BitsN.@@(BitsN.B(0xF7F,12),imm4),BitsN.B(0x8000,16))
      else BadCode("SecureMonitorCall"))
   | StoreReturnState(increment,(wordhigher,(wback,mode))) =>
     let
       val W = BitsN.fromBit wback
       val U = BitsN.fromBit increment
     in
       if e = Enc_ARM
         then if c = (BitsN.B(0xE,4))
                then let
                       val P = if wordhigher then U else BitsN.~ U
                     in
                       ARM(BitsN.concat
                             [BitsN.B(0x7C,7),P,U,BitsN.B(0x1,1),W,
                              BitsN.B(0x6828,16),mode])
                     end
              else BadCode("StoreReturnState")
       else if not(wordhigher orelse (e = Enc_Narrow))
         then Thumb2
                (BitsN.concat
                   [BitsN.B(0x74,7),U,U,BitsN.B(0x0,1),W,BitsN.B(0xD,5)],
                 BitsN.@@(BitsN.B(0x600,11),mode))
       else BadCode("StoreReturnState")
     end
   | SupervisorCall imm32 =>
     (if e = Enc_ARM
        then let
               val imm24 = BitsN.bits(23,0) imm32
             in
               ARM(BitsN.concat[c,BitsN.B(0xF,4),imm24])
             end
      else if not(e = Enc_Wide)
        then let
               val imm8 = BitsN.bits(7,0) imm32
             in
               Thumb(BitsN.@@(BitsN.B(0xDF,8),imm8))
             end
      else BadCode("SupervisorCall"))
   | Setend E =>
     (if e = Enc_ARM
        then if c = (BitsN.B(0xE,4))
               then ARM(BitsN.concat
                          [BitsN.B(0x3C4040,22),BitsN.fromBit E,
                           BitsN.B(0x0,9)])
             else BadCode("Setend")
      else if not(e = Enc_Wide)
        then Thumb
               (BitsN.concat
                  [BitsN.B(0xB65,12),BitsN.fromBit E,BitsN.B(0x0,3)])
      else BadCode("Setend"));

fun e_multiply (c,(ast,e)) =
  case ast of
     MultiplyAccumulate(setflags,(Rd,(Rn,(Rm,Ra)))) =>
       (if e = Enc_ARM
          then let
                 val S = BitsN.fromBit setflags
               in
                 ARM(BitsN.concat
                       [c,BitsN.B(0x1,7),S,Rd,Ra,Rm,BitsN.B(0x9,4),Rn])
               end
        else if (not setflags) andalso (not(e = Enc_Narrow))
          then Thumb2
                 (BitsN.@@(BitsN.B(0xFB0,12),Rn),
                  BitsN.concat[Ra,Rd,BitsN.B(0x0,4),Rm])
        else BadCode("MultiplyAccumulate"))
   | Multiply32(setflags,(d,(n,Rm))) =>
     (if e = Enc_ARM
        then let
               val S = BitsN.fromBit setflags
               val Rd = d
               val Rn = n
             in
               ARM(BitsN.concat
                     [c,BitsN.B(0x0,7),S,Rd,BitsN.B(0x0,4),Rm,
                      BitsN.B(0x9,4),Rn])
             end
      else if (d = Rm) andalso
         (not((setflags = (not(c = (BitsN.B(0xE,4))))) orelse
              ((BitsN.bit(d,3)) orelse (e = Enc_Wide))))
        then let
               val Rn = BitsN.bits(2,0) n
               val Rdm = BitsN.bits(2,0) d
             in
               Thumb(BitsN.concat[BitsN.B(0x10D,10),Rn,Rdm])
             end
      else if not(setflags orelse (e = Enc_Narrow))
        then let
               val Rd = d
               val Rn = n
             in
               Thumb2
                 (BitsN.@@(BitsN.B(0xFB0,12),Rn),
                  BitsN.concat[BitsN.B(0xF,4),Rd,BitsN.B(0x0,4),Rm])
             end
      else BadCode("Multiply32"))
   | MultiplyLong(accumulate,(signed,(setflags,(Rdhi,(Rdlo,(Rn,Rm)))))) =>
     (if e = Enc_ARM
        then let
               val A = BitsN.fromBit accumulate
               val I = BitsN.fromBit signed
               val S = BitsN.fromBit setflags
             in
               ARM(BitsN.concat
                     [c,BitsN.B(0x1,5),I,A,S,Rdhi,Rdlo,Rm,BitsN.B(0x9,4),
                      Rn])
             end
      else if not(setflags orelse (e = Enc_Narrow))
        then let
               val A = BitsN.fromBit accumulate
               val U = BitsN.fromBit(not signed)
             in
               Thumb2
                 (BitsN.concat[BitsN.B(0x1F7,9),A,U,BitsN.B(0x0,1),Rn],
                  BitsN.concat[Rdlo,Rdhi,BitsN.B(0x0,4),Rm])
             end
      else BadCode("MultiplyLong"))
   | MultiplyAccumulateAccumulate(Rdhi,(Rdlo,(Rn,Rm))) =>
     (if e = Enc_ARM
        then ARM(BitsN.concat
                   [c,BitsN.B(0x4,8),Rdhi,Rdlo,Rm,BitsN.B(0x9,4),Rn])
      else if not(e = Enc_Narrow)
        then Thumb2
               (BitsN.@@(BitsN.B(0xFBE,12),Rn),
                BitsN.concat[Rdlo,Rdhi,BitsN.B(0x6,4),Rm])
      else BadCode("MultiplyAccumulateAccumulate"))
   | MultiplySubtract(Rd,(Rn,(Rm,Ra))) =>
     (if e = Enc_ARM
        then ARM(BitsN.concat[c,BitsN.B(0x6,8),Rd,Ra,Rm,BitsN.B(0x9,4),Rn])
      else if not(e = Enc_Narrow)
        then Thumb2
               (BitsN.@@(BitsN.B(0xFB0,12),Rn),
                BitsN.concat[Ra,Rd,BitsN.B(0x1,4),Rm])
      else BadCode("MultiplySubtract"))
   | Signed16Multiply32Accumulate(m_high,(n_high,(Rd,(Rn,(Rm,Ra))))) =>
     let
       val M = BitsN.fromBit m_high
       val N = BitsN.fromBit n_high
     in
       if e = Enc_ARM
         then ARM(BitsN.concat
                    [c,BitsN.B(0x10,8),Rd,Ra,Rm,BitsN.B(0x1,1),M,N,
                     BitsN.B(0x0,1),Rn])
       else if not(e = Enc_Narrow)
         then Thumb2
                (BitsN.@@(BitsN.B(0xFB1,12),Rn),
                 BitsN.concat[Ra,Rd,BitsN.B(0x0,2),N,M,Rm])
       else BadCode("Signed16Multiply32Accumulate")
     end
   | Signed16Multiply32Result(m_high,(n_high,(Rd,(Rn,Rm)))) =>
     let
       val M = BitsN.fromBit m_high
       val N = BitsN.fromBit n_high
     in
       if e = Enc_ARM
         then ARM(BitsN.concat
                    [c,BitsN.B(0x16,8),Rd,BitsN.B(0x0,4),Rm,
                     BitsN.B(0x1,1),M,N,BitsN.B(0x0,1),Rn])
       else if not(e = Enc_Narrow)
         then Thumb2
                (BitsN.@@(BitsN.B(0xFB1,12),Rn),
                 BitsN.concat[BitsN.B(0xF,4),Rd,BitsN.B(0x0,2),N,M,Rm])
       else BadCode("Signed16Multiply32Result")
     end
   | Signed16x32Multiply32Accumulate(m_high,(Rd,(Rn,(Rm,Ra)))) =>
     let
       val M = BitsN.fromBit m_high
     in
       if e = Enc_ARM
         then ARM(BitsN.concat
                    [c,BitsN.B(0x12,8),Rd,Ra,Rm,BitsN.B(0x1,1),M,
                     BitsN.B(0x0,2),Rn])
       else if not(e = Enc_Narrow)
         then Thumb2
                (BitsN.@@(BitsN.B(0xFB3,12),Rn),
                 BitsN.concat[Ra,Rd,BitsN.B(0x0,3),M,Rm])
       else BadCode("Signed16x32Multiply32Accumulate")
     end
   | Signed16x32Multiply32Result(m_high,(Rd,(Rn,Rm))) =>
     let
       val M = BitsN.fromBit m_high
     in
       if e = Enc_ARM
         then ARM(BitsN.concat
                    [c,BitsN.B(0x12,8),Rd,BitsN.B(0x0,4),Rm,
                     BitsN.B(0x1,1),M,BitsN.B(0x2,2),Rn])
       else if not(e = Enc_Narrow)
         then Thumb2
                (BitsN.@@(BitsN.B(0xFB3,12),Rn),
                 BitsN.concat[BitsN.B(0xF,4),Rd,BitsN.B(0x0,3),M,Rm])
       else BadCode("Signed16x32Multiply32Result")
     end
   | Signed16Multiply64Accumulate(m_high,(n_high,(Rdhi,(Rdlo,(Rn,Rm))))) =>
     let
       val M = BitsN.fromBit m_high
       val N = BitsN.fromBit n_high
     in
       if e = Enc_ARM
         then ARM(BitsN.concat
                    [c,BitsN.B(0x14,8),Rdhi,Rdlo,Rm,BitsN.B(0x1,1),M,N,
                     BitsN.B(0x0,1),Rn])
       else if not(e = Enc_Narrow)
         then Thumb2
                (BitsN.@@(BitsN.B(0xFBC,12),Rn),
                 BitsN.concat[Rdlo,Rdhi,BitsN.B(0x2,2),N,M,Rm])
       else BadCode("Signed16Multiply64Accumulate")
     end
   | SignedMultiplyDual(sub,(m_swap,(Rd,(Rn,(Rm,Ra))))) =>
     let
       val M = BitsN.fromBit m_swap
     in
       if e = Enc_ARM
         then let
                val S = BitsN.fromBit sub
              in
                ARM(BitsN.concat
                      [c,BitsN.B(0x70,8),Rd,Ra,Rm,BitsN.B(0x0,1),S,M,
                       BitsN.B(0x1,1),Rn])
              end
       else if not(e = Enc_Narrow)
         then let
                val opc = if sub then BitsN.B(0x4,3) else BitsN.B(0x2,3)
              in
                Thumb2
                  (BitsN.concat[BitsN.B(0x1F6,9),opc,Rn],
                   BitsN.concat[Ra,Rd,BitsN.B(0x0,3),M,Rm])
              end
       else BadCode("SignedMultiplyDual")
     end
   | SignedMultiplyLongDual(sub,(m_swap,(Rdhi,(Rdlo,(Rn,Rm))))) =>
     let
       val S = BitsN.fromBit sub
       val M = BitsN.fromBit m_swap
     in
       if e = Enc_ARM
         then ARM(BitsN.concat
                    [c,BitsN.B(0x74,8),Rdhi,Rdlo,Rm,BitsN.B(0x0,1),S,M,
                     BitsN.B(0x1,1),Rn])
       else if not(e = Enc_Narrow)
         then Thumb2
                (BitsN.concat[BitsN.B(0x7DE,11),S,Rn],
                 BitsN.concat[Rdlo,Rdhi,BitsN.B(0x6,3),M,Rm])
       else BadCode("SignedMultiplyLongDual")
     end
   | SignedMostSignificantMultiply(round,(Rd,(Rn,(Rm,Ra)))) =>
     let
       val R = BitsN.fromBit round
     in
       if e = Enc_ARM
         then ARM(BitsN.concat
                    [c,BitsN.B(0x75,8),Rd,Ra,Rm,BitsN.B(0x0,2),R,
                     BitsN.B(0x1,1),Rn])
       else if not(e = Enc_Narrow)
         then Thumb2
                (BitsN.@@(BitsN.B(0xFB5,12),Rn),
                 BitsN.concat[Ra,Rd,BitsN.B(0x0,3),R,Rm])
       else BadCode("SignedMostSignificantMultiply")
     end
   | SignedMostSignificantMultiplySubtract(round,(Rd,(Rn,(Rm,Ra)))) =>
     let
       val R = BitsN.fromBit round
     in
       if e = Enc_ARM
         then ARM(BitsN.concat
                    [c,BitsN.B(0x75,8),Rd,Ra,Rm,BitsN.B(0x3,2),R,
                     BitsN.B(0x1,1),Rn])
       else if not(e = Enc_Narrow)
         then Thumb2
                (BitsN.@@(BitsN.B(0xFB6,12),Rn),
                 BitsN.concat[Ra,Rd,BitsN.B(0x0,3),R,Rm])
       else BadCode("SignedMostSignificantMultiplySubtract")
     end;

fun e_simd (c,(ast,e)) =
  case ast of
     SignedAddSub16(opc,(Rd,(Rn,Rm))) =>
       (if e = Enc_ARM
          then ARM(BitsN.concat
                     [c,BitsN.B(0x61,8),Rn,Rd,BitsN.B(0x1E,5),opc,
                      BitsN.B(0x1,1),Rm])
        else if not(e = Enc_Narrow)
          then let
                 val op1 = EncodeAddSubOpc opc
               in
                 Thumb2
                   (BitsN.concat[BitsN.B(0x1F5,9),op1,Rn],
                    BitsN.concat[BitsN.B(0xF,4),Rd,BitsN.B(0x0,4),Rm])
               end
        else BadCode("SignedAddSub16"))
   | UnsignedAddSub16(opc,(Rd,(Rn,Rm))) =>
     (if e = Enc_ARM
        then ARM(BitsN.concat
                   [c,BitsN.B(0x65,8),Rn,Rd,BitsN.B(0x1E,5),opc,
                    BitsN.B(0x1,1),Rm])
      else if not(e = Enc_Narrow)
        then let
               val op1 = EncodeAddSubOpc opc
             in
               Thumb2
                 (BitsN.concat[BitsN.B(0x1F5,9),op1,Rn],
                  BitsN.concat[BitsN.B(0xF,4),Rd,BitsN.B(0x4,4),Rm])
             end
      else BadCode("UnsignedAddSub16"))
   | SignedSaturatingAddSub16(opc,(Rd,(Rn,Rm))) =>
     (if e = Enc_ARM
        then ARM(BitsN.concat
                   [c,BitsN.B(0x62,8),Rn,Rd,BitsN.B(0x1E,5),opc,
                    BitsN.B(0x1,1),Rm])
      else if not(e = Enc_Narrow)
        then let
               val op1 = EncodeAddSubOpc opc
             in
               Thumb2
                 (BitsN.concat[BitsN.B(0x1F5,9),op1,Rn],
                  BitsN.concat[BitsN.B(0xF,4),Rd,BitsN.B(0x1,4),Rm])
             end
      else BadCode("SignedSaturatingAddSub16"))
   | UnsignedSaturatingAddSub16(opc,(Rd,(Rn,Rm))) =>
     (if e = Enc_ARM
        then ARM(BitsN.concat
                   [c,BitsN.B(0x66,8),Rn,Rd,BitsN.B(0x1E,5),opc,
                    BitsN.B(0x1,1),Rm])
      else if not(e = Enc_Narrow)
        then let
               val op1 = EncodeAddSubOpc opc
               val op2 = BitsN.-(opc,BitsN.B(0x1,2))
             in
               Thumb2
                 (BitsN.concat[BitsN.B(0x1F5,9),op1,Rn],
                  BitsN.concat[BitsN.B(0xF,4),Rd,BitsN.B(0x5,4),Rm])
             end
      else BadCode("UnsignedSaturatingAddSub16"))
   | SignedHalvingAddSub16(opc,(Rd,(Rn,Rm))) =>
     (if e = Enc_ARM
        then ARM(BitsN.concat
                   [c,BitsN.B(0x63,8),Rn,Rd,BitsN.B(0x1E,5),opc,
                    BitsN.B(0x1,1),Rm])
      else if not(e = Enc_Narrow)
        then let
               val op1 = EncodeAddSubOpc opc
             in
               Thumb2
                 (BitsN.concat[BitsN.B(0x1F5,9),op1,Rn],
                  BitsN.concat[BitsN.B(0xF,4),Rd,BitsN.B(0x2,4),Rm])
             end
      else BadCode("SignedHalvingAddSub16"))
   | UnsignedHalvingAddSub16(opc,(Rd,(Rn,Rm))) =>
     (if e = Enc_ARM
        then ARM(BitsN.concat
                   [c,BitsN.B(0x67,8),Rn,Rd,BitsN.B(0x1E,5),opc,
                    BitsN.B(0x1,1),Rm])
      else if not(e = Enc_Narrow)
        then let
               val op1 = EncodeAddSubOpc opc
               val op2 = BitsN.-(opc,BitsN.B(0x1,2))
             in
               Thumb2
                 (BitsN.concat[BitsN.B(0x1F5,9),op1,Rn],
                  BitsN.concat[BitsN.B(0xF,4),Rd,BitsN.B(0x6,4),Rm])
             end
      else BadCode("UnsignedHalvingAddSub16"))
   | SignedAddSub8(sub,(Rd,(Rn,Rm))) =>
     (if e = Enc_ARM
        then let
               val opc = if sub then BitsN.B(0x7,3) else BitsN.B(0x4,3)
             in
               ARM(BitsN.concat
                     [c,BitsN.B(0x61,8),Rn,Rd,BitsN.B(0xF,4),opc,
                      BitsN.B(0x1,1),Rm])
             end
      else if not(e = Enc_Narrow)
        then let
               val opc = if sub then BitsN.B(0x4,3) else BitsN.B(0x0,3)
             in
               Thumb2
                 (BitsN.concat[BitsN.B(0x1F5,9),opc,Rn],
                  BitsN.concat[BitsN.B(0xF,4),Rd,BitsN.B(0x0,4),Rm])
             end
      else BadCode("SignedAddSub8"))
   | UnsignedAddSub8(sub,(Rd,(Rn,Rm))) =>
     (if e = Enc_ARM
        then let
               val opc = if sub then BitsN.B(0x7,3) else BitsN.B(0x4,3)
             in
               ARM(BitsN.concat
                     [c,BitsN.B(0x65,8),Rn,Rd,BitsN.B(0xF,4),opc,
                      BitsN.B(0x1,1),Rm])
             end
      else if not(e = Enc_Narrow)
        then let
               val opc = if sub then BitsN.B(0x4,3) else BitsN.B(0x0,3)
             in
               Thumb2
                 (BitsN.concat[BitsN.B(0x1F5,9),opc,Rn],
                  BitsN.concat[BitsN.B(0xF,4),Rd,BitsN.B(0x4,4),Rm])
             end
      else BadCode("UnsignedAddSub8"))
   | SignedSaturatingAddSub8(sub,(Rd,(Rn,Rm))) =>
     (if e = Enc_ARM
        then let
               val opc = if sub then BitsN.B(0x7,3) else BitsN.B(0x4,3)
             in
               ARM(BitsN.concat
                     [c,BitsN.B(0x62,8),Rn,Rd,BitsN.B(0xF,4),opc,
                      BitsN.B(0x1,1),Rm])
             end
      else if not(e = Enc_Narrow)
        then let
               val opc = if sub then BitsN.B(0x4,3) else BitsN.B(0x0,3)
             in
               Thumb2
                 (BitsN.concat[BitsN.B(0x1F5,9),opc,Rn],
                  BitsN.concat[BitsN.B(0xF,4),Rd,BitsN.B(0x1,4),Rm])
             end
      else BadCode("SignedSaturatingAddSub8"))
   | UnsignedSaturatingAddSub8(sub,(Rd,(Rn,Rm))) =>
     (if e = Enc_ARM
        then let
               val opc = if sub then BitsN.B(0x7,3) else BitsN.B(0x4,3)
             in
               ARM(BitsN.concat
                     [c,BitsN.B(0x66,8),Rn,Rd,BitsN.B(0xF,4),opc,
                      BitsN.B(0x1,1),Rm])
             end
      else if not(e = Enc_Narrow)
        then let
               val opc = if sub then BitsN.B(0x4,3) else BitsN.B(0x0,3)
             in
               Thumb2
                 (BitsN.concat[BitsN.B(0x1F5,9),opc,Rn],
                  BitsN.concat[BitsN.B(0xF,4),Rd,BitsN.B(0x5,4),Rm])
             end
      else BadCode("UnsignedSaturatingAddSub8"))
   | SignedHalvingAddSub8(sub,(Rd,(Rn,Rm))) =>
     (if e = Enc_ARM
        then let
               val opc = if sub then BitsN.B(0x7,3) else BitsN.B(0x4,3)
             in
               ARM(BitsN.concat
                     [c,BitsN.B(0x63,8),Rn,Rd,BitsN.B(0xF,4),opc,
                      BitsN.B(0x1,1),Rm])
             end
      else if not(e = Enc_Narrow)
        then let
               val opc = if sub then BitsN.B(0x4,3) else BitsN.B(0x0,3)
             in
               Thumb2
                 (BitsN.concat[BitsN.B(0x1F5,9),opc,Rn],
                  BitsN.concat[BitsN.B(0xF,4),Rd,BitsN.B(0x2,4),Rm])
             end
      else BadCode("SignedHalvingAddSub8"))
   | UnsignedHalvingAddSub8(sub,(Rd,(Rn,Rm))) =>
     (if e = Enc_ARM
        then let
               val opc = if sub then BitsN.B(0x7,3) else BitsN.B(0x4,3)
             in
               ARM(BitsN.concat
                     [c,BitsN.B(0x67,8),Rn,Rd,BitsN.B(0xF,4),opc,
                      BitsN.B(0x1,1),Rm])
             end
      else if not(e = Enc_Narrow)
        then let
               val opc = if sub then BitsN.B(0x4,3) else BitsN.B(0x0,3)
             in
               Thumb2
                 (BitsN.concat[BitsN.B(0x1F5,9),opc,Rn],
                  BitsN.concat[BitsN.B(0xF,4),Rd,BitsN.B(0x6,4),Rm])
             end
      else BadCode("UnsignedHalvingAddSub8"))
   | UnsignedSumAbsoluteDifferences(Rd,(Rn,(Rm,Ra))) =>
     (if e = Enc_ARM
        then ARM(BitsN.concat
                   [c,BitsN.B(0x78,8),Rd,Ra,Rm,BitsN.B(0x1,4),Rn])
      else if not(e = Enc_Narrow)
        then Thumb2
               (BitsN.@@(BitsN.B(0xFB7,12),Rn),
                BitsN.concat[Ra,Rd,BitsN.B(0x0,4),Rm])
      else BadCode("UnsignedSumAbsoluteDifferences"));

fun e_load (c,(ast,e)) =
  case ast of
     LoadWord(_,(false,(false,_))) => BadCode("LoadWord")
   | LoadWord(add,(index,(wback,(t,(n,immediate_form1 imm32))))) =>
     (if e = Enc_ARM
        then if BitsN.<=+(imm32,BitsN.B(0xFFF,32))
               then let
                      val Rt = t
                      val Rn = n
                      val P = BitsN.fromBit index
                      val U = BitsN.fromBit add
                      val W = BitsN.fromBit(index andalso wback)
                      val imm12 = BitsN.bits(11,0) imm32
                    in
                      ARM(BitsN.concat
                            [c,BitsN.B(0x2,3),P,U,BitsN.B(0x0,1),W,
                             BitsN.B(0x1,1),Rn,Rt,imm12])
                    end
             else BadCode("LoadWord")
      else if index andalso (add andalso (not wback))
        then if (n = (BitsN.B(0xD,4))) andalso
                ((BitsN.<=+(imm32,BitsN.B(0x3FC,32))) andalso
                 ((Aligned 32 (imm32,4)) andalso
                  (not((BitsN.bit(t,3)) orelse (e = Enc_Wide)))))
               then let
                      val Rt = BitsN.bits(2,0) t
                      val imm8 = BitsN.bits(9,2) imm32
                    in
                      Thumb(BitsN.concat[BitsN.B(0x13,5),Rt,imm8])
                    end
             else if (BitsN.<=+(imm32,BitsN.B(0x7C,32))) andalso
                ((Aligned 32 (imm32,4)) andalso
                 (not((BitsN.bit(t,3)) orelse
                      ((BitsN.bit(n,3)) orelse (e = Enc_Wide)))))
               then let
                      val Rt = BitsN.bits(2,0) t
                      val Rn = BitsN.bits(2,0) n
                      val imm5 = BitsN.bits(6,2) imm32
                    in
                      Thumb(BitsN.concat[BitsN.B(0xD,5),imm5,Rn,Rt])
                    end
             else if (BitsN.<=+(imm32,BitsN.B(0xFFF,32))) andalso
                (not(e = Enc_Narrow))
               then let
                      val Rt = t
                      val Rn = n
                      val imm12 = BitsN.bits(11,0) imm32
                    in
                      Thumb2
                        (BitsN.@@(BitsN.B(0xF8D,12),Rn),BitsN.@@(Rt,imm12))
                    end
             else BadCode("LoadWord")
      else if (BitsN.<=+(imm32,BitsN.B(0xFF,32))) andalso
         (not(e = Enc_Narrow))
        then let
               val Rt = t
               val Rn = n
               val P = BitsN.fromBit index
               val U = BitsN.fromBit add
               val W = BitsN.fromBit wback
               val imm8 = BitsN.bits(7,0) imm32
             in
               Thumb2
                 (BitsN.@@(BitsN.B(0xF85,12),Rn),
                  BitsN.concat[Rt,BitsN.B(0x1,1),P,U,W,imm8])
             end
      else BadCode("LoadWord"))
   | LoadWord
     (add,(index,(wback,(t,(n,register_form1(m,(shift_t,shift_n))))))) =>
     let
       val (typ,imm5) = EncodeImmShift(shift_t,shift_n)
     in
       if e = Enc_ARM
         then let
                val Rn = n
                val Rt = t
                val Rm = m
                val P = BitsN.fromBit index
                val U = BitsN.fromBit add
                val W = BitsN.fromBit(index andalso wback)
              in
                ARM(BitsN.concat
                      [c,BitsN.B(0x3,3),P,U,BitsN.B(0x0,1),W,
                       BitsN.B(0x1,1),Rn,Rt,imm5,typ,BitsN.B(0x0,1),Rm])
              end
       else if (shift_t = SRType_LSL) andalso
          (index andalso (add andalso (not wback)))
         then if (shift_n = 0) andalso
                 (not((BitsN.bit(m,3)) orelse
                      ((BitsN.bit(n,3)) orelse
                       ((BitsN.bit(t,3)) orelse (e = Enc_Wide)))))
                then let
                       val Rm = BitsN.bits(2,0) m
                       val Rn = BitsN.bits(2,0) n
                       val Rt = BitsN.bits(2,0) t
                     in
                       Thumb(BitsN.concat[BitsN.B(0x2C,7),Rm,Rn,Rt])
                     end
              else if (Nat.<(shift_n,4)) andalso (not(e = Enc_Narrow))
                then let
                       val Rn = n
                       val Rt = t
                       val Rm = m
                       val imm2 = BitsN.bits(1,0) imm5
                     in
                       Thumb2
                         (BitsN.@@(BitsN.B(0xF85,12),Rn),
                          BitsN.concat[Rt,BitsN.B(0x0,6),imm2,Rm])
                     end
              else BadCode("LoadWord")
       else BadCode("LoadWord")
     end
   | LoadLiteral(add,(t,imm32)) =>
     (if e = Enc_ARM
        then if BitsN.<=+(imm32,BitsN.B(0xFFF,32))
               then let
                      val Rt = t
                      val U = BitsN.fromBit add
                      val imm12 = BitsN.bits(11,0) imm32
                    in
                      ARM(BitsN.concat
                            [c,BitsN.B(0x5,4),U,BitsN.B(0x1F,7),Rt,imm12])
                    end
             else BadCode("LoadLiteral")
      else if add andalso
         ((BitsN.<=+(imm32,BitsN.B(0x3FC,32))) andalso
          ((Aligned 32 (imm32,4)) andalso
           (not((BitsN.bit(t,3)) orelse (e = Enc_Wide)))))
        then let
               val Rt = BitsN.bits(2,0) t
               val imm8 = BitsN.bits(9,2) imm32
             in
               Thumb(BitsN.concat[BitsN.B(0x9,5),Rt,imm8])
             end
      else if (BitsN.<=+(imm32,BitsN.B(0xFFF,32))) andalso
         (not(e = Enc_Narrow))
        then let
               val Rt = t
               val U = BitsN.fromBit add
               val imm12 = BitsN.bits(11,0) imm32
             in
               Thumb2
                 (BitsN.concat[BitsN.B(0xF8,8),U,BitsN.B(0x5F,7)],
                  BitsN.@@(Rt,imm12))
             end
      else BadCode("LoadLiteral"))
   | LoadUnprivileged(add,(postindex,(Rt,(Rn,immediate_form1 imm32)))) =>
     (if (e = Enc_ARM) andalso
         (postindex andalso (BitsN.<=+(imm32,BitsN.B(0xFFF,32))))
        then let
               val imm12 = BitsN.bits(11,0) imm32
               val U = BitsN.fromBit add
             in
               ARM(BitsN.concat
                     [c,BitsN.B(0x4,4),U,BitsN.B(0x3,3),Rn,Rt,imm12])
             end
      else if (Set.mem(e,[Enc_Thumb,Enc_Wide])) andalso
         (add andalso
          ((not postindex) andalso (BitsN.<=+(imm32,BitsN.B(0xFF,32)))))
        then let
               val imm8 = BitsN.bits(7,0) imm32
             in
               Thumb2
                 (BitsN.@@(BitsN.B(0xF85,12),Rn),
                  BitsN.concat[Rt,BitsN.B(0xE,4),imm8])
             end
      else BadCode("LoadUnprivileged"))
   | LoadUnprivileged
     (add,(postindex,(Rt,(Rn,register_form1(Rm,(shift_t,shift_n)))))) =>
     (if (e = Enc_ARM) andalso postindex
        then let
               val (typ,imm5) = EncodeImmShift(shift_t,shift_n)
               val U = BitsN.fromBit add
             in
               ARM(BitsN.concat
                     [c,BitsN.B(0x6,4),U,BitsN.B(0x3,3),Rn,Rt,imm5,typ,
                      BitsN.B(0x0,1),Rm])
             end
      else BadCode("LoadUnprivileged"))
   | LoadByte(_,(_,(false,(false,_)))) => BadCode("LoadByte")
   | LoadByte
     (unsigned,(add,(index,(wback,(t,(n,immediate_form1 imm32)))))) =>
     (if e = Enc_ARM
        then let
               val Rt = t
               val Rn = n
               val P = BitsN.fromBit index
               val U = BitsN.fromBit add
               val W = BitsN.fromBit(index andalso wback)
             in
               if unsigned andalso (BitsN.<=+(imm32,BitsN.B(0xFFF,32)))
                 then let
                        val imm12 = BitsN.bits(11,0) imm32
                      in
                        ARM(BitsN.concat
                              [c,BitsN.B(0x2,3),P,U,BitsN.B(0x1,1),W,
                               BitsN.B(0x1,1),Rn,Rt,imm12])
                      end
               else if BitsN.<=+(imm32,BitsN.B(0xFF,32))
                 then let
                        val imm4H = BitsN.bits(7,4) imm32
                        val imm4L = BitsN.bits(3,0) imm32
                      in
                        ARM(BitsN.concat
                              [c,BitsN.B(0x0,3),P,U,BitsN.B(0x1,1),W,
                               BitsN.B(0x1,1),Rn,Rt,imm4H,BitsN.B(0xD,4),
                               imm4L])
                      end
               else BadCode("LoadByte")
             end
      else if index andalso (add andalso (not wback))
        then if unsigned andalso
                ((BitsN.<=+(imm32,BitsN.B(0x1F,32))) andalso
                 (not((BitsN.bit(t,3)) orelse
                      ((BitsN.bit(n,3)) orelse (e = Enc_Wide)))))
               then let
                      val Rt = BitsN.bits(2,0) t
                      val Rn = BitsN.bits(2,0) n
                      val imm5 = BitsN.bits(4,0) imm32
                    in
                      Thumb(BitsN.concat[BitsN.B(0xF,5),imm5,Rn,Rt])
                    end
             else if (BitsN.<=+(imm32,BitsN.B(0xFFF,32))) andalso
                (not(e = Enc_Narrow))
               then let
                      val Rt = t
                      val Rn = n
                      val imm12 = BitsN.bits(11,0) imm32
                      val S = BitsN.fromBit(not unsigned)
                    in
                      Thumb2
                        (BitsN.concat[BitsN.B(0x7C,7),S,BitsN.B(0x9,4),Rn],
                         BitsN.@@(Rt,imm12))
                    end
             else BadCode("LoadByte")
      else if (BitsN.<=+(imm32,BitsN.B(0xFF,32))) andalso
         (not(e = Enc_Narrow))
        then let
               val Rt = t
               val Rn = n
               val P = BitsN.fromBit index
               val U = BitsN.fromBit add
               val W = BitsN.fromBit wback
               val imm8 = BitsN.bits(7,0) imm32
               val S = BitsN.fromBit(not unsigned)
             in
               Thumb2
                 (BitsN.concat[BitsN.B(0x7C,7),S,BitsN.B(0x1,4),Rn],
                  BitsN.concat[Rt,BitsN.B(0x1,1),P,U,W,imm8])
             end
      else BadCode("LoadByte"))
   | LoadByte
     (unsigned,
      (add,(index,(wback,(t,(n,register_form1(m,(shift_t,shift_n)))))))) =>
     let
       val (typ,imm5) = EncodeImmShift(shift_t,shift_n)
     in
       if e = Enc_ARM
         then let
                val Rt = t
                val Rn = n
                val Rm = m
                val P = BitsN.fromBit index
                val U = BitsN.fromBit add
                val W = BitsN.fromBit(index andalso wback)
              in
                if unsigned
                  then ARM(BitsN.concat
                             [c,BitsN.B(0x3,3),P,U,BitsN.B(0x1,1),W,
                              BitsN.B(0x1,1),Rn,Rt,imm5,typ,
                              BitsN.B(0x0,1),Rm])
                else if (shift_t = SRType_LSL) andalso (shift_n = 0)
                  then ARM(BitsN.concat
                             [c,BitsN.B(0x0,3),P,U,BitsN.B(0x0,1),W,
                              BitsN.B(0x1,1),Rn,Rt,BitsN.B(0xD,8),Rm])
                else BadCode("LoadByte")
              end
       else if (shift_t = SRType_LSL) andalso
          (index andalso (add andalso (not wback)))
         then if (shift_n = 0) andalso
                 (not((BitsN.bit(m,3)) orelse
                      ((BitsN.bit(n,3)) orelse
                       ((BitsN.bit(t,3)) orelse (e = Enc_Wide)))))
                then let
                       val Rm = BitsN.bits(2,0) m
                       val Rn = BitsN.bits(2,0) n
                       val Rt = BitsN.bits(2,0) t
                       val U = BitsN.fromBit unsigned
                       val S = BitsN.~ U
                     in
                       Thumb
                         (BitsN.concat
                            [BitsN.B(0x5,4),U,BitsN.B(0x1,1),S,Rm,Rn,Rt])
                     end
              else if (Nat.<(shift_n,4)) andalso (not(e = Enc_Narrow))
                then let
                       val Rt = t
                       val Rn = n
                       val Rm = m
                       val imm2 = BitsN.bits(1,0) imm5
                       val S = BitsN.fromBit(not unsigned)
                     in
                       Thumb2
                         (BitsN.concat
                            [BitsN.B(0x7C,7),S,BitsN.B(0x1,4),Rn],
                          BitsN.concat[Rt,BitsN.B(0x0,6),imm2,Rm])
                     end
              else BadCode("LoadByte")
       else BadCode("LoadByte")
     end
   | LoadByteLiteral(unsigned,(add,(Rt,imm32))) =>
     (if e = Enc_ARM
        then let
               val U = BitsN.fromBit add
             in
               if unsigned andalso (BitsN.<=+(imm32,BitsN.B(0xFFF,32)))
                 then let
                        val imm12 = BitsN.bits(11,0) imm32
                      in
                        ARM(BitsN.concat
                              [c,BitsN.B(0x5,4),U,BitsN.B(0x5F,7),Rt,imm12])
                      end
               else if BitsN.<=+(imm32,BitsN.B(0xFF,32))
                 then let
                        val imm4H = BitsN.bits(7,4) imm32
                        val imm4L = BitsN.bits(3,0) imm32
                      in
                        ARM(BitsN.concat
                              [c,BitsN.B(0x1,4),U,BitsN.B(0x5F,7),Rt,
                               imm4H,BitsN.B(0xD,4),imm4L])
                      end
               else BadCode("LoadByteLiteral")
             end
      else if (BitsN.<=+(imm32,BitsN.B(0xFFF,32))) andalso
         (not(e = Enc_Narrow))
        then let
               val U = BitsN.fromBit add
               val S = BitsN.fromBit(not unsigned)
               val imm12 = BitsN.bits(11,0) imm32
             in
               Thumb2
                 (BitsN.concat[BitsN.B(0x7C,7),S,U,BitsN.B(0x1F,7)],
                  BitsN.@@(Rt,imm12))
             end
      else BadCode("LoadByteLiteral"))
   | LoadByteUnprivileged(add,(postindex,(Rt,(Rn,immediate_form1 imm32)))) =>
     (if (e = Enc_ARM) andalso
         (postindex andalso (BitsN.<=+(imm32,BitsN.B(0xFFF,32))))
        then let
               val imm12 = BitsN.bits(11,0) imm32
               val U = BitsN.fromBit add
             in
               ARM(BitsN.concat
                     [c,BitsN.B(0x4,4),U,BitsN.B(0x7,3),Rn,Rt,imm12])
             end
      else if (Set.mem(e,[Enc_Thumb,Enc_Wide])) andalso
         (add andalso
          ((not postindex) andalso (BitsN.<=+(imm32,BitsN.B(0xFF,32)))))
        then let
               val imm8 = BitsN.bits(7,0) imm32
             in
               Thumb2
                 (BitsN.@@(BitsN.B(0xF81,12),Rn),
                  BitsN.concat[Rt,BitsN.B(0xE,4),imm8])
             end
      else BadCode("LoadByteUnprivileged"))
   | LoadByteUnprivileged
     (add,(postindex,(Rt,(Rn,register_form1(Rm,(shift_t,shift_n)))))) =>
     (if (e = Enc_ARM) andalso postindex
        then let
               val (typ,imm5) = EncodeImmShift(shift_t,shift_n)
               val U = BitsN.fromBit add
             in
               ARM(BitsN.concat
                     [c,BitsN.B(0x6,4),U,BitsN.B(0x7,3),Rn,Rt,imm5,typ,
                      BitsN.B(0x0,1),Rm])
             end
      else BadCode("LoadByteUnprivileged"))
   | LoadSignedByteUnprivileged
     (add,(postindex,(Rt,(Rn,immediate_form2 imm32)))) =>
     (if (e = Enc_ARM) andalso
         (postindex andalso (BitsN.<=+(imm32,BitsN.B(0xFF,32))))
        then let
               val imm4H = BitsN.bits(7,4) imm32
               val imm4L = BitsN.bits(3,0) imm32
               val U = BitsN.fromBit add
             in
               ARM(BitsN.concat
                     [c,BitsN.B(0x0,4),U,BitsN.B(0x7,3),Rn,Rt,imm4H,
                      BitsN.B(0xD,4),imm4L])
             end
      else if (Set.mem(e,[Enc_Thumb,Enc_Wide])) andalso
         (add andalso
          ((not postindex) andalso (BitsN.<=+(imm32,BitsN.B(0xFF,32)))))
        then let
               val imm8 = BitsN.bits(7,0) imm32
             in
               Thumb2
                 (BitsN.@@(BitsN.B(0xF91,12),Rn),
                  BitsN.concat[Rt,BitsN.B(0xE,4),imm8])
             end
      else BadCode("LoadSignedByteUnprivileged"))
   | LoadSignedByteUnprivileged
     (add,(postindex,(Rt,(Rn,register_form2 Rm)))) =>
     (if (e = Enc_ARM) andalso postindex
        then let
               val U = BitsN.fromBit add
             in
               ARM(BitsN.concat
                     [c,BitsN.B(0x0,4),U,BitsN.B(0x3,3),Rn,Rt,
                      BitsN.B(0xD,8),Rm])
             end
      else BadCode("LoadSignedByteUnprivileged"))
   | LoadHalf(_,(_,(false,(false,_)))) => BadCode("LoadHalf")
   | LoadHalf
     (unsigned,(add,(index,(wback,(t,(n,immediate_form1 imm32)))))) =>
     (if e = Enc_ARM
        then if BitsN.<=+(imm32,BitsN.B(0xFF,32))
               then let
                      val Rt = t
                      val Rn = n
                      val P = BitsN.fromBit index
                      val U = BitsN.fromBit add
                      val W = BitsN.fromBit(index andalso wback)
                      val S = BitsN.fromBit(not unsigned)
                      val imm4H = BitsN.bits(7,4) imm32
                      val imm4L = BitsN.bits(3,0) imm32
                    in
                      ARM(BitsN.concat
                            [c,BitsN.B(0x0,3),P,U,BitsN.B(0x1,1),W,
                             BitsN.B(0x1,1),Rn,Rt,imm4H,BitsN.B(0x1,1),S,
                             BitsN.B(0x3,2),imm4L])
                    end
             else BadCode("LoadHalf")
      else if index andalso (add andalso (not wback))
        then if unsigned andalso
                ((BitsN.<=+(imm32,BitsN.B(0x3E,32))) andalso
                 ((Aligned 32 (imm32,2)) andalso
                  (not((BitsN.bit(t,3)) orelse
                       ((BitsN.bit(n,3)) orelse (e = Enc_Wide))))))
               then let
                      val Rt = BitsN.bits(2,0) t
                      val Rn = BitsN.bits(2,0) n
                      val imm5 = BitsN.bits(5,1) imm32
                    in
                      Thumb(BitsN.concat[BitsN.B(0x11,5),imm5,Rn,Rt])
                    end
             else if (BitsN.<=+(imm32,BitsN.B(0xFFF,32))) andalso
                (not(e = Enc_Narrow))
               then let
                      val Rt = t
                      val Rn = n
                      val imm12 = BitsN.bits(11,0) imm32
                      val S = BitsN.fromBit(not unsigned)
                    in
                      Thumb2
                        (BitsN.concat[BitsN.B(0x7C,7),S,BitsN.B(0xB,4),Rn],
                         BitsN.@@(Rt,imm12))
                    end
             else BadCode("LoadHalf")
      else if (BitsN.<=+(imm32,BitsN.B(0xFF,32))) andalso
         (not(e = Enc_Narrow))
        then let
               val Rt = t
               val Rn = n
               val P = BitsN.fromBit index
               val U = BitsN.fromBit add
               val W = BitsN.fromBit wback
               val imm8 = BitsN.bits(7,0) imm32
               val S = BitsN.fromBit(not unsigned)
             in
               Thumb2
                 (BitsN.concat[BitsN.B(0x7C,7),S,BitsN.B(0x3,4),Rn],
                  BitsN.concat[Rt,BitsN.B(0x1,1),P,U,W,imm8])
             end
      else BadCode("LoadHalf"))
   | LoadHalf
     (unsigned,
      (add,(index,(wback,(t,(n,register_form1(m,(shift_t,shift_n)))))))) =>
     let
       val S = BitsN.fromBit(not unsigned)
     in
       if e = Enc_ARM
         then if (shift_t = SRType_LSL) andalso (shift_n = 0)
                then let
                       val Rt = t
                       val Rn = n
                       val Rm = m
                       val P = BitsN.fromBit index
                       val U = BitsN.fromBit add
                       val W = BitsN.fromBit(index andalso wback)
                     in
                       ARM(BitsN.concat
                             [c,BitsN.B(0x0,3),P,U,BitsN.B(0x0,1),W,
                              BitsN.B(0x1,1),Rn,Rt,BitsN.B(0x1,5),S,
                              BitsN.B(0x3,2),Rm])
                     end
              else BadCode("LoadHalf")
       else if (shift_t = SRType_LSL) andalso
          (index andalso (add andalso (not wback)))
         then if (shift_n = 0) andalso
                 (not((BitsN.bit(m,3)) orelse
                      ((BitsN.bit(n,3)) orelse
                       ((BitsN.bit(t,3)) orelse (e = Enc_Wide)))))
                then let
                       val Rm = BitsN.bits(2,0) m
                       val Rn = BitsN.bits(2,0) n
                       val Rt = BitsN.bits(2,0) t
                     in
                       Thumb
                         (BitsN.concat
                            [BitsN.B(0xB,5),S,BitsN.B(0x1,1),Rm,Rn,Rt])
                     end
              else if (Nat.<(shift_n,4)) andalso (not(e = Enc_Narrow))
                then let
                       val Rt = t
                       val Rn = n
                       val Rm = m
                       val imm5 = BitsN.fromNat(shift_n,5)
                       val imm2 = BitsN.bits(1,0) imm5
                     in
                       Thumb2
                         (BitsN.concat
                            [BitsN.B(0x7C,7),S,BitsN.B(0x3,4),Rn],
                          BitsN.concat[Rt,BitsN.B(0x0,6),imm2,Rm])
                     end
              else BadCode("LoadHalf")
       else BadCode("LoadHalf")
     end
   | LoadHalfLiteral(unsigned,(add,(Rt,imm32))) =>
     let
       val U = BitsN.fromBit add
       val S = BitsN.fromBit(not unsigned)
     in
       if e = Enc_ARM
         then if BitsN.<=+(imm32,BitsN.B(0xFF,32))
                then let
                       val imm4H = BitsN.bits(7,4) imm32
                       val imm4L = BitsN.bits(3,0) imm32
                     in
                       ARM(BitsN.concat
                             [c,BitsN.B(0x1,4),U,BitsN.B(0x5F,7),Rt,imm4H,
                              BitsN.B(0x1,1),S,BitsN.B(0x3,2),imm4L])
                     end
              else BadCode("LoadHalfLiteral")
       else if (BitsN.<=+(imm32,BitsN.B(0xFFF,32))) andalso
          (not(e = Enc_Narrow))
         then let
                val imm12 = BitsN.bits(11,0) imm32
              in
                Thumb2
                  (BitsN.concat[BitsN.B(0x7C,7),S,U,BitsN.B(0x3F,7)],
                   BitsN.@@(Rt,imm12))
              end
       else BadCode("LoadHalfLiteral")
     end
   | LoadHalfUnprivileged
     (unsigned,(add,(postindex,(Rt,(Rn,immediate_form2 imm32))))) =>
     let
       val U = BitsN.fromBit add
       val S = BitsN.fromBit(not unsigned)
     in
       if BitsN.<+(BitsN.B(0xFF,32),imm32)
         then BadCode("LoadHalfUnprivileged: bad immediate")
       else if (e = Enc_ARM) andalso postindex
         then let
                val imm4H = BitsN.bits(7,4) imm32
                val imm4L = BitsN.bits(3,0) imm32
              in
                ARM(BitsN.concat
                      [c,BitsN.B(0x0,4),U,BitsN.B(0x7,3),Rn,Rt,imm4H,
                       BitsN.B(0x1,1),S,BitsN.B(0x3,2),imm4L])
              end
       else if (Set.mem(e,[Enc_Thumb,Enc_Wide])) andalso
          (add andalso (not postindex))
         then let
                val imm8 = BitsN.bits(7,0) imm32
              in
                Thumb2
                  (BitsN.concat[BitsN.B(0x7C,7),S,BitsN.B(0x3,4),Rn],
                   BitsN.concat[Rt,BitsN.B(0xE,4),imm8])
              end
       else BadCode("LoadHalfUnprivileged")
     end
   | LoadHalfUnprivileged
     (unsigned,(add,(postindex,(Rt,(Rn,register_form2 Rm))))) =>
     (if (e = Enc_ARM) andalso postindex
        then let
               val U = BitsN.fromBit add
               val S = BitsN.fromBit(not unsigned)
             in
               ARM(BitsN.concat
                     [c,BitsN.B(0x0,4),U,BitsN.B(0x3,3),Rn,Rt,
                      BitsN.B(0x1,5),S,BitsN.B(0x3,2),Rm])
             end
      else BadCode("LoadHalfUnprivileged"))
   | LoadMultiple(increment,(index,(wback,(n,registers)))) =>
     (if e = Enc_ARM
        then let
               val U = BitsN.fromBit increment
               val P = BitsN.fromBit index
               val W = BitsN.fromBit wback
               val Rn = n
             in
               ARM(BitsN.concat
                     [c,BitsN.B(0x4,3),P,U,BitsN.B(0x0,1),W,
                      BitsN.B(0x1,1),Rn,registers])
             end
      else if (n = (BitsN.B(0xD,4))) andalso
         (increment andalso
          ((not index) andalso
           (wback andalso
            (((BitsN.bits(14,8) registers) = (BitsN.B(0x0,7))) andalso
             (not(e = Enc_Wide))))))
        then let
               val P = BitsN.bits(15,15) registers
               val register_list = BitsN.bits(7,0) registers
             in
               Thumb(BitsN.concat[BitsN.B(0x5E,7),P,register_list])
             end
      else if (not(BitsN.bit(n,3))) andalso
         (increment andalso
          ((not index) andalso
           ((not(wback = (BitsN.bit(registers,BitsN.toNat n)))) andalso
            (((BitsN.bits(15,8) registers) = (BitsN.B(0x0,8))) andalso
             (not(e = Enc_Wide))))))
        then let
               val Rn = BitsN.bits(2,0) n
               val register_list = BitsN.bits(7,0) registers
             in
               Thumb(BitsN.concat[BitsN.B(0x19,5),Rn,register_list])
             end
      else if increment andalso
         ((not index) andalso (not(e = Enc_Narrow)))
        then let
               val Rn = n
               val W = BitsN.fromBit wback
             in
               Thumb2
                 (BitsN.concat[BitsN.B(0x3A2,10),W,BitsN.B(0x1,1),Rn],
                  registers)
             end
      else if (not increment) andalso
         (index andalso (not(e = Enc_Narrow)))
        then let
               val Rn = n
               val W = BitsN.fromBit wback
             in
               Thumb2
                 (BitsN.concat[BitsN.B(0x3A4,10),W,BitsN.B(0x1,1),Rn],
                  registers)
             end
      else BadCode("LoadMultiple"))
   | LoadMultipleExceptionReturn
     (increment,(wordhigher,(wback,(Rn,registers)))) =>
     (if e = Enc_ARM
        then let
               val W = BitsN.fromBit wback
               val U = BitsN.fromBit increment
               val P =
                 BitsN.fromBit
                   (if wordhigher then increment else not increment)
             in
               ARM(BitsN.concat
                     [c,BitsN.B(0x4,3),P,U,BitsN.B(0x1,1),W,
                      BitsN.B(0x1,1),Rn,BitsN.B(0x1,1),registers])
             end
      else BadCode("LoadMultipleExceptionReturn"))
   | LoadMultipleUserRegisters(increment,(wordhigher,(Rn,registers))) =>
     (if e = Enc_ARM
        then let
               val U = BitsN.fromBit increment
               val P =
                 BitsN.fromBit
                   (if wordhigher then increment else not increment)
             in
               ARM(BitsN.concat
                     [c,BitsN.B(0x4,3),P,U,BitsN.B(0x5,3),Rn,
                      BitsN.B(0x0,1),registers])
             end
      else BadCode("LoadMultipleUserRegisters"))
   | LoadDual(add,(index,(wback,(Rt,(Rt2,(Rn,immediate_form2 imm32)))))) =>
     let
       val P = BitsN.fromBit index
       val U = BitsN.fromBit add
     in
       if e = Enc_ARM
         then if ((BitsN.+(Rt,BitsN.B(0x1,4))) = Rt2) andalso
                 (BitsN.<=+(imm32,BitsN.B(0xFF,32)))
                then let
                       val W = BitsN.fromBit(index andalso wback)
                       val imm4H = BitsN.bits(7,4) imm32
                       val imm4L = BitsN.bits(3,0) imm32
                     in
                       ARM(BitsN.concat
                             [c,BitsN.B(0x0,3),P,U,BitsN.B(0x1,1),W,
                              BitsN.B(0x0,1),Rn,Rt,imm4H,BitsN.B(0xD,4),
                              imm4L])
                     end
              else BadCode("LoadDual")
       else if (BitsN.<=+(imm32,BitsN.B(0x3FC,32))) andalso
          ((Aligned 32 (imm32,4)) andalso (not(e = Enc_Narrow)))
         then let
                val W = BitsN.fromBit wback
                val imm8 = BitsN.bits(9,2) imm32
              in
                Thumb2
                  (BitsN.concat
                     [BitsN.B(0x74,7),P,U,BitsN.B(0x1,1),W,BitsN.B(0x1,1),
                      Rn],BitsN.concat[Rt,Rt2,imm8])
              end
       else BadCode("LoadDual")
     end
   | LoadDual(add,(index,(wback,(Rt,(Rt2,(Rn,register_form2 Rm)))))) =>
     (if (e = Enc_ARM) andalso ((BitsN.+(Rt,BitsN.B(0x1,4))) = Rt2)
        then let
               val P = BitsN.fromBit index
               val U = BitsN.fromBit add
               val W = BitsN.fromBit(index andalso wback)
             in
               ARM(BitsN.concat
                     [c,BitsN.B(0x0,3),P,U,BitsN.B(0x0,1),W,
                      BitsN.B(0x0,1),Rn,Rt,BitsN.B(0xD,8),Rm])
             end
      else BadCode("LoadDual"))
   | LoadDualLiteral(add,(Rt,(Rt2,imm32))) =>
     let
       val U = BitsN.fromBit add
     in
       if e = Enc_ARM
         then if ((BitsN.+(Rt,BitsN.B(0x1,4))) = Rt2) andalso
                 (BitsN.<=+(imm32,BitsN.B(0xFF,32)))
                then let
                       val imm4H = BitsN.bits(7,4) imm32
                       val imm4L = BitsN.bits(3,0) imm32
                     in
                       ARM(BitsN.concat
                             [c,BitsN.B(0x1,4),U,BitsN.B(0x4F,7),Rt,imm4H,
                              BitsN.B(0xD,4),imm4L])
                     end
              else BadCode("LoadDualLiteral")
       else if (BitsN.<=+(imm32,BitsN.B(0x3FC,32))) andalso
          ((Aligned 32 (imm32,4)) andalso (not(e = Enc_Narrow)))
         then let
                val imm8 = BitsN.bits(9,2) imm32
              in
                Thumb2
                  (BitsN.concat[BitsN.B(0xE9,8),U,BitsN.B(0x5F,7)],
                   BitsN.concat[Rt,Rt2,imm8])
              end
       else BadCode("LoadDualLiteral")
     end
   | LoadExclusive(Rt,(Rn,imm32)) =>
     (if e = Enc_ARM
        then if imm32 = (BitsN.B(0x0,32))
               then ARM(BitsN.concat
                          [c,BitsN.B(0x19,8),Rn,Rt,BitsN.B(0xF9F,12)])
             else BadCode("LoadExclusive")
      else if (BitsN.<=+(imm32,BitsN.B(0x3FC,32))) andalso
         ((Aligned 32 (imm32,4)) andalso (not(e = Enc_Narrow)))
        then let
               val imm8 = BitsN.bits(9,2) imm32
             in
               Thumb2
                 (BitsN.@@(BitsN.B(0xE85,12),Rn),
                  BitsN.concat[Rt,BitsN.B(0xF,4),imm8])
             end
      else BadCode("LoadExclusive"))
   | LoadExclusiveByte(Rt,Rn) =>
     (if e = Enc_ARM
        then ARM(BitsN.concat[c,BitsN.B(0x1D,8),Rn,Rt,BitsN.B(0xF9F,12)])
      else if not(e = Enc_Narrow)
        then Thumb2
               (BitsN.@@(BitsN.B(0xE8D,12),Rn),
                BitsN.@@(Rt,BitsN.B(0xF4F,12)))
      else BadCode("LoadExclusiveByte"))
   | LoadExclusiveHalf(Rt,Rn) =>
     (if e = Enc_ARM
        then ARM(BitsN.concat[c,BitsN.B(0x1F,8),Rn,Rt,BitsN.B(0xF9F,12)])
      else if not(e = Enc_Narrow)
        then Thumb2
               (BitsN.@@(BitsN.B(0xE8D,12),Rn),
                BitsN.@@(Rt,BitsN.B(0xF5F,12)))
      else BadCode("LoadExclusiveHalf"))
   | LoadExclusiveDoubleword(Rt,(Rt2,Rn)) =>
     (if e = Enc_ARM
        then if (BitsN.+(Rt,BitsN.B(0x1,4))) = Rt2
               then ARM(BitsN.concat
                          [c,BitsN.B(0x1B,8),Rn,Rt,BitsN.B(0xF9F,12)])
             else BadCode("LoadExclusiveDoubleword")
      else if not(e = Enc_Narrow)
        then Thumb2
               (BitsN.@@(BitsN.B(0xE8D,12),Rn),
                BitsN.concat[Rt,Rt2,BitsN.B(0x7F,8)])
      else BadCode("LoadExclusiveDoubleword"));

fun e_store (c,(ast,e)) =
  case ast of
     StoreWord(_,(false,(false,_))) => BadCode("StoreWord")
   | StoreWord(add,(index,(wback,(t,(n,immediate_form1 imm32))))) =>
     (if e = Enc_ARM
        then if BitsN.<=+(imm32,BitsN.B(0xFFF,32))
               then let
                      val Rt = t
                      val Rn = n
                      val P = BitsN.fromBit index
                      val U = BitsN.fromBit add
                      val W = BitsN.fromBit(index andalso wback)
                      val imm12 = BitsN.bits(11,0) imm32
                    in
                      ARM(BitsN.concat
                            [c,BitsN.B(0x2,3),P,U,BitsN.B(0x0,1),W,
                             BitsN.B(0x0,1),Rn,Rt,imm12])
                    end
             else BadCode("StoreWord")
      else if index andalso (add andalso (not wback))
        then if (n = (BitsN.B(0xD,4))) andalso
                ((BitsN.<=+(imm32,BitsN.B(0x3FC,32))) andalso
                 ((Aligned 32 (imm32,4)) andalso
                  (not((BitsN.bit(t,3)) orelse (e = Enc_Wide)))))
               then let
                      val Rt = BitsN.bits(2,0) t
                      val imm8 = BitsN.bits(9,2) imm32
                    in
                      Thumb(BitsN.concat[BitsN.B(0x12,5),Rt,imm8])
                    end
             else if (BitsN.<=+(imm32,BitsN.B(0x7C,32))) andalso
                ((Aligned 32 (imm32,4)) andalso
                 (not((BitsN.bit(t,3)) orelse
                      ((BitsN.bit(n,3)) orelse (e = Enc_Wide)))))
               then let
                      val Rt = BitsN.bits(2,0) t
                      val Rn = BitsN.bits(2,0) n
                      val imm5 = BitsN.bits(6,2) imm32
                    in
                      Thumb(BitsN.concat[BitsN.B(0xC,5),imm5,Rn,Rt])
                    end
             else if (BitsN.<=+(imm32,BitsN.B(0xFFF,32))) andalso
                (not(e = Enc_Narrow))
               then let
                      val Rt = t
                      val Rn = n
                      val imm12 = BitsN.bits(11,0) imm32
                    in
                      Thumb2
                        (BitsN.@@(BitsN.B(0xF8C,12),Rn),BitsN.@@(Rt,imm12))
                    end
             else BadCode("StoreWord")
      else if (BitsN.<=+(imm32,BitsN.B(0xFF,32))) andalso
         (not(e = Enc_Narrow))
        then let
               val Rt = t
               val Rn = n
               val P = BitsN.fromBit index
               val U = BitsN.fromBit add
               val W = BitsN.fromBit wback
               val imm8 = BitsN.bits(7,0) imm32
             in
               Thumb2
                 (BitsN.@@(BitsN.B(0xF84,12),Rn),
                  BitsN.concat[Rt,BitsN.B(0x1,1),P,U,W,imm8])
             end
      else BadCode("StoreWord"))
   | StoreWord
     (add,(index,(wback,(t,(n,register_form1(m,(shift_t,shift_n))))))) =>
     let
       val (typ,imm5) = EncodeImmShift(shift_t,shift_n)
     in
       if e = Enc_ARM
         then let
                val Rn = n
                val Rt = t
                val Rm = m
                val P = BitsN.fromBit index
                val U = BitsN.fromBit add
                val W = BitsN.fromBit(index andalso wback)
              in
                ARM(BitsN.concat
                      [c,BitsN.B(0x3,3),P,U,BitsN.B(0x0,1),W,
                       BitsN.B(0x0,1),Rn,Rt,imm5,typ,BitsN.B(0x0,1),Rm])
              end
       else if (shift_t = SRType_LSL) andalso
          (index andalso (add andalso (not wback)))
         then if (shift_n = 0) andalso
                 (not((BitsN.bit(m,3)) orelse
                      ((BitsN.bit(n,3)) orelse
                       ((BitsN.bit(t,3)) orelse (e = Enc_Wide)))))
                then let
                       val Rm = BitsN.bits(2,0) m
                       val Rn = BitsN.bits(2,0) n
                       val Rt = BitsN.bits(2,0) t
                     in
                       Thumb(BitsN.concat[BitsN.B(0x28,7),Rm,Rn,Rt])
                     end
              else if (Nat.<(shift_n,4)) andalso (not(e = Enc_Narrow))
                then let
                       val Rn = n
                       val Rt = t
                       val Rm = m
                       val imm2 = BitsN.bits(1,0) imm5
                     in
                       Thumb2
                         (BitsN.@@(BitsN.B(0xF84,12),Rn),
                          BitsN.concat[Rt,BitsN.B(0x0,6),imm2,Rm])
                     end
              else BadCode("StoreWord")
       else BadCode("StoreWord")
     end
   | StoreUnprivileged(add,(postindex,(Rt,(Rn,immediate_form1 imm32)))) =>
     (if (e = Enc_ARM) andalso
         (postindex andalso (BitsN.<=+(imm32,BitsN.B(0xFFF,32))))
        then let
               val imm12 = BitsN.bits(11,0) imm32
               val U = BitsN.fromBit add
             in
               ARM(BitsN.concat
                     [c,BitsN.B(0x4,4),U,BitsN.B(0x2,3),Rn,Rt,imm12])
             end
      else if (Set.mem(e,[Enc_Thumb,Enc_Wide])) andalso
         (add andalso
          ((not postindex) andalso (BitsN.<=+(imm32,BitsN.B(0xFF,32)))))
        then let
               val imm8 = BitsN.bits(7,0) imm32
             in
               Thumb2
                 (BitsN.@@(BitsN.B(0xF84,12),Rn),
                  BitsN.concat[Rt,BitsN.B(0xE,4),imm8])
             end
      else BadCode("StoreUnprivileged"))
   | StoreUnprivileged
     (add,(postindex,(Rt,(Rn,register_form1(Rm,(shift_t,shift_n)))))) =>
     (if (e = Enc_ARM) andalso postindex
        then let
               val (typ,imm5) = EncodeImmShift(shift_t,shift_n)
               val U = BitsN.fromBit add
             in
               ARM(BitsN.concat
                     [c,BitsN.B(0x6,4),U,BitsN.B(0x2,3),Rn,Rt,imm5,typ,
                      BitsN.B(0x0,1),Rm])
             end
      else BadCode("StoreUnprivileged"))
   | StoreByte(_,(false,(false,_))) => BadCode("StoreByte")
   | StoreByte(add,(index,(wback,(t,(n,immediate_form1 imm32))))) =>
     (if e = Enc_ARM
        then if BitsN.<=+(imm32,BitsN.B(0xFFF,32))
               then let
                      val Rt = t
                      val Rn = n
                      val P = BitsN.fromBit index
                      val U = BitsN.fromBit add
                      val W = BitsN.fromBit(index andalso wback)
                      val imm12 = BitsN.bits(11,0) imm32
                    in
                      ARM(BitsN.concat
                            [c,BitsN.B(0x2,3),P,U,BitsN.B(0x1,1),W,
                             BitsN.B(0x0,1),Rn,Rt,imm12])
                    end
             else BadCode("StoreByte")
      else if index andalso (add andalso (not wback))
        then if (BitsN.<=+(imm32,BitsN.B(0x1F,32))) andalso
                (not((BitsN.bit(t,3)) orelse
                     ((BitsN.bit(n,3)) orelse (e = Enc_Wide))))
               then let
                      val Rt = BitsN.bits(2,0) t
                      val Rn = BitsN.bits(2,0) n
                      val imm5 = BitsN.bits(4,0) imm32
                    in
                      Thumb(BitsN.concat[BitsN.B(0xE,5),imm5,Rn,Rt])
                    end
             else if (BitsN.<=+(imm32,BitsN.B(0xFFF,32))) andalso
                (not(e = Enc_Narrow))
               then let
                      val Rt = t
                      val Rn = n
                      val imm12 = BitsN.bits(11,0) imm32
                    in
                      Thumb2
                        (BitsN.@@(BitsN.B(0xF88,12),Rn),BitsN.@@(Rt,imm12))
                    end
             else BadCode("StoreByte")
      else if (BitsN.<=+(imm32,BitsN.B(0xFF,32))) andalso
         (not(e = Enc_Narrow))
        then let
               val Rt = t
               val Rn = n
               val P = BitsN.fromBit index
               val U = BitsN.fromBit add
               val W = BitsN.fromBit wback
               val imm8 = BitsN.bits(7,0) imm32
             in
               Thumb2
                 (BitsN.@@(BitsN.B(0xF80,12),Rn),
                  BitsN.concat[Rt,BitsN.B(0x1,1),P,U,W,imm8])
             end
      else BadCode("StoreByte"))
   | StoreByte
     (add,(index,(wback,(t,(n,register_form1(m,(shift_t,shift_n))))))) =>
     let
       val (typ,imm5) = EncodeImmShift(shift_t,shift_n)
     in
       if e = Enc_ARM
         then let
                val Rt = t
                val Rn = n
                val Rm = m
                val P = BitsN.fromBit index
                val U = BitsN.fromBit add
                val W = BitsN.fromBit(index andalso wback)
              in
                ARM(BitsN.concat
                      [c,BitsN.B(0x3,3),P,U,BitsN.B(0x1,1),W,
                       BitsN.B(0x0,1),Rn,Rt,imm5,typ,BitsN.B(0x0,1),Rm])
              end
       else if (shift_t = SRType_LSL) andalso
          (index andalso (add andalso (not wback)))
         then if (shift_n = 0) andalso
                 (not((BitsN.bit(m,3)) orelse
                      ((BitsN.bit(n,3)) orelse
                       ((BitsN.bit(t,3)) orelse (e = Enc_Wide)))))
                then let
                       val Rm = BitsN.bits(2,0) m
                       val Rn = BitsN.bits(2,0) n
                       val Rt = BitsN.bits(2,0) t
                     in
                       Thumb(BitsN.concat[BitsN.B(0x2A,7),Rm,Rn,Rt])
                     end
              else if (Nat.<(shift_n,4)) andalso (not(e = Enc_Narrow))
                then let
                       val Rt = t
                       val Rn = n
                       val Rm = m
                       val imm2 = BitsN.bits(1,0) imm5
                     in
                       Thumb2
                         (BitsN.@@(BitsN.B(0xF80,12),Rn),
                          BitsN.concat[Rt,BitsN.B(0x0,6),imm2,Rm])
                     end
              else BadCode("StoreByte")
       else BadCode("StoreByte")
     end
   | StoreByteUnprivileged
     (add,(postindex,(Rt,(Rn,immediate_form1 imm32)))) =>
     (if (e = Enc_ARM) andalso
         (postindex andalso (BitsN.<=+(imm32,BitsN.B(0xFFF,32))))
        then let
               val imm12 = BitsN.bits(11,0) imm32
               val U = BitsN.fromBit add
             in
               ARM(BitsN.concat
                     [c,BitsN.B(0x4,4),U,BitsN.B(0x6,3),Rn,Rt,imm12])
             end
      else if (Set.mem(e,[Enc_Thumb,Enc_Wide])) andalso
         (add andalso
          ((not postindex) andalso (BitsN.<=+(imm32,BitsN.B(0xFF,32)))))
        then let
               val imm8 = BitsN.bits(7,0) imm32
             in
               Thumb2
                 (BitsN.@@(BitsN.B(0xF80,12),Rn),
                  BitsN.concat[Rt,BitsN.B(0xE,4),imm8])
             end
      else BadCode("StoreByteUnprivileged"))
   | StoreByteUnprivileged
     (add,(postindex,(Rt,(Rn,register_form1(Rm,(shift_t,shift_n)))))) =>
     (if (e = Enc_ARM) andalso postindex
        then let
               val (typ,imm5) = EncodeImmShift(shift_t,shift_n)
               val U = BitsN.fromBit add
             in
               ARM(BitsN.concat
                     [c,BitsN.B(0x6,4),U,BitsN.B(0x6,3),Rn,Rt,imm5,typ,
                      BitsN.B(0x0,1),Rm])
             end
      else BadCode("StoreByteUnprivileged"))
   | StoreHalf(_,(false,(false,_))) => BadCode("StoreHalf")
   | StoreHalf(add,(index,(wback,(t,(n,immediate_form1 imm32))))) =>
     (if e = Enc_ARM
        then if BitsN.<=+(imm32,BitsN.B(0xFF,32))
               then let
                      val Rt = t
                      val Rn = n
                      val P = BitsN.fromBit index
                      val U = BitsN.fromBit add
                      val W = BitsN.fromBit(index andalso wback)
                      val imm4H = BitsN.bits(7,4) imm32
                      val imm4L = BitsN.bits(3,0) imm32
                    in
                      ARM(BitsN.concat
                            [c,BitsN.B(0x0,3),P,U,BitsN.B(0x1,1),W,
                             BitsN.B(0x0,1),Rn,Rt,imm4H,BitsN.B(0xB,4),
                             imm4L])
                    end
             else BadCode("StoreHalf")
      else if index andalso (add andalso (not wback))
        then if (BitsN.<=+(imm32,BitsN.B(0x3E,32))) andalso
                ((Aligned 32 (imm32,2)) andalso
                 (not((BitsN.bit(t,3)) orelse
                      ((BitsN.bit(n,3)) orelse (e = Enc_Wide)))))
               then let
                      val Rt = BitsN.bits(2,0) t
                      val Rn = BitsN.bits(2,0) n
                      val imm5 = BitsN.bits(5,1) imm32
                    in
                      Thumb(BitsN.concat[BitsN.B(0x10,5),imm5,Rn,Rt])
                    end
             else if (BitsN.<=+(imm32,BitsN.B(0xFFF,32))) andalso
                (not(e = Enc_Narrow))
               then let
                      val Rt = t
                      val Rn = n
                      val imm12 = BitsN.bits(11,0) imm32
                    in
                      Thumb2
                        (BitsN.@@(BitsN.B(0xF8A,12),Rn),BitsN.@@(Rt,imm12))
                    end
             else BadCode("StoreHalf")
      else if (BitsN.<=+(imm32,BitsN.B(0xFF,32))) andalso
         (not(e = Enc_Narrow))
        then let
               val Rt = t
               val Rn = n
               val P = BitsN.fromBit index
               val U = BitsN.fromBit add
               val W = BitsN.fromBit wback
               val imm8 = BitsN.bits(7,0) imm32
             in
               Thumb2
                 (BitsN.@@(BitsN.B(0xF82,12),Rn),
                  BitsN.concat[Rt,BitsN.B(0x1,1),P,U,W,imm8])
             end
      else BadCode("StoreHalf"))
   | StoreHalf
     (add,(index,(wback,(t,(n,register_form1(m,(shift_t,shift_n))))))) =>
     (if e = Enc_ARM
        then if (shift_t = SRType_LSL) andalso (shift_n = 0)
               then let
                      val Rt = t
                      val Rn = n
                      val Rm = m
                      val P = BitsN.fromBit index
                      val U = BitsN.fromBit add
                      val W = BitsN.fromBit(index andalso wback)
                    in
                      ARM(BitsN.concat
                            [c,BitsN.B(0x0,3),P,U,BitsN.B(0x0,1),W,
                             BitsN.B(0x0,1),Rn,Rt,BitsN.B(0xB,8),Rm])
                    end
             else BadCode("StoreHalf")
      else if (shift_t = SRType_LSL) andalso
         (index andalso (add andalso (not wback)))
        then if (shift_n = 0) andalso
                (not((BitsN.bit(m,3)) orelse
                     ((BitsN.bit(n,3)) orelse
                      ((BitsN.bit(t,3)) orelse (e = Enc_Wide)))))
               then let
                      val Rm = BitsN.bits(2,0) m
                      val Rn = BitsN.bits(2,0) n
                      val Rt = BitsN.bits(2,0) t
                    in
                      Thumb(BitsN.concat[BitsN.B(0x29,7),Rm,Rn,Rt])
                    end
             else if (Nat.<(shift_n,4)) andalso (not(e = Enc_Narrow))
               then let
                      val Rt = t
                      val Rn = n
                      val Rm = m
                      val imm5 = BitsN.fromNat(shift_n,5)
                      val imm2 = BitsN.bits(1,0) imm5
                    in
                      Thumb2
                        (BitsN.@@(BitsN.B(0xF82,12),Rn),
                         BitsN.concat[Rt,BitsN.B(0x0,6),imm2,Rm])
                    end
             else BadCode("StoreHalf")
      else BadCode("StoreHalf"))
   | StoreHalfUnprivileged
     (add,(postindex,(Rt,(Rn,immediate_form2 imm32)))) =>
     let
       val U = BitsN.fromBit add
     in
       if BitsN.<+(BitsN.B(0xFF,32),imm32)
         then BadCode("StoreHalfUnprivileged: bad immediate")
       else if (e = Enc_ARM) andalso postindex
         then let
                val imm4H = BitsN.bits(7,4) imm32
                val imm4L = BitsN.bits(3,0) imm32
              in
                ARM(BitsN.concat
                      [c,BitsN.B(0x0,4),U,BitsN.B(0x6,3),Rn,Rt,imm4H,
                       BitsN.B(0xB,4),imm4L])
              end
       else if (Set.mem(e,[Enc_Thumb,Enc_Wide])) andalso
          (add andalso (not postindex))
         then let
                val imm8 = BitsN.bits(7,0) imm32
              in
                Thumb2
                  (BitsN.@@(BitsN.B(0xF82,12),Rn),
                   BitsN.concat[Rt,BitsN.B(0xE,4),imm8])
              end
       else BadCode("StoreHalfUnprivileged")
     end
   | StoreHalfUnprivileged(add,(postindex,(Rt,(Rn,register_form2 Rm)))) =>
     (if (e = Enc_ARM) andalso postindex
        then let
               val U = BitsN.fromBit add
             in
               ARM(BitsN.concat
                     [c,BitsN.B(0x0,4),U,BitsN.B(0x2,3),Rn,Rt,
                      BitsN.B(0xB,8),Rm])
             end
      else BadCode("StoreHalfUnprivileged"))
   | StoreMultiple(increment,(index,(wback,(n,registers)))) =>
     (if e = Enc_ARM
        then let
               val U = BitsN.fromBit increment
               val P = BitsN.fromBit index
               val W = BitsN.fromBit wback
               val Rn = n
             in
               ARM(BitsN.concat
                     [c,BitsN.B(0x4,3),P,U,BitsN.B(0x0,1),W,
                      BitsN.B(0x0,1),Rn,registers])
             end
      else if (n = (BitsN.B(0xD,4))) andalso
         ((not increment) andalso
          (index andalso
           (wback andalso
            ((not(BitsN.bit(registers,15))) andalso
             (((BitsN.bits(13,8) registers) = (BitsN.B(0x0,6))) andalso
              (not(e = Enc_Wide)))))))
        then let
               val M = BitsN.bits(14,14) registers
               val register_list = BitsN.bits(7,0) registers
             in
               Thumb(BitsN.concat[BitsN.B(0x5A,7),M,register_list])
             end
      else if (not(BitsN.bit(n,3))) andalso
         (increment andalso
          ((not index) andalso
           (wback andalso
            (((BitsN.bits(15,8) registers) = (BitsN.B(0x0,8))) andalso
             (not(e = Enc_Wide))))))
        then let
               val Rn = BitsN.bits(2,0) n
               val register_list = BitsN.bits(7,0) registers
             in
               Thumb(BitsN.concat[BitsN.B(0x18,5),Rn,register_list])
             end
      else if (not(increment = index)) andalso (not(e = Enc_Narrow))
        then let
               val Rn = n
               val U = BitsN.fromBit increment
               val P = BitsN.fromBit index
               val W = BitsN.fromBit wback
             in
               Thumb2
                 (BitsN.concat
                    [BitsN.B(0x74,7),P,U,BitsN.B(0x0,1),W,BitsN.B(0x0,1),
                     Rn],registers)
             end
      else BadCode("StoreHalfUnprivileged"))
   | StoreMultipleUserRegisters(increment,(wordhigher,(Rn,registers))) =>
     (if e = Enc_ARM
        then let
               val U = BitsN.fromBit increment
               val P =
                 BitsN.fromBit
                   (if wordhigher then increment else not increment)
             in
               ARM(BitsN.concat
                     [c,BitsN.B(0x4,3),P,U,BitsN.B(0x4,3),Rn,registers])
             end
      else BadCode("StoreMultipleUserRegisters"))
   | StoreDual(add,(index,(wback,(Rt,(Rt2,(Rn,immediate_form2 imm32)))))) =>
     let
       val P = BitsN.fromBit index
       val U = BitsN.fromBit add
     in
       if e = Enc_ARM
         then if ((BitsN.+(Rt,BitsN.B(0x1,4))) = Rt2) andalso
                 (BitsN.<=+(imm32,BitsN.B(0xFF,32)))
                then let
                       val W = BitsN.fromBit(index andalso wback)
                       val imm4H = BitsN.bits(7,4) imm32
                       val imm4L = BitsN.bits(3,0) imm32
                     in
                       ARM(BitsN.concat
                             [c,BitsN.B(0x0,3),P,U,BitsN.B(0x1,1),W,
                              BitsN.B(0x0,1),Rn,Rt,imm4H,BitsN.B(0xF,4),
                              imm4L])
                     end
              else BadCode("StoreDual")
       else if (BitsN.<=+(imm32,BitsN.B(0x3FC,32))) andalso
          ((Aligned 32 (imm32,4)) andalso (not(e = Enc_Narrow)))
         then let
                val W = BitsN.fromBit wback
                val imm8 = BitsN.bits(9,2) imm32
              in
                Thumb2
                  (BitsN.concat
                     [BitsN.B(0x74,7),P,U,BitsN.B(0x1,1),W,BitsN.B(0x0,1),
                      Rn],BitsN.concat[Rt,Rt2,imm8])
              end
       else BadCode("StoreDual")
     end
   | StoreDual(add,(index,(wback,(Rt,(Rt2,(Rn,register_form2 Rm)))))) =>
     (if (e = Enc_ARM) andalso ((BitsN.+(Rt,BitsN.B(0x1,4))) = Rt2)
        then let
               val P = BitsN.fromBit index
               val U = BitsN.fromBit add
               val W = BitsN.fromBit(index andalso wback)
             in
               ARM(BitsN.concat
                     [c,BitsN.B(0x0,3),P,U,BitsN.B(0x0,1),W,
                      BitsN.B(0x0,1),Rn,Rt,BitsN.B(0xF,8),Rm])
             end
      else BadCode("StoreDual"))
   | StoreExclusive(Rd,(Rt,(Rn,imm32))) =>
     (if e = Enc_ARM
        then if imm32 = (BitsN.B(0x0,32))
               then ARM(BitsN.concat
                          [c,BitsN.B(0x18,8),Rn,Rd,BitsN.B(0xF9,8),Rt])
             else BadCode("StoreExclusive")
      else if (BitsN.<=+(imm32,BitsN.B(0x3FC,32))) andalso
         ((Aligned 32 (imm32,4)) andalso (not(e = Enc_Narrow)))
        then let
               val imm8 = BitsN.bits(9,2) imm32
             in
               Thumb2
                 (BitsN.@@(BitsN.B(0xE84,12),Rn),BitsN.concat[Rt,Rd,imm8])
             end
      else BadCode("StoreExclusive"))
   | StoreExclusiveByte(Rd,(Rt,Rn)) =>
     (if e = Enc_ARM
        then ARM(BitsN.concat[c,BitsN.B(0x1C,8),Rn,Rd,BitsN.B(0xF9,8),Rt])
      else if not(e = Enc_Narrow)
        then Thumb2
               (BitsN.@@(BitsN.B(0xE8C,12),Rn),
                BitsN.concat[Rt,BitsN.B(0xF4,8),Rd])
      else BadCode("StoreExclusiveByte"))
   | StoreExclusiveHalf(Rd,(Rt,Rn)) =>
     (if e = Enc_ARM
        then ARM(BitsN.concat[c,BitsN.B(0x1E,8),Rn,Rd,BitsN.B(0xF9,8),Rt])
      else if not(e = Enc_Narrow)
        then Thumb2
               (BitsN.@@(BitsN.B(0xE8C,12),Rn),
                BitsN.concat[Rt,BitsN.B(0xF5,8),Rd])
      else BadCode("StoreExclusiveByte"))
   | StoreExclusiveDoubleword(Rd,(Rt,(Rt2,Rn))) =>
     (if e = Enc_ARM
        then if (BitsN.+(Rt,BitsN.B(0x1,4))) = Rt2
               then ARM(BitsN.concat
                          [c,BitsN.B(0x1A,8),Rn,Rd,BitsN.B(0xF9,8),Rt])
             else BadCode("StoreExclusiveDoubleword")
      else if not(e = Enc_Narrow)
        then Thumb2
               (BitsN.@@(BitsN.B(0xE8C,12),Rn),
                BitsN.concat[Rt,Rt2,BitsN.B(0x7,4),Rd])
      else BadCode("StoreExclusiveDoubleword"));

fun instructionEncode (c,(ast,e)) =
  case ast of
     Branch b => e_branch(c,(b,e))
   | Data d => e_data(c,(d,e))
   | Load l => e_load(c,(l,e))
   | Store s => e_store(c,(s,e))
   | Multiply m => e_multiply(c,(m,e))
   | Media m => e_media(c,(m,e))
   | SIMD m => e_simd(c,(m,e))
   | System s => e_system(c,(s,e))
   | Hint h => e_hint(c,(h,e))
   | VFP v => e_vfp(c,(v,e))
   | IfThen(firstcond,mask) =>
     (if Set.mem(e,[Enc_Thumb,Enc_Narrow])
        then Thumb(BitsN.concat[BitsN.B(0xBF,8),firstcond,mask])
      else BadCode("IfThen"))
   | Divide(unsigned,(Rd,(Rn,Rm))) =>
     (if Set.mem(e,[Enc_Thumb,Enc_Wide])
        then let
               val U = BitsN.fromBit unsigned
             in
               Thumb2
                 (BitsN.concat[BitsN.B(0x3EE,10),U,BitsN.B(0x1,1),Rn],
                  BitsN.concat[BitsN.B(0xF,4),Rd,BitsN.B(0xF,4),Rm])
             end
      else BadCode("Divide"))
   | ClearExclusive =>
     if e = Enc_ARM
       then if c = (BitsN.B(0xE,4))
              then ARM(BitsN.B(0xF57FF01F,32))
            else BadCode("ClearExclusive")
     else if not(e = Enc_Narrow)
       then Thumb2(BitsN.B(0xF3BF,16),BitsN.B(0x8F2F,16))
     else BadCode("ClearExclusive")
   | Swap(byte,(Rt,(Rt2,Rn))) =>
     (if e = Enc_ARM
        then let
               val B = BitsN.fromBit byte
             in
               ARM(BitsN.concat
                     [c,BitsN.B(0x2,5),B,BitsN.B(0x0,2),Rn,Rt,
                      BitsN.B(0x9,8),Rt2])
             end
      else BadCode("Swap"))
   | Undefined imm32 =>
     (if e = Enc_ARM
        then let
               val imm12 = BitsN.bits(15,4) imm32
               val imm4 = BitsN.bits(3,0) imm32
             in
               ARM(BitsN.concat
                     [BitsN.B(0xE7F,12),imm12,BitsN.B(0xF,4),imm4])
             end
      else if (not(e = Enc_Wide)) andalso
         ((BitsN.bits(31,8) imm32) = (BitsN.B(0x0,24)))
        then let
               val imm8 = BitsN.bits(7,0) imm32
             in
               Thumb(BitsN.@@(BitsN.B(0xDE,8),imm8))
             end
      else if not(e = Enc_Narrow)
        then let
               val imm4 = BitsN.bits(15,12) imm32
               val imm12 = BitsN.bits(11,0) imm32
             in
               Thumb2
                 (BitsN.@@(BitsN.B(0xF7F,12),imm4),
                  BitsN.@@(BitsN.B(0xA,4),imm12))
             end
      else BadCode("Undefined"))
   | NoOperation =>
     if e = Enc_ARM
       then ARM(BitsN.@@(c,BitsN.B(0x320F000,28)))
     else if e = Enc_Wide
       then Thumb2(BitsN.B(0xF3AF,16),BitsN.B(0x8000,16))
     else Thumb(BitsN.B(0xBF00,16));

fun SetPassCondition c =
  case c of
     BitsN.B(0x0,_) => CPSR := (PSR_Z_rupd((!CPSR),true))
   | BitsN.B(0x1,_) => CPSR := (PSR_Z_rupd((!CPSR),false))
   | BitsN.B(0x2,_) => CPSR := (PSR_C_rupd((!CPSR),true))
   | BitsN.B(0x3,_) => CPSR := (PSR_C_rupd((!CPSR),false))
   | BitsN.B(0x4,_) => CPSR := (PSR_N_rupd((!CPSR),true))
   | BitsN.B(0x5,_) => CPSR := (PSR_N_rupd((!CPSR),false))
   | BitsN.B(0x6,_) => CPSR := (PSR_V_rupd((!CPSR),true))
   | BitsN.B(0x7,_) => CPSR := (PSR_V_rupd((!CPSR),false))
   | BitsN.B(0x8,_) =>
     ( CPSR := (PSR_C_rupd((!CPSR),true))
     ; CPSR := (PSR_Z_rupd((!CPSR),false))
     )
   | BitsN.B(0x9,_) => CPSR := (PSR_C_rupd((!CPSR),false))
   | BitsN.B(0xA,_) =>
     ( CPSR := (PSR_N_rupd((!CPSR),false))
     ; CPSR := (PSR_V_rupd((!CPSR),false))
     )
   | BitsN.B(0xB,_) =>
     ( CPSR := (PSR_N_rupd((!CPSR),false))
     ; CPSR := (PSR_V_rupd((!CPSR),true))
     )
   | BitsN.B(0xC,_) =>
     ( CPSR := (PSR_N_rupd((!CPSR),false))
     ; CPSR := (PSR_V_rupd((!CPSR),false))
     ; CPSR := (PSR_Z_rupd((!CPSR),false))
     )
   | BitsN.B(0xD,_) =>
     ( CPSR := (PSR_N_rupd((!CPSR),false))
     ; CPSR := (PSR_V_rupd((!CPSR),true))
     )
   | _ => ();

fun Encode (c,(ast,enc)) =
  let
    val mc = instructionEncode(c,(ast,enc))
  in
    ( case mc of
         ARM _ => Encoding := Encoding_ARM
       | Thumb2 _ => Encoding := Encoding_Thumb2
       | Thumb _ => Encoding := Encoding_Thumb
       | ThumbEE _ => Encoding := Encoding_Thumb
       | BadCode _ => ()
    ; SetPassCondition c
    ; if ((Decode mc) = ast) andalso
         (((!CurrentCondition) = c) orelse
          (((!CurrentCondition) = (BitsN.B(0xE,4))) andalso
           (c = (BitsN.B(0xF,4)))))
        then mc
      else BadCode("Does not decode to the same instruction")
    )
  end;

val al = (BitsN.B(0xE,4),"")

fun stripSpaces s =
  L3.fst
    (L3.splitr
       (fn c => Char.isSpace c,L3.snd(L3.splitl(fn c => Char.isSpace c,s))));

fun p_number s =
  case String.explode(stripSpaces s) of
     #"0" :: (#"b" :: t) => Nat.fromBinString(String.implode t)
   | #"0" :: (#"x" :: t) => Nat.fromHexString(String.implode t)
   | _ => Nat.fromString s;

fun p_signed_number (b,s) =
  case p_number s of Option.SOME n => Option.SOME(b,n) | NONE => NONE;

fun p_encode_immediate N s =
  case p_number s of
     Option.SOME n =>
       let
         val r = BitsN.fromNat(n,N)
       in
         Option.SOME(n = (BitsN.toNat r),r)
       end
   | NONE => NONE;

fun p_encode_signed_immediate N x =
  case p_signed_number x of
     Option.SOME(sub,n) =>
       let
         val r = BitsN.fromNat(n,N)
       in
         Option.SOME(sub,(n = (BitsN.toNat r),r))
       end
   | NONE => NONE;

fun p_encode_signed_immediate_offset N x =
  case p_signed_number x of
     Option.SOME(sub,n) =>
       let
         val (sub,n) =
           if sub
             then (true,Nat.+(n,8))
           else if Nat.<(n,8)
             then (true,Nat.-(8,n))
           else (false,Nat.-(n,8))
         val r = BitsN.fromNat(n,N)
       in
         Option.SOME(sub,(n = (BitsN.toNat r),r))
       end
   | NONE => NONE;

fun p_encode_signed_offset N x =
  case p_signed_number x of
     Option.SOME(sub,n) =>
       let
         val i =
           IntInf.-(if sub then IntInf.~(Nat.toInt n) else Nat.toInt n,8)
         val r = BitsN.fromInt(i,N)
       in
         Option.SOME(i = (BitsN.toInt r),r)
       end
   | NONE => NONE;

fun p_unbounded_immediate s =
  case String.explode(stripSpaces s) of
     #"#" :: t => p_number(String.implode t)
   | _ => NONE;

fun p_immediate N s =
  case String.explode(stripSpaces s) of
     #"#" :: t => p_encode_immediate N (String.implode t)
   | _ => NONE;

fun p_immediate_number N s =
  case String.explode(stripSpaces s) of
     #"#" :: t => p_encode_immediate N (String.implode t)
   | t => p_encode_immediate N (String.implode t);

fun p_signed_immediate N s =
  case String.explode(stripSpaces s) of
     #"#" :: (#"-" :: t) =>
       p_encode_signed_immediate N (true,String.implode t)
   | #"#" :: (#"+" :: t) =>
     p_encode_signed_immediate N (false,String.implode t)
   | #"#" :: t => p_encode_signed_immediate N (false,String.implode t)
   | _ => NONE;

fun p_signed_offset N s =
  case String.explode(stripSpaces s) of
     #"-" :: (#"#" :: t) =>
       p_encode_signed_immediate_offset N (true,String.implode t)
   | #"+" :: (#"#" :: t) =>
     p_encode_signed_immediate_offset N (false,String.implode t)
   | _ => NONE;

fun p_offset N s =
  case String.explode(stripSpaces s) of
     #"-" :: (#"#" :: t) =>
       p_encode_signed_offset N (true,String.implode t)
   | #"+" :: (#"#" :: t) =>
     p_encode_signed_offset N (false,String.implode t)
   | _ => NONE;

fun p_arm_immediate s =
  case p_immediate 32 s of
     Option.SOME(true,imm32) =>
       (case EncodeARMImmediate imm32 of
           Option.SOME imm12 => Option.SOME("",imm12)
         | NONE => Option.SOME("immediate not encodable",BitsN.B(0x0,12)))
   | Option.SOME(false,_) =>
     Option.SOME("immediate too large",BitsN.B(0x0,12))
   | NONE => NONE;

fun p_arm_fp_immediate (single,s) =
  case p_immediate 64 s of
     Option.SOME(true,imm64) => Option.SOME("",imm64)
   | Option.SOME(false,_) =>
     Option.SOME("FP immediate too large",BitsN.B(0x0,64))
   | NONE =>
     (case p_encode_immediate 8 s of
         Option.SOME(true,w) => Option.SOME("",VFPExpandImm(w,single))
       | Option.SOME(false,_) =>
         Option.SOME("FP too large",BitsN.B(0x0,64))
       | NONE => NONE);

fun p_range_imm (mn,(mx,s)) =
  case String.explode(stripSpaces s) of
     #"#" :: t =>
       (case p_number(String.implode t) of
           Option.SOME n =>
             (if (Nat.<=(mn,n)) andalso (Nat.<=(n,mx))
                then ("",n)
              else (String.concat
                      ["immediate not in range ",Nat.toString mn," to ",
                       Nat.toString mx],0))
         | NONE => ("syntax error",0))
   | _ => ("syntax error",0);

fun p_label s =
  case L3.uncurry String.tokens (fn c => Char.isSpace c,s) of
     [t] =>
       let
         val (l,r) =
           L3.splitl
             (fn c => (Char.isAlphaNum c) orelse (Set.mem(c,[#"_",#"."])),
              t)
       in
         if (r = ("")) andalso
            ((not(l = (""))) andalso (not(Char.isDigit(L3.strHd l))))
           then Option.SOME l
         else NONE
       end
   | _ => NONE;

fun p_cond s =
  case s of
     "eq" => Option.SOME(BitsN.B(0x0,4))
   | "ne" => Option.SOME(BitsN.B(0x1,4))
   | "cs" => Option.SOME(BitsN.B(0x2,4))
   | "hs" => Option.SOME(BitsN.B(0x2,4))
   | "cc" => Option.SOME(BitsN.B(0x3,4))
   | "lo" => Option.SOME(BitsN.B(0x3,4))
   | "mi" => Option.SOME(BitsN.B(0x4,4))
   | "pl" => Option.SOME(BitsN.B(0x5,4))
   | "vs" => Option.SOME(BitsN.B(0x6,4))
   | "vc" => Option.SOME(BitsN.B(0x7,4))
   | "hi" => Option.SOME(BitsN.B(0x8,4))
   | "ls" => Option.SOME(BitsN.B(0x9,4))
   | "ge" => Option.SOME(BitsN.B(0xA,4))
   | "lt" => Option.SOME(BitsN.B(0xB,4))
   | "gt" => Option.SOME(BitsN.B(0xC,4))
   | "le" => Option.SOME(BitsN.B(0xD,4))
   | "al" => Option.SOME(BitsN.B(0xE,4))
   | "" => Option.SOME(BitsN.B(0xE,4))
   | _ => NONE;

fun p_suffix s =
  case L3.uncurry String.fields (fn c => c = #".",s) of
     [cond,s] =>
       (case (p_cond cond,
         Set.mem(s,["w","n","f32","f64","32","64","s32","u32"])) of
           (Option.SOME c,true) => Option.SOME(c,s)
         | _ => NONE)
   | [cond] =>
     (case p_cond cond of
         Option.SOME c => Option.SOME(c,"")
       | NONE => NONE)
   | _ => NONE;

fun p_suffix2 s =
  case L3.uncurry String.fields (fn c => c = #".",s) of
     [cond,s1,s2] =>
       (case (p_cond cond,
         (Set.mem(s1,["f32","f64","s32","u32"])) andalso
         (Set.mem(s2,["f32","f64","s32","u32"]))) of
           (Option.SOME c,true) => Option.SOME(c,(s1,s2))
         | _ => NONE)
   | _ => NONE;

fun p_register s =
  case stripSpaces s of
     "r0" => Option.SOME(BitsN.B(0x0,4))
   | "r1" => Option.SOME(BitsN.B(0x1,4))
   | "r2" => Option.SOME(BitsN.B(0x2,4))
   | "r3" => Option.SOME(BitsN.B(0x3,4))
   | "r4" => Option.SOME(BitsN.B(0x4,4))
   | "r5" => Option.SOME(BitsN.B(0x5,4))
   | "r6" => Option.SOME(BitsN.B(0x6,4))
   | "r7" => Option.SOME(BitsN.B(0x7,4))
   | "r8" => Option.SOME(BitsN.B(0x8,4))
   | "r9" => Option.SOME(BitsN.B(0x9,4))
   | "r10" => Option.SOME(BitsN.B(0xA,4))
   | "r11" => Option.SOME(BitsN.B(0xB,4))
   | "r12" => Option.SOME(BitsN.B(0xC,4))
   | "r13" => Option.SOME(BitsN.B(0xD,4))
   | "r14" => Option.SOME(BitsN.B(0xE,4))
   | "r15" => Option.SOME(BitsN.B(0xF,4))
   | "sp" => Option.SOME(BitsN.B(0xD,4))
   | "lr" => Option.SOME(BitsN.B(0xE,4))
   | "pc" => Option.SOME(BitsN.B(0xF,4))
   | _ => NONE;

fun p_register1 l = case l of [r1] => p_register r1 | _ => NONE;

fun p_register2 l =
  case l of
     [r1,r2] =>
       (case (p_register r1,p_register r2) of
           (Option.SOME v1,Option.SOME v2) => Option.SOME(v1,v2)
         | _ => NONE)
   | _ => NONE;

fun p_register3 l =
  case l of
     [r1,r2,r3] =>
       (case (p_register r1,(p_register r2,p_register r3)) of
           (Option.SOME v1,(Option.SOME v2,Option.SOME v3)) =>
             Option.SOME(v1,(v2,v3))
         | _ => NONE)
   | _ => NONE;

fun p_register4 l =
  case l of
     [r1,r2,r3,r4] =>
       (case (p_register r1,(p_register r2,(p_register r3,p_register r4))) of
           (Option.SOME v1,
            (Option.SOME v2,(Option.SOME v3,Option.SOME v4))) =>
             Option.SOME(v1,(v2,(v3,v4)))
         | _ => NONE)
   | _ => NONE;

fun p_reg_offset (sub,s) =
  case p_register s of Option.SOME r => Option.SOME(sub,r) | NONE => NONE;

fun p_register_offset s =
  case String.explode(stripSpaces s) of
     #"-" :: t => p_reg_offset(false,String.implode t)
   | #"+" :: t => p_reg_offset(true,String.implode t)
   | t => p_reg_offset(true,String.implode t);

fun p_fp_register (single,s) =
  case (String.explode(stripSpaces s),single) of
     (#"s" :: r,true) =>
       (case Nat.fromString(String.implode r) of
           Option.SOME n =>
             (if Nat.<(n,32)
                then Option.SOME(BitsN.fromNat(n,5))
              else NONE)
         | NONE => NONE)
   | (#"d" :: r,false) =>
     (case Nat.fromString(String.implode r) of
         Option.SOME n =>
           (if Nat.<(n,32) then Option.SOME(BitsN.fromNat(n,5)) else NONE)
       | NONE => NONE)
   | _ => NONE;

fun p_any_fp_register (s,t) =
  case (p_fp_register(true,s),Set.mem(t,["","32"])) of
     (Option.SOME r,true) => Option.SOME(true,r)
   | _ =>
     (case (p_fp_register(false,s),Set.mem(t,["","64"])) of
         (Option.SOME r,true) => Option.SOME(false,r)
       | _ => NONE);

fun p_fp_register3 (single,l) =
  case l of
     [r1,r2,r3] =>
       (case (p_fp_register(single,r1),
         (p_fp_register(single,r2),p_fp_register(single,r3))) of
           (Option.SOME v1,(Option.SOME v2,Option.SOME v3)) =>
             Option.SOME(v1,(v2,v3))
         | _ => NONE)
   | _ => NONE;

fun closingRegList s =
  let
    val (l,caret) = L3.splitr(fn c => c = #"^",stripSpaces s)
    val (l,r) = L3.splitr(fn c => c = #"}",stripSpaces l)
  in
    if (r = ("}")) andalso (Nat.<(L3.size caret,2))
      then Option.SOME(caret = ("^"),l)
    else NONE
  end;

fun p_reg_list (w,s) =
  case p_register s of
     Option.SOME r =>
       let
         val n = BitsN.toNat r
       in
         if BitsN.bit(w,n)
           then NONE
         else Option.SOME(BitsN.||(w,BitsN.<<(BitsN.B(0x1,16),n)))
       end
   | NONE =>
     (case L3.uncurry String.fields (fn c => c = #"-",s) of
         [r1,r2] =>
           (case p_register2[r1,r2] of
               Option.SOME(rlo,rhi) =>
                 let
                   val lo = BitsN.toNat rlo
                   val hi = BitsN.toNat rhi
                   val mask =
                     BitsN.-
                       (BitsN.<<(BitsN.B(0x1,16),Nat.+(hi,1)),
                        BitsN.<<(BitsN.B(0x1,16),lo))
                 in
                   if (Nat.<(lo,hi)) andalso
                      ((BitsN.&&(w,mask)) = (BitsN.B(0x0,16)))
                     then Option.SOME(BitsN.||(w,mask))
                   else NONE
                 end
             | NONE => NONE)
       | _ => NONE);

fun p_registers_loop (w,l) =
  case l of
     [s] =>
       (case closingRegList s of
           Option.SOME(caret,h) =>
             (case p_reg_list(w,h) of
                 Option.SOME r => Option.SOME(caret,r)
               | NONE => NONE)
         | NONE => NONE)
   | h :: t =>
     (case p_reg_list(w,h) of
         Option.SOME r => p_registers_loop(r,t)
       | NONE => NONE)
   | [] => NONE;

fun p_registers l =
  case l of
     h :: t =>
       (case String.explode(stripSpaces h) of
           #"{" :: r =>
             let
               val r = stripSpaces(String.implode r)
             in
               p_registers_loop
                 (BitsN.B(0x0,16),if r = ("") then t else r :: t)
             end
         | _ => NONE)
   | _ => NONE;

fun p_fp_reg_list (single,(w,s)) =
  case p_fp_register(single,s) of
     Option.SOME r =>
       let
         val n = BitsN.toNat r
       in
         if BitsN.bit(w,n)
           then NONE
         else Option.SOME(BitsN.||(w,BitsN.<<(BitsN.B(0x1,32),n)))
       end
   | NONE =>
     (case L3.uncurry String.fields (fn c => c = #"-",s) of
         [r1,r2] =>
           (case (p_fp_register(single,r1),p_fp_register(single,r2)) of
               (Option.SOME rlo,Option.SOME rhi) =>
                 let
                   val lo = BitsN.toNat rlo
                   val hi = BitsN.toNat rhi
                   val mask =
                     BitsN.-
                       (BitsN.<<(BitsN.B(0x1,32),Nat.+(hi,1)),
                        BitsN.<<(BitsN.B(0x1,32),lo))
                 in
                   if (Nat.<(lo,hi)) andalso
                      ((BitsN.&&(w,mask)) = (BitsN.B(0x0,32)))
                     then Option.SOME(BitsN.||(w,mask))
                   else NONE
                 end
             | _ => NONE)
       | _ => NONE);

fun p_fp_registers_loop (single,(w,l)) =
  case l of
     [s] =>
       (case closingRegList s of
           Option.SOME(false,h) =>
             (case p_fp_reg_list(single,(w,h)) of
                 Option.SOME r => Option.SOME r
               | NONE => NONE)
         | _ => NONE)
   | h :: t =>
     (case p_fp_reg_list(single,(w,h)) of
         Option.SOME r => p_fp_registers_loop(single,(r,t))
       | NONE => NONE)
   | [] => NONE;

fun fp_reg_list (single,imm32) =
  if imm32 = (BitsN.B(0x0,32))
    then NONE
  else let
         val lo = LowestSetBit 32 imm32
         val hi = Nat.fromInt(HighestSetBit 32 imm32)
         val n = Nat.-(Nat.+(hi,1),lo)
       in
         if imm32 =
            (BitsN.<<
               (BitsN.-(BitsN.<<(BitsN.B(0x1,32),n),BitsN.B(0x1,32)),lo))
           then Option.SOME
                  (single,
                   (BitsN.fromNat(lo,5),
                    BitsN.fromNat(if single then n else Nat.*(n,2),8)))
         else NONE
       end;

fun p_fp_registers l =
  case l of
     h :: t =>
       (case String.explode(stripSpaces h) of
           #"{" :: r =>
             let
               val r = stripSpaces(String.implode r)
               val l = if r = ("") then t else r :: t
             in
               case p_fp_registers_loop(true,(BitsN.B(0x0,32),l)) of
                  Option.SOME imm32 => fp_reg_list(true,imm32)
                | NONE =>
                  (case p_fp_registers_loop(false,(BitsN.B(0x0,32),l)) of
                      Option.SOME imm32 => fp_reg_list(false,imm32)
                    | NONE => NONE)
             end
         | _ => NONE)
   | _ => NONE;

fun p_shift_amount (typ,(h,s)) =
  if Char.isSpace h
    then case p_unbounded_immediate s of
            Option.SOME n =>
              (if (Nat.<(n,32)) orelse
                  ((n = 32) andalso (Set.mem(typ,[SRType_LSR,SRType_ASR])))
                 then ("",(typ,NAT n))
               else ("shift amount too large",(SRType_LSL,NAT 0)))
          | NONE =>
            (case p_register s of
                Option.SOME rs => ("",(typ,REGISTER rs))
              | NONE => ("syntax error",(SRType_LSL,NAT 0)))
  else ("syntax error",(SRType_LSL,NAT 0));

fun p_shift_imm_or_reg s =
  case String.explode(stripSpaces s) of
     [#"r",#"r",#"x"] => ("",(SRType_RRX,NAT 1))
   | #"l" :: (#"s" :: (#"l" :: (h :: t))) =>
     p_shift_amount(SRType_LSL,(h,String.implode t))
   | #"l" :: (#"s" :: (#"r" :: (h :: t))) =>
     p_shift_amount(SRType_LSR,(h,String.implode t))
   | #"a" :: (#"s" :: (#"r" :: (h :: t))) =>
     p_shift_amount(SRType_ASR,(h,String.implode t))
   | #"r" :: (#"o" :: (#"r" :: (h :: t))) =>
     p_shift_amount(SRType_ROR,(h,String.implode t))
   | _ => ("syntax error",(SRType_LSL,NAT 0));

fun p_rotation s =
  case String.explode(stripSpaces s) of
     #"r" :: (#"o" :: (#"r" :: (h :: t))) =>
       (if Char.isSpace h
          then case p_unbounded_immediate(String.implode t) of
                  Option.SOME n =>
                    (if Set.mem(n,[0,8,16,24])
                       then ("",n)
                     else ("rotation not 0, 8, 16 or 24",0))
                | NONE => ("syntax error",0)
        else ("syntax error",0))
   | _ => ("syntax error",0);

fun p_arith_logic_full (c,(opc,(setflags,l))) =
  case (p_suffix c,l) of
     (Option.SOME c,[r1,r2,x]) =>
       (case p_register2[r1,r2] of
           Option.SOME(rd,rn) =>
             (case p_register x of
                 Option.SOME rm =>
                   OK(c,
                      Data
                        (Register
                           (opc,(setflags,(rd,(rn,(rm,(SRType_LSL,0))))))))
               | NONE =>
                 (case p_arm_immediate x of
                     Option.SOME("",imm12) =>
                       OK(c,
                          Data
                            (ArithLogicImmediate
                               (opc,(setflags,(rd,(rn,imm12))))))
                   | Option.SOME(s,_) => FAIL s
                   | NONE => FAIL("syntax error")))
         | NONE => FAIL("syntax error"))
   | (Option.SOME c,[r1,r2,r3,sh]) =>
     (case (p_register3[r1,r2,r3],p_shift_imm_or_reg sh) of
         (Option.SOME(rd,(rn,rm)),("",(typ,NAT n))) =>
           OK(c,Data(Register(opc,(setflags,(rd,(rn,(rm,(typ,n))))))))
       | (Option.SOME(rd,(rn,rm)),("",(typ,REGISTER rs))) =>
         OK(c,
            Data
              (RegisterShiftedRegister
                 (opc,(setflags,(rd,(rn,(rm,(typ,rs))))))))
       | (Option.SOME _,(err,_)) => FAIL err
       | _ => FAIL("syntax error"))
   | _ => FAIL("syntax error");

fun p_arith_logic (c,(opc,(setflags,l))) =
  case l of
     h :: _ =>
       (case p_arith_logic_full(c,(opc,(setflags,l))) of
           FAIL("syntax error") =>
             p_arith_logic_full(c,(opc,(setflags,h :: l)))
         | r => r)
   | [] => FAIL("syntax error");

fun p_test_compare (c,(opc,l)) =
  case (p_suffix c,l) of
     (Option.SOME c,[r1,x]) =>
       (case p_register r1 of
           Option.SOME rn =>
             (case p_register x of
                 Option.SOME rm =>
                   OK(c,
                      Data
                        (TestCompareRegister(opc,(rn,(rm,(SRType_LSL,0))))))
               | NONE =>
                 (case p_arm_immediate x of
                     Option.SOME("",imm12) =>
                       OK(c,Data(TestCompareImmediate(opc,(rn,imm12))))
                   | Option.SOME(s,_) => FAIL s
                   | NONE => FAIL("syntax error")))
         | NONE => FAIL("syntax error"))
   | (Option.SOME c,[r1,r2,sh]) =>
     (case (p_register2[r1,r2],p_shift_imm_or_reg sh) of
         (Option.SOME(rn,rm),("",(typ,NAT n))) =>
           OK(c,Data(TestCompareRegister(opc,(rn,(rm,(typ,n))))))
       | (Option.SOME(rn,rm),("",(typ,REGISTER rs))) =>
         OK(c,
            Data
              (RegisterShiftedRegister
                 (BitsN.@@(BitsN.B(0x2,2),opc),
                  (true,(BitsN.B(0x0,4),(rn,(rm,(typ,rs))))))))
       | (Option.SOME _,(err,_)) => FAIL err
       | _ => FAIL("syntax error"))
   | _ => FAIL("syntax error");

fun p_mov_mvn (c,(negate,(setflags,l))) =
  case (p_suffix c,l) of
     (Option.SOME c,[r1,x]) =>
       (case p_register r1 of
           Option.SOME rd =>
             (case p_register x of
                 Option.SOME rm =>
                   OK(c,
                      Data
                        (ShiftImmediate
                           (negate,(setflags,(rd,(rm,(SRType_LSL,0)))))))
               | NONE =>
                 (case p_arm_immediate x of
                     Option.SOME("",imm12) =>
                       OK(c,Data(Move(setflags,(negate,(rd,imm12)))))
                   | Option.SOME(s,_) => FAIL s
                   | NONE => FAIL("syntax error")))
         | NONE => FAIL("syntax error"))
   | (Option.SOME c,[r1,r2,sh]) =>
     (case (p_register2[r1,r2],p_shift_imm_or_reg sh) of
         (Option.SOME(rd,rm),("",(typ,NAT n))) =>
           OK(c,Data(ShiftImmediate(negate,(setflags,(rd,(rm,(typ,n)))))))
       | (Option.SOME(rd,rm),("",(typ,REGISTER rs))) =>
         OK(c,Data(ShiftRegister(negate,(setflags,(rd,(rm,(typ,rs)))))))
       | (Option.SOME _,(err,_)) => FAIL err
       | _ => FAIL("syntax error"))
   | _ => FAIL("syntax error");

fun p_shift_full (c,(typ,(setflags,l))) =
  case (p_suffix c,l) of
     (Option.SOME c,[r1,r2,s]) =>
       (case p_register2[r1,r2] of
           Option.SOME(rd,rn) =>
             (case p_register s of
                 Option.SOME rm =>
                   OK(c,
                      Data
                        (ShiftRegister
                           (false,(setflags,(rd,(rn,(typ,rm)))))))
               | NONE =>
                 (case p_unbounded_immediate s of
                     Option.SOME n =>
                       (if (Nat.<(n,32)) orelse
                           ((n = 32) andalso
                            (Set.mem(typ,[SRType_LSR,SRType_ASR])))
                          then OK(c,
                                  Data
                                    (ShiftImmediate
                                       (false,(setflags,(rd,(rn,(typ,n)))))))
                        else FAIL("shift amount too large"))
                   | NONE => FAIL("syntax error")))
         | NONE => FAIL("syntax error"))
   | _ => FAIL("syntax error");

fun p_shift (c,(typ,(setflags,l))) =
  case l of
     h :: _ =>
       (case p_shift_full(c,(typ,(setflags,l))) of
           FAIL("syntax error") => p_shift_full(c,(typ,(setflags,h :: l)))
         | r => r)
   | [] => FAIL("syntax error");

fun p_rrx (c,(setflags,l)) =
  case (p_suffix c,p_register2 l) of
     (Option.SOME c,Option.SOME(d,m)) =>
       OK(c,Data(ShiftImmediate(false,(setflags,(d,(m,(SRType_RRX,1)))))))
   | _ => FAIL("syntax error");

fun p_adr (c,l) =
  case (p_suffix c,l) of
     (Option.SOME c,[r,n]) =>
       (case p_register r of
           Option.SOME d =>
             (case p_signed_offset 32 n of
                 Option.SOME(sub,(true,imm32)) =>
                   (case EncodeARMImmediate imm32 of
                       Option.SOME imm12 =>
                         OK(c,
                            Data
                              (ArithLogicImmediate
                                 (if sub
                                    then BitsN.B(0x2,4)
                                  else BitsN.B(0x4,4),
                                  (false,(d,(BitsN.B(0xF,4),imm12))))))
                     | NONE => FAIL("offset not encodable"))
               | Option.SOME _ => FAIL("bad offset")
               | NONE =>
                 (case p_label n of
                     Option.SOME s =>
                       PENDING
                         (s,
                          (c,
                           Data
                             (ArithLogicImmediate
                                (BitsN.B(0x4,4),
                                 (false,
                                  (d,(BitsN.B(0xF,4),BitsN.B(0x0,12))))))))
                   | NONE => FAIL("syntax error")))
         | NONE => FAIL("syntax error"))
   | _ => FAIL("syntax error");

fun p_bx (c,l) =
  case (p_suffix c,p_register1 l) of
     (Option.SOME c,Option.SOME rm) => OK(c,Branch(BranchExchange rm))
   | _ => FAIL("syntax error");

fun p_bl (c,l) =
  case (p_suffix c,l) of
     (Option.SOME c,[a]) =>
       (case p_offset 32 a of
           Option.SOME(true,offset) =>
             OK(c,Branch(BranchLinkExchangeImmediate(InstrSet_ARM,offset)))
         | Option.SOME(false,_) => FAIL("bad offset")
         | NONE =>
           (case p_label a of
               Option.SOME label =>
                 PENDING
                   (label,
                    (c,
                     Branch
                       (BranchLinkExchangeImmediate
                          (InstrSet_ARM,BitsN.B(0x0,32)))))
             | NONE => FAIL("syntax error")))
   | _ => FAIL("syntax error");

fun p_b (c,l) =
  case (p_suffix c,l) of
     (Option.SOME c,[a]) =>
       (case p_offset 32 a of
           Option.SOME(true,offset) => OK(c,Branch(BranchTarget offset))
         | Option.SOME(false,_) => FAIL("bad offset")
         | NONE =>
           (case p_label a of
               Option.SOME label =>
                 PENDING(label,(c,Branch(BranchTarget(BitsN.B(0x0,32)))))
             | NONE => FAIL("syntax error")))
   | _ => FAIL("syntax error");

fun p_blx (c,l) =
  case (p_suffix c,l) of
     (Option.SOME c,[a]) =>
       (case p_register a of
           Option.SOME rm => OK(c,Branch(BranchLinkExchangeRegister rm))
         | NONE =>
           (case p_offset 32 a of
               Option.SOME(true,offset) =>
                 OK(c,
                    Branch
                      (BranchLinkExchangeImmediate(InstrSet_Thumb,offset)))
             | Option.SOME(false,_) => FAIL("bad offset")
             | NONE =>
               (case p_label a of
                   Option.SOME label =>
                     PENDING
                       (label,
                        (c,
                         Branch
                           (BranchLinkExchangeImmediate
                              (InstrSet_Thumb,BitsN.B(0x0,32)))))
                 | NONE => FAIL("syntax error"))))
   | _ => FAIL("syntax error");

fun p_clz (c,l) =
  case (p_suffix c,p_register2 l) of
     (Option.SOME c,Option.SOME(rd,rm)) =>
       OK(c,Data(CountLeadingZeroes(rd,rm)))
   | _ => FAIL("syntax error");

fun p_movt_movw (c,(high,l)) =
  case l of
     [r,imm] =>
       (case (p_suffix c,(p_register r,p_immediate 16 imm)) of
           (Option.SOME c,(Option.SOME rd,Option.SOME(true,imm16))) =>
             OK(c,Data(MoveHalfword(high,(rd,imm16))))
         | (Option.SOME _,(Option.SOME _,Option.SOME(false,_))) =>
           FAIL("immediate too large")
         | _ => FAIL("syntax error"))
   | _ => FAIL("syntax error");

fun p_addw_subw (c,(sub,l)) =
  case l of
     [r1,r2,imm] =>
       (case (p_suffix c,(p_register2[r1,r2],p_immediate 12 imm)) of
           (Option.SOME c,(Option.SOME(rd,rn),Option.SOME(true,imm12))) =>
             OK(c,Data(AddSub(sub,(rd,(rn,imm12)))))
         | (Option.SOME _,(Option.SOME _,Option.SOME(false,_))) =>
           FAIL("immediate too large")
         | _ => FAIL("syntax error"))
   | _ => FAIL("syntax error");

fun p_mul (c,(setflags,l)) =
  case (p_suffix c,p_register3 l) of
     (Option.SOME c,Option.SOME(rd,(rn,rm))) =>
       OK(c,Multiply(Multiply32(setflags,(rd,(rn,rm)))))
   | _ => FAIL("syntax error");

fun p_mla (c,(setflags,l)) =
  case (p_suffix c,p_register4 l) of
     (Option.SOME c,Option.SOME(rd,(rn,(rm,ra)))) =>
       OK(c,Multiply(MultiplyAccumulate(setflags,(rd,(rn,(rm,ra))))))
   | _ => FAIL("syntax error");

fun p_umull_etc (c,(acc,(signed,(setflags,l)))) =
  case (p_suffix c,p_register4 l) of
     (Option.SOME c,Option.SOME(rdlo,(rdhi,(rn,rm)))) =>
       OK(c,
          Multiply
            (MultiplyLong(acc,(signed,(setflags,(rdhi,(rdlo,(rn,rm))))))))
   | _ => FAIL("syntax error");

fun p_umaal (c,l) =
  case (p_suffix c,p_register4 l) of
     (Option.SOME c,Option.SOME(rdlo,(rdhi,(rn,rm)))) =>
       OK(c,Multiply(MultiplyAccumulateAccumulate(rdhi,(rdlo,(rn,rm)))))
   | _ => FAIL("syntax error");

fun p_mls (c,l) =
  case (p_suffix c,p_register4 l) of
     (Option.SOME c,Option.SOME(rd,(rn,(rm,ra)))) =>
       OK(c,Multiply(MultiplySubtract(rd,(rn,(rm,ra)))))
   | _ => FAIL("syntax error");

fun p_smla (c,(m_high,(n_high,l))) =
  case (p_suffix c,p_register4 l) of
     (Option.SOME c,Option.SOME(rd,(rn,(rm,ra)))) =>
       OK(c,
          Multiply
            (Signed16Multiply32Accumulate
               (m_high,(n_high,(rd,(rn,(rm,ra)))))))
   | _ => FAIL("syntax error");

fun p_smul (c,(m_high,(n_high,l))) =
  case (p_suffix c,p_register3 l) of
     (Option.SOME c,Option.SOME(rd,(rn,rm))) =>
       OK(c,
          Multiply(Signed16Multiply32Result(m_high,(n_high,(rd,(rn,rm))))))
   | _ => FAIL("syntax error");

fun p_smlaw (c,(m_high,l)) =
  case (p_suffix c,p_register4 l) of
     (Option.SOME c,Option.SOME(rd,(rn,(rm,ra)))) =>
       OK(c,
          Multiply
            (Signed16x32Multiply32Accumulate(m_high,(rd,(rn,(rm,ra))))))
   | _ => FAIL("syntax error");

fun p_smulw (c,(m_high,l)) =
  case (p_suffix c,p_register3 l) of
     (Option.SOME c,Option.SOME(rd,(rn,rm))) =>
       OK(c,Multiply(Signed16x32Multiply32Result(m_high,(rd,(rn,rm)))))
   | _ => FAIL("syntax error");

fun p_smlal (c,(m_high,(n_high,l))) =
  case (p_suffix c,p_register4 l) of
     (Option.SOME c,Option.SOME(rdlo,(rdhi,(rn,rm)))) =>
       OK(c,
          Multiply
            (Signed16Multiply64Accumulate
               (m_high,(n_high,(rdhi,(rdlo,(rn,rm)))))))
   | _ => FAIL("syntax error");

fun p_smuad_smusd (c,(sub,(swap,l))) =
  case (p_suffix c,p_register3 l) of
     (Option.SOME c,Option.SOME(rd,(rn,rm))) =>
       OK(c,
          Multiply
            (SignedMultiplyDual(sub,(swap,(rd,(rn,(rm,BitsN.B(0xF,4))))))))
   | _ => FAIL("syntax error");

fun p_smlad_smlsd (c,(sub,(swap,l))) =
  case (p_suffix c,p_register4 l) of
     (Option.SOME c,Option.SOME(rd,(rn,(rm,ra)))) =>
       OK(c,Multiply(SignedMultiplyDual(sub,(swap,(rd,(rn,(rm,ra)))))))
   | _ => FAIL("syntax error");

fun p_smlald_smlsld (c,(sub,(swap,l))) =
  case (p_suffix c,p_register4 l) of
     (Option.SOME c,Option.SOME(rdlo,(rdhi,(rn,rm)))) =>
       OK(c,
          Multiply
            (SignedMultiplyLongDual(sub,(swap,(rdhi,(rdlo,(rn,rm)))))))
   | _ => FAIL("syntax error");

fun p_smmul (c,(round,l)) =
  case (p_suffix c,p_register3 l) of
     (Option.SOME c,Option.SOME(rd,(rn,rm))) =>
       OK(c,
          Multiply
            (SignedMostSignificantMultiply
               (round,(rd,(rn,(rm,BitsN.B(0xF,4)))))))
   | _ => FAIL("syntax error");

fun p_smmla (c,(round,l)) =
  case (p_suffix c,p_register4 l) of
     (Option.SOME c,Option.SOME(rd,(rn,(rm,ra)))) =>
       OK(c,
          Multiply(SignedMostSignificantMultiply(round,(rd,(rn,(rm,ra))))))
   | _ => FAIL("syntax error");

fun p_smmls (c,(round,l)) =
  case (p_suffix c,p_register4 l) of
     (Option.SOME c,Option.SOME(rd,(rn,(rm,ra)))) =>
       OK(c,
          Multiply
            (SignedMostSignificantMultiplySubtract
               (round,(rd,(rn,(rm,ra))))))
   | _ => FAIL("syntax error");

fun p_qadd_etc (c,(opc,l)) =
  case (p_suffix c,p_register3 l) of
     (Option.SOME c,Option.SOME(rd,(rm,rn))) =>
       OK(c,Media(SaturatingAddSubtract(opc,(rd,(rm,rn)))))
   | _ => FAIL("syntax error");

fun p_sadd16_etc (c,(opc,l)) =
  case (p_suffix c,p_register3 l) of
     (Option.SOME c,Option.SOME(rd,(rn,rm))) =>
       OK(c,SIMD(SignedAddSub16(opc,(rd,(rn,rm)))))
   | _ => FAIL("syntax error");

fun p_qadd16_etc (c,(opc,l)) =
  case (p_suffix c,p_register3 l) of
     (Option.SOME c,Option.SOME(rd,(rn,rm))) =>
       OK(c,SIMD(SignedSaturatingAddSub16(opc,(rd,(rn,rm)))))
   | _ => FAIL("syntax error");

fun p_shadd16_etc (c,(opc,l)) =
  case (p_suffix c,p_register3 l) of
     (Option.SOME c,Option.SOME(rd,(rn,rm))) =>
       OK(c,SIMD(SignedHalvingAddSub16(opc,(rd,(rn,rm)))))
   | _ => FAIL("syntax error");

fun p_sadd8_etc (c,(sub,l)) =
  case (p_suffix c,p_register3 l) of
     (Option.SOME c,Option.SOME(rd,(rn,rm))) =>
       OK(c,SIMD(SignedAddSub8(sub,(rd,(rn,rm)))))
   | _ => FAIL("syntax error");

fun p_qadd8_etc (c,(sub,l)) =
  case (p_suffix c,p_register3 l) of
     (Option.SOME c,Option.SOME(rd,(rn,rm))) =>
       OK(c,SIMD(SignedSaturatingAddSub8(sub,(rd,(rn,rm)))))
   | _ => FAIL("syntax error");

fun p_shadd8_etc (c,(sub,l)) =
  case (p_suffix c,p_register3 l) of
     (Option.SOME c,Option.SOME(rd,(rn,rm))) =>
       OK(c,SIMD(SignedHalvingAddSub8(sub,(rd,(rn,rm)))))
   | _ => FAIL("syntax error");

fun p_uadd16_etc (c,(opc,l)) =
  case (p_suffix c,p_register3 l) of
     (Option.SOME c,Option.SOME(rd,(rn,rm))) =>
       OK(c,SIMD(UnsignedAddSub16(opc,(rd,(rn,rm)))))
   | _ => FAIL("syntax error");

fun p_uqadd16_etc (c,(opc,l)) =
  case (p_suffix c,p_register3 l) of
     (Option.SOME c,Option.SOME(rd,(rn,rm))) =>
       OK(c,SIMD(UnsignedSaturatingAddSub16(opc,(rd,(rn,rm)))))
   | _ => FAIL("syntax error");

fun p_uhadd16_etc (c,(opc,l)) =
  case (p_suffix c,p_register3 l) of
     (Option.SOME c,Option.SOME(rd,(rn,rm))) =>
       OK(c,SIMD(UnsignedHalvingAddSub16(opc,(rd,(rn,rm)))))
   | _ => FAIL("syntax error");

fun p_uadd8_etc (c,(sub,l)) =
  case (p_suffix c,p_register3 l) of
     (Option.SOME c,Option.SOME(rd,(rn,rm))) =>
       OK(c,SIMD(UnsignedAddSub8(sub,(rd,(rn,rm)))))
   | _ => FAIL("syntax error");

fun p_uqadd8_etc (c,(sub,l)) =
  case (p_suffix c,p_register3 l) of
     (Option.SOME c,Option.SOME(rd,(rn,rm))) =>
       OK(c,SIMD(UnsignedSaturatingAddSub8(sub,(rd,(rn,rm)))))
   | _ => FAIL("syntax error");

fun p_uhadd8_etc (c,(sub,l)) =
  case (p_suffix c,p_register3 l) of
     (Option.SOME c,Option.SOME(rd,(rn,rm))) =>
       OK(c,SIMD(UnsignedHalvingAddSub8(sub,(rd,(rn,rm)))))
   | _ => FAIL("syntax error");

fun p_usad8 (c,l) =
  case (p_suffix c,p_register3 l) of
     (Option.SOME c,Option.SOME(rd,(rn,rm))) =>
       OK(c,
          SIMD
            (UnsignedSumAbsoluteDifferences(rd,(rn,(rm,BitsN.B(0xF,4))))))
   | _ => FAIL("syntax error");

fun p_usada8 (c,l) =
  case (p_suffix c,p_register4 l) of
     (Option.SOME c,Option.SOME(rd,(rn,(rm,ra)))) =>
       OK(c,SIMD(UnsignedSumAbsoluteDifferences(rd,(rn,(rm,ra)))))
   | _ => FAIL("syntax error");

fun p_pkhbt_pkhtb (c,(tbform,l)) =
  case (p_suffix c,l) of
     (Option.SOME c,[r1,r2,r3]) =>
       (case p_register3[r1,r2,r3] of
           Option.SOME(rd,(rn,rm)) =>
             let
               val (rn,rm) = if tbform then (rm,rn) else (rn,rm)
             in
               OK(c,
                  Media(PackHalfword(SRType_LSL,(0,(false,(rd,(rn,rm)))))))
             end
         | NONE => FAIL("syntax error"))
   | (Option.SOME c,[r1,r2,r3,sh]) =>
     (case p_register3[r1,r2,r3] of
         Option.SOME(rd,(rn,rm)) =>
           let
             val sh = stripSpaces sh
           in
             if tbform
               then case String.explode sh of
                       #"a" :: (#"s" :: (#"r" :: (h :: t))) =>
                         (case p_shift_amount
                            (SRType_ASR,(h,String.implode t)) of
                             ("",(_,NAT n)) =>
                               OK(c,
                                  Media
                                    (PackHalfword
                                       (SRType_ASR,(n,(true,(rd,(rn,rm)))))))
                           | ("",(_,REGISTER _)) => FAIL("syntax error")
                           | (err,_) => FAIL err)
                     | _ => FAIL("syntax error")
             else case String.explode sh of
                     #"l" :: (#"s" :: (#"l" :: (h :: t))) =>
                       (case p_shift_amount
                          (SRType_LSL,(h,String.implode t)) of
                           ("",(_,NAT n)) =>
                             OK(c,
                                Media
                                  (PackHalfword
                                     (SRType_LSL,(n,(false,(rd,(rn,rm)))))))
                         | ("",(_,REGISTER _)) => FAIL("syntax error")
                         | (err,_) => FAIL err)
                   | _ => FAIL("syntax error")
           end
       | NONE => FAIL("syntax error"))
   | _ => FAIL("syntax error");

fun p_sat (c,(unsigned,l)) =
  case (p_suffix c,l) of
     (Option.SOME c,r1 :: (imm :: (r2 :: t))) =>
       let
         val (s,sat_to) =
           if unsigned
             then p_range_imm(0,(31,imm))
           else p_range_imm(1,(32,imm))
       in
         case (s,p_register2[r1,r2]) of
            ("",Option.SOME(rd,rn)) =>
              (case t of
                  [] =>
                    OK(c,
                       Media
                         (Saturate
                            (SRType_LSL,(0,(sat_to,(unsigned,(rd,rn)))))))
                | [sh] =>
                  (case p_shift_imm_or_reg sh of
                      ("",(SRType_LSL,NAT n)) =>
                        OK(c,
                           Media
                             (Saturate
                                (SRType_LSL,
                                 (n,(sat_to,(unsigned,(rd,rn)))))))
                    | ("",(SRType_ASR,NAT n)) =>
                      OK(c,
                         Media
                           (Saturate
                              (SRType_ASR,(n,(sat_to,(unsigned,(rd,rn)))))))
                    | ("",_) => FAIL("syntax error")
                    | (s,_) => FAIL s)
                | _ => FAIL("syntax error"))
          | (s,Option.SOME _) => FAIL s
          | _ => FAIL("syntax error")
       end
   | _ => FAIL("syntax error");

fun p_sat16 (c,(unsigned,l)) =
  case (p_suffix c,l) of
     (Option.SOME c,[r1,imm,r2]) =>
       let
         val (s,sat_to) =
           if unsigned
             then p_range_imm(0,(15,imm))
           else p_range_imm(1,(16,imm))
       in
         case (s,p_register2[r1,r2]) of
            ("",Option.SOME(rd,rn)) =>
              OK(c,Media(Saturate16(sat_to,(unsigned,(rd,rn)))))
          | (s,Option.SOME _) => FAIL s
          | _ => FAIL("syntax error")
       end
   | _ => FAIL("syntax error");

fun pick_sxtb (opc,a) =
  Media
    (if opc = 0
       then ExtendByte16 a
     else if opc = 1 then ExtendByte a else ExtendHalfword a);

fun p_sxtb_etc (c,(opc,(unsigned,l))) =
  case (p_suffix c,l) of
     (Option.SOME c,[r1,r2]) =>
       (case p_register2[r1,r2] of
           Option.SOME(rd,rm) =>
             OK(c,pick_sxtb(opc,(unsigned,(rd,(BitsN.B(0xF,4),(rm,0))))))
         | NONE => FAIL("syntax error"))
   | (Option.SOME c,[r1,r2,rot]) =>
     (case (p_register2[r1,r2],p_rotation rot) of
         (Option.SOME(rd,rm),("",r)) =>
           OK(c,pick_sxtb(opc,(unsigned,(rd,(BitsN.B(0xF,4),(rm,r))))))
       | (Option.SOME _,(s,_)) => FAIL s
       | _ => FAIL("syntax error"))
   | _ => FAIL("syntax error");

fun p_sxtab_etc (c,(opc,(unsigned,l))) =
  case (p_suffix c,l) of
     (Option.SOME c,[r1,r2,r3]) =>
       (case p_register3[r1,r2,r3] of
           Option.SOME(rd,(rn,rm)) =>
             OK(c,pick_sxtb(opc,(unsigned,(rd,(rn,(rm,0))))))
         | NONE => FAIL("syntax error"))
   | (Option.SOME c,[r1,r2,r3,rot]) =>
     (case (p_register3[r1,r2,r3],p_rotation rot) of
         (Option.SOME(rd,(rn,rm)),("",r)) =>
           OK(c,pick_sxtb(opc,(unsigned,(rd,(rn,(rm,r))))))
       | (Option.SOME _,(s,_)) => FAIL s
       | _ => FAIL("syntax error"))
   | _ => FAIL("syntax error");

fun p_sel (c,l) =
  case (p_suffix c,p_register3 l) of
     (Option.SOME c,Option.SOME(rd,(rn,rm))) =>
       OK(c,Media(SelectBytes(rd,(rn,rm))))
   | _ => FAIL("syntax error");

fun p_rev (c,l) =
  case (p_suffix c,p_register2 l) of
     (Option.SOME c,Option.SOME(rd,rm)) => OK(c,Media(ByteReverse(rd,rm)))
   | _ => FAIL("syntax error");

fun p_rev16 (c,l) =
  case (p_suffix c,p_register2 l) of
     (Option.SOME c,Option.SOME(rd,rm)) =>
       OK(c,Media(ByteReversePackedHalfword(rd,rm)))
   | _ => FAIL("syntax error");

fun p_revsh (c,l) =
  case (p_suffix c,p_register2 l) of
     (Option.SOME c,Option.SOME(rd,rm)) =>
       OK(c,Media(ByteReverseSignedHalfword(rd,rm)))
   | _ => FAIL("syntax error");

fun p_rbit (c,l) =
  case (p_suffix c,p_register2 l) of
     (Option.SOME c,Option.SOME(rd,rm)) => OK(c,Media(ReverseBits(rd,rm)))
   | _ => FAIL("syntax error");

fun p_sbfx_ubfx (c,(unsigned,l)) =
  case (p_suffix c,l) of
     (Option.SOME c,[r1,r2,lsb,width]) =>
       (case p_register2[r1,r2] of
           Option.SOME(rd,rn) =>
             (case p_range_imm(0,(31,lsb)) of
                 ("",l) =>
                   (case p_range_imm(1,(Nat.-(32,l),width)) of
                       ("",w) =>
                         OK(c,
                            Media
                              (BitFieldExtract
                                 (unsigned,(rd,(rn,(l,Nat.-(w,1)))))))
                     | (err,_) => FAIL err)
               | (err,_) => FAIL err)
         | NONE => FAIL("syntax error"))
   | _ => FAIL("syntax error");

fun p_bfc (c,l) =
  case (p_suffix c,l) of
     (Option.SOME c,[r1,lsb,width]) =>
       (case p_register r1 of
           Option.SOME rd =>
             (case p_range_imm(0,(31,lsb)) of
                 ("",l) =>
                   (case p_range_imm(1,(Nat.-(32,l),width)) of
                       ("",w) =>
                         OK(c,
                            Media
                              (BitFieldClearOrInsert
                                 (rd,
                                  (BitsN.B(0xF,4),(l,Nat.-(Nat.+(l,w),1))))))
                     | (err,_) => FAIL err)
               | (err,_) => FAIL err)
         | NONE => FAIL("syntax error"))
   | _ => FAIL("syntax error");

fun p_bfi (c,l) =
  case (p_suffix c,l) of
     (Option.SOME c,[r1,r2,lsb,width]) =>
       (case p_register2[r1,r2] of
           Option.SOME(rd,rn) =>
             (case p_range_imm(0,(31,lsb)) of
                 ("",l) =>
                   (case p_range_imm(1,(Nat.-(32,l),width)) of
                       ("",w) =>
                         OK(c,
                            Media
                              (BitFieldClearOrInsert
                                 (rd,(rn,(l,Nat.-(Nat.+(l,w),1))))))
                     | (err,_) => FAIL err)
               | (err,_) => FAIL err)
         | NONE => FAIL("syntax error"))
   | _ => FAIL("syntax error");

fun closingAddress s =
  let
    val (l,wb) = L3.splitr(fn c => c = #"!",stripSpaces s)
    val (l,r) = L3.splitr(fn c => c = #"]",stripSpaces l)
  in
    if (r = ("]")) andalso (Nat.<(L3.size wb,2))
      then Option.SOME(wb = ("!"),l)
    else NONE
  end;

fun p_address_mode1 l =
  case l of
     h1 :: t1 =>
       (case String.explode(stripSpaces h1) of
           #"[" :: r1 =>
             let
               val r1 = String.implode r1
             in
               case p_register r1 of
                  Option.SOME rn =>
                    (case t1 of
                        [offset] =>
                          (case closingAddress offset of
                              Option.SOME(wb,offset1) =>
                                (case p_signed_immediate 32 offset1 of
                                    Option.SOME(sub,(true,imm32)) =>
                                      ("",
                                       Option.SOME
                                         (not sub,
                                          (true,
                                           (wb,(rn,immediate_form1 imm32)))))
                                  | Option.SOME(_,(false,_)) =>
                                    ("immediate too large",NONE)
                                  | NONE =>
                                    (case p_register_offset offset1 of
                                        Option.SOME(add,rm) =>
                                          ("",
                                           Option.SOME
                                             (add,
                                              (true,
                                               (wb,
                                                (rn,
                                                 register_form1
                                                   (rm,(SRType_LSL,0)))))))
                                      | NONE => ("syntax error",NONE)))
                            | NONE => ("syntax error",NONE))
                      | [offset,sh] =>
                        (case closingAddress sh of
                            Option.SOME(wb,sh1) =>
                              (case (p_register_offset offset,
                                p_shift_imm_or_reg sh1) of
                                  (Option.SOME(add,rm),("",(typ,NAT n))) =>
                                    ("",
                                     Option.SOME
                                       (add,
                                        (true,
                                         (wb,
                                          (rn,register_form1(rm,(typ,n)))))))
                                | (Option.SOME _,(err,(_,NAT _))) =>
                                  (err,NONE)
                                | _ => ("syntax error",NONE))
                          | NONE => ("syntax error",NONE))
                      | _ => ("syntax error",NONE))
                | NONE =>
                  (case closingAddress r1 of
                      Option.SOME(wb,r2) =>
                        (case (p_register r2,t1) of
                            (Option.SOME rn,[]) =>
                              ("",
                               Option.SOME
                                 (true,
                                  (true,
                                   (wb,
                                    (rn,immediate_form1(BitsN.B(0x0,32)))))))
                          | (Option.SOME rn,[offset]) =>
                            (if wb
                               then ("syntax error",NONE)
                             else case p_signed_immediate 32 offset of
                                     Option.SOME(sub,(true,imm32)) =>
                                       ("",
                                        Option.SOME
                                          (not sub,
                                           (false,
                                            (true,
                                             (rn,immediate_form1 imm32)))))
                                   | Option.SOME(_,(false,_)) =>
                                     ("immediate too large",NONE)
                                   | NONE =>
                                     (case p_register_offset offset of
                                         Option.SOME(add,rm) =>
                                           ("",
                                            Option.SOME
                                              (add,
                                               (false,
                                                (true,
                                                 (rn,
                                                  register_form1
                                                    (rm,(SRType_LSL,0)))))))
                                       | NONE => ("syntax error",NONE)))
                          | (Option.SOME rn,[offset,sh]) =>
                            (if wb
                               then ("syntax error",NONE)
                             else case (p_register_offset offset,
                                   p_shift_imm_or_reg sh) of
                                     (Option.SOME(add,rm),("",(typ,NAT n))) =>
                                       ("",
                                        Option.SOME
                                          (add,
                                           (false,
                                            (true,
                                             (rn,
                                              register_form1(rm,(typ,n)))))))
                                   | (Option.SOME _,(err,(_,NAT _))) =>
                                     (err,NONE)
                                   | _ => ("syntax error",NONE))
                          | _ => ("syntax error",NONE))
                    | NONE => ("syntax error",NONE))
             end
         | _ =>
           (case (p_signed_offset 32 h1,t1) of
               (Option.SOME(sub,(true,imm32)),[]) =>
                 ("",
                  Option.SOME
                    (not sub,
                     (true,(false,(BitsN.B(0xF,4),immediate_form1 imm32)))))
             | (Option.SOME(_,(false,_)),[]) => ("bad offset",NONE)
             | _ => ("syntax error",NONE)))
   | _ => ("syntax error",NONE);

fun p_address_mode2 l =
  case p_address_mode1 l of
     ("",Option.SOME(add,(index,(wback,(r,immediate_form1 imm32))))) =>
       ("",Option.SOME(add,(index,(wback,(r,immediate_form2 imm32)))))
   | ("",
    Option.SOME(add,(index,(wback,(r,register_form1(m,(SRType_LSL,0))))))) =>
     ("",Option.SOME(add,(index,(wback,(r,register_form2 m)))))
   | (_,Option.SOME _) => ("syntax error",NONE)
   | (s,_) => (s,NONE);

fun p_address_mode3 l =
  case l of
     [r1,imm] =>
       (case (String.explode(stripSpaces r1),closingAddress imm) of
           (#"[" :: r2,Option.SOME(false,imm10)) =>
             (case (p_register(String.implode r2),p_immediate 32 imm10) of
                 (Option.SOME rn,Option.SOME(true,imm32)) =>
                   ("",Option.SOME(rn,Option.SOME imm32))
               | (Option.SOME _,Option.SOME(false,_)) =>
                 ("immediate too large",NONE)
               | _ => ("syntax error",NONE))
         | _ => ("syntax error",NONE))
   | [r1] =>
     (case String.explode(stripSpaces r1) of
         #"[" :: r2 =>
           (case closingAddress(String.implode r2) of
               Option.SOME(false,r3) =>
                 (case p_register r3 of
                     Option.SOME rn => ("",Option.SOME(rn,NONE))
                   | NONE => ("syntax error",NONE))
             | Option.SOME _ => ("write-back not allowed",NONE)
             | NONE => ("syntax error",NONE))
       | _ => ("syntax error",NONE))
   | _ => ("syntax error",NONE);

fun pick_ldr_str (opc,(add,(index,(wback,(rt,(rn,offset)))))) =
  let
    val r = (add,(index,(wback,(rt,(rn,offset)))))
  in
    case opc of
       0 =>
         (case (index,(wback,(rn,offset))) of
             (true,(false,(BitsN.B(0xF,_),immediate_form1 imm32))) =>
               Load(LoadLiteral(add,(rt,imm32)))
           | _ => Load(LoadWord r))
     | 1 => Store(StoreByte r)
     | 2 => Store(StoreHalf r)
     | _ => Store(StoreWord r)
  end;

fun p_ldr_str (c,(opc,l)) =
  case (p_suffix c,l) of
     (Option.SOME c,h :: t) =>
       (case p_register h of
           Option.SOME rt =>
             (case p_address_mode1 t of
                 ("",Option.SOME(add,(index,(wback,(rn,offset))))) =>
                   OK(c,
                      pick_ldr_str
                        (opc,(add,(index,(wback,(rt,(rn,offset)))))))
               | (err,_) =>
                 (case t of
                     [l] =>
                       (case p_label l of
                           Option.SOME s =>
                             PENDING
                               (s,
                                (c,
                                 pick_ldr_str
                                   (opc,
                                    (false,
                                     (true,
                                      (false,
                                       (rt,
                                        (BitsN.B(0xF,4),
                                         immediate_form1(BitsN.B(0x0,32))))))))))
                         | NONE => FAIL err)
                   | _ => FAIL err))
         | NONE => FAIL("syntax error"))
   | _ => FAIL("syntax error");

fun pick_ldrb_ldrh
  (byte,(unsigned,(add,(index,(wback,(rt,(rn,offset))))))) =
  case (index,(wback,(rn,offset))) of
     (true,(false,(BitsN.B(0xF,_),immediate_form1 imm32))) =>
       let
         val r = (unsigned,(add,(rt,imm32)))
       in
         Load(if byte then LoadByteLiteral r else LoadHalfLiteral r)
       end
   | _ =>
     let
       val r = (unsigned,(add,(index,(wback,(rt,(rn,offset))))))
     in
       Load(if byte then LoadByte r else LoadHalf r)
     end;

fun p_ldrb_ldrh (c,(unsigned,(byte,l))) =
  case (p_suffix c,l) of
     (Option.SOME c,h :: t) =>
       (case p_register h of
           Option.SOME rt =>
             (case p_address_mode1 t of
                 ("",Option.SOME(add,(index,(wback,(rn,offset))))) =>
                   OK(c,
                      pick_ldrb_ldrh
                        (byte,
                         (unsigned,(add,(index,(wback,(rt,(rn,offset))))))))
               | (err,_) =>
                 (case t of
                     [l] =>
                       (case p_label l of
                           Option.SOME s =>
                             let
                               val r =
                                 (unsigned,(false,(rt,BitsN.B(0x0,32))))
                               val a =
                                 if byte
                                   then LoadByteLiteral r
                                 else LoadHalfLiteral r
                             in
                               PENDING(s,(c,Load a))
                             end
                         | NONE => FAIL err)
                   | _ => FAIL err))
         | NONE => FAIL("syntax error"))
   | _ => FAIL("syntax error");

fun pick_ldrd_strd (load,(add,(index,(wback,(rt1,(rt2,(rn,offset))))))) =
  let
    val r = (add,(index,(wback,(rt1,(rt2,(rn,offset))))))
  in
    if load
      then case (index,(wback,(rn,offset))) of
              (true,(false,(BitsN.B(0xF,_),immediate_form2 imm32))) =>
                Load(LoadDualLiteral(add,(rt1,(rt2,imm32))))
            | _ => Load(LoadDual r)
    else Store(StoreDual r)
  end;

fun p_ldrd_strd (c,(load,l)) =
  case (p_suffix c,l) of
     (Option.SOME c,r1 :: (r2 :: t)) =>
       (case p_register2[r1,r2] of
           Option.SOME(rt1,rt2) =>
             (case p_address_mode2 t of
                 ("",Option.SOME(add,(index,(wback,(rn,offset))))) =>
                   OK(c,
                      pick_ldrd_strd
                        (load,
                         (add,(index,(wback,(rt1,(rt2,(rn,offset))))))))
               | (err,_) =>
                 (case t of
                     [l] =>
                       (case p_label l of
                           Option.SOME s =>
                             PENDING
                               (s,
                                (c,
                                 pick_ldrd_strd
                                   (load,
                                    (false,
                                     (true,
                                      (false,
                                       (rt1,
                                        (rt2,
                                         (BitsN.B(0xF,4),
                                          immediate_form2(BitsN.B(0x0,32)))))))))))
                         | NONE => FAIL err)
                   | _ => FAIL err))
         | NONE => FAIL("syntax error"))
   | _ => FAIL("syntax error");

fun p_ldrt_strt1 (c,(opc,l)) =
  case p_ldr_str(c,(3,l)) of
     OK(c,Store(StoreWord(_,(true,(_,(_,(_,register_form1 _))))))) =>
       FAIL("syntax error")
   | OK(c,Store(StoreWord(false,(true,_)))) => FAIL("syntax error")
   | OK(c,Store(StoreWord(_,(true,(true,_))))) => FAIL("syntax error")
   | OK(c,Store(StoreWord(add,(index,(wback,(t,(n,m))))))) =>
     let
       val a = (add,(not(index = wback),(t,(n,m))))
     in
       case opc of
          0 => OK(c,Load(LoadUnprivileged a))
        | 1 => OK(c,Load(LoadByteUnprivileged a))
        | 2 => OK(c,Store(StoreUnprivileged a))
        | _ => OK(c,Store(StoreByteUnprivileged a))
     end
   | _ => FAIL("syntax error");

fun p_ldrt_strt2 (c,(opc,l)) =
  case p_ldrd_strd(c,(false,("r0") :: l)) of
     OK(c,Store(StoreDual(_,(true,(_,(_,(_,(_,register_form2 _)))))))) =>
       FAIL("syntax error")
   | OK(c,Store(StoreDual(false,(true,_)))) => FAIL("syntax error")
   | OK(c,Store(StoreDual(_,(true,(true,_))))) => FAIL("syntax error")
   | OK(c,Store(StoreDual(add,(index,(wback,(_,(t,(n,m)))))))) =>
     let
       val a = (add,(not(index = wback),(t,(n,m))))
     in
       case opc of
          0 => OK(c,Load(LoadSignedByteUnprivileged a))
        | 1 => OK(c,Load(LoadHalfUnprivileged(false,a)))
        | 2 => OK(c,Load(LoadHalfUnprivileged(true,a)))
        | _ => OK(c,Store(StoreHalfUnprivileged a))
     end
   | _ => FAIL("syntax error");

fun p_pld (c,(is_pldw,l)) =
  case p_ldr_str(c,(0,("r0") :: l)) of
     OK(c,Load(LoadWord(add,(true,(false,(_,(n,m))))))) =>
       OK(c,Hint(PreloadData(add,(is_pldw,(n,m)))))
   | OK(c,Load(LoadLiteral(add,(_,imm32)))) =>
     OK(c,Hint(PreloadDataLiteral(add,imm32)))
   | PENDING(s,(c,Load(LoadLiteral(false,(_,BitsN.B(0x0,32)))))) =>
     PENDING(s,(c,Hint(PreloadDataLiteral(false,BitsN.B(0x0,32)))))
   | _ => FAIL("syntax error");

fun p_pli (c,l) =
  case p_ldr_str(c,(0,("r0") :: l)) of
     OK(c,Load(LoadWord(add,(true,(false,(_,(n,m))))))) =>
       OK(c,Hint(PreloadInstruction(add,(n,m))))
   | OK(c,Load(LoadLiteral(add,(_,imm32)))) =>
     OK(c,
        Hint
          (PreloadInstruction(add,(BitsN.B(0xF,4),immediate_form1 imm32))))
   | _ => FAIL("syntax error");

fun p_ldrex (c,l) =
  case (p_suffix c,l) of
     (Option.SOME c,h :: t) =>
       (case (p_register h,p_address_mode3 t) of
           (Option.SOME rt,("",Option.SOME(rn,Option.SOME imm32))) =>
             OK(c,Load(LoadExclusive(rt,(rn,imm32))))
         | (Option.SOME rt,("",Option.SOME(rn,NONE))) =>
           OK(c,Load(LoadExclusive(rt,(rn,BitsN.B(0x0,32)))))
         | (Option.SOME _,(err,Option.SOME _)) => FAIL err
         | _ => FAIL("syntax error"))
   | _ => FAIL("syntax error");

fun p_ldrexb_ldrexh (c,(byte,l)) =
  case (p_suffix c,l) of
     (Option.SOME c,h :: t) =>
       (case (p_register h,p_address_mode3 t) of
           (Option.SOME rt,("",Option.SOME(rn,NONE))) =>
             OK(c,
                Load
                  (if byte
                     then LoadExclusiveByte(rt,rn)
                   else LoadExclusiveHalf(rt,rn)))
         | _ => FAIL("syntax error"))
   | _ => FAIL("syntax error");

fun p_ldrexd (c,l) =
  case (p_suffix c,l) of
     (Option.SOME c,[r1,r2,a]) =>
       (case (p_register2[r1,r2],p_address_mode3[a]) of
           (Option.SOME(rt1,rt2),("",Option.SOME(rn,NONE))) =>
             OK(c,Load(LoadExclusiveDoubleword(rt1,(rt2,rn))))
         | _ => FAIL("syntax error"))
   | _ => FAIL("syntax error");

fun p_strex (c,l) =
  case (p_suffix c,l) of
     (Option.SOME c,r1 :: (r2 :: a)) =>
       (case (p_register2[r1,r2],p_address_mode3 a) of
           (Option.SOME(rd,rt),("",Option.SOME(rn,Option.SOME imm32))) =>
             OK(c,Store(StoreExclusive(rd,(rt,(rn,imm32)))))
         | (Option.SOME(rd,rt),("",Option.SOME(rn,NONE))) =>
           OK(c,Store(StoreExclusive(rd,(rt,(rn,BitsN.B(0x0,32))))))
         | _ => FAIL("syntax error"))
   | _ => FAIL("syntax error");

fun p_strexb_strexh (c,(byte,l)) =
  case (p_suffix c,l) of
     (Option.SOME c,[r1,r2,a]) =>
       (case (p_register2[r1,r2],p_address_mode3[a]) of
           (Option.SOME(rd,rt),("",Option.SOME(rn,NONE))) =>
             OK(c,
                Store
                  (if byte
                     then StoreExclusiveByte(rd,(rt,rn))
                   else StoreExclusiveHalf(rd,(rt,rn))))
         | _ => FAIL("syntax error"))
   | _ => FAIL("syntax error");

fun p_strexd (c,l) =
  case (p_suffix c,l) of
     (Option.SOME c,[r1,r2,r3,a]) =>
       (case (p_register3[r1,r2,r3],p_address_mode3[a]) of
           (Option.SOME(rd,(rt1,rt2)),("",Option.SOME(rn,NONE))) =>
             OK(c,Store(StoreExclusiveDoubleword(rd,(rt1,(rt2,rn)))))
         | _ => FAIL("syntax error"))
   | _ => FAIL("syntax error");

fun p_swp (c,(byte,l)) =
  case (p_suffix c,l) of
     (Option.SOME c,[r1,r2,a]) =>
       (case (p_register2[r1,r2],p_address_mode3[a]) of
           (Option.SOME(rt1,rt2),("",Option.SOME(rn,NONE))) =>
             OK(c,Swap(byte,(rt1,(rt2,rn))))
         | _ => FAIL("syntax error"))
   | _ => FAIL("syntax error");

fun p_pop_push (c,(pop,l)) =
  case (p_suffix c,p_registers l) of
     (Option.SOME c,Option.SOME(false,w)) =>
       OK(c,
          if pop
            then Load
                   (LoadMultiple(true,(false,(true,(BitsN.B(0xD,4),w)))))
          else Store
                 (StoreMultiple(false,(true,(true,(BitsN.B(0xD,4),w))))))
   | (NONE,_) => FAIL("syntax error")
   | _ => FAIL("bad register list");

fun p_vpop_vpush (c,(pop,l)) =
  case (p_suffix c,p_fp_registers l) of
     (Option.SOME c,Option.SOME(single,(d,imm8))) =>
       OK(c,
          if pop
            then VFP(vldm(single,(true,(true,(d,(BitsN.B(0xD,4),imm8))))))
          else VFP(vstm(single,(false,(true,(d,(BitsN.B(0xD,4),imm8)))))))
   | (NONE,_) => FAIL("syntax error")
   | _ => FAIL("bad floating-point register list");

fun p_ldm_stm (c,(load,(inc,(index,l)))) =
  case (p_suffix c,l) of
     (Option.SOME c,h :: t) =>
       let
         val (r,wb) = L3.splitr(fn c => c = #"!",stripSpaces h)
       in
         case (p_register r,(p_registers t,Set.mem(wb,["","!"]))) of
            (Option.SOME rn,(Option.SOME(false,w),true)) =>
              let
                val r = (inc,(index,(wb = ("!"),(rn,w))))
              in
                OK(c,
                   if load
                     then Load(LoadMultiple r)
                   else Store(StoreMultiple r))
              end
          | (Option.SOME rn,(Option.SOME(true,w),true)) =>
            (if load
               then if BitsN.bit(w,15)
                      then OK(c,
                              Load
                                (LoadMultipleExceptionReturn
                                   (inc,
                                    (index = inc,
                                     (wb = ("!"),(rn,BitsN.bits(14,0) w))))))
                    else if wb = ("")
                      then OK(c,
                              Load
                                (LoadMultipleUserRegisters
                                   (inc,
                                    (index = inc,(rn,BitsN.bits(14,0) w)))))
                    else FAIL
                           ("write-back not allowed for LDM (user registers)")
             else if wb = ("")
               then OK(c,
                       Store
                         (StoreMultipleUserRegisters
                            (inc,(index = inc,(rn,w)))))
             else FAIL("write-back not allowed for STM (user registers)"))
          | (Option.SOME _,(NONE,true)) => FAIL("bad register list")
          | _ => FAIL("syntax error")
       end
   | _ => FAIL("syntax error");

fun p_vldm_vstm (c,(load,(inc,l))) =
  case (p_suffix c,l) of
     (Option.SOME c,h :: t) =>
       let
         val (r,wb) = L3.splitr(fn c => c = #"!",stripSpaces h)
       in
         case (p_register r,(p_fp_registers t,Set.mem(wb,["","!"]))) of
            (Option.SOME rn,(Option.SOME(single,(d,imm8)),true)) =>
              let
                val wback = wb = ("!")
                val a = (single,(inc,(wback,(d,(rn,imm8)))))
              in
                if not(inc orelse wback)
                  then FAIL("write-back required for VLDMDB and VSTMDB")
                else OK(c,VFP(if load then vldm a else vstm a))
              end
          | (Option.SOME _,(NONE,true)) =>
            FAIL("bad floating-point register list")
          | _ => FAIL("syntax error")
       end
   | _ => FAIL("syntax error");

fun p_setend l =
  case l of
     [e] =>
       (case stripSpaces e of
           "be" => OK(al,System(Setend true))
         | "le" => OK(al,System(Setend false))
         | _ => FAIL("syntax error"))
   | _ => FAIL("syntax error");

fun p_aif (a,(i,(f,s))) =
  case String.explode s of
     [] => Option.SOME(a,(i,f))
   | #"a" :: r => p_aif(true,(i,(f,String.implode r)))
   | #"i" :: r => p_aif(a,(true,(f,String.implode r)))
   | #"f" :: r => p_aif(a,(i,(true,String.implode r)))
   | _ => NONE;

fun p_cps (enable,(disable,l)) =
  case l of
     [aif_m] =>
       (case p_immediate 5 aif_m of
           Option.SOME(true,mode) =>
             (if enable orelse disable
                then FAIL("syntax error")
              else OK(al,
                      System
                        (ChangeProcessorState
                           (false,
                            (false,
                             (false,(false,(false,Option.SOME mode))))))))
         | Option.SOME(false,_) =>
           (if enable orelse disable
              then FAIL("syntax error")
            else FAIL("immediate too large"))
         | NONE =>
           if enable orelse disable
             then case p_aif(false,(false,(false,stripSpaces aif_m))) of
                     Option.SOME(a,(i,f)) =>
                       OK(al,
                          System
                            (ChangeProcessorState
                               (enable,(disable,(a,(i,(f,NONE)))))))
                   | NONE => FAIL("syntax error")
           else FAIL("syntax error"))
   | [aif,m] =>
     (case (p_aif(false,(false,(false,stripSpaces aif))),p_immediate 5 m) of
         (Option.SOME _,Option.SOME(false,_)) =>
           (if enable orelse disable
              then FAIL("immediate too large")
            else FAIL("syntax error"))
       | (Option.SOME(a,(i,f)),Option.SOME(true,mode)) =>
         (if enable orelse disable
            then OK(al,
                    System
                      (ChangeProcessorState
                         (enable,(disable,(a,(i,(f,Option.SOME mode)))))))
          else FAIL("syntax error"))
       | _ => FAIL("syntax error"))
   | _ => FAIL("syntax error");

fun p_mode s =
  case s of
     "fiq" => Option.SOME(BitsN.B(0xE,5))
   | "irq" => Option.SOME(BitsN.B(0x10,5))
   | "svc" => Option.SOME(BitsN.B(0x12,5))
   | "abt" => Option.SOME(BitsN.B(0x14,5))
   | "und" => Option.SOME(BitsN.B(0x16,5))
   | "mon" => Option.SOME(BitsN.B(0x1C,5))
   | "hyp" => Option.SOME(BitsN.B(0x1E,5))
   | _ =>
     (case Nat.fromString s of
         Option.SOME n => Option.SOME(BitsN.fromNat(n,5))
       | NONE => NONE);

fun banked_register (r,mode) =
  case mode of
     "usr" =>
       let
         val i = BitsN.-(r,BitsN.B(0x8,4))
       in
         if BitsN.<+(i,BitsN.B(0x7,4))
           then Option.SOME
                  (BitsN.@@(BitsN.B(0x0,2),BitsN.fromNat(BitsN.toNat i,3)))
         else NONE
       end
   | "fiq" =>
     let
       val i = BitsN.-(r,BitsN.B(0x8,4))
     in
       if BitsN.<+(i,BitsN.B(0x7,4))
         then Option.SOME
                (BitsN.@@(BitsN.B(0x1,2),BitsN.fromNat(BitsN.toNat i,3)))
       else NONE
     end
   | "irq" =>
     if r = (BitsN.B(0xD,4))
       then Option.SOME(BitsN.B(0x11,5))
     else if r = (BitsN.B(0xE,4))
       then Option.SOME(BitsN.B(0x10,5))
     else NONE
   | "svc" =>
     if r = (BitsN.B(0xD,4))
       then Option.SOME(BitsN.B(0x13,5))
     else if r = (BitsN.B(0xE,4))
       then Option.SOME(BitsN.B(0x12,5))
     else NONE
   | "abt" =>
     if r = (BitsN.B(0xD,4))
       then Option.SOME(BitsN.B(0x15,5))
     else if r = (BitsN.B(0xE,4))
       then Option.SOME(BitsN.B(0x14,5))
     else NONE
   | "und" =>
     if r = (BitsN.B(0xD,4))
       then Option.SOME(BitsN.B(0x17,5))
     else if r = (BitsN.B(0xE,4))
       then Option.SOME(BitsN.B(0x16,5))
     else NONE
   | "mon" =>
     if r = (BitsN.B(0xD,4))
       then Option.SOME(BitsN.B(0x1D,5))
     else if r = (BitsN.B(0xE,4))
       then Option.SOME(BitsN.B(0x1C,5))
     else NONE
   | "hyp" =>
     if r = (BitsN.B(0xD,4)) then Option.SOME(BitsN.B(0x1F,5)) else NONE
   | _ => NONE;

fun p_banked_register s =
  case L3.uncurry String.tokens (fn c => c = #"_",s) of
     [r,m] =>
       (case p_register r of
           Option.SOME r0 => banked_register(r0,stripSpaces m)
         | NONE => NONE)
   | _ => NONE;

fun p_mrs (c,l) =
  case (p_suffix c,l) of
     (Option.SOME c,[r1,r2]) =>
       (case p_register r1 of
           Option.SOME rd =>
             (case String.explode(stripSpaces r2) of
                 [#"a",#"p",#"s",#"r"] =>
                   OK(c,System(MoveToRegisterFromSpecial(false,rd)))
               | [#"c",#"p",#"s",#"r"] =>
                 OK(c,System(MoveToRegisterFromSpecial(false,rd)))
               | [#"s",#"p",#"s",#"r"] =>
                 OK(c,System(MoveToRegisterFromSpecial(true,rd)))
               | [#"e",#"l",#"r",#"_",#"h",#"y",#"p"] =>
                 OK(c,
                    System
                      (MoveToRegisterFromBankedOrSpecial
                         (false,(BitsN.B(0x1E,5),rd))))
               | #"s" :: (#"p" :: (#"s" :: (#"r" :: (#"_" :: m)))) =>
                 (case p_mode(String.implode m) of
                     Option.SOME sysm =>
                       OK(c,
                          System
                            (MoveToRegisterFromBankedOrSpecial
                               (true,(sysm,rd))))
                   | NONE => FAIL("syntax error"))
               | r_mode =>
                 (case p_banked_register(String.implode r_mode) of
                     Option.SOME sysm =>
                       OK(c,
                          System
                            (MoveToRegisterFromBankedOrSpecial
                               (false,(sysm,rd))))
                   | NONE => FAIL("syntax error")))
         | NONE => FAIL("syntax error"))
   | _ => FAIL("syntax error");

fun p_cxsf (mask,s) =
  case String.explode s of
     [] => Option.SOME mask
   | #"c" :: r =>
     (if BitsN.bit(mask,0)
        then NONE
      else p_cxsf(BitsN.||(mask,BitsN.B(0x1,4)),String.implode r))
   | #"x" :: r =>
     (if BitsN.bit(mask,1)
        then NONE
      else p_cxsf(BitsN.||(mask,BitsN.B(0x2,4)),String.implode r))
   | #"s" :: r =>
     (if BitsN.bit(mask,2)
        then NONE
      else p_cxsf(BitsN.||(mask,BitsN.B(0x4,4)),String.implode r))
   | #"f" :: r =>
     (if BitsN.bit(mask,3)
        then NONE
      else p_cxsf(BitsN.||(mask,BitsN.B(0x8,4)),String.implode r))
   | _ => NONE;

fun p_spec_reg s =
  case String.explode(stripSpaces s) of
     [#"a",#"p",#"s",#"r"] => Option.SOME(false,BitsN.B(0xF,4))
   | [#"c",#"p",#"s",#"r"] => Option.SOME(false,BitsN.B(0xF,4))
   | [#"s",#"p",#"s",#"r"] => Option.SOME(true,BitsN.B(0xF,4))
   | [#"a",#"p",#"s",#"r",#"_",#"n",#"z",#"c",#"v",#"q"] =>
     Option.SOME(false,BitsN.B(0x8,4))
   | [#"a",#"p",#"s",#"r",#"_",#"g"] => Option.SOME(false,BitsN.B(0x4,4))
   | [#"a",#"p",#"s",#"r",#"_",#"n",#"z",#"c",#"v",#"q",#"g"] =>
     Option.SOME(false,BitsN.B(0xC,4))
   | #"c" :: (#"p" :: (#"s" :: (#"r" :: (#"_" :: r)))) =>
     (case p_cxsf(BitsN.B(0x0,4),String.implode r) of
         Option.SOME mask => Option.SOME(false,mask)
       | NONE => NONE)
   | #"s" :: (#"p" :: (#"s" :: (#"r" :: (#"_" :: r)))) =>
     (case p_cxsf(BitsN.B(0x0,4),String.implode r) of
         Option.SOME mask => Option.SOME(true,mask)
       | NONE => NONE)
   | _ => NONE;

fun p_msr (c,l) =
  case (p_suffix c,l) of
     (Option.SOME c,[r1,r2]) =>
       (case p_immediate 32 r2 of
           Option.SOME(true,imm32) =>
             (case p_spec_reg r1 of
                 Option.SOME(write_spsr,mask) =>
                   OK(c,
                      System
                        (MoveToSpecialFromImmediate
                           (write_spsr,(imm32,mask))))
               | NONE => FAIL("syntax error"))
         | Option.SOME(false,_) => FAIL("immediate too large")
         | NONE =>
           (case (p_spec_reg r1,p_register r2) of
               (Option.SOME(write_spsr,mask),Option.SOME n) =>
                 OK(c,
                    System(MoveToSpecialFromRegister(write_spsr,(n,mask))))
             | (NONE,Option.SOME n) =>
               (case String.explode(stripSpaces r1) of
                   [#"e",#"l",#"r",#"_",#"h",#"y",#"p"] =>
                     OK(c,
                        System
                          (MoveToBankedOrSpecialRegister
                             (false,(BitsN.B(0x1E,5),n))))
                 | #"s" :: (#"p" :: (#"s" :: (#"r" :: (#"_" :: m)))) =>
                   (case p_mode(String.implode m) of
                       Option.SOME sysm =>
                         OK(c,
                            System
                              (MoveToBankedOrSpecialRegister
                                 (true,(sysm,n))))
                     | NONE => FAIL("syntax error"))
                 | r_mode =>
                   (case p_banked_register(String.implode r_mode) of
                       Option.SOME sysm =>
                         OK(c,
                            System
                              (MoveToBankedOrSpecialRegister
                                 (false,(sysm,n))))
                     | NONE => FAIL("syntax error")))
             | _ => FAIL("syntax error")))
   | _ => FAIL("syntax error");

fun p_rfe (c,(increment,(wordhigher,l))) =
  case (p_suffix c,l) of
     (Option.SOME c,[h]) =>
       let
         val (r,wb) = L3.splitr(fn c => c = #"!",stripSpaces h)
       in
         case (p_register r,Set.mem(wb,["","!"])) of
            (Option.SOME n,true) =>
              OK(c,
                 System
                   (ReturnFromException
                      (increment,(wordhigher,(wb = ("!"),n)))))
          | _ => FAIL("syntax error")
       end
   | _ => FAIL("syntax error");

fun p_srs (c,(increment,(wordhigher,l))) =
  case (p_suffix c,l) of
     (Option.SOME c,[h,m]) =>
       let
         val (r,wb) = L3.splitr(fn c => c = #"!",stripSpaces h)
       in
         case (p_register r,(Set.mem(wb,["","!"]),p_immediate_number 5 m)) of
            (Option.SOME(BitsN.B(0xD,_)),(true,Option.SOME(ok,mode))) =>
              (if ok
                 then OK(c,
                         System
                           (StoreReturnState
                              (increment,(wordhigher,(wb = ("!"),mode)))))
               else FAIL("immediate too large"))
          | _ => FAIL("syntax error")
       end
   | _ => FAIL("syntax error");

fun p_call (c,(e,l)) =
  case (p_suffix c,l) of
     (Option.SOME c,[imm]) =>
       (case p_immediate_number 32 imm of
           Option.SOME(true,imm32) =>
             let
               val ast =
                 case e of
                    0 => Undefined imm32
                  | 1 => Hint(Debug(BitsN.fromNat(BitsN.toNat imm32,4)))
                  | 2 =>
                    System
                      (SecureMonitorCall
                         (BitsN.fromNat(BitsN.toNat imm32,4)))
                  | 3 => System(SupervisorCall imm32)
                  | 4 =>
                    System
                      (HypervisorCall(BitsN.fromNat(BitsN.toNat imm32,16)))
                  | _ => Hint(Breakpoint imm32)
             in
               if (((e = 1) orelse (e = 2)) andalso
                   (BitsN.<+(BitsN.B(0xF,32),imm32))) orelse
                  ((e = 4) andalso (BitsN.<+(BitsN.B(0xFFFF,32),imm32)))
                 then FAIL("immediate too large")
               else OK(c,ast)
             end
         | Option.SOME(false,_) => FAIL("immediate too large")
         | _ => FAIL("syntax error"))
   | _ => FAIL("syntax error");

fun p_barrier_option l =
  case l of
     [] => Option.SOME(BitsN.B(0xF,4))
   | [s] =>
     (case stripSpaces s of
         "sy" => Option.SOME(BitsN.B(0xF,4))
       | "st" => Option.SOME(BitsN.B(0xE,4))
       | "ish" => Option.SOME(BitsN.B(0xB,4))
       | "ishst" => Option.SOME(BitsN.B(0xA,4))
       | "nsh" => Option.SOME(BitsN.B(0x7,4))
       | "nshst" => Option.SOME(BitsN.B(0x6,4))
       | "osh" => Option.SOME(BitsN.B(0x3,4))
       | "oshst" => Option.SOME(BitsN.B(0x2,4))
       | n =>
         (case Nat.fromString n of
             Option.SOME v => Option.SOME(BitsN.fromNat(v,4))
           | NONE => NONE))
   | _ => NONE;

fun p_dmb_dsb (c,(sync,l)) =
  case (p_suffix c,p_barrier_option l) of
     (Option.SOME c,Option.SOME option) =>
       OK(c,
          Hint
            (if sync
               then DataSynchronizationBarrier option
             else DataMemoryBarrier option))
   | _ => FAIL("syntax error");

fun p_isb (c,l) =
  case (p_suffix c,p_barrier_option l) of
     (Option.SOME c,Option.SOME(BitsN.B(0xF,_))) =>
       OK(c,Hint(InstructionSynchronizationBarrier(BitsN.B(0xF,4))))
   | _ => FAIL("syntax error");

fun p_vcmpe (c,l) =
  case (p_suffix c,l) of
     (Option.SOME(c,s),[d,v]) =>
       let
         val single = s = ("f32")
       in
         if single orelse (s = ("f64"))
           then case p_fp_register(single,d) of
                   Option.SOME dd =>
                     (case p_fp_register(single,v) of
                         Option.SOME dm =>
                           OK((c,""),
                              VFP(vcmp(not single,(dd,Option.SOME dm))))
                       | NONE =>
                         if (stripSpaces v) = ("#0.0")
                           then OK((c,""),VFP(vcmp(not single,(dd,NONE))))
                         else FAIL("syntax error"))
                 | NONE => FAIL("syntax error")
         else FAIL("syntax error")
       end
   | _ => FAIL("syntax error");

fun p_vmrs_register s =
  case p_register s of
     Option.SOME n =>
       (if n = (BitsN.B(0xF,4)) then NONE else Option.SOME n)
   | NONE =>
     if (stripSpaces s) = ("apsr_nzcv")
       then Option.SOME(BitsN.B(0xF,4))
     else NONE;

fun p_vmrs (c,l) =
  case (p_suffix c,l) of
     (Option.SOME c,[t,s]) =>
       (case (p_vmrs_register t,stripSpaces s) of
           (Option.SOME rt,"fpscr") => OK(c,VFP(vmrs rt))
         | _ => FAIL("syntax error"))
   | _ => FAIL("syntax error");

fun p_vmsr (c,l) =
  case (p_suffix c,l) of
     (Option.SOME c,[t,s]) =>
       (case (p_register s,stripSpaces t) of
           (Option.SOME rt,"fpscr") => OK(c,VFP(vmsr rt))
         | _ => FAIL("syntax error"))
   | _ => FAIL("syntax error");

fun p_vcvt (c,(r,l)) =
  case (r,(p_suffix2 c,l)) of
     (false,(Option.SOME(c,("f32","f64")),[d,m])) =>
       (case (p_fp_register(true,d),p_fp_register(false,m)) of
           (Option.SOME dd,Option.SOME mm) =>
             OK((c,""),VFP(vcvt_float(true,(dd,mm))))
         | _ => FAIL("syntax error"))
   | (false,(Option.SOME(c,("f64","f32")),[d,m])) =>
     (case (p_fp_register(false,d),p_fp_register(true,m)) of
         (Option.SOME dd,Option.SOME mm) =>
           OK((c,""),VFP(vcvt_float(false,(dd,mm))))
       | _ => FAIL("syntax error"))
   | (_,(Option.SOME(c,(s1,s2)),[d,m])) =>
     (if (not r) andalso
         ((Set.mem(s1,["f32","f64"])) andalso (Set.mem(s2,["u32","s32"])))
        then let
               val single = s1 = ("f32")
             in
               case (p_fp_register(single,d),p_fp_register(true,m)) of
                  (Option.SOME dd,Option.SOME mm) =>
                    OK((c,""),
                       VFP(vcvt_from_integer
                             (not single,(s2 = ("u32"),(dd,mm)))))
                | _ => FAIL("syntax error")
             end
      else if (Set.mem(s2,["f32","f64"])) andalso
         (Set.mem(s1,["u32","s32"]))
        then let
               val single = s2 = ("f32")
             in
               case (p_fp_register(true,d),p_fp_register(single,m)) of
                  (Option.SOME dd,Option.SOME mm) =>
                    OK((c,""),
                       VFP(vcvt_to_integer
                             (not single,(s1 = ("u32"),(not r,(dd,mm))))))
                | _ => FAIL("syntax error")
             end
      else FAIL("syntax error"))
   | _ => FAIL("syntax error");

fun p_fp2 (c,(opc,l)) =
  case (p_suffix c,l) of
     (Option.SOME(c,""),[r1,r2,r3,r4]) =>
       (case (opc = 0,
         (p_fp_register(true,r1),
          (p_fp_register(true,r2),(p_register r3,p_register r4)))) of
           (true,
            (Option.SOME rr1,
             (Option.SOME rr2,(Option.SOME rr3,Option.SOME rr4)))) =>
             (if rr2 = (BitsN.+(rr1,BitsN.B(0x1,5)))
                then OK((c,""),
                        VFP(vmov_two_singles(false,(rr3,(rr4,rr1)))))
              else FAIL("syntax error"))
         | (true,_) =>
           (case (p_register r1,
             (p_register r2,
              (p_fp_register(true,r3),p_fp_register(true,r4)))) of
               (Option.SOME rr1,
                (Option.SOME rr2,(Option.SOME rr3,Option.SOME rr4))) =>
                 (if rr4 = (BitsN.+(rr3,BitsN.B(0x1,5)))
                    then OK((c,""),
                            VFP(vmov_two_singles(true,(rr1,(rr2,rr3)))))
                  else FAIL("syntax error"))
             | _ => FAIL("syntax error"))
         | _ => FAIL("syntax error"))
   | (Option.SOME(c,""),[r1,r2,r3]) =>
     (case (opc = 0,
       (p_fp_register(false,r1),(p_register r2,p_register r3))) of
         (true,(Option.SOME rr1,(Option.SOME rr2,Option.SOME rr3))) =>
           OK((c,""),VFP(vmov_double(false,(rr2,(rr3,rr1)))))
       | (true,_) =>
         (case (p_register r1,(p_register r2,p_fp_register(false,r3))) of
             (Option.SOME rr1,(Option.SOME rr2,Option.SOME rr3)) =>
               OK((c,""),VFP(vmov_double(true,(rr1,(rr2,rr3)))))
           | _ => FAIL("syntax error"))
       | _ => FAIL("syntax error"))
   | (Option.SOME(c,""),[d,t]) =>
     (case (opc = 0,(p_fp_register(true,d),p_register t)) of
         (true,(Option.SOME dd,Option.SOME tt)) =>
           OK((c,""),VFP(vmov_single(false,(tt,dd))))
       | (true,_) =>
         (case (p_register d,p_fp_register(true,t)) of
             (Option.SOME tt,Option.SOME dd) =>
               OK((c,""),VFP(vmov_single(true,(tt,dd))))
           | _ => FAIL("syntax error"))
       | _ => FAIL("syntax error"))
   | (Option.SOME(c,s),[d,v]) =>
     let
       val single = s = ("f32")
       val double = s = ("f64")
     in
       if single orelse double
         then case p_fp_register(single,d) of
                 Option.SOME dd =>
                   (case p_fp_register(single,v) of
                       Option.SOME dm =>
                         OK((c,""),
                            VFP(case opc of
                                   0 => vmov(single,(dd,dm))
                                 | 1 => vabs(double,(dd,dm))
                                 | 2 => vneg(double,(dd,dm))
                                 | _ => vsqrt(double,(dd,dm))))
                     | NONE =>
                       if opc = 0
                         then case p_arm_fp_immediate(single,v) of
                                 Option.SOME("",imm64) =>
                                   OK((c,""),
                                      VFP(vmov_imm(single,(dd,imm64))))
                               | Option.SOME(err,_) => FAIL err
                               | NONE => FAIL("syntax error")
                       else FAIL("syntax error"))
               | NONE => FAIL("syntax error")
       else FAIL("syntax error")
     end
   | _ => FAIL("syntax error");

fun p_fp3 (c,(opc,l)) =
  case p_suffix c of
     Option.SOME(c,s) =>
       let
         val single = s = ("f32")
         val double = s = ("f64")
       in
         if single orelse double
           then case p_fp_register3(single,l) of
                   Option.SOME(d,(n,m)) =>
                     OK((c,""),
                        VFP(case opc of
                               0 => vadd(double,(d,(n,m)))
                             | 1 => vsub(double,(d,(n,m)))
                             | 2 => vmul(double,(d,(n,m)))
                             | 3 => vdiv(double,(d,(n,m)))
                             | 4 => vmla_vmls(double,(true,(d,(n,m))))
                             | 5 => vmla_vmls(double,(false,(d,(n,m))))
                             | 6 => vfma_vfms(double,(true,(d,(n,m))))
                             | 7 => vfma_vfms(double,(false,(d,(n,m))))
                             | 8 => vfnma_vfnms(double,(true,(d,(n,m))))
                             | 9 => vfnma_vfnms(double,(false,(d,(n,m))))
                             | 10 =>
                               vneg_mul
                                 (double,(VFPNegMul_VNMLA,(d,(n,m))))
                             | 11 =>
                               vneg_mul
                                 (double,(VFPNegMul_VNMLS,(d,(n,m))))
                             | _ =>
                               vneg_mul
                                 (double,(VFPNegMul_VNMUL,(d,(n,m))))))
                 | NONE => FAIL("syntax error")
         else FAIL("syntax error")
       end
   | _ => FAIL("syntax error");

fun p_vldr_vstr (c,(load,l)) =
  case (p_suffix c,l) of
     (Option.SOME(c,s),r :: t) =>
       (case p_any_fp_register(r,s) of
           Option.SOME(single,d) =>
             (case p_address_mode2 t of
                 ("",
                  Option.SOME
                    (add,(true,(false,(n,immediate_form2 imm32))))) =>
                   let
                     val arg = (single,(add,(d,(n,imm32))))
                   in
                     OK((c,""),VFP(if load then vldr arg else vstr arg))
                   end
               | ("",Option.SOME _) => FAIL("syntax error")
               | (err,_) =>
                 (case t of
                     [l] =>
                       (case p_label l of
                           Option.SOME s =>
                             let
                               val arg =
                                 (single,
                                  (false,
                                   (d,(BitsN.B(0xF,4),BitsN.B(0x0,32)))))
                             in
                               PENDING
                                 (s,
                                  ((c,""),
                                   VFP(if load then vldr arg else vstr arg)))
                             end
                         | NONE => FAIL err)
                   | _ => FAIL err))
         | NONE => FAIL("syntax error"))
   | _ => FAIL("syntax error");

fun p_noarg (c,i) =
  case p_suffix c of
     Option.SOME c => OK(c,i)
   | NONE => FAIL("syntax error");

fun p_tokens s =
  let
    val (l,r) =
      L3.splitl
        (fn c => not(Char.isSpace c),
         L3.lowercase(L3.snd(L3.splitl(fn c => Char.isSpace c,s))))
    val r = L3.uncurry String.fields (fn c => c = #",",r)
    val r =
      if ((L3.length r) = 1) andalso ((stripSpaces(List.hd r)) = (""))
        then []
      else r
  in
    l :: r
  end;

fun instructionFromString s =
  case p_tokens s of
     v'0 :: v'1 =>
       (case (String.explode v'0,v'1) of
           (#"c" :: (#"l" :: (#"z" :: c)),l) => p_clz(String.implode c,l)
         | (#"m" :: (#"o" :: (#"v" :: (#"t" :: c))),l) =>
           p_movt_movw(String.implode c,(true,l))
         | (#"m" :: (#"o" :: (#"v" :: (#"w" :: c))),l) =>
           p_movt_movw(String.implode c,(false,l))
         | (#"a" :: (#"d" :: (#"d" :: (#"w" :: c))),l) =>
           p_addw_subw(String.implode c,(false,l))
         | (#"s" :: (#"u" :: (#"b" :: (#"w" :: c))),l) =>
           p_addw_subw(String.implode c,(true,l))
         | (#"a" :: (#"d" :: (#"r" :: c)),l) => p_adr(String.implode c,l)
         | (#"a" :: (#"n" :: (#"d" :: (#"s" :: c))),l) =>
           p_arith_logic(String.implode c,(BitsN.B(0x0,4),(true,l)))
         | (#"a" :: (#"n" :: (#"d" :: c)),l) =>
           p_arith_logic(String.implode c,(BitsN.B(0x0,4),(false,l)))
         | (#"e" :: (#"o" :: (#"r" :: (#"s" :: c))),l) =>
           p_arith_logic(String.implode c,(BitsN.B(0x1,4),(true,l)))
         | (#"e" :: (#"o" :: (#"r" :: c)),l) =>
           p_arith_logic(String.implode c,(BitsN.B(0x1,4),(false,l)))
         | (#"s" :: (#"u" :: (#"b" :: (#"s" :: c))),l) =>
           p_arith_logic(String.implode c,(BitsN.B(0x2,4),(true,l)))
         | (#"s" :: (#"u" :: (#"b" :: c)),l) =>
           p_arith_logic(String.implode c,(BitsN.B(0x2,4),(false,l)))
         | (#"r" :: (#"s" :: (#"b" :: (#"s" :: c))),l) =>
           p_arith_logic(String.implode c,(BitsN.B(0x3,4),(true,l)))
         | (#"r" :: (#"s" :: (#"b" :: c)),l) =>
           p_arith_logic(String.implode c,(BitsN.B(0x3,4),(false,l)))
         | (#"a" :: (#"d" :: (#"d" :: (#"s" :: c))),l) =>
           p_arith_logic(String.implode c,(BitsN.B(0x4,4),(true,l)))
         | (#"a" :: (#"d" :: (#"d" :: c)),l) =>
           p_arith_logic(String.implode c,(BitsN.B(0x4,4),(false,l)))
         | (#"a" :: (#"d" :: (#"c" :: (#"s" :: c))),l) =>
           p_arith_logic(String.implode c,(BitsN.B(0x5,4),(true,l)))
         | (#"a" :: (#"d" :: (#"c" :: c)),l) =>
           p_arith_logic(String.implode c,(BitsN.B(0x5,4),(false,l)))
         | (#"s" :: (#"b" :: (#"c" :: (#"s" :: c))),l) =>
           p_arith_logic(String.implode c,(BitsN.B(0x6,4),(true,l)))
         | (#"s" :: (#"b" :: (#"c" :: c)),l) =>
           p_arith_logic(String.implode c,(BitsN.B(0x6,4),(false,l)))
         | (#"r" :: (#"s" :: (#"c" :: (#"s" :: c))),l) =>
           p_arith_logic(String.implode c,(BitsN.B(0x7,4),(true,l)))
         | (#"r" :: (#"s" :: (#"c" :: c)),l) =>
           p_arith_logic(String.implode c,(BitsN.B(0x7,4),(false,l)))
         | (#"o" :: (#"r" :: (#"r" :: (#"s" :: c))),l) =>
           p_arith_logic(String.implode c,(BitsN.B(0xC,4),(true,l)))
         | (#"o" :: (#"r" :: (#"r" :: c)),l) =>
           p_arith_logic(String.implode c,(BitsN.B(0xC,4),(false,l)))
         | (#"b" :: (#"i" :: (#"c" :: (#"s" :: c))),l) =>
           p_arith_logic(String.implode c,(BitsN.B(0xE,4),(true,l)))
         | (#"b" :: (#"i" :: (#"c" :: c)),l) =>
           p_arith_logic(String.implode c,(BitsN.B(0xE,4),(false,l)))
         | (#"t" :: (#"s" :: (#"t" :: c)),l) =>
           p_test_compare(String.implode c,(BitsN.B(0x0,2),l))
         | (#"t" :: (#"e" :: (#"q" :: c)),l) =>
           p_test_compare(String.implode c,(BitsN.B(0x1,2),l))
         | (#"c" :: (#"m" :: (#"p" :: c)),l) =>
           p_test_compare(String.implode c,(BitsN.B(0x2,2),l))
         | (#"c" :: (#"m" :: (#"n" :: c)),l) =>
           p_test_compare(String.implode c,(BitsN.B(0x3,2),l))
         | (#"m" :: (#"o" :: (#"v" :: (#"s" :: c))),l) =>
           p_mov_mvn(String.implode c,(false,(true,l)))
         | (#"m" :: (#"o" :: (#"v" :: c)),l) =>
           p_mov_mvn(String.implode c,(false,(false,l)))
         | (#"m" :: (#"v" :: (#"n" :: (#"s" :: c))),l) =>
           p_mov_mvn(String.implode c,(true,(true,l)))
         | (#"m" :: (#"v" :: (#"n" :: c)),l) =>
           p_mov_mvn(String.implode c,(true,(false,l)))
         | (#"l" :: (#"s" :: (#"l" :: (#"s" :: c))),l) =>
           p_shift(String.implode c,(SRType_LSL,(true,l)))
         | (#"l" :: (#"s" :: (#"l" :: c)),l) =>
           p_shift(String.implode c,(SRType_LSL,(false,l)))
         | (#"l" :: (#"s" :: (#"r" :: (#"s" :: c))),l) =>
           p_shift(String.implode c,(SRType_LSR,(true,l)))
         | (#"l" :: (#"s" :: (#"r" :: c)),l) =>
           p_shift(String.implode c,(SRType_LSR,(false,l)))
         | (#"a" :: (#"s" :: (#"r" :: (#"s" :: c))),l) =>
           p_shift(String.implode c,(SRType_ASR,(true,l)))
         | (#"a" :: (#"s" :: (#"r" :: c)),l) =>
           p_shift(String.implode c,(SRType_ASR,(false,l)))
         | (#"r" :: (#"o" :: (#"r" :: (#"s" :: c))),l) =>
           p_shift(String.implode c,(SRType_ROR,(true,l)))
         | (#"r" :: (#"o" :: (#"r" :: c)),l) =>
           p_shift(String.implode c,(SRType_ROR,(false,l)))
         | (#"r" :: (#"r" :: (#"x" :: (#"s" :: c))),l) =>
           p_rrx(String.implode c,(true,l))
         | (#"r" :: (#"r" :: (#"x" :: c)),l) =>
           p_rrx(String.implode c,(false,l))
         | (#"m" :: (#"u" :: (#"l" :: (#"s" :: c))),l) =>
           p_mul(String.implode c,(true,l))
         | (#"m" :: (#"u" :: (#"l" :: c)),l) =>
           p_mul(String.implode c,(false,l))
         | (#"m" :: (#"l" :: (#"a" :: (#"s" :: c))),l) =>
           p_mla(String.implode c,(true,l))
         | (#"m" :: (#"l" :: (#"a" :: c)),l) =>
           p_mla(String.implode c,(false,l))
         | (#"m" :: (#"l" :: (#"s" :: c)),l) => p_mls(String.implode c,l)
         | (#"u" :: (#"m" :: (#"a" :: (#"a" :: (#"l" :: c)))),l) =>
           p_umaal(String.implode c,l)
         | (#"s" ::
          (#"m" :: (#"l" :: (#"a" :: (#"l" :: (#"b" :: (#"b" :: c)))))),l) =>
           p_smlal(String.implode c,(false,(false,l)))
         | (#"s" ::
          (#"m" :: (#"l" :: (#"a" :: (#"l" :: (#"b" :: (#"t" :: c)))))),l) =>
           p_smlal(String.implode c,(false,(true,l)))
         | (#"s" ::
          (#"m" :: (#"l" :: (#"a" :: (#"l" :: (#"t" :: (#"b" :: c)))))),l) =>
           p_smlal(String.implode c,(true,(false,l)))
         | (#"s" ::
          (#"m" :: (#"l" :: (#"a" :: (#"l" :: (#"t" :: (#"t" :: c)))))),l) =>
           p_smlal(String.implode c,(true,(true,l)))
         | (#"s" ::
          (#"m" :: (#"l" :: (#"a" :: (#"l" :: (#"d" :: (#"x" :: c)))))),l) =>
           p_smlald_smlsld(String.implode c,(false,(true,l)))
         | (#"s" ::
          (#"m" :: (#"l" :: (#"s" :: (#"l" :: (#"d" :: (#"x" :: c)))))),l) =>
           p_smlald_smlsld(String.implode c,(true,(true,l)))
         | (#"s" :: (#"m" :: (#"l" :: (#"a" :: (#"l" :: (#"d" :: c))))),l) =>
           p_smlald_smlsld(String.implode c,(false,(false,l)))
         | (#"s" :: (#"m" :: (#"l" :: (#"s" :: (#"l" :: (#"d" :: c))))),l) =>
           p_smlald_smlsld(String.implode c,(true,(false,l)))
         | (#"u" :: (#"m" :: (#"u" :: (#"l" :: (#"l" :: (#"s" :: c))))),l) =>
           p_umull_etc(String.implode c,(false,(false,(true,l))))
         | (#"u" :: (#"m" :: (#"u" :: (#"l" :: (#"l" :: c)))),l) =>
           p_umull_etc(String.implode c,(false,(false,(false,l))))
         | (#"s" :: (#"m" :: (#"u" :: (#"l" :: (#"l" :: (#"s" :: c))))),l) =>
           p_umull_etc(String.implode c,(false,(true,(true,l))))
         | (#"s" :: (#"m" :: (#"u" :: (#"l" :: (#"l" :: c)))),l) =>
           p_umull_etc(String.implode c,(false,(true,(false,l))))
         | (#"u" :: (#"m" :: (#"l" :: (#"a" :: (#"l" :: (#"s" :: c))))),l) =>
           p_umull_etc(String.implode c,(true,(false,(true,l))))
         | (#"u" :: (#"m" :: (#"l" :: (#"a" :: (#"l" :: c)))),l) =>
           p_umull_etc(String.implode c,(true,(false,(false,l))))
         | (#"s" :: (#"m" :: (#"l" :: (#"a" :: (#"l" :: (#"s" :: c))))),l) =>
           p_umull_etc(String.implode c,(true,(true,(true,l))))
         | (#"s" :: (#"m" :: (#"l" :: (#"a" :: (#"l" :: c)))),l) =>
           p_umull_etc(String.implode c,(true,(true,(false,l))))
         | (#"s" :: (#"m" :: (#"u" :: (#"l" :: (#"b" :: (#"b" :: c))))),l) =>
           p_smul(String.implode c,(false,(false,l)))
         | (#"s" :: (#"m" :: (#"u" :: (#"l" :: (#"b" :: (#"t" :: c))))),l) =>
           p_smul(String.implode c,(false,(true,l)))
         | (#"s" :: (#"m" :: (#"u" :: (#"l" :: (#"t" :: (#"b" :: c))))),l) =>
           p_smul(String.implode c,(true,(false,l)))
         | (#"s" :: (#"m" :: (#"u" :: (#"l" :: (#"t" :: (#"t" :: c))))),l) =>
           p_smul(String.implode c,(true,(true,l)))
         | (#"s" :: (#"m" :: (#"l" :: (#"a" :: (#"b" :: (#"b" :: c))))),l) =>
           p_smla(String.implode c,(false,(false,l)))
         | (#"s" :: (#"m" :: (#"l" :: (#"a" :: (#"b" :: (#"t" :: c))))),l) =>
           p_smla(String.implode c,(false,(true,l)))
         | (#"s" :: (#"m" :: (#"l" :: (#"a" :: (#"t" :: (#"b" :: c))))),l) =>
           p_smla(String.implode c,(true,(false,l)))
         | (#"s" :: (#"m" :: (#"l" :: (#"a" :: (#"t" :: (#"t" :: c))))),l) =>
           p_smla(String.implode c,(true,(true,l)))
         | (#"s" :: (#"m" :: (#"l" :: (#"a" :: (#"w" :: (#"b" :: c))))),l) =>
           p_smlaw(String.implode c,(false,l))
         | (#"s" :: (#"m" :: (#"l" :: (#"a" :: (#"w" :: (#"t" :: c))))),l) =>
           p_smlaw(String.implode c,(true,l))
         | (#"s" :: (#"m" :: (#"u" :: (#"l" :: (#"w" :: (#"b" :: c))))),l) =>
           p_smulw(String.implode c,(false,l))
         | (#"s" :: (#"m" :: (#"u" :: (#"l" :: (#"w" :: (#"t" :: c))))),l) =>
           p_smulw(String.implode c,(true,l))
         | (#"s" :: (#"m" :: (#"u" :: (#"a" :: (#"d" :: (#"x" :: c))))),l) =>
           p_smuad_smusd(String.implode c,(false,(true,l)))
         | (#"s" :: (#"m" :: (#"u" :: (#"s" :: (#"d" :: (#"x" :: c))))),l) =>
           p_smuad_smusd(String.implode c,(true,(true,l)))
         | (#"s" :: (#"m" :: (#"u" :: (#"a" :: (#"d" :: c)))),l) =>
           p_smuad_smusd(String.implode c,(false,(false,l)))
         | (#"s" :: (#"m" :: (#"u" :: (#"s" :: (#"d" :: c)))),l) =>
           p_smuad_smusd(String.implode c,(true,(false,l)))
         | (#"s" :: (#"m" :: (#"l" :: (#"a" :: (#"d" :: (#"x" :: c))))),l) =>
           p_smlad_smlsd(String.implode c,(false,(true,l)))
         | (#"s" :: (#"m" :: (#"l" :: (#"s" :: (#"d" :: (#"x" :: c))))),l) =>
           p_smlad_smlsd(String.implode c,(true,(true,l)))
         | (#"s" :: (#"m" :: (#"l" :: (#"a" :: (#"d" :: c)))),l) =>
           p_smlad_smlsd(String.implode c,(false,(false,l)))
         | (#"s" :: (#"m" :: (#"l" :: (#"s" :: (#"d" :: c)))),l) =>
           p_smlad_smlsd(String.implode c,(true,(false,l)))
         | (#"s" :: (#"m" :: (#"m" :: (#"u" :: (#"l" :: (#"r" :: c))))),l) =>
           p_smmul(String.implode c,(true,l))
         | (#"s" :: (#"m" :: (#"m" :: (#"u" :: (#"l" :: c)))),l) =>
           p_smmul(String.implode c,(false,l))
         | (#"s" :: (#"m" :: (#"m" :: (#"l" :: (#"a" :: (#"r" :: c))))),l) =>
           p_smmla(String.implode c,(true,l))
         | (#"s" :: (#"m" :: (#"m" :: (#"l" :: (#"a" :: c)))),l) =>
           p_smmla(String.implode c,(false,l))
         | (#"s" :: (#"m" :: (#"m" :: (#"l" :: (#"s" :: (#"r" :: c))))),l) =>
           p_smmls(String.implode c,(true,l))
         | (#"s" :: (#"m" :: (#"m" :: (#"l" :: (#"s" :: c)))),l) =>
           p_smmls(String.implode c,(false,l))
         | (#"s" :: (#"a" :: (#"d" :: (#"d" :: (#"1" :: (#"6" :: c))))),l) =>
           p_sadd16_etc(String.implode c,(BitsN.B(0x0,2),l))
         | (#"s" :: (#"a" :: (#"s" :: (#"x" :: c))),l) =>
           p_sadd16_etc(String.implode c,(BitsN.B(0x1,2),l))
         | (#"s" :: (#"s" :: (#"a" :: (#"x" :: c))),l) =>
           p_sadd16_etc(String.implode c,(BitsN.B(0x2,2),l))
         | (#"s" :: (#"s" :: (#"u" :: (#"b" :: (#"1" :: (#"6" :: c))))),l) =>
           p_sadd16_etc(String.implode c,(BitsN.B(0x3,2),l))
         | (#"q" :: (#"a" :: (#"d" :: (#"d" :: (#"1" :: (#"6" :: c))))),l) =>
           p_qadd16_etc(String.implode c,(BitsN.B(0x0,2),l))
         | (#"q" :: (#"a" :: (#"s" :: (#"x" :: c))),l) =>
           p_qadd16_etc(String.implode c,(BitsN.B(0x1,2),l))
         | (#"q" :: (#"s" :: (#"a" :: (#"x" :: c))),l) =>
           p_qadd16_etc(String.implode c,(BitsN.B(0x2,2),l))
         | (#"q" :: (#"s" :: (#"u" :: (#"b" :: (#"1" :: (#"6" :: c))))),l) =>
           p_qadd16_etc(String.implode c,(BitsN.B(0x3,2),l))
         | (#"s" ::
          (#"h" :: (#"a" :: (#"d" :: (#"d" :: (#"1" :: (#"6" :: c)))))),l) =>
           p_shadd16_etc(String.implode c,(BitsN.B(0x0,2),l))
         | (#"s" :: (#"h" :: (#"a" :: (#"s" :: (#"x" :: c)))),l) =>
           p_shadd16_etc(String.implode c,(BitsN.B(0x1,2),l))
         | (#"s" :: (#"h" :: (#"s" :: (#"a" :: (#"x" :: c)))),l) =>
           p_shadd16_etc(String.implode c,(BitsN.B(0x2,2),l))
         | (#"s" ::
          (#"h" :: (#"s" :: (#"u" :: (#"b" :: (#"1" :: (#"6" :: c)))))),l) =>
           p_shadd16_etc(String.implode c,(BitsN.B(0x3,2),l))
         | (#"s" :: (#"a" :: (#"d" :: (#"d" :: (#"8" :: c)))),l) =>
           p_sadd8_etc(String.implode c,(false,l))
         | (#"s" :: (#"s" :: (#"u" :: (#"b" :: (#"8" :: c)))),l) =>
           p_sadd8_etc(String.implode c,(true,l))
         | (#"q" :: (#"a" :: (#"d" :: (#"d" :: (#"8" :: c)))),l) =>
           p_qadd8_etc(String.implode c,(false,l))
         | (#"q" :: (#"s" :: (#"u" :: (#"b" :: (#"8" :: c)))),l) =>
           p_qadd8_etc(String.implode c,(true,l))
         | (#"s" :: (#"h" :: (#"a" :: (#"d" :: (#"d" :: (#"8" :: c))))),l) =>
           p_shadd8_etc(String.implode c,(false,l))
         | (#"s" :: (#"h" :: (#"s" :: (#"u" :: (#"b" :: (#"8" :: c))))),l) =>
           p_shadd8_etc(String.implode c,(true,l))
         | (#"u" :: (#"a" :: (#"d" :: (#"d" :: (#"1" :: (#"6" :: c))))),l) =>
           p_uadd16_etc(String.implode c,(BitsN.B(0x0,2),l))
         | (#"u" :: (#"a" :: (#"s" :: (#"x" :: c))),l) =>
           p_uadd16_etc(String.implode c,(BitsN.B(0x1,2),l))
         | (#"u" :: (#"s" :: (#"a" :: (#"x" :: c))),l) =>
           p_uadd16_etc(String.implode c,(BitsN.B(0x2,2),l))
         | (#"u" :: (#"s" :: (#"u" :: (#"b" :: (#"1" :: (#"6" :: c))))),l) =>
           p_uadd16_etc(String.implode c,(BitsN.B(0x3,2),l))
         | (#"u" ::
          (#"q" :: (#"a" :: (#"d" :: (#"d" :: (#"1" :: (#"6" :: c)))))),l) =>
           p_uqadd16_etc(String.implode c,(BitsN.B(0x0,2),l))
         | (#"u" :: (#"q" :: (#"a" :: (#"s" :: (#"x" :: c)))),l) =>
           p_uqadd16_etc(String.implode c,(BitsN.B(0x1,2),l))
         | (#"u" :: (#"q" :: (#"s" :: (#"a" :: (#"x" :: c)))),l) =>
           p_uqadd16_etc(String.implode c,(BitsN.B(0x2,2),l))
         | (#"u" ::
          (#"q" :: (#"s" :: (#"u" :: (#"b" :: (#"1" :: (#"6" :: c)))))),l) =>
           p_uqadd16_etc(String.implode c,(BitsN.B(0x3,2),l))
         | (#"u" ::
          (#"h" :: (#"a" :: (#"d" :: (#"d" :: (#"1" :: (#"6" :: c)))))),l) =>
           p_uhadd16_etc(String.implode c,(BitsN.B(0x0,2),l))
         | (#"u" :: (#"h" :: (#"a" :: (#"s" :: (#"x" :: c)))),l) =>
           p_uhadd16_etc(String.implode c,(BitsN.B(0x1,2),l))
         | (#"u" :: (#"h" :: (#"s" :: (#"a" :: (#"x" :: c)))),l) =>
           p_uhadd16_etc(String.implode c,(BitsN.B(0x2,2),l))
         | (#"u" ::
          (#"h" :: (#"s" :: (#"u" :: (#"b" :: (#"1" :: (#"6" :: c)))))),l) =>
           p_uhadd16_etc(String.implode c,(BitsN.B(0x3,2),l))
         | (#"u" :: (#"a" :: (#"d" :: (#"d" :: (#"8" :: c)))),l) =>
           p_uadd8_etc(String.implode c,(false,l))
         | (#"u" :: (#"s" :: (#"u" :: (#"b" :: (#"8" :: c)))),l) =>
           p_uadd8_etc(String.implode c,(true,l))
         | (#"u" :: (#"q" :: (#"a" :: (#"d" :: (#"d" :: (#"8" :: c))))),l) =>
           p_uqadd8_etc(String.implode c,(false,l))
         | (#"u" :: (#"q" :: (#"s" :: (#"u" :: (#"b" :: (#"8" :: c))))),l) =>
           p_uqadd8_etc(String.implode c,(true,l))
         | (#"u" :: (#"h" :: (#"a" :: (#"d" :: (#"d" :: (#"8" :: c))))),l) =>
           p_uhadd8_etc(String.implode c,(false,l))
         | (#"u" :: (#"h" :: (#"s" :: (#"u" :: (#"b" :: (#"8" :: c))))),l) =>
           p_uhadd8_etc(String.implode c,(true,l))
         | (#"u" :: (#"s" :: (#"a" :: (#"d" :: (#"8" :: c)))),l) =>
           p_usad8(String.implode c,l)
         | (#"u" :: (#"s" :: (#"a" :: (#"d" :: (#"a" :: (#"8" :: c))))),l) =>
           p_usada8(String.implode c,l)
         | (#"q" :: (#"a" :: (#"d" :: (#"d" :: c))),l) =>
           p_qadd_etc(String.implode c,(BitsN.B(0x0,2),l))
         | (#"q" :: (#"s" :: (#"u" :: (#"b" :: c))),l) =>
           p_qadd_etc(String.implode c,(BitsN.B(0x1,2),l))
         | (#"q" :: (#"d" :: (#"a" :: (#"d" :: (#"d" :: c)))),l) =>
           p_qadd_etc(String.implode c,(BitsN.B(0x2,2),l))
         | (#"q" :: (#"d" :: (#"s" :: (#"u" :: (#"b" :: c)))),l) =>
           p_qadd_etc(String.implode c,(BitsN.B(0x3,2),l))
         | (#"p" :: (#"k" :: (#"h" :: (#"t" :: (#"b" :: c)))),l) =>
           p_pkhbt_pkhtb(String.implode c,(true,l))
         | (#"p" :: (#"k" :: (#"h" :: (#"b" :: (#"t" :: c)))),l) =>
           p_pkhbt_pkhtb(String.implode c,(false,l))
         | (#"s" :: (#"s" :: (#"a" :: (#"t" :: (#"1" :: (#"6" :: c))))),l) =>
           p_sat16(String.implode c,(false,l))
         | (#"u" :: (#"s" :: (#"a" :: (#"t" :: (#"1" :: (#"6" :: c))))),l) =>
           p_sat16(String.implode c,(true,l))
         | (#"s" :: (#"s" :: (#"a" :: (#"t" :: c))),l) =>
           p_sat(String.implode c,(false,l))
         | (#"u" :: (#"s" :: (#"a" :: (#"t" :: c))),l) =>
           p_sat(String.implode c,(true,l))
         | (#"s" :: (#"x" :: (#"t" :: (#"b" :: (#"1" :: (#"6" :: c))))),l) =>
           p_sxtb_etc(String.implode c,(0,(false,l)))
         | (#"u" :: (#"x" :: (#"t" :: (#"b" :: (#"1" :: (#"6" :: c))))),l) =>
           p_sxtb_etc(String.implode c,(0,(true,l)))
         | (#"s" :: (#"x" :: (#"t" :: (#"b" :: c))),l) =>
           p_sxtb_etc(String.implode c,(1,(false,l)))
         | (#"u" :: (#"x" :: (#"t" :: (#"b" :: c))),l) =>
           p_sxtb_etc(String.implode c,(1,(true,l)))
         | (#"s" :: (#"x" :: (#"t" :: (#"h" :: c))),l) =>
           p_sxtb_etc(String.implode c,(2,(false,l)))
         | (#"u" :: (#"x" :: (#"t" :: (#"h" :: c))),l) =>
           p_sxtb_etc(String.implode c,(2,(true,l)))
         | (#"s" ::
          (#"x" :: (#"t" :: (#"a" :: (#"b" :: (#"1" :: (#"6" :: c)))))),l) =>
           p_sxtab_etc(String.implode c,(0,(false,l)))
         | (#"u" ::
          (#"x" :: (#"t" :: (#"a" :: (#"b" :: (#"1" :: (#"6" :: c)))))),l) =>
           p_sxtab_etc(String.implode c,(0,(true,l)))
         | (#"s" :: (#"x" :: (#"t" :: (#"a" :: (#"b" :: c)))),l) =>
           p_sxtab_etc(String.implode c,(1,(false,l)))
         | (#"u" :: (#"x" :: (#"t" :: (#"a" :: (#"b" :: c)))),l) =>
           p_sxtab_etc(String.implode c,(1,(true,l)))
         | (#"s" :: (#"x" :: (#"t" :: (#"a" :: (#"h" :: c)))),l) =>
           p_sxtab_etc(String.implode c,(2,(false,l)))
         | (#"u" :: (#"x" :: (#"t" :: (#"a" :: (#"h" :: c)))),l) =>
           p_sxtab_etc(String.implode c,(2,(true,l)))
         | (#"s" :: (#"e" :: (#"l" :: c)),l) => p_sel(String.implode c,l)
         | (#"r" :: (#"e" :: (#"v" :: (#"1" :: (#"6" :: c)))),l) =>
           p_rev16(String.implode c,l)
         | (#"r" :: (#"e" :: (#"v" :: (#"s" :: (#"h" :: c)))),l) =>
           p_revsh(String.implode c,l)
         | (#"r" :: (#"e" :: (#"v" :: c)),l) => p_rev(String.implode c,l)
         | (#"r" :: (#"b" :: (#"i" :: (#"t" :: c))),l) =>
           p_rbit(String.implode c,l)
         | (#"s" :: (#"b" :: (#"f" :: (#"x" :: c))),l) =>
           p_sbfx_ubfx(String.implode c,(false,l))
         | (#"u" :: (#"b" :: (#"f" :: (#"x" :: c))),l) =>
           p_sbfx_ubfx(String.implode c,(true,l))
         | (#"b" :: (#"f" :: (#"c" :: c)),l) => p_bfc(String.implode c,l)
         | (#"b" :: (#"f" :: (#"i" :: c)),l) => p_bfi(String.implode c,l)
         | (#"p" :: (#"l" :: (#"d" :: (#"w" :: c))),l) =>
           p_pld(String.implode c,(true,l))
         | (#"p" :: (#"l" :: (#"d" :: c)),l) =>
           p_pld(String.implode c,(false,l))
         | (#"p" :: (#"l" :: (#"i" :: c)),l) => p_pli(String.implode c,l)
         | (#"l" :: (#"d" :: (#"r" :: (#"t" :: c))),l) =>
           p_ldrt_strt1(String.implode c,(0,l))
         | (#"l" :: (#"d" :: (#"r" :: (#"b" :: (#"t" :: c)))),l) =>
           p_ldrt_strt1(String.implode c,(1,l))
         | (#"s" :: (#"t" :: (#"r" :: (#"t" :: c))),l) =>
           p_ldrt_strt1(String.implode c,(2,l))
         | (#"s" :: (#"t" :: (#"r" :: (#"b" :: (#"t" :: c)))),l) =>
           p_ldrt_strt1(String.implode c,(3,l))
         | (#"l" :: (#"d" :: (#"r" :: (#"s" :: (#"b" :: (#"t" :: c))))),l) =>
           p_ldrt_strt2(String.implode c,(0,l))
         | (#"l" :: (#"d" :: (#"r" :: (#"s" :: (#"h" :: (#"t" :: c))))),l) =>
           p_ldrt_strt2(String.implode c,(1,l))
         | (#"l" :: (#"d" :: (#"r" :: (#"h" :: (#"t" :: c)))),l) =>
           p_ldrt_strt2(String.implode c,(2,l))
         | (#"s" :: (#"t" :: (#"r" :: (#"h" :: (#"t" :: c)))),l) =>
           p_ldrt_strt2(String.implode c,(3,l))
         | (#"l" :: (#"d" :: (#"r" :: (#"b" :: c))),l) =>
           p_ldrb_ldrh(String.implode c,(true,(true,l)))
         | (#"l" :: (#"d" :: (#"r" :: (#"s" :: (#"b" :: c)))),l) =>
           p_ldrb_ldrh(String.implode c,(false,(true,l)))
         | (#"l" :: (#"d" :: (#"r" :: (#"h" :: c))),l) =>
           p_ldrb_ldrh(String.implode c,(true,(false,l)))
         | (#"l" :: (#"d" :: (#"r" :: (#"s" :: (#"h" :: c)))),l) =>
           p_ldrb_ldrh(String.implode c,(false,(false,l)))
         | (#"l" :: (#"d" :: (#"r" :: (#"d" :: c))),l) =>
           p_ldrd_strd(String.implode c,(true,l))
         | (#"s" :: (#"t" :: (#"r" :: (#"d" :: c))),l) =>
           p_ldrd_strd(String.implode c,(false,l))
         | (#"l" :: (#"d" :: (#"r" :: (#"e" :: (#"x" :: (#"b" :: c))))),l) =>
           p_ldrexb_ldrexh(String.implode c,(true,l))
         | (#"l" :: (#"d" :: (#"r" :: (#"e" :: (#"x" :: (#"h" :: c))))),l) =>
           p_ldrexb_ldrexh(String.implode c,(false,l))
         | (#"l" :: (#"d" :: (#"r" :: (#"e" :: (#"x" :: (#"d" :: c))))),l) =>
           p_ldrexd(String.implode c,l)
         | (#"l" :: (#"d" :: (#"r" :: (#"e" :: (#"x" :: c)))),l) =>
           p_ldrex(String.implode c,l)
         | (#"s" :: (#"t" :: (#"r" :: (#"e" :: (#"x" :: (#"b" :: c))))),l) =>
           p_strexb_strexh(String.implode c,(true,l))
         | (#"s" :: (#"t" :: (#"r" :: (#"e" :: (#"x" :: (#"h" :: c))))),l) =>
           p_strexb_strexh(String.implode c,(false,l))
         | (#"s" :: (#"t" :: (#"r" :: (#"e" :: (#"x" :: (#"d" :: c))))),l) =>
           p_strexd(String.implode c,l)
         | (#"s" :: (#"t" :: (#"r" :: (#"e" :: (#"x" :: c)))),l) =>
           p_strex(String.implode c,l)
         | (#"l" :: (#"d" :: (#"r" :: c)),l) =>
           p_ldr_str(String.implode c,(0,l))
         | (#"s" :: (#"t" :: (#"r" :: (#"b" :: c))),l) =>
           p_ldr_str(String.implode c,(1,l))
         | (#"s" :: (#"t" :: (#"r" :: (#"h" :: c))),l) =>
           p_ldr_str(String.implode c,(2,l))
         | (#"s" :: (#"t" :: (#"r" :: c)),l) =>
           p_ldr_str(String.implode c,(3,l))
         | (#"p" :: (#"o" :: (#"p" :: c)),l) =>
           p_pop_push(String.implode c,(true,l))
         | (#"p" :: (#"u" :: (#"s" :: (#"h" :: c))),l) =>
           p_pop_push(String.implode c,(false,l))
         | (#"l" :: (#"d" :: (#"m" :: (#"d" :: (#"a" :: c)))),l) =>
           p_ldm_stm(String.implode c,(true,(false,(false,l))))
         | (#"l" :: (#"d" :: (#"m" :: (#"f" :: (#"a" :: c)))),l) =>
           p_ldm_stm(String.implode c,(true,(false,(false,l))))
         | (#"l" :: (#"d" :: (#"m" :: (#"d" :: (#"b" :: c)))),l) =>
           p_ldm_stm(String.implode c,(true,(false,(true,l))))
         | (#"l" :: (#"d" :: (#"m" :: (#"e" :: (#"a" :: c)))),l) =>
           p_ldm_stm(String.implode c,(true,(false,(true,l))))
         | (#"l" :: (#"d" :: (#"m" :: (#"i" :: (#"b" :: c)))),l) =>
           p_ldm_stm(String.implode c,(true,(true,(true,l))))
         | (#"l" :: (#"d" :: (#"m" :: (#"e" :: (#"d" :: c)))),l) =>
           p_ldm_stm(String.implode c,(true,(true,(true,l))))
         | (#"l" :: (#"d" :: (#"m" :: (#"i" :: (#"a" :: c)))),l) =>
           p_ldm_stm(String.implode c,(true,(true,(false,l))))
         | (#"l" :: (#"d" :: (#"m" :: (#"f" :: (#"d" :: c)))),l) =>
           p_ldm_stm(String.implode c,(true,(true,(false,l))))
         | (#"l" :: (#"d" :: (#"m" :: c)),l) =>
           p_ldm_stm(String.implode c,(true,(true,(false,l))))
         | (#"s" :: (#"t" :: (#"m" :: (#"d" :: (#"a" :: c)))),l) =>
           p_ldm_stm(String.implode c,(false,(false,(false,l))))
         | (#"s" :: (#"t" :: (#"m" :: (#"e" :: (#"d" :: c)))),l) =>
           p_ldm_stm(String.implode c,(false,(false,(false,l))))
         | (#"s" :: (#"t" :: (#"m" :: (#"d" :: (#"b" :: c)))),l) =>
           p_ldm_stm(String.implode c,(false,(false,(true,l))))
         | (#"s" :: (#"t" :: (#"m" :: (#"f" :: (#"d" :: c)))),l) =>
           p_ldm_stm(String.implode c,(false,(false,(true,l))))
         | (#"s" :: (#"t" :: (#"m" :: (#"i" :: (#"b" :: c)))),l) =>
           p_ldm_stm(String.implode c,(false,(true,(true,l))))
         | (#"s" :: (#"t" :: (#"m" :: (#"f" :: (#"a" :: c)))),l) =>
           p_ldm_stm(String.implode c,(false,(true,(true,l))))
         | (#"s" :: (#"t" :: (#"m" :: (#"i" :: (#"a" :: c)))),l) =>
           p_ldm_stm(String.implode c,(false,(true,(false,l))))
         | (#"s" :: (#"t" :: (#"m" :: (#"e" :: (#"a" :: c)))),l) =>
           p_ldm_stm(String.implode c,(false,(true,(false,l))))
         | (#"s" :: (#"t" :: (#"m" :: c)),l) =>
           p_ldm_stm(String.implode c,(false,(true,(false,l))))
         | (#"s" :: (#"w" :: (#"p" :: (#"b" :: c))),l) =>
           p_swp(String.implode c,(true,l))
         | (#"s" :: (#"w" :: (#"p" :: c)),l) =>
           p_swp(String.implode c,(false,l))
         | ([#"s",#"e",#"t",#"e",#"n",#"d"],l) => p_setend l
         | ([#"c",#"p",#"s",#"i",#"e"],l) => p_cps(true,(false,l))
         | ([#"c",#"p",#"s",#"i",#"d"],l) => p_cps(false,(true,l))
         | ([#"c",#"p",#"s"],l) => p_cps(false,(false,l))
         | (#"r" :: (#"f" :: (#"e" :: (#"d" :: (#"a" :: c)))),l) =>
           p_rfe(String.implode c,(false,(true,l)))
         | (#"r" :: (#"f" :: (#"e" :: (#"d" :: (#"b" :: c)))),l) =>
           p_rfe(String.implode c,(false,(false,l)))
         | (#"r" :: (#"f" :: (#"e" :: (#"i" :: (#"a" :: c)))),l) =>
           p_rfe(String.implode c,(true,(false,l)))
         | (#"r" :: (#"f" :: (#"e" :: (#"i" :: (#"b" :: c)))),l) =>
           p_rfe(String.implode c,(true,(true,l)))
         | (#"r" :: (#"f" :: (#"e" :: c)),l) =>
           p_rfe(String.implode c,(true,(false,l)))
         | (#"s" :: (#"r" :: (#"s" :: (#"d" :: (#"a" :: c)))),l) =>
           p_srs(String.implode c,(false,(true,l)))
         | (#"s" :: (#"r" :: (#"s" :: (#"d" :: (#"b" :: c)))),l) =>
           p_srs(String.implode c,(false,(false,l)))
         | (#"s" :: (#"r" :: (#"s" :: (#"i" :: (#"a" :: c)))),l) =>
           p_srs(String.implode c,(true,(false,l)))
         | (#"s" :: (#"r" :: (#"s" :: (#"i" :: (#"b" :: c)))),l) =>
           p_srs(String.implode c,(true,(true,l)))
         | (#"s" :: (#"r" :: (#"s" :: c)),l) =>
           p_srs(String.implode c,(true,(false,l)))
         | (#"m" :: (#"r" :: (#"s" :: c)),l) => p_mrs(String.implode c,l)
         | (#"m" :: (#"s" :: (#"r" :: c)),l) => p_msr(String.implode c,l)
         | (#"u" :: (#"d" :: (#"f" :: c)),l) =>
           p_call(String.implode c,(0,l))
         | (#"d" :: (#"b" :: (#"g" :: c)),l) =>
           p_call(String.implode c,(1,l))
         | (#"s" :: (#"m" :: (#"c" :: c)),l) =>
           p_call(String.implode c,(2,l))
         | (#"s" :: (#"v" :: (#"c" :: c)),l) =>
           p_call(String.implode c,(3,l))
         | ([#"h",#"v",#"c"],l) => p_call("",(4,l))
         | ([#"b",#"k",#"p",#"t"],l) => p_call("",(5,l))
         | (#"d" :: (#"m" :: (#"b" :: c)),l) =>
           p_dmb_dsb(String.implode c,(false,l))
         | (#"d" :: (#"s" :: (#"b" :: c)),l) =>
           p_dmb_dsb(String.implode c,(true,l))
         | (#"i" :: (#"s" :: (#"b" :: c)),l) => p_isb(String.implode c,l)
         | (#"n" :: (#"o" :: (#"p" :: c)),[]) =>
           p_noarg(String.implode c,NoOperation)
         | (#"c" :: (#"l" :: (#"r" :: (#"e" :: (#"x" :: c)))),[]) =>
           p_noarg(String.implode c,ClearExclusive)
         | (#"s" :: (#"e" :: (#"v" :: c)),[]) =>
           p_noarg(String.implode c,Hint SendEvent)
         | (#"w" :: (#"f" :: (#"e" :: c)),[]) =>
           p_noarg(String.implode c,Hint WaitForEvent)
         | (#"w" :: (#"f" :: (#"i" :: c)),[]) =>
           p_noarg(String.implode c,Hint WaitForInterrupt)
         | (#"y" :: (#"i" :: (#"e" :: (#"l" :: (#"d" :: c)))),[]) =>
           p_noarg(String.implode c,Hint Yield)
         | (#"e" :: (#"r" :: (#"e" :: (#"t" :: c))),[]) =>
           p_noarg(String.implode c,System ExceptionReturn)
         | (#"e" :: (#"n" :: (#"t" :: (#"e" :: (#"r" :: (#"x" :: c))))),[]) =>
           p_noarg(String.implode c,System(EnterxLeavex true))
         | (#"l" :: (#"e" :: (#"a" :: (#"v" :: (#"e" :: (#"x" :: c))))),[]) =>
           p_noarg(String.implode c,System(EnterxLeavex false))
         | (#"v" :: (#"m" :: (#"o" :: (#"v" :: c))),l) =>
           p_fp2(String.implode c,(0,l))
         | (#"v" :: (#"a" :: (#"b" :: (#"s" :: c))),l) =>
           p_fp2(String.implode c,(1,l))
         | (#"v" :: (#"n" :: (#"e" :: (#"g" :: c))),l) =>
           p_fp2(String.implode c,(2,l))
         | (#"v" :: (#"s" :: (#"q" :: (#"r" :: (#"t" :: c)))),l) =>
           p_fp2(String.implode c,(3,l))
         | (#"v" :: (#"a" :: (#"d" :: (#"d" :: c))),l) =>
           p_fp3(String.implode c,(0,l))
         | (#"v" :: (#"s" :: (#"u" :: (#"b" :: c))),l) =>
           p_fp3(String.implode c,(1,l))
         | (#"v" :: (#"m" :: (#"u" :: (#"l" :: c))),l) =>
           p_fp3(String.implode c,(2,l))
         | (#"v" :: (#"d" :: (#"i" :: (#"v" :: c))),l) =>
           p_fp3(String.implode c,(3,l))
         | (#"v" :: (#"m" :: (#"l" :: (#"a" :: c))),l) =>
           p_fp3(String.implode c,(4,l))
         | (#"v" :: (#"m" :: (#"l" :: (#"s" :: c))),l) =>
           p_fp3(String.implode c,(5,l))
         | (#"v" :: (#"f" :: (#"m" :: (#"a" :: c))),l) =>
           p_fp3(String.implode c,(6,l))
         | (#"v" :: (#"f" :: (#"m" :: (#"s" :: c))),l) =>
           p_fp3(String.implode c,(7,l))
         | (#"v" :: (#"f" :: (#"n" :: (#"m" :: (#"a" :: c)))),l) =>
           p_fp3(String.implode c,(8,l))
         | (#"v" :: (#"f" :: (#"n" :: (#"m" :: (#"s" :: c)))),l) =>
           p_fp3(String.implode c,(9,l))
         | (#"v" :: (#"n" :: (#"m" :: (#"l" :: (#"a" :: c)))),l) =>
           p_fp3(String.implode c,(10,l))
         | (#"v" :: (#"n" :: (#"m" :: (#"l" :: (#"s" :: c)))),l) =>
           p_fp3(String.implode c,(11,l))
         | (#"v" :: (#"n" :: (#"m" :: (#"u" :: (#"l" :: c)))),l) =>
           p_fp3(String.implode c,(12,l))
         | (#"v" :: (#"c" :: (#"m" :: (#"p" :: (#"e" :: c)))),l) =>
           p_vcmpe(String.implode c,l)
         | (#"v" :: (#"c" :: (#"v" :: (#"t" :: (#"r" :: c)))),l) =>
           p_vcvt(String.implode c,(true,l))
         | (#"v" :: (#"c" :: (#"v" :: (#"t" :: c))),l) =>
           p_vcvt(String.implode c,(false,l))
         | (#"v" :: (#"m" :: (#"r" :: (#"s" :: c))),l) =>
           p_vmrs(String.implode c,l)
         | (#"v" :: (#"m" :: (#"s" :: (#"r" :: c))),l) =>
           p_vmsr(String.implode c,l)
         | (#"v" :: (#"l" :: (#"d" :: (#"r" :: c))),l) =>
           p_vldr_vstr(String.implode c,(true,l))
         | (#"v" :: (#"s" :: (#"t" :: (#"r" :: c))),l) =>
           p_vldr_vstr(String.implode c,(false,l))
         | (#"v" :: (#"p" :: (#"o" :: (#"p" :: c))),l) =>
           p_vpop_vpush(String.implode c,(true,l))
         | (#"v" :: (#"p" :: (#"u" :: (#"s" :: (#"h" :: c)))),l) =>
           p_vpop_vpush(String.implode c,(false,l))
         | (#"v" :: (#"l" :: (#"d" :: (#"m" :: (#"d" :: (#"b" :: c))))),l) =>
           p_vldm_vstm(String.implode c,(true,(false,l)))
         | (#"v" :: (#"l" :: (#"d" :: (#"m" :: (#"i" :: (#"a" :: c))))),l) =>
           p_vldm_vstm(String.implode c,(true,(true,l)))
         | (#"v" :: (#"l" :: (#"d" :: (#"m" :: c))),l) =>
           p_vldm_vstm(String.implode c,(true,(true,l)))
         | (#"v" :: (#"s" :: (#"t" :: (#"m" :: (#"d" :: (#"b" :: c))))),l) =>
           p_vldm_vstm(String.implode c,(false,(false,l)))
         | (#"v" :: (#"s" :: (#"t" :: (#"m" :: (#"i" :: (#"a" :: c))))),l) =>
           p_vldm_vstm(String.implode c,(false,(true,l)))
         | (#"v" :: (#"s" :: (#"t" :: (#"m" :: c))),l) =>
           p_vldm_vstm(String.implode c,(false,(true,l)))
         | (#"b" :: (#"x" :: c),l) => p_bx(String.implode c,l)
         | (#"b" :: (#"l" :: (#"x" :: c)),l) => p_blx(String.implode c,l)
         | ([#"b",#"l",c1,c2,#".",e],l) =>
           p_bl(String.implode[c1,c2,#".",e],l)
         | ([#"b",#"l",c1,c2],l) => p_bl(String.implode[c1,c2],l)
         | ([#"b",#"l"],l) => p_bl("",l)
         | (#"b" :: c,l) => p_b(String.implode c,l)
         | ([#"w",#"o",#"r",#"d"],[w]) =>
           (case p_encode_immediate 32 w of
               Option.SOME(true,w) => WORD w
             | Option.SOME _ => FAIL("immediate too large")
             | NONE => FAIL("syntax error"))
         | _ => FAIL("Unrecognised op-code"))
   | _ => FAIL("Unrecognised op-code");

fun s_cond c =
  case c of
     BitsN.B(0x0,_) => "eq"
   | BitsN.B(0x1,_) => "ne"
   | BitsN.B(0x2,_) => "cs"
   | BitsN.B(0x3,_) => "cc"
   | BitsN.B(0x4,_) => "mi"
   | BitsN.B(0x5,_) => "pl"
   | BitsN.B(0x6,_) => "vs"
   | BitsN.B(0x7,_) => "vc"
   | BitsN.B(0x8,_) => "hi"
   | BitsN.B(0x9,_) => "ls"
   | BitsN.B(0xA,_) => "ge"
   | BitsN.B(0xB,_) => "lt"
   | BitsN.B(0xC,_) => "gt"
   | BitsN.B(0xD,_) => "le"
   | _ => "";

fun s_reg r =
  case r of
     BitsN.B(0xD,_) => "sp"
   | BitsN.B(0xE,_) => "lr"
   | BitsN.B(0xF,_) => "pc"
   | _ => ("r") ^ (Nat.toString(BitsN.toNat r));

fun s_reg2 (r1,r2) = String.concat[s_reg r1,", ",s_reg r2];

fun s_reg3 (r1,(r2,r3)) = String.concat[s_reg2(r1,r2),", ",s_reg r3];

fun s_reg4 (r1,(r2,(r3,r4))) =
  String.concat[s_reg3(r1,(r2,r3)),", ",s_reg r4];

fun s_vfp_reg (dp,n) =
  (if dp then "d" else "s") ^ (Nat.toString(BitsN.toNat n));

fun s_any_reg (dpo,n) =
  case dpo of
     NONE => s_reg(BitsN.fromNat(n,4))
   | Option.SOME dp => s_vfp_reg(dp,BitsN.fromNat(n,5));

fun contiguous (a,(i,l)) =
  case l of
     [] => a
   | y :: x =>
     contiguous
       (if y
          then case a of
                  [] => [(i,i)]
                | (b,t) :: r =>
                  (if (Nat.+(i,1)) = b then (i,t) :: r else (i,i) :: a)
        else a,(Nat.-(i,1),x));

fun s_registers_from_contiguous (dpo,(a,l)) =
  case l of
     [] => a
   | (b,t) :: r =>
     let
       val d = Nat.-(t,b)
     in
       s_registers_from_contiguous
         (dpo,
          (if d = 0
             then String.concat[a,", ",s_any_reg(dpo,b)]
           else if d = 1
             then String.concat
                    [a,", ",s_any_reg(dpo,b),", ",s_any_reg(dpo,t)]
           else String.concat
                  [a,", ",s_any_reg(dpo,b),"-",s_any_reg(dpo,t)],r))
     end;

fun s_registers N (dpo,l) =
  case String.explode
    (s_registers_from_contiguous
       (dpo,
        ("",
         contiguous
           ([],(Nat.-(BitsN.size(BitsN.BV(0x0,N)),1),BitsN.toBitstring l))))) of
     [] => "{}"
   | #"," :: (#" " :: s) => String.concat["{",String.implode s,"}"]
   | _ => "???";

fun s_arm_registers N l = s_registers N (NONE,l);

fun s_fp_registers N (dp,l) = s_registers N (Option.SOME dp,l);

fun s_hex N v =
  if BitsN.<+(v,BitsN.BV(0x64,N))
    then Nat.toString(BitsN.toNat v)
  else ("0x") ^ (BitsN.toHexString v);

fun s_offset imm32 =
  let
    val imm32 = BitsN.+(imm32,BitsN.B(0x8,32))
  in
    if BitsN.<(imm32,BitsN.B(0x0,32))
      then ("-#") ^ (s_hex 32 (BitsN.neg imm32))
    else ("+#") ^ (s_hex 32 imm32)
  end;

fun s_add_sub_offset (add,imm32) =
  if add andalso (imm32 = (BitsN.B(0x0,32)))
    then ""
  else String.concat[", #",if add then "" else "-",s_hex 32 imm32];

fun s_branch (c,ast) =
  case ast of
     BranchTarget imm32 => (("b") ^ (s_cond c),s_offset imm32)
   | BranchExchange m => (("bx") ^ (s_cond c),s_reg m)
   | BranchLinkExchangeImmediate(targetInstrSet,imm32) =>
     (String.concat
        ["bl",if (CurrentInstrSet ()) = targetInstrSet then "" else "x",
         s_cond c],s_offset imm32)
   | BranchLinkExchangeRegister m => (("blx") ^ (s_cond c),s_reg m)
   | CompareBranch(nonzero,(n,imm32)) =>
     (String.concat["cb",if nonzero then "n" else "",s_cond c],
      String.concat[s_reg n,", ",s_offset imm32])
   | TableBranchByte(true,(m,n)) =>
     (("tbh") ^ (s_cond c),String.concat["[",s_reg2(n,m),", lsl #1]"])
   | TableBranchByte(false,(m,n)) =>
     (("tbb") ^ (s_cond c),String.concat["[",s_reg2(n,m),"]"])
   | CheckArray(m,n) => (("chka") ^ (s_cond c),s_reg2(n,m))
   | HandlerBranchLink(generate_link,handler_offset) =>
     (String.concat["hb",if generate_link then "l" else "",s_cond c],
      ("#") ^ (BitsN.toHexString handler_offset))
   | HandlerBranchLinkParameter(imm32,handler_offset) =>
     (("hblp") ^ (s_cond c),
      String.concat
        ["#",s_hex 32 imm32,", #",BitsN.toHexString handler_offset])
   | HandlerBranchParameter(imm32,handler_offset) =>
     (("hbp") ^ (s_cond c),
      String.concat
        ["#",s_hex 32 imm32,", #",BitsN.toHexString handler_offset]);

fun s_vfp_suffix (c,dp) = (s_cond c) ^ (if dp then ".f64" else ".f32");

fun s_vfp (c,ast) =
  case ast of
     vmrs t =>
       (("vmrs") ^ (s_cond c),
        (if t = (BitsN.B(0xF,4)) then "APSR_nzcv" else s_reg t)
          ^
          (", FPSCR"))
   | vmsr t => (("vmsr") ^ (s_cond c),("FPSCR, ") ^ (s_reg t))
   | vcmp(dp,(d,Option.SOME m)) =>
     (("vcmpe") ^ (s_vfp_suffix(c,dp)),
      String.concat[s_vfp_reg(dp,d),", ",s_vfp_reg(dp,m)])
   | vcmp(dp,(d,NONE)) =>
     (("vcmpe") ^ (s_vfp_suffix(c,dp)),(s_vfp_reg(dp,d)) ^ (", #0.0"))
   | vcvt_float(double_to_single,(d,m)) =>
     (String.concat
        ["vcvt",s_cond c,
         if double_to_single then ".f32.f64" else ".f64.f32"],
      String.concat
        [s_vfp_reg(not double_to_single,d),", ",
         s_vfp_reg(double_to_single,m)])
   | vcvt_from_integer(dp,(unsigned,(d,m))) =>
     (String.concat
        ["vcvt",s_vfp_suffix(c,dp),if unsigned then ".u" else ".s","32"],
      String.concat[s_vfp_reg(dp,d),", ",s_vfp_reg(false,m)])
   | vcvt_to_integer(dp,(unsigned,(round_zero,(d,m)))) =>
     (String.concat
        ["vcvt",if round_zero then "" else "r",s_cond c,
         if unsigned then ".u" else ".s","32",
         if dp then ".f64" else ".f32"],
      String.concat[s_vfp_reg(false,d),", ",s_vfp_reg(dp,m)])
   | vmov_imm(sp,(d,imm64)) =>
     (("vmov") ^ (s_vfp_suffix(c,not sp)),
      String.concat[s_vfp_reg(not sp,d),", #0x",BitsN.toHexString imm64])
   | vmov(sp,(d,m)) =>
     (("vmov") ^ (s_vfp_suffix(c,not sp)),
      String.concat[s_vfp_reg(not sp,d),", ",s_vfp_reg(not sp,m)])
   | vmov_single(to_arm_register,(t,n)) =>
     (("vmov") ^ (s_cond c),
      if to_arm_register
        then String.concat[s_reg t,", ",s_vfp_reg(false,n)]
      else String.concat[s_vfp_reg(false,n),", ",s_reg t])
   | vmov_two_singles(to_arm_registers,(t,(t2,m))) =>
     (("vmov") ^ (s_cond c),
      if to_arm_registers
        then String.concat
               [s_reg2(t,t2),", ",s_vfp_reg(false,m),", ",
                s_vfp_reg(false,BitsN.+(m,BitsN.B(0x1,5)))]
      else String.concat
             [s_vfp_reg(false,m),", ",
              s_vfp_reg(false,BitsN.+(m,BitsN.B(0x1,5))),", ",s_reg2(t,t2)])
   | vmov_double(to_arm_registers,(t,(t2,m))) =>
     (("vmov") ^ (s_cond c),
      if to_arm_registers
        then String.concat[s_reg2(t,t2),", ",s_vfp_reg(true,m)]
      else String.concat[s_vfp_reg(true,m),", ",s_reg2(t,t2)])
   | vabs(dp,(d,m)) =>
     (("vabs") ^ (s_vfp_suffix(c,dp)),
      String.concat[s_vfp_reg(dp,d),", ",s_vfp_reg(dp,m)])
   | vneg(dp,(d,m)) =>
     (("vneg") ^ (s_vfp_suffix(c,dp)),
      String.concat[s_vfp_reg(dp,d),", ",s_vfp_reg(dp,m)])
   | vsqrt(dp,(d,m)) =>
     (("vsqrt") ^ (s_vfp_suffix(c,dp)),
      String.concat[s_vfp_reg(dp,d),", ",s_vfp_reg(dp,m)])
   | vadd(dp,(d,(n,m))) =>
     (("vadd") ^ (s_vfp_suffix(c,dp)),
      String.concat
        [s_vfp_reg(dp,d),", ",s_vfp_reg(dp,n),", ",s_vfp_reg(dp,m)])
   | vsub(dp,(d,(n,m))) =>
     (("vsub") ^ (s_vfp_suffix(c,dp)),
      String.concat
        [s_vfp_reg(dp,d),", ",s_vfp_reg(dp,n),", ",s_vfp_reg(dp,m)])
   | vmul(dp,(d,(n,m))) =>
     (("vmul") ^ (s_vfp_suffix(c,dp)),
      String.concat
        [s_vfp_reg(dp,d),", ",s_vfp_reg(dp,n),", ",s_vfp_reg(dp,m)])
   | vdiv(dp,(d,(n,m))) =>
     (("vdiv") ^ (s_vfp_suffix(c,dp)),
      String.concat
        [s_vfp_reg(dp,d),", ",s_vfp_reg(dp,n),", ",s_vfp_reg(dp,m)])
   | vneg_mul(dp,(typ,(d,(n,m)))) =>
     ((case typ of
          VFPNegMul_VNMLA => "vnmla"
        | VFPNegMul_VNMLS => "vnmls"
        | VFPNegMul_VNMUL => "vnmul")
        ^
        (s_vfp_suffix(c,dp)),
      String.concat
        [s_vfp_reg(dp,d),", ",s_vfp_reg(dp,n),", ",s_vfp_reg(dp,m)])
   | vmla_vmls(dp,(add,(d,(n,m)))) =>
     ((if add then "vmla" else "vmls") ^ (s_vfp_suffix(c,dp)),
      String.concat
        [s_vfp_reg(dp,d),", ",s_vfp_reg(dp,n),", ",s_vfp_reg(dp,m)])
   | vfma_vfms(dp,(add,(d,(n,m)))) =>
     ((if add then "vfma" else "vfms") ^ (s_vfp_suffix(c,dp)),
      String.concat
        [s_vfp_reg(dp,d),", ",s_vfp_reg(dp,n),", ",s_vfp_reg(dp,m)])
   | vfnma_vfnms(dp,(add,(d,(n,m)))) =>
     ((if add then "vfnma" else "vfnms") ^ (s_vfp_suffix(c,dp)),
      String.concat
        [s_vfp_reg(dp,d),", ",s_vfp_reg(dp,n),", ",s_vfp_reg(dp,m)])
   | vldr(sp,(add,(d,(n,imm32)))) =>
     (("vldr") ^ (s_cond c),
      String.concat
        [s_vfp_reg(not sp,d),", [",s_reg n,
         if add andalso (imm32 = (BitsN.B(0x0,32)))
           then ""
         else (if add then ", #+" else ", #-") ^ (s_hex 32 imm32),"]"])
   | vstr(sp,(add,(d,(n,imm32)))) =>
     (("vstr") ^ (s_cond c),
      String.concat
        [s_vfp_reg(not sp,d),", [",s_reg n,
         if add andalso (imm32 = (BitsN.B(0x0,32)))
           then ""
         else (if add then ", #+" else ", #-") ^ (s_hex 32 imm32),"]"])
   | vldm(sp,(true,(true,(d,(BitsN.B(0xD,4),imm8))))) =>
     let
       val regs =
         BitsN.fromNat
           (BitsN.toNat(if sp then imm8 else BitsN.>>(imm8,1)),32)
     in
       (("vpop") ^ (s_cond c),
        s_fp_registers 32
          (not sp,
           BitsN.<<
             (BitsN.-(BitsN.<<^(BitsN.B(0x1,32),regs),BitsN.B(0x1,32)),
              BitsN.toNat d)))
     end
   | vldm(sp,(add,(wback,(d,(n,imm8))))) =>
     let
       val regs =
         BitsN.fromNat
           (BitsN.toNat(if sp then imm8 else BitsN.>>(imm8,1)),32)
     in
       (String.concat["vldm",if add then "ia" else "db",s_cond c],
        String.concat
          [s_reg n,if wback then "!" else "",", ",
           s_fp_registers 32
             (not sp,
              BitsN.<<
                (BitsN.-(BitsN.<<^(BitsN.B(0x1,32),regs),BitsN.B(0x1,32)),
                 BitsN.toNat d))])
     end
   | vstm(sp,(false,(true,(d,(BitsN.B(0xD,4),imm8))))) =>
     let
       val regs =
         BitsN.fromNat
           (BitsN.toNat(if sp then imm8 else BitsN.>>(imm8,1)),32)
     in
       (("vpush") ^ (s_cond c),
        s_fp_registers 32
          (not sp,
           BitsN.<<
             (BitsN.-(BitsN.<<^(BitsN.B(0x1,32),regs),BitsN.B(0x1,32)),
              BitsN.toNat d)))
     end
   | vstm(sp,(add,(wback,(d,(n,imm8))))) =>
     let
       val regs =
         BitsN.fromNat
           (BitsN.toNat(if sp then imm8 else BitsN.>>(imm8,1)),32)
     in
       (String.concat["vstm",if add then "ia" else "db",s_cond c],
        String.concat
          [s_reg n,if wback then "!" else "",", ",
           s_fp_registers 32
             (not sp,
              BitsN.<<
                (BitsN.-(BitsN.<<^(BitsN.B(0x1,32),regs),BitsN.B(0x1,32)),
                 BitsN.toNat d))])
     end;

fun s_test_compare opc =
  case opc of
     BitsN.B(0x0,_) => "tst"
   | BitsN.B(0x1,_) => "teq"
   | BitsN.B(0x2,_) => "cmp"
   | BitsN.B(0x3,_) => "cmn"
   | _ => raise General.Bind;

fun s_arith_logic opc =
  case opc of
     BitsN.B(0x0,_) => "and"
   | BitsN.B(0x1,_) => "eor"
   | BitsN.B(0x2,_) => "sub"
   | BitsN.B(0x3,_) => "rsb"
   | BitsN.B(0x4,_) => "add"
   | BitsN.B(0x5,_) => "adc"
   | BitsN.B(0x6,_) => "sbc"
   | BitsN.B(0x7,_) => "rsc"
   | BitsN.B(0x8,_) => "tst"
   | BitsN.B(0x9,_) => "teq"
   | BitsN.B(0xA,_) => "cmp"
   | BitsN.B(0xB,_) => "cmn"
   | BitsN.B(0xC,_) => "orr"
   | BitsN.B(0xD,_) => "mov"
   | BitsN.B(0xE,_) => "bic"
   | BitsN.B(0xF,_) => "mvn"
   | _ => raise General.Bind;

fun s_shift shift_t =
  case shift_t of
     SRType_LSL => "lsl"
   | SRType_LSR => "lsr"
   | SRType_ASR => "asr"
   | SRType_ROR => "ror"
   | SRType_RRX => "rrx";

fun s_shift_n (shift_t,shift_n) =
  case (shift_t,shift_n) of
     (SRType_LSL,0) => ""
   | (SRType_RRX,1) => ", rrx"
   | _ => String.concat[", ",s_shift shift_t," #",Nat.toString shift_n];

fun s_shift_r (add,(r,(shift_t,shift_n))) =
  String.concat
    [", ",if add then "" else "-",s_reg r,s_shift_n(shift_t,shift_n)];

fun s_expand_imm imm12 = s_hex 32 (L3.fst(ExpandImm_C(imm12,false)));

fun s_data (c,ast) =
  case ast of
     CountLeadingZeroes(d,m) => (("clz") ^ (s_cond c),s_reg2(d,m))
   | MoveHalfword(high,(d,imm16)) =>
     (String.concat["mov",if high then "t" else "w",s_cond c],
      String.concat[s_reg d,", #",s_hex 16 imm16])
   | Move(setflags,(negate,(d,imm12))) =>
     (String.concat
        [if negate then "mvn" else "mov",if setflags then "s" else "",
         s_cond c],String.concat[s_reg d,", #",s_expand_imm imm12])
   | AddSub(sub,(d,(n,imm12))) =>
     ((if sub then "subw" else "addw") ^ (s_cond c),
      String.concat[s_reg2(d,n),", #",s_hex 12 imm12])
   | TestCompareImmediate(opc,(n,imm12)) =>
     ((s_test_compare opc) ^ (s_cond c),
      String.concat[s_reg n,", #",s_expand_imm imm12])
   | ArithLogicImmediate(opc,(setflags,(d,(n,imm12)))) =>
     (String.concat
        [s_arith_logic opc,if setflags then "s" else "",s_cond c],
      String.concat[s_reg2(d,n),", #",s_expand_imm imm12])
   | Register(opc,(setflags,(d,(n,(m,(shift_t,shift_n)))))) =>
     (String.concat
        [s_arith_logic opc,if setflags then "s" else "",s_cond c],
      (s_reg3(d,(n,m))) ^ (s_shift_n(shift_t,shift_n)))
   | TestCompareRegister(opc,(n,(m,(shift_t,shift_n)))) =>
     ((s_test_compare opc) ^ (s_cond c),
      (s_reg2(n,m)) ^ (s_shift_n(shift_t,shift_n)))
   | ShiftImmediate(true,(setflags,(d,(m,(shift_t,shift_n))))) =>
     (String.concat["mvn",if setflags then "s" else "",s_cond c],
      (s_reg2(d,m)) ^ (s_shift_n(shift_t,shift_n)))
   | ShiftImmediate(false,(setflags,(d,(m,(SRType_LSL,0))))) =>
     (String.concat["mov",if setflags then "s" else "",s_cond c],
      s_reg2(d,m))
   | ShiftImmediate(false,(setflags,(d,(m,(shift_t,shift_n))))) =>
     (String.concat[s_shift shift_t,if setflags then "s" else "",s_cond c],
      (s_reg2(d,m))
        ^
        (if (shift_t = SRType_RRX) andalso (shift_n = 1)
           then ""
         else (", #") ^ (Nat.toString shift_n)))
   | RegisterShiftedRegister(opc,(setflags,(d,(n,(m,(shift_t,s)))))) =>
     let
       val tstcmp = (BitsN.bits(3,2) opc) = (BitsN.B(0x2,2))
     in
       (String.concat
          [s_arith_logic opc,
           if setflags andalso (not tstcmp) then "s" else "",s_cond c],
        String.concat
          [if tstcmp then "" else (s_reg d) ^ (", "),s_reg2(n,m),", ",
           s_shift shift_t," ",s_reg s])
     end
   | ShiftRegister(true,(setflags,(d,(n,(shift_t,m))))) =>
     (String.concat["mvn",if setflags then "s" else "",s_cond c],
      String.concat[s_reg2(d,n),", ",s_shift shift_t," ",s_reg m])
   | ShiftRegister(false,(setflags,(d,(n,(shift_t,m))))) =>
     (String.concat[s_shift shift_t,if setflags then "s" else "",s_cond c],
      s_reg3(d,(n,m)));

fun s_multiply (c,ast) =
  case ast of
     MultiplyAccumulate(setflags,(d,(n,(m,a)))) =>
       (String.concat["mla",if setflags then "s" else "",s_cond c],
        s_reg4(d,(n,(m,a))))
   | Multiply32(setflags,(d,(n,m))) =>
     (String.concat["mul",if setflags then "s" else "",s_cond c],
      s_reg3(d,(n,m)))
   | MultiplyLong(accumulate,(signed,(setflags,(dhi,(dlo,(n,m)))))) =>
     (String.concat
        [if signed then "s" else "u",
         if accumulate then "mlal" else "mull",
         if setflags then "s" else "",s_cond c],s_reg4(dlo,(dhi,(n,m))))
   | MultiplyAccumulateAccumulate(dhi,(dlo,(n,m))) =>
     (("umaal") ^ (s_cond c),s_reg4(dlo,(dhi,(n,m))))
   | MultiplySubtract(d,(n,(m,a))) =>
     (("mls") ^ (s_cond c),s_reg4(d,(n,(m,a))))
   | Signed16Multiply32Accumulate(m_high,(n_high,(d,(n,(m,a))))) =>
     (String.concat
        ["smla",if m_high then "t" else "b",if n_high then "t" else "b",
         s_cond c],s_reg4(d,(n,(m,a))))
   | Signed16Multiply32Result(m_high,(n_high,(d,(n,m)))) =>
     (String.concat
        ["smul",if m_high then "t" else "b",if n_high then "t" else "b",
         s_cond c],s_reg3(d,(n,m)))
   | Signed16x32Multiply32Accumulate(m_high,(d,(n,(m,a)))) =>
     (String.concat["smlaw",if m_high then "t" else "b",s_cond c],
      s_reg4(d,(n,(m,a))))
   | Signed16x32Multiply32Result(m_high,(d,(n,m))) =>
     (String.concat["smulw",if m_high then "t" else "b",s_cond c],
      s_reg3(d,(n,m)))
   | Signed16Multiply64Accumulate(m_high,(n_high,(dhi,(dlo,(n,m))))) =>
     (String.concat
        ["smlal",if m_high then "t" else "b",if n_high then "t" else "b",
         s_cond c],s_reg4(dlo,(dhi,(n,m))))
   | SignedMultiplyDual(sub,(m_swap,(d,(n,(m,a))))) =>
     (String.concat
        [case (sub,a = (BitsN.B(0xF,4))) of
            (false,false) => "smlad"
          | (false,true) => "smuad"
          | (true,false) => "smlsd"
          | (true,true) => "smusd",if m_swap then "x" else "",s_cond c],
      (s_reg3(d,(n,m)))
        ^
        (if a = (BitsN.B(0xF,4)) then "" else (", ") ^ (s_reg a)))
   | SignedMultiplyLongDual(sub,(m_swap,(dhi,(dlo,(n,m))))) =>
     (String.concat
        [if sub then "smlsld" else "smlald",if m_swap then "x" else "",
         s_cond c],s_reg4(dlo,(dhi,(n,m))))
   | SignedMostSignificantMultiply(round,(d,(n,(m,a)))) =>
     (String.concat
        [if a = (BitsN.B(0xF,4)) then "smmul" else "smmla",
         if round then "r" else "",s_cond c],
      (s_reg3(d,(n,m)))
        ^
        (if a = (BitsN.B(0xF,4)) then "" else (", ") ^ (s_reg a)))
   | SignedMostSignificantMultiplySubtract(round,(d,(n,(m,a)))) =>
     (String.concat["smmls",if round then "r" else "",s_cond c],
      s_reg4(d,(n,(m,a))));

fun s_imm_form (add,(index,(wback,(t,(n,imm32))))) =
  String.concat
    [s_reg t,", [",s_reg n,
     if index
       then String.concat
              [s_add_sub_offset(add,imm32),"]",if wback then "!" else ""]
     else String.concat["], #",if add then "" else "-",s_hex 32 imm32]];

fun s_reg_form (add,(index,(wback,(t,(n,(m,(shift_t,shift_n))))))) =
  String.concat
    [s_reg t,", [",s_reg n,
     if index
       then String.concat
              [s_shift_r(add,(m,(shift_t,shift_n))),"]",
               if wback then "!" else ""]
     else ("]") ^ (s_shift_r(add,(m,(shift_t,shift_n))))];

fun s_stack (increment,wordhigher) =
  case (increment,wordhigher) of
     (false,false) => "db"
   | (false,true) => "da"
   | (true,false) => ""
   | (true,true) => "ib";

fun s_load (c,ast) =
  case ast of
     LoadWord(add,(index,(wback,(t,(n,immediate_form1 imm32))))) =>
       (("ldr") ^ (s_cond c),s_imm_form(add,(index,(wback,(t,(n,imm32))))))
   | LoadWord
     (add,(index,(wback,(t,(n,register_form1(m,(shift_t,shift_n))))))) =>
     (("ldr") ^ (s_cond c),
      s_reg_form(add,(index,(wback,(t,(n,(m,(shift_t,shift_n))))))))
   | LoadLiteral(add,(t,imm32)) =>
     (("ldr") ^ (s_cond c),
      String.concat[s_reg t,", [pc",s_add_sub_offset(add,imm32),"]"])
   | LoadUnprivileged(add,(postindex,(t,(n,immediate_form1 imm32)))) =>
     (("ldrt") ^ (s_cond c),
      s_imm_form(add,(not postindex,(false,(t,(n,imm32))))))
   | LoadUnprivileged
     (add,(postindex,(t,(n,register_form1(m,(shift_t,shift_n)))))) =>
     (("ldrt") ^ (s_cond c),
      s_reg_form
        (add,(not postindex,(false,(t,(n,(m,(shift_t,shift_n))))))))
   | LoadByte
     (unsigned,(add,(index,(wback,(t,(n,immediate_form1 imm32)))))) =>
     (String.concat["ldr",if unsigned then "b" else "sb",s_cond c],
      s_imm_form(add,(index,(wback,(t,(n,imm32))))))
   | LoadByte
     (unsigned,
      (add,(index,(wback,(t,(n,register_form1(m,(shift_t,shift_n)))))))) =>
     (String.concat["ldr",if unsigned then "b" else "sb",s_cond c],
      s_reg_form(add,(index,(wback,(t,(n,(m,(shift_t,shift_n))))))))
   | LoadByteLiteral(unsigned,(add,(t,imm32))) =>
     (String.concat["ldr",if unsigned then "b" else "sb",s_cond c],
      String.concat[s_reg t,", [pc",s_add_sub_offset(add,imm32),"]"])
   | LoadByteUnprivileged(add,(postindex,(t,(n,immediate_form1 imm32)))) =>
     (("ldrbt") ^ (s_cond c),
      s_imm_form(add,(not postindex,(false,(t,(n,imm32))))))
   | LoadByteUnprivileged
     (add,(postindex,(t,(n,register_form1(m,(shift_t,shift_n)))))) =>
     (("ldrbt") ^ (s_cond c),
      s_reg_form
        (add,(not postindex,(false,(t,(n,(m,(shift_t,shift_n))))))))
   | LoadSignedByteUnprivileged
     (add,(postindex,(t,(n,immediate_form2 imm32)))) =>
     (("ldrsbt") ^ (s_cond c),
      s_imm_form(add,(not postindex,(false,(t,(n,imm32))))))
   | LoadSignedByteUnprivileged(add,(postindex,(t,(n,register_form2 m)))) =>
     (("ldrsbt") ^ (s_cond c),
      s_reg_form(add,(not postindex,(false,(t,(n,(m,(SRType_LSL,0))))))))
   | LoadHalf
     (unsigned,(add,(index,(wback,(t,(n,immediate_form1 imm32)))))) =>
     (String.concat["ldr",if unsigned then "h" else "sh",s_cond c],
      s_imm_form(add,(index,(wback,(t,(n,imm32))))))
   | LoadHalf
     (unsigned,
      (add,(index,(wback,(t,(n,register_form1(m,(shift_t,shift_n)))))))) =>
     (String.concat["ldr",if unsigned then "h" else "sh",s_cond c],
      s_reg_form(add,(index,(wback,(t,(n,(m,(shift_t,shift_n))))))))
   | LoadHalfLiteral(unsigned,(add,(t,imm32))) =>
     (String.concat["ldr",if unsigned then "h" else "sh",s_cond c],
      String.concat[s_reg t,", [pc",s_add_sub_offset(add,imm32),"]"])
   | LoadHalfUnprivileged
     (unsigned,(add,(postindex,(t,(n,immediate_form2 imm32))))) =>
     (String.concat["ldr",if unsigned then "ht" else "sht",s_cond c],
      s_imm_form(add,(not postindex,(false,(t,(n,imm32))))))
   | LoadHalfUnprivileged
     (unsigned,(add,(postindex,(t,(n,register_form2 m))))) =>
     (String.concat["ldr",if unsigned then "ht" else "sht",s_cond c],
      s_reg_form(add,(not postindex,(false,(t,(n,(m,(SRType_LSL,0))))))))
   | LoadMultiple(true,(false,(true,(BitsN.B(0xD,4),registers)))) =>
     (("pop") ^ (s_cond c),s_arm_registers 16 registers)
   | LoadMultiple(increment,(index,(wback,(n,registers)))) =>
     (String.concat["ldm",s_stack(increment,increment = index),s_cond c],
      String.concat
        [s_reg n,if wback then "!" else "",", ",
         s_arm_registers 16 registers])
   | LoadMultipleExceptionReturn
     (increment,(wordhigher,(wback,(n,registers)))) =>
     (String.concat["ldm",s_stack(increment,wordhigher),s_cond c],
      String.concat
        [s_reg n,if wback then "!" else "",", ",
         s_arm_registers 16 (BitsN.@@(BitsN.B(0x1,1),registers)),"^"])
   | LoadMultipleUserRegisters(increment,(wordhigher,(n,registers))) =>
     (String.concat["ldm",s_stack(increment,wordhigher),s_cond c],
      String.concat[s_reg n,", ",s_arm_registers 15 registers,"^"])
   | LoadDual(add,(index,(wback,(t,(t2,(n,immediate_form2 imm32)))))) =>
     (("ldrd") ^ (s_cond c),
      String.concat
        [s_reg t,", ",s_imm_form(add,(index,(wback,(t2,(n,imm32)))))])
   | LoadDual(add,(index,(wback,(t,(t2,(n,register_form2 m)))))) =>
     (("ldrd") ^ (s_cond c),
      String.concat
        [s_reg t,", ",
         s_reg_form(add,(index,(wback,(t2,(n,(m,(SRType_LSL,0)))))))])
   | LoadDualLiteral(add,(t,(t2,imm32))) =>
     (("ldrd") ^ (s_cond c),
      String.concat[s_reg2(t,t2),", [pc",s_add_sub_offset(add,imm32),"]"])
   | LoadExclusive(t,(n,imm32)) =>
     (("ldrex") ^ (s_cond c),
      String.concat
        [s_reg t,", [",s_reg n,s_add_sub_offset(true,imm32),"]"])
   | LoadExclusiveByte(t,n) =>
     (("ldrexb") ^ (s_cond c),String.concat[s_reg t,", [",s_reg n,"]"])
   | LoadExclusiveHalf(t,n) =>
     (("ldrexh") ^ (s_cond c),String.concat[s_reg t,", [",s_reg n,"]"])
   | LoadExclusiveDoubleword(t,(t2,n)) =>
     (("ldrexd") ^ (s_cond c),
      String.concat[s_reg2(t,t2),", [",s_reg n,"]"]);

fun s_store (c,ast) =
  case ast of
     StoreWord(add,(index,(wback,(t,(n,immediate_form1 imm32))))) =>
       (("str") ^ (s_cond c),s_imm_form(add,(index,(wback,(t,(n,imm32))))))
   | StoreWord
     (add,(index,(wback,(t,(n,register_form1(m,(shift_t,shift_n))))))) =>
     (("str") ^ (s_cond c),
      s_reg_form(add,(index,(wback,(t,(n,(m,(shift_t,shift_n))))))))
   | StoreUnprivileged(add,(postindex,(t,(n,immediate_form1 imm32)))) =>
     (("strt") ^ (s_cond c),
      s_imm_form(add,(not postindex,(false,(t,(n,imm32))))))
   | StoreUnprivileged
     (add,(postindex,(t,(n,register_form1(m,(shift_t,shift_n)))))) =>
     (("strt") ^ (s_cond c),
      s_reg_form
        (add,(not postindex,(false,(t,(n,(m,(shift_t,shift_n))))))))
   | StoreByte(add,(index,(wback,(t,(n,immediate_form1 imm32))))) =>
     (("strb") ^ (s_cond c),s_imm_form(add,(index,(wback,(t,(n,imm32))))))
   | StoreByte
     (add,(index,(wback,(t,(n,register_form1(m,(shift_t,shift_n))))))) =>
     (("strb") ^ (s_cond c),
      s_reg_form(add,(index,(wback,(t,(n,(m,(shift_t,shift_n))))))))
   | StoreByteUnprivileged(add,(postindex,(t,(n,immediate_form1 imm32)))) =>
     (("strbt") ^ (s_cond c),
      s_imm_form(add,(not postindex,(false,(t,(n,imm32))))))
   | StoreByteUnprivileged
     (add,(postindex,(t,(n,register_form1(m,(shift_t,shift_n)))))) =>
     (("strbt") ^ (s_cond c),
      s_reg_form
        (add,(not postindex,(false,(t,(n,(m,(shift_t,shift_n))))))))
   | StoreHalf(add,(index,(wback,(t,(n,immediate_form1 imm32))))) =>
     (("strh") ^ (s_cond c),s_imm_form(add,(index,(wback,(t,(n,imm32))))))
   | StoreHalf
     (add,(index,(wback,(t,(n,register_form1(m,(shift_t,shift_n))))))) =>
     (("strh") ^ (s_cond c),
      s_reg_form(add,(index,(wback,(t,(n,(m,(shift_t,shift_n))))))))
   | StoreHalfUnprivileged(add,(postindex,(t,(n,immediate_form2 imm32)))) =>
     (("strht") ^ (s_cond c),
      s_imm_form(add,(not postindex,(false,(t,(n,imm32))))))
   | StoreHalfUnprivileged(add,(postindex,(t,(n,register_form2 m)))) =>
     (("strht") ^ (s_cond c),
      s_reg_form(add,(not postindex,(false,(t,(n,(m,(SRType_LSL,0))))))))
   | StoreMultiple(false,(true,(true,(BitsN.B(0xD,4),registers)))) =>
     (("push") ^ (s_cond c),s_arm_registers 16 registers)
   | StoreMultiple(increment,(index,(wback,(n,registers)))) =>
     (String.concat["stm",s_stack(increment,increment = index),s_cond c],
      String.concat
        [s_reg n,if wback then "!" else "",", ",
         s_arm_registers 16 registers])
   | StoreMultipleUserRegisters(increment,(wordhigher,(n,registers))) =>
     (String.concat["stm",s_stack(increment,wordhigher),s_cond c],
      String.concat[s_reg n,", ",s_arm_registers 16 registers,"^"])
   | StoreDual(add,(index,(wback,(t,(t2,(n,immediate_form2 imm32)))))) =>
     (("strd") ^ (s_cond c),
      String.concat
        [s_reg t,", ",s_imm_form(add,(index,(wback,(t2,(n,imm32)))))])
   | StoreDual(add,(index,(wback,(t,(t2,(n,register_form2 m)))))) =>
     (("strd") ^ (s_cond c),
      String.concat
        [s_reg t,", ",
         s_reg_form(add,(index,(wback,(t2,(n,(m,(SRType_LSL,0)))))))])
   | StoreExclusive(d,(t,(n,imm32))) =>
     (("strex") ^ (s_cond c),
      String.concat
        [s_reg2(d,t),", [",s_reg n,s_add_sub_offset(true,imm32),"]"])
   | StoreExclusiveByte(d,(t,n)) =>
     (("strexb") ^ (s_cond c),String.concat[s_reg2(d,t),", [",s_reg n,"]"])
   | StoreExclusiveHalf(d,(t,n)) =>
     (("strexh") ^ (s_cond c),String.concat[s_reg2(d,t),", [",s_reg n,"]"])
   | StoreExclusiveDoubleword(d,(t,(t2,n))) =>
     (("strexd") ^ (s_cond c),
      String.concat[s_reg3(d,(t,t2)),", [",s_reg n,"]"]);

fun s_barrier_option option =
  case option of
     BitsN.B(0x2,_) => "oshst"
   | BitsN.B(0x3,_) => "osh"
   | BitsN.B(0x6,_) => "nshst"
   | BitsN.B(0x7,_) => "nsh"
   | BitsN.B(0xA,_) => "ishst"
   | BitsN.B(0xB,_) => "ish"
   | BitsN.B(0xE,_) => "st"
   | BitsN.B(0xF,_) => "sy"
   | _ => Nat.toString(BitsN.toNat option);

fun s_hint (c,ast) =
  case ast of
     Breakpoint imm32 => (("bkpt") ^ (s_cond c),("#") ^ (s_hex 32 imm32))
   | Debug option =>
     (("dbg") ^ (s_cond c),("#") ^ (Nat.toString(BitsN.toNat option)))
   | DataMemoryBarrier option =>
     (("dmb") ^ (s_cond c),s_barrier_option option)
   | DataSynchronizationBarrier option =>
     (("dsb") ^ (s_cond c),s_barrier_option option)
   | InstructionSynchronizationBarrier option =>
     (("isb") ^ (s_cond c),s_barrier_option option)
   | SendEvent => (("sev") ^ (s_cond c),"")
   | WaitForEvent => (("wfe") ^ (s_cond c),"")
   | WaitForInterrupt => (("wfi") ^ (s_cond c),"")
   | Yield => (("yield") ^ (s_cond c),"")
   | PreloadData(add,(is_pldw,(n,immediate_form1 imm32))) =>
     (String.concat["pld",if is_pldw then "w" else "",s_cond c],
      String.concat["[",s_reg n,s_add_sub_offset(add,imm32),"]"])
   | PreloadData(add,(is_pldw,(n,register_form1(m,(shift_t,shift_n))))) =>
     (String.concat["pld",if is_pldw then "w" else "",s_cond c],
      String.concat
        ["[",s_reg n,if add then ", " else ", -",s_reg m,
         s_shift_n(shift_t,shift_n),"]"])
   | PreloadDataLiteral(add,imm32) =>
     (("pld") ^ (s_cond c),
      String.concat["[pc",s_add_sub_offset(add,imm32),"]"])
   | PreloadInstruction(add,(n,immediate_form1 imm32)) =>
     (("pli") ^ (s_cond c),
      String.concat["[",s_reg n,s_add_sub_offset(add,imm32),"]"])
   | PreloadInstruction(add,(n,register_form1(m,(shift_t,shift_n)))) =>
     (("pli") ^ (s_cond c),
      String.concat
        ["[",s_reg n,if add then ", " else ", -",s_reg m,
         s_shift_n(shift_t,shift_n),"]"]);

fun s_add_sub16 (s,(c,(opc,a))) =
  (String.concat
     [s,
      case opc of
         BitsN.B(0x0,_) => "add16"
       | BitsN.B(0x1,_) => "asx"
       | BitsN.B(0x2,_) => "sax"
       | BitsN.B(0x3,_) => "sub16"
       | _ => raise General.Bind,s_cond c],s_reg3 a);

fun s_add_sub8 (s,(c,(sub,a))) =
  (String.concat[s,if sub then "sub8" else "add8",s_cond c],s_reg3 a);

fun s_simd (c,ast) =
  case ast of
     SignedAddSub16(opc,(d,(n,m))) => s_add_sub16("s",(c,(opc,(d,(n,m)))))
   | UnsignedAddSub16(opc,(d,(n,m))) =>
     s_add_sub16("u",(c,(opc,(d,(n,m)))))
   | SignedSaturatingAddSub16(opc,(d,(n,m))) =>
     s_add_sub16("q",(c,(opc,(d,(n,m)))))
   | UnsignedSaturatingAddSub16(opc,(d,(n,m))) =>
     s_add_sub16("uq",(c,(opc,(d,(n,m)))))
   | SignedHalvingAddSub16(opc,(d,(n,m))) =>
     s_add_sub16("sh",(c,(opc,(d,(n,m)))))
   | UnsignedHalvingAddSub16(opc,(d,(n,m))) =>
     s_add_sub16("uh",(c,(opc,(d,(n,m)))))
   | SignedAddSub8(sub,(d,(n,m))) => s_add_sub8("s",(c,(sub,(d,(n,m)))))
   | UnsignedAddSub8(sub,(d,(n,m))) => s_add_sub8("u",(c,(sub,(d,(n,m)))))
   | SignedSaturatingAddSub8(sub,(d,(n,m))) =>
     s_add_sub8("q",(c,(sub,(d,(n,m)))))
   | UnsignedSaturatingAddSub8(sub,(d,(n,m))) =>
     s_add_sub8("uq",(c,(sub,(d,(n,m)))))
   | SignedHalvingAddSub8(sub,(d,(n,m))) =>
     s_add_sub8("sh",(c,(sub,(d,(n,m)))))
   | UnsignedHalvingAddSub8(sub,(d,(n,m))) =>
     s_add_sub8("uh",(c,(sub,(d,(n,m)))))
   | UnsignedSumAbsoluteDifferences(d,(n,(m,a))) =>
     (if a = (BitsN.B(0xF,4))
        then (("usad8") ^ (s_cond c),s_reg3(d,(n,m)))
      else (("usada8") ^ (s_cond c),s_reg4(d,(n,(m,a)))));

fun s_xt_rotation (d,(n,(m,rotation))) =
  String.concat
    [s_reg d,", ",if n = (BitsN.B(0xF,4)) then "" else (s_reg n) ^ (", "),
     s_reg m,
     if rotation = 0 then "" else (", ror #") ^ (Nat.toString rotation)];

fun s_media (c,ast) =
  case ast of
     SaturatingAddSubtract(opc,(d,(m,n))) =>
       ((case opc of
            BitsN.B(0x0,_) => "qadd"
          | BitsN.B(0x1,_) => "qsub"
          | BitsN.B(0x2,_) => "qdadd"
          | BitsN.B(0x3,_) => "qdsub"
          | _ => raise General.Bind)
          ^
          (s_cond c),s_reg3(d,(m,n)))
   | PackHalfword(shift_t,(shift_n,(tbform,(d,(n,m))))) =>
     ((if tbform then "pkhtb" else "pkhbt") ^ (s_cond c),
      (s_reg3(d,(n,m)))
        ^
        (if shift_n = 0 then "" else s_shift_n(shift_t,shift_n)))
   | Saturate(shift_t,(shift_n,(saturate_to,(unsigned,(d,n))))) =>
     (String.concat[if unsigned then "u" else "s","sat",s_cond c],
      String.concat
        [s_reg d,", #",Nat.toString saturate_to,", ",s_reg n,
         if shift_n = 0 then "" else s_shift_n(shift_t,shift_n)])
   | Saturate16(saturate_to,(unsigned,(d,n))) =>
     (String.concat[if unsigned then "u" else "s","sat16",s_cond c],
      String.concat[s_reg d,", #",Nat.toString saturate_to,", ",s_reg n])
   | ExtendByte(unsigned,(d,(n,(m,rotation)))) =>
     (String.concat
        [if unsigned then "u" else "s","xt",
         if n = (BitsN.B(0xF,4)) then "b" else "ab",s_cond c],
      s_xt_rotation(d,(n,(m,rotation))))
   | ExtendHalfword(unsigned,(d,(n,(m,rotation)))) =>
     (String.concat
        [if unsigned then "u" else "s","xt",
         if n = (BitsN.B(0xF,4)) then "h" else "ah",s_cond c],
      s_xt_rotation(d,(n,(m,rotation))))
   | ExtendByte16(unsigned,(d,(n,(m,rotation)))) =>
     (String.concat
        [if unsigned then "u" else "s","xt",
         if n = (BitsN.B(0xF,4)) then "b16" else "ab16",s_cond c],
      s_xt_rotation(d,(n,(m,rotation))))
   | SelectBytes(d,(n,m)) => (("sel") ^ (s_cond c),s_reg3(d,(n,m)))
   | ByteReverse(d,m) => (("rev") ^ (s_cond c),s_reg2(d,m))
   | ByteReversePackedHalfword(d,m) =>
     (("rev16") ^ (s_cond c),s_reg2(d,m))
   | ByteReverseSignedHalfword(d,m) =>
     (("revsh") ^ (s_cond c),s_reg2(d,m))
   | ReverseBits(d,m) => (("rbit") ^ (s_cond c),s_reg2(d,m))
   | BitFieldExtract(unsigned,(d,(n,(lsbit,widthminus1)))) =>
     (String.concat[if unsigned then "u" else "s","bfx",s_cond c],
      String.concat
        [s_reg2(d,n),", #",Nat.toString lsbit,", #",
         Nat.toString(Nat.+(widthminus1,1))])
   | BitFieldClearOrInsert(d,(BitsN.B(0xF,4),(lsbit,msbit))) =>
     (("bfc") ^ (s_cond c),
      String.concat
        [s_reg d,", #",Nat.toString lsbit,", #",
         Nat.toString(Nat.-(Nat.+(msbit,1),lsbit))])
   | BitFieldClearOrInsert(d,(n,(lsbit,msbit))) =>
     (("bfi") ^ (s_cond c),
      String.concat
        [s_reg2(d,n),", #",Nat.toString lsbit,", #",
         Nat.toString(Nat.-(Nat.+(msbit,1),lsbit))]);

fun s_psr (write_spsr,mask) =
  String.concat
    [if write_spsr then "S" else "C","PSR_",
     if BitsN.bit(mask,0) then "c" else "",
     if BitsN.bit(mask,1) then "x" else "",
     if BitsN.bit(mask,2) then "s" else "",
     if BitsN.bit(mask,3) then "f" else ""];

fun s_special (spsr,SYSm) =
  if spsr
    then ("SPSR_")
           ^
           (case SYSm of
               BitsN.B(0xE,_) => "fiq"
             | BitsN.B(0x10,_) => "irq"
             | BitsN.B(0x12,_) => "svc"
             | BitsN.B(0x14,_) => "abt"
             | BitsN.B(0x16,_) => "und"
             | BitsN.B(0x1C,_) => "mon"
             | BitsN.B(0x1E,_) => "hyp"
             | _ => Nat.toString(BitsN.toNat SYSm))
  else case boolify'5 SYSm of
          (false,(false,(m'2,(m'1,m'0)))) =>
            String.concat
              ["r",
               Nat.toString
                 (Nat.+
                    (BitsN.toNat(BitsN.fromBitstring([m'2,m'1,m'0],3)),8)),
               "_usr"]
        | (false,(true,(m'2,(m'1,m'0)))) =>
          String.concat
            ["r",
             Nat.toString
               (Nat.+(BitsN.toNat(BitsN.fromBitstring([m'2,m'1,m'0],3)),8)),
             "_fiq"]
        | (true,(true,(_,(false,false)))) => "lr_mon"
        | (true,(true,(_,(false,true)))) => "sp_mon"
        | (true,(true,(_,(true,false)))) => "elr_hyp"
        | (true,(true,(_,(true,true)))) => "sp_hyp"
        | (true,(false,(false,(false,false)))) => "lr_irq"
        | (true,(false,(false,(false,true)))) => "sp_irq"
        | (true,(false,(false,(true,false)))) => "lr_svc"
        | (true,(false,(false,(true,true)))) => "sp_svc"
        | (true,(false,(true,(false,false)))) => "lr_abt"
        | (true,(false,(true,(false,true)))) => "sp_abt"
        | (true,(false,(true,(true,false)))) => "lr_und"
        | (true,(false,(true,(true,true)))) => "sp_und";

fun s_system (c,ast) =
  case ast of
     EnterxLeavex false => (("leavex") ^ (s_cond c),"")
   | EnterxLeavex true => (("enterx") ^ (s_cond c),"")
   | ChangeProcessorState
     (enable,(disable,(affectA,(affectI,(affectF,changemode))))) =>
     (String.concat
        ["cps",if enable then "ie" else "",if disable then "id" else "",
         s_cond c],
      String.concat
        [if affectA then "a" else "",if affectI then "i" else "",
         if affectF then "f" else "",
         case changemode of
            Option.SOME m =>
              (if affectA orelse (affectI orelse affectF)
                 then ", #"
               else "#")
                ^
                (Nat.toString(BitsN.toNat m))
          | NONE => ""])
   | ExceptionReturn => (("eret") ^ (s_cond c),"")
   | HypervisorCall imm16 =>
     (("hvc") ^ (s_cond c),("#") ^ (s_hex 16 imm16))
   | MoveToRegisterFromSpecial(read_spsr,d) =>
     (("mrs") ^ (s_cond c),
      String.concat[s_reg d,", ",if read_spsr then "SPSR" else "CPSR"])
   | MoveToRegisterFromBankedOrSpecial(read_spsr,(SYSm,d)) =>
     (("mrs") ^ (s_cond c),
      String.concat[s_reg d,", ",s_special(read_spsr,SYSm)])
   | MoveToSpecialFromImmediate(write_spsr,(imm32,mask)) =>
     (("msr") ^ (s_cond c),
      String.concat[s_psr(write_spsr,mask),", #",s_hex 32 imm32])
   | MoveToSpecialFromRegister(write_spsr,(n,mask)) =>
     (("msr") ^ (s_cond c),
      String.concat[s_psr(write_spsr,mask),", ",s_reg n])
   | MoveToBankedOrSpecialRegister(write_spsr,(SYSm,n)) =>
     (("msr") ^ (s_cond c),
      String.concat[s_special(write_spsr,SYSm),", ",s_reg n])
   | ReturnFromException(increment,(wordhigher,(wback,n))) =>
     (String.concat["rfe",s_stack(increment,wordhigher),s_cond c],
      (s_reg n) ^ (if wback then "!" else ""))
   | SecureMonitorCall imm4 =>
     (("smc") ^ (s_cond c),("#") ^ (Nat.toString(BitsN.toNat imm4)))
   | StoreReturnState(increment,(wordhigher,(wback,mode))) =>
     (String.concat["srs",s_stack(increment,wordhigher),s_cond c],
      String.concat
        ["sp",if wback then "!" else "",", #",
         Nat.toString(BitsN.toNat mode)])
   | SupervisorCall imm32 =>
     (("svc") ^ (s_cond c),("#") ^ (s_hex 32 imm32))
   | Setend E => (("setend") ^ (s_cond c),if E then "be" else "le");

fun s_it_mask (c0,mask) =
  case (c0,mask) of
     (_,BitsN.B(0x8,_)) => ""
   | (true,BitsN.B(0xC,_)) => "t"
   | (false,BitsN.B(0x4,_)) => "t"
   | (true,BitsN.B(0x4,_)) => "e"
   | (false,BitsN.B(0xC,_)) => "e"
   | (true,BitsN.B(0xE,_)) => "tt"
   | (false,BitsN.B(0x2,_)) => "tt"
   | (true,BitsN.B(0x6,_)) => "et"
   | (false,BitsN.B(0xA,_)) => "et"
   | (true,BitsN.B(0xA,_)) => "te"
   | (false,BitsN.B(0x6,_)) => "te"
   | (true,BitsN.B(0x2,_)) => "ee"
   | (false,BitsN.B(0xE,_)) => "ee"
   | (true,BitsN.B(0xF,_)) => "ttt"
   | (false,BitsN.B(0x1,_)) => "ttt"
   | (true,BitsN.B(0x7,_)) => "ett"
   | (false,BitsN.B(0x9,_)) => "ett"
   | (true,BitsN.B(0xB,_)) => "tet"
   | (false,BitsN.B(0x5,_)) => "tet"
   | (true,BitsN.B(0x3,_)) => "eet"
   | (false,BitsN.B(0xD,_)) => "eet"
   | (true,BitsN.B(0xD,_)) => "tte"
   | (false,BitsN.B(0x3,_)) => "tte"
   | (true,BitsN.B(0x5,_)) => "ete"
   | (false,BitsN.B(0xB,_)) => "ete"
   | (true,BitsN.B(0x9,_)) => "tee"
   | (false,BitsN.B(0x7,_)) => "tee"
   | (true,BitsN.B(0x1,_)) => "eee"
   | (false,BitsN.B(0xF,_)) => "eee"
   | _ => "???";

fun instructionToString (c,ast) =
  case ast of
     Branch b => s_branch(c,b)
   | Data d => s_data(c,d)
   | Load l => s_load(c,l)
   | Store s => s_store(c,s)
   | Multiply m => s_multiply(c,m)
   | Media m => s_media(c,m)
   | SIMD m => s_simd(c,m)
   | System s => s_system(c,s)
   | Hint h => s_hint(c,h)
   | VFP v => s_vfp(c,v)
   | IfThen(firstcond,mask) =>
     (("it") ^ (s_it_mask(BitsN.bit(firstcond,0),mask)),
      if firstcond = (BitsN.B(0xE,4)) then "al" else s_cond firstcond)
   | Divide(unsigned,(d,(n,m))) =>
     (String.concat[if unsigned then "u" else "s","div",s_cond c],
      s_reg3(d,(n,m)))
   | ClearExclusive => (("clrex") ^ (s_cond c),"")
   | Swap(byte,(t,(t2,n))) =>
     (String.concat["swp",if byte then "b" else "",s_cond c],
      String.concat[s_reg2(t,t2),", [",s_reg n,"]"])
   | Undefined imm32 => (("udf") ^ (s_cond c),("#") ^ (s_hex 32 imm32))
   | NoOperation => (("nop") ^ (s_cond c),"");

end