(* x64 - generated by L3 - Thu Mar 30 14:42:27 2017 *)

structure x64 :> x64 =
struct

structure Map = MutableMap

(* -------------------------------------------------------------------------
   Type declarations
   ------------------------------------------------------------------------- *)

datatype Zreg
  = RAX | RCX | RDX | RBX | RSP | RBP | RSI | RDI | zR8 | zR9 | zR10
  | zR11 | zR12 | zR13 | zR14 | zR15

datatype Zeflags = Z_CF | Z_PF | Z_AF | Z_ZF | Z_SF | Z_OF

datatype Zsize = Z16 | Z32 | Z64 | Z8 of bool

datatype Zbase = ZnoBase | ZregBase of Zreg | ZripBase

datatype Zrm
  = Zm of ((BitsN.nbit * Zreg) option) * (Zbase * BitsN.nbit) | Zr of Zreg

datatype Zdest_src
  = Zr_rm of Zreg * Zrm | Zrm_i of Zrm * BitsN.nbit | Zrm_r of Zrm * Zreg

datatype Zimm_rm = Zimm of BitsN.nbit | Zrm of Zrm

datatype Zmonop_name = Zdec | Zinc | Znot | Zneg

datatype Zbinop_name
  = Zadd | Zor | Zadc | Zsbb | Zand | Zsub | Zxor | Zcmp | Zrol | Zror
  | Zrcl | Zrcr | Zshl | Zshr | Ztest | Zsar

datatype Zcond
  = Z_O | Z_NO | Z_B | Z_NB | Z_E | Z_NE | Z_NA | Z_A | Z_S | Z_NS | Z_P
  | Z_NP | Z_L | Z_NL | Z_NG | Z_G | Z_ALWAYS

datatype Zea
  = Zea_i of Zsize * BitsN.nbit
  | Zea_m of Zsize * BitsN.nbit
  | Zea_r of Zsize * Zreg

datatype instruction
  = Zbinop of Zbinop_name * (Zsize * Zdest_src)
  | Zcall of Zimm_rm
  | Zclc
  | Zcmc
  | Zcmpxchg of Zsize * (Zrm * Zreg)
  | Zdiv of Zsize * Zrm
  | Zjcc of Zcond * BitsN.nbit
  | Zjmp of Zrm
  | Zlea of Zsize * Zdest_src
  | Zleave
  | Zloop of Zcond * BitsN.nbit
  | Zmonop of Zmonop_name * (Zsize * Zrm)
  | Zmov of Zcond * (Zsize * Zdest_src)
  | Zmovsx of Zsize * (Zdest_src * Zsize)
  | Zmovzx of Zsize * (Zdest_src * Zsize)
  | Zmul of Zsize * Zrm
  | Znop
  | Zpop of Zrm
  | Zpush of Zimm_rm
  | Zret of BitsN.nbit
  | Zset of Zcond * (bool * Zrm)
  | Zstc
  | Zxadd of Zsize * (Zrm * Zreg)
  | Zxchg of Zsize * (Zrm * Zreg)

datatype Zinst
  = Zdec_fail of string
  | Zfull_inst of
      (BitsN.nbit list) * (instruction * ((BitsN.nbit list) option))

type REX = { B: bool, R: bool, W: bool, X: bool }

datatype maybe_instruction
  = FAIL of string
  | OK of instruction
  | PENDING of string * instruction
  | STREAM of BitsN.nbit list

(* -------------------------------------------------------------------------
   Casting maps (for enumerated types)
   ------------------------------------------------------------------------- *)

structure Cast =
struct
fun natToZreg x =
  case Nat.toInt x of
     0 => RAX
   | 1 => RCX
   | 2 => RDX
   | 3 => RBX
   | 4 => RSP
   | 5 => RBP
   | 6 => RSI
   | 7 => RDI
   | 8 => zR8
   | 9 => zR9
   | 10 => zR10
   | 11 => zR11
   | 12 => zR12
   | 13 => zR13
   | 14 => zR14
   | 15 => zR15
   | _ => raise Fail "natToZreg"

fun natToZeflags x =
  case Nat.toInt x of
     0 => Z_CF
   | 1 => Z_PF
   | 2 => Z_AF
   | 3 => Z_ZF
   | 4 => Z_SF
   | 5 => Z_OF
   | _ => raise Fail "natToZeflags"

fun natToZmonop_name x =
  case Nat.toInt x of
     0 => Zdec
   | 1 => Zinc
   | 2 => Znot
   | 3 => Zneg
   | _ => raise Fail "natToZmonop_name"

fun natToZbinop_name x =
  case Nat.toInt x of
     0 => Zadd
   | 1 => Zor
   | 2 => Zadc
   | 3 => Zsbb
   | 4 => Zand
   | 5 => Zsub
   | 6 => Zxor
   | 7 => Zcmp
   | 8 => Zrol
   | 9 => Zror
   | 10 => Zrcl
   | 11 => Zrcr
   | 12 => Zshl
   | 13 => Zshr
   | 14 => Ztest
   | 15 => Zsar
   | _ => raise Fail "natToZbinop_name"

fun natToZcond x =
  case Nat.toInt x of
     0 => Z_O
   | 1 => Z_NO
   | 2 => Z_B
   | 3 => Z_NB
   | 4 => Z_E
   | 5 => Z_NE
   | 6 => Z_NA
   | 7 => Z_A
   | 8 => Z_S
   | 9 => Z_NS
   | 10 => Z_P
   | 11 => Z_NP
   | 12 => Z_L
   | 13 => Z_NL
   | 14 => Z_NG
   | 15 => Z_G
   | 16 => Z_ALWAYS
   | _ => raise Fail "natToZcond"

fun ZregToNat x =
  case x of
     RAX => 0
   | RCX => 1
   | RDX => 2
   | RBX => 3
   | RSP => 4
   | RBP => 5
   | RSI => 6
   | RDI => 7
   | zR8 => 8
   | zR9 => 9
   | zR10 => 10
   | zR11 => 11
   | zR12 => 12
   | zR13 => 13
   | zR14 => 14
   | zR15 => 15

fun ZeflagsToNat x =
  case x of
     Z_CF => 0 | Z_PF => 1 | Z_AF => 2 | Z_ZF => 3 | Z_SF => 4 | Z_OF => 5

fun Zmonop_nameToNat x =
  case x of
     Zdec => 0 | Zinc => 1 | Znot => 2 | Zneg => 3

fun Zbinop_nameToNat x =
  case x of
     Zadd => 0
   | Zor => 1
   | Zadc => 2
   | Zsbb => 3
   | Zand => 4
   | Zsub => 5
   | Zxor => 6
   | Zcmp => 7
   | Zrol => 8
   | Zror => 9
   | Zrcl => 10
   | Zrcr => 11
   | Zshl => 12
   | Zshr => 13
   | Ztest => 14
   | Zsar => 15

fun ZcondToNat x =
  case x of
     Z_O => 0
   | Z_NO => 1
   | Z_B => 2
   | Z_NB => 3
   | Z_E => 4
   | Z_NE => 5
   | Z_NA => 6
   | Z_A => 7
   | Z_S => 8
   | Z_NS => 9
   | Z_P => 10
   | Z_NP => 11
   | Z_L => 12
   | Z_NL => 13
   | Z_NG => 14
   | Z_G => 15
   | Z_ALWAYS => 16

fun ZregToString x =
  case x of
     RAX => "RAX"
   | RCX => "RCX"
   | RDX => "RDX"
   | RBX => "RBX"
   | RSP => "RSP"
   | RBP => "RBP"
   | RSI => "RSI"
   | RDI => "RDI"
   | zR8 => "zR8"
   | zR9 => "zR9"
   | zR10 => "zR10"
   | zR11 => "zR11"
   | zR12 => "zR12"
   | zR13 => "zR13"
   | zR14 => "zR14"
   | zR15 => "zR15"

fun ZeflagsToString x =
  case x of
     Z_CF => "Z_CF"
   | Z_PF => "Z_PF"
   | Z_AF => "Z_AF"
   | Z_ZF => "Z_ZF"
   | Z_SF => "Z_SF"
   | Z_OF => "Z_OF"

fun Zmonop_nameToString x =
  case x of
     Zdec => "Zdec" | Zinc => "Zinc" | Znot => "Znot" | Zneg => "Zneg"

fun Zbinop_nameToString x =
  case x of
     Zadd => "Zadd"
   | Zor => "Zor"
   | Zadc => "Zadc"
   | Zsbb => "Zsbb"
   | Zand => "Zand"
   | Zsub => "Zsub"
   | Zxor => "Zxor"
   | Zcmp => "Zcmp"
   | Zrol => "Zrol"
   | Zror => "Zror"
   | Zrcl => "Zrcl"
   | Zrcr => "Zrcr"
   | Zshl => "Zshl"
   | Zshr => "Zshr"
   | Ztest => "Ztest"
   | Zsar => "Zsar"

fun ZcondToString x =
  case x of
     Z_O => "Z_O"
   | Z_NO => "Z_NO"
   | Z_B => "Z_B"
   | Z_NB => "Z_NB"
   | Z_E => "Z_E"
   | Z_NE => "Z_NE"
   | Z_NA => "Z_NA"
   | Z_A => "Z_A"
   | Z_S => "Z_S"
   | Z_NS => "Z_NS"
   | Z_P => "Z_P"
   | Z_NP => "Z_NP"
   | Z_L => "Z_L"
   | Z_NL => "Z_NL"
   | Z_NG => "Z_NG"
   | Z_G => "Z_G"
   | Z_ALWAYS => "Z_ALWAYS"

fun stringToZreg x =
  case x of
     "RAX" => RAX
   | "RCX" => RCX
   | "RDX" => RDX
   | "RBX" => RBX
   | "RSP" => RSP
   | "RBP" => RBP
   | "RSI" => RSI
   | "RDI" => RDI
   | "zR8" => zR8
   | "zR9" => zR9
   | "zR10" => zR10
   | "zR11" => zR11
   | "zR12" => zR12
   | "zR13" => zR13
   | "zR14" => zR14
   | "zR15" => zR15
   | _ => raise Fail "stringToZreg"

fun stringToZeflags x =
  case x of
     "Z_CF" => Z_CF
   | "Z_PF" => Z_PF
   | "Z_AF" => Z_AF
   | "Z_ZF" => Z_ZF
   | "Z_SF" => Z_SF
   | "Z_OF" => Z_OF
   | _ => raise Fail "stringToZeflags"

fun stringToZmonop_name x =
  case x of
     "Zdec" => Zdec
   | "Zinc" => Zinc
   | "Znot" => Znot
   | "Zneg" => Zneg
   | _ => raise Fail "stringToZmonop_name"

fun stringToZbinop_name x =
  case x of
     "Zadd" => Zadd
   | "Zor" => Zor
   | "Zadc" => Zadc
   | "Zsbb" => Zsbb
   | "Zand" => Zand
   | "Zsub" => Zsub
   | "Zxor" => Zxor
   | "Zcmp" => Zcmp
   | "Zrol" => Zrol
   | "Zror" => Zror
   | "Zrcl" => Zrcl
   | "Zrcr" => Zrcr
   | "Zshl" => Zshl
   | "Zshr" => Zshr
   | "Ztest" => Ztest
   | "Zsar" => Zsar
   | _ => raise Fail "stringToZbinop_name"

fun stringToZcond x =
  case x of
     "Z_O" => Z_O
   | "Z_NO" => Z_NO
   | "Z_B" => Z_B
   | "Z_NB" => Z_NB
   | "Z_E" => Z_E
   | "Z_NE" => Z_NE
   | "Z_NA" => Z_NA
   | "Z_A" => Z_A
   | "Z_S" => Z_S
   | "Z_NS" => Z_NS
   | "Z_P" => Z_P
   | "Z_NP" => Z_NP
   | "Z_L" => Z_L
   | "Z_NL" => Z_NL
   | "Z_NG" => Z_NG
   | "Z_G" => Z_G
   | "Z_ALWAYS" => Z_ALWAYS
   | _ => raise Fail "stringToZcond"
end

(* -------------------------------------------------------------------------
   Record update functions
   ------------------------------------------------------------------------- *)

fun REX_B_rupd ({B, R, W, X}: REX, x') = {B = x', R = R, W = W, X = X}
  : REX

fun REX_R_rupd ({B, R, W, X}: REX, x') = {B = B, R = x', W = W, X = X}
  : REX

fun REX_W_rupd ({B, R, W, X}: REX, x') = {B = B, R = R, W = x', X = X}
  : REX

fun REX_X_rupd ({B, R, W, X}: REX, x') = {B = B, R = R, W = W, X = x'}
  : REX

(* -------------------------------------------------------------------------
   Exceptions
   ------------------------------------------------------------------------- *)

exception BadFlagAccess of string

exception BadMemAccess of BitsN.nbit

exception FAILURE of string

(* -------------------------------------------------------------------------
   Global variables (state)
   ------------------------------------------------------------------------- *)

val EFLAGS = ref (Map.mkMap(SOME 6,NONE)): ((bool option) Map.map) ref

val MEM = ref (Map.mkMap(SOME 18446744073709551616,BitsN.B(0x0,8)))
  : (BitsN.nbit Map.map) ref

val REG = ref (Map.mkMap(SOME 16,BitsN.B(0x0,64)))
  : (BitsN.nbit Map.map) ref

val RIP = ref (BitsN.B(0x0,64)): BitsN.nbit ref

(* -------------------------------------------------------------------------
   Main specification
   ------------------------------------------------------------------------- *)

local
  fun tuple'8 [t0,t1,t2,t3,t4,t5,t6,t7] =
    (t0,(t1,(t2,(t3,(t4,(t5,(t6,t7)))))))
    | tuple'8 (_: bool list) = raise Fail "tuple'8"
in
  val boolify'8 = tuple'8 o BitsN.toList
end

fun mem8 addr = Map.lookup((!MEM),BitsN.toNat addr);

fun write'mem8 (b,addr) = MEM := (Map.update((!MEM),BitsN.toNat addr,b));

fun mem16 addr = BitsN.@@(mem8(BitsN.+(addr,BitsN.B(0x1,64))),mem8 addr);

fun write'mem16 (w,addr) =
  ( write'mem8(BitsN.bits(7,0) w,addr)
  ; let
      val x = BitsN.+(addr,BitsN.B(0x1,64))
    in
      write'mem8(BitsN.bits(15,8) w,x)
    end
  );

fun mem32 addr =
  BitsN.@@(mem16(BitsN.+(addr,BitsN.B(0x2,64))),mem16 addr);

fun write'mem32 (w,addr) =
  ( write'mem16(BitsN.bits(15,0) w,addr)
  ; let
      val x = BitsN.+(addr,BitsN.B(0x2,64))
    in
      write'mem16(BitsN.bits(31,16) w,x)
    end
  );

fun mem64 addr =
  BitsN.@@(mem32(BitsN.+(addr,BitsN.B(0x4,64))),mem32 addr);

fun write'mem64 (w,addr) =
  ( write'mem32(BitsN.bits(31,0) w,addr)
  ; let
      val x = BitsN.+(addr,BitsN.B(0x4,64))
    in
      write'mem32(BitsN.bits(63,32) w,x)
    end
  );

fun Eflag flag =
  case Map.lookup((!EFLAGS),Cast.ZeflagsToNat flag) of
     Option.SOME b => b
   | NONE => raise BadFlagAccess (Cast.ZeflagsToString flag);

fun write'Eflag (b,flag) =
  EFLAGS := (Map.update((!EFLAGS),Cast.ZeflagsToNat flag,Option.SOME b));

fun FlagUnspecified flag =
  EFLAGS := (Map.update((!EFLAGS),Cast.ZeflagsToNat flag,NONE));

fun CF () = Eflag Z_CF;

fun write'CF b = write'Eflag(b,Z_CF);

fun PF () = Eflag Z_PF;

fun write'PF b = write'Eflag(b,Z_PF);

fun AF () = Eflag Z_AF;

fun write'AF b = write'Eflag(b,Z_AF);

fun ZF () = Eflag Z_ZF;

fun write'ZF b = write'Eflag(b,Z_ZF);

fun SF () = Eflag Z_SF;

fun write'SF b = write'Eflag(b,Z_SF);

fun OF () = Eflag Z_OF;

fun write'OF b = write'Eflag(b,Z_OF);

fun ea_index index =
  case index of
     NONE => BitsN.B(0x0,64)
   | Option.SOME(scale,idx) =>
     BitsN.*
       (BitsN.<<(BitsN.B(0x1,64),BitsN.toNat scale),
        Map.lookup((!REG),Cast.ZregToNat idx));

fun ea_base base =
  case base of
     ZnoBase => BitsN.B(0x0,64)
   | ZripBase => (!RIP)
   | ZregBase b => Map.lookup((!REG),Cast.ZregToNat b);

fun ea_Zrm (size,rm) =
  case rm of
     Zr r => Zea_r(size,r)
   | Zm(index,(base,displacement)) =>
     Zea_m
       (size,BitsN.+(BitsN.+(ea_index index,ea_base base),displacement));

fun ea_Zdest (size,ds) =
  case ds of
     Zrm_i(rm,_) => ea_Zrm(size,rm)
   | Zrm_r(rm,_) => ea_Zrm(size,rm)
   | Zr_rm(r,_) => Zea_r(size,r);

fun ea_Zsrc (size,ds) =
  case ds of
     Zrm_i(_,i) => Zea_i(size,i)
   | Zrm_r(_,r) => Zea_r(size,r)
   | Zr_rm(_,rm) => ea_Zrm(size,rm);

fun ea_Zimm_rm (size,imm_rm) =
  case imm_rm of Zrm rm => ea_Zrm(size,rm) | Zimm imm => Zea_i(size,imm);

fun restrictSize (size,imm) =
  case size of
     Z8 _ => BitsN.&&(imm,BitsN.B(0xFF,64))
   | Z16 => BitsN.&&(imm,BitsN.B(0xFFFF,64))
   | Z32 => BitsN.&&(imm,BitsN.B(0xFFFFFFFF,64))
   | Z64 => imm;

fun EA ea =
  case ea of
     Zea_i i => restrictSize i
   | Zea_r(Z8 have_rex,r) =>
     BitsN.&&
       (if have_rex orelse (not(Set.mem(r,[RSP,RBP,RSI,RDI])))
          then Map.lookup((!REG),Cast.ZregToNat r)
        else BitsN.>>+
               (Map.lookup
                  ((!REG),
                   Cast.ZregToNat
                     (Cast.natToZreg(Nat.-(Cast.ZregToNat r,4)))),8),
        BitsN.B(0xFF,64))
   | Zea_r(s,r) => restrictSize(s,Map.lookup((!REG),Cast.ZregToNat r))
   | Zea_m(Z8 _,a) => BitsN.fromNat(BitsN.toNat(mem8 a),64)
   | Zea_m(Z16,a) => BitsN.fromNat(BitsN.toNat(mem16 a),64)
   | Zea_m(Z32,a) => BitsN.fromNat(BitsN.toNat(mem32 a),64)
   | Zea_m(Z64,a) => mem64 a;

fun write'EA (w,ea) =
  case ea of
     Zea_i i => raise FAILURE ("write to constant")
   | Zea_r(Z8 have_rex,r) =>
     (if have_rex orelse (not(Set.mem(r,[RSP,RBP,RSI,RDI])))
        then let
               val w0 = Map.lookup((!REG),Cast.ZregToNat r)
             in
               REG :=
               (Map.update
                  ((!REG),Cast.ZregToNat r,
                   BitsN.bitFieldInsert(7,0) (w0,BitsN.bits(7,0) w)))
             end
      else let
             val x = Cast.natToZreg(Nat.-(Cast.ZregToNat r,4))
             val w0 = Map.lookup((!REG),Cast.ZregToNat x)
           in
             REG :=
             (Map.update
                ((!REG),Cast.ZregToNat x,
                 BitsN.bitFieldInsert(15,8) (w0,BitsN.bits(7,0) w)))
           end)
   | Zea_r(Z16,r) =>
     let
       val w0 = Map.lookup((!REG),Cast.ZregToNat r)
     in
       REG :=
       (Map.update
          ((!REG),Cast.ZregToNat r,
           BitsN.bitFieldInsert(15,0) (w0,BitsN.bits(15,0) w)))
     end
   | Zea_r(Z32,r) =>
     REG :=
     (Map.update
        ((!REG),Cast.ZregToNat r,BitsN.zeroExtend 64 (BitsN.bits(31,0) w)))
   | Zea_r(Z64,r) => REG := (Map.update((!REG),Cast.ZregToNat r,w))
   | Zea_m(Z8 _,a) => write'mem8(BitsN.bits(7,0) w,a)
   | Zea_m(Z16,a) => write'mem16(BitsN.bits(15,0) w,a)
   | Zea_m(Z32,a) => write'mem32(BitsN.bits(31,0) w,a)
   | Zea_m(Z64,a) => write'mem64(w,a);

fun read_dest_src_ea sd =
  let val ea = ea_Zdest sd in (ea,(EA ea,EA(ea_Zsrc sd))) end;

fun call_dest_from_ea ea =
  case ea of
     Zea_i(_,i) => BitsN.+((!RIP),i)
   | Zea_r(_,r) => Map.lookup((!REG),Cast.ZregToNat r)
   | Zea_m(_,a) => mem64 a;

fun get_ea_address ea =
  case ea of
     Zea_i(_,i) => BitsN.B(0x0,64)
   | Zea_r(_,r) => BitsN.B(0x0,64)
   | Zea_m(_,a) => a;

fun jump_to_ea ea = RIP := (call_dest_from_ea ea);

fun ByteParity b =
  let
    val count =
      Nat.+
        (Nat.+
           (Nat.+
              (Nat.+
                 (Nat.+
                    (Nat.+
                       (Nat.+
                          (Nat.fromBool(BitsN.bit(b,7)),
                           Nat.fromBool(BitsN.bit(b,6))),
                        Nat.fromBool(BitsN.bit(b,5))),
                     Nat.fromBool(BitsN.bit(b,4))),
                  Nat.fromBool(BitsN.bit(b,3))),
               Nat.fromBool(BitsN.bit(b,2))),Nat.fromBool(BitsN.bit(b,1))),
         Nat.fromBool(BitsN.bit(b,0)))
  in
    (Nat.mod(count,2)) = 0
  end;

fun Zsize_width size =
  case size of Z8 _ => 8 | Z16 => 16 | Z32 => 32 | Z64 => 64;

fun word_size_msb (size,w) = BitsN.bit(w,Nat.-(Zsize_width size,1));

fun write_PF w = write'PF(ByteParity(BitsN.bits(7,0) w));

fun write_SF s_w = write'SF(word_size_msb s_w);

fun write_ZF (size,w) =
  write'ZF
    (case size of
        Z8 _ => (BitsN.fromNat(BitsN.toNat w,8)) = (BitsN.B(0x0,8))
      | Z16 => (BitsN.fromNat(BitsN.toNat w,16)) = (BitsN.B(0x0,16))
      | Z32 => (BitsN.fromNat(BitsN.toNat w,32)) = (BitsN.B(0x0,32))
      | Z64 => w = (BitsN.B(0x0,64)));

fun write_logical_eflags (size,w) =
  ( write'CF false
  ; write'OF false
  ; write_PF w
  ; write_SF(size,w)
  ; write_ZF(size,w)
  ; FlagUnspecified Z_AF
  );

fun write_arith_eflags_except_CF_OF (size,w) =
  ( write_PF w; write_SF(size,w); write_ZF(size,w); FlagUnspecified Z_AF );

fun write_arith_eflags (size,r) =
  let
    val (w,(c,x)) = r
  in
    ( write'CF c; write'OF x; write_arith_eflags_except_CF_OF(size,w) )
  end;

fun erase_eflags () = EFLAGS := (Map.mkMap(SOME 6,NONE));

fun value_width s = Nat.pow(2,Zsize_width s);

fun word_signed_overflow_add (size,(a,b)) =
  ((word_size_msb(size,a)) = (word_size_msb(size,b))) andalso
  (not((word_size_msb(size,BitsN.+(a,b))) = (word_size_msb(size,a))));

fun word_signed_overflow_sub (size,(a,b)) =
  (not((word_size_msb(size,a)) = (word_size_msb(size,b)))) andalso
  (not((word_size_msb(size,BitsN.-(a,b))) = (word_size_msb(size,a))));

fun add_with_carry_out (size,(x,y)) =
  (BitsN.+(x,y),
   (Nat.<=(value_width size,Nat.+(BitsN.toNat x,BitsN.toNat y)),
    word_signed_overflow_add(size,(x,y))));

fun sub_with_borrow (size,(x,y)) =
  (BitsN.-(x,y),(BitsN.<+(x,y),word_signed_overflow_sub(size,(x,y))));

fun write_arith_result (size,(r,ea)) =
  ( write_arith_eflags(size,r); write'EA(L3.fst r,ea) );

fun write_arith_result_no_CF_OF (size,(w,ea)) =
  ( write_arith_eflags_except_CF_OF(size,w); write'EA(w,ea) );

fun write_logical_result (size,(w,ea)) =
  ( write_logical_eflags(size,w); write'EA(w,ea) );

fun write_result_erase_eflags (w,ea) =
  ( erase_eflags (); write'EA(w,ea) );

fun SignExtension (w,(size1,size2)) =
  let
    val v = ref w
  in
    ( case (size1,size2) of
         (Z8 _,Z16) =>
           v :=
           (BitsN.bitFieldInsert(15,0)
              ((!v),BitsN.signExtend 16 (BitsN.bits(7,0) w)))
       | (Z8 _,Z32) =>
         v :=
         (BitsN.bitFieldInsert(31,0)
            ((!v),BitsN.signExtend 32 (BitsN.bits(7,0) w)))
       | (Z8 _,Z64) => v := (BitsN.signExtend 64 (BitsN.bits(7,0) w))
       | (Z16,Z32) =>
         v :=
         (BitsN.bitFieldInsert(31,0)
            ((!v),BitsN.signExtend 32 (BitsN.bits(15,0) w)))
       | (Z16,Z64) => v := (BitsN.signExtend 64 (BitsN.bits(15,0) w))
       | (Z32,Z64) => v := (BitsN.signExtend 64 (BitsN.bits(31,0) w))
       | _ => raise FAILURE ("SignExtension")
    ; (!v)
    )
  end;

fun maskShift (size,w) =
  if size = Z64
    then BitsN.toNat(BitsN.bits(5,0) w)
  else BitsN.toNat(BitsN.bits(4,0) w);

fun ROL (size,(x,y)) =
  case size of
     Z8 _ =>
       BitsN.fromNat
         (BitsN.toNat
            (BitsN.#<<(BitsN.bits(7,0) x,BitsN.toNat(BitsN.bits(4,0) y))),
          64)
   | Z16 =>
     BitsN.fromNat
       (BitsN.toNat
          (BitsN.#<<(BitsN.bits(15,0) x,BitsN.toNat(BitsN.bits(4,0) y))),
        64)
   | Z32 =>
     BitsN.fromNat
       (BitsN.toNat
          (BitsN.#<<(BitsN.bits(31,0) x,BitsN.toNat(BitsN.bits(4,0) y))),
        64)
   | Z64 => BitsN.#<<(x,BitsN.toNat(BitsN.bits(5,0) y));

fun ROR (size,(x,y)) =
  case size of
     Z8 _ =>
       BitsN.fromNat
         (BitsN.toNat
            (BitsN.#>>(BitsN.bits(7,0) x,BitsN.toNat(BitsN.bits(4,0) y))),
          64)
   | Z16 =>
     BitsN.fromNat
       (BitsN.toNat
          (BitsN.#>>(BitsN.bits(15,0) x,BitsN.toNat(BitsN.bits(4,0) y))),
        64)
   | Z32 =>
     BitsN.fromNat
       (BitsN.toNat
          (BitsN.#>>(BitsN.bits(31,0) x,BitsN.toNat(BitsN.bits(4,0) y))),
        64)
   | Z64 => BitsN.#>>(x,BitsN.toNat(BitsN.bits(5,0) y));

fun SAR (size,(x,y)) =
  case size of
     Z8 _ =>
       BitsN.fromNat
         (BitsN.toNat
            (BitsN.>>(BitsN.bits(7,0) x,BitsN.toNat(BitsN.bits(4,0) y))),
          64)
   | Z16 =>
     BitsN.fromNat
       (BitsN.toNat
          (BitsN.>>(BitsN.bits(15,0) x,BitsN.toNat(BitsN.bits(4,0) y))),64)
   | Z32 =>
     BitsN.fromNat
       (BitsN.toNat
          (BitsN.>>(BitsN.bits(31,0) x,BitsN.toNat(BitsN.bits(4,0) y))),64)
   | Z64 => BitsN.>>(x,BitsN.toNat(BitsN.bits(5,0) y));

fun write_binop (s,(bop,(x,(y,ea)))) =
  case bop of
     Zadd => write_arith_result(s,(add_with_carry_out(s,(x,y)),ea))
   | Zsub => write_arith_result(s,(sub_with_borrow(s,(x,y)),ea))
   | Zcmp => write_arith_eflags(s,sub_with_borrow(s,(x,y)))
   | Ztest => write_logical_eflags(s,BitsN.&&(x,y))
   | Zand => write_logical_result(s,(BitsN.&&(x,y),ea))
   | Zxor => write_logical_result(s,(BitsN.??(x,y),ea))
   | Zor => write_logical_result(s,(BitsN.||(x,y),ea))
   | Zrol => write_result_erase_eflags(ROL(s,(x,y)),ea)
   | Zror => write_result_erase_eflags(ROR(s,(x,y)),ea)
   | Zsar => write_result_erase_eflags(SAR(s,(x,y)),ea)
   | Zshl => write_result_erase_eflags(BitsN.<<(x,maskShift(s,y)),ea)
   | Zshr => write_result_erase_eflags(BitsN.>>+(x,maskShift(s,y)),ea)
   | Zadc =>
     let
       val carry = CF ()
       val result = BitsN.+(BitsN.+(x,y),BitsN.fromBool 64 carry)
     in
       ( write'CF
           (Nat.<=
              (value_width s,
               Nat.+
                 (Nat.+(BitsN.toNat x,BitsN.toNat y),Nat.fromBool carry)))
       ; FlagUnspecified Z_OF
       ; write_arith_result_no_CF_OF(s,(result,ea))
       )
     end
   | Zsbb =>
     let
       val carry = CF ()
       val result = BitsN.-(x,BitsN.+(y,BitsN.fromBool 64 carry))
     in
       ( write'CF
           (Nat.<(BitsN.toNat x,Nat.+(BitsN.toNat y,Nat.fromBool carry)))
       ; FlagUnspecified Z_OF
       ; write_arith_result_no_CF_OF(s,(result,ea))
       )
     end
   | _ =>
     raise FAILURE
       (("Binary op not implemented: ") ^ (Cast.Zbinop_nameToString bop));

fun write_monop (s,(mop,(x,ea))) =
  case mop of
     Znot => write'EA(BitsN.~ x,ea)
   | Zdec =>
     write_arith_result_no_CF_OF(s,(BitsN.-(x,BitsN.B(0x1,64)),ea))
   | Zinc =>
     write_arith_result_no_CF_OF(s,(BitsN.+(x,BitsN.B(0x1,64)),ea))
   | Zneg =>
     ( write_arith_result_no_CF_OF(s,(BitsN.neg x,ea))
     ; FlagUnspecified Z_CF
     );

fun read_cond c =
  case c of
     Z_A =>
       (case (Map.lookup((!EFLAGS),Cast.ZeflagsToNat Z_CF),
         Map.lookup((!EFLAGS),Cast.ZeflagsToNat Z_ZF)) of
           (Option.SOME false,Option.SOME false) => true
         | (Option.SOME true,_) => false
         | (_,Option.SOME true) => false
         | _ =>
           raise BadFlagAccess (("read_cond: ") ^ (Cast.ZcondToString c)))
   | Z_NB => not(CF ())
   | Z_B => CF ()
   | Z_NA =>
     (case (Map.lookup((!EFLAGS),Cast.ZeflagsToNat Z_CF),
       Map.lookup((!EFLAGS),Cast.ZeflagsToNat Z_ZF)) of
         (Option.SOME true,_) => true
       | (_,Option.SOME true) => true
       | (Option.SOME false,Option.SOME false) => false
       | _ =>
         raise BadFlagAccess (("read_cond: ") ^ (Cast.ZcondToString c)))
   | Z_E => ZF ()
   | Z_G =>
     (case (Map.lookup((!EFLAGS),Cast.ZeflagsToNat Z_SF),
       Map.lookup((!EFLAGS),Cast.ZeflagsToNat Z_OF)) of
         (Option.SOME a,Option.SOME b) => (a = b) andalso (not(ZF ()))
       | _ =>
         (case Map.lookup((!EFLAGS),Cast.ZeflagsToNat Z_ZF) of
             Option.SOME true => false
           | _ =>
             raise BadFlagAccess
               (("read_cond: ") ^ (Cast.ZcondToString c))))
   | Z_NL => (SF ()) = (OF ())
   | Z_L => not((SF ()) = (OF ()))
   | Z_NG =>
     (case (Map.lookup((!EFLAGS),Cast.ZeflagsToNat Z_SF),
       Map.lookup((!EFLAGS),Cast.ZeflagsToNat Z_OF)) of
         (Option.SOME a,Option.SOME b) => (not(a = b)) orelse (ZF ())
       | _ =>
         (case Map.lookup((!EFLAGS),Cast.ZeflagsToNat Z_ZF) of
             Option.SOME true => true
           | _ =>
             raise BadFlagAccess
               (("read_cond: ") ^ (Cast.ZcondToString c))))
   | Z_NE => not(ZF ())
   | Z_NO => not(OF ())
   | Z_NP => not(PF ())
   | Z_NS => not(SF ())
   | Z_O => OF ()
   | Z_P => PF ()
   | Z_S => SF ()
   | Z_ALWAYS => true;

fun x64_pop_aux () =
  let
    val rsp = Map.lookup((!REG),Cast.ZregToNat RSP)
    val top = mem64 rsp
  in
    ( REG :=
      (Map.update((!REG),Cast.ZregToNat RSP,BitsN.+(rsp,BitsN.B(0x8,64))))
    ; top
    )
  end;

fun x64_pop rm =
  let val x = ea_Zrm(Z64,rm) in write'EA(x64_pop_aux (),x) end;

fun x64_pop_rip () = RIP := (x64_pop_aux ());

fun x64_push_aux w =
  let
    val rsp =
      BitsN.-(Map.lookup((!REG),Cast.ZregToNat RSP),BitsN.B(0x8,64))
  in
    ( REG := (Map.update((!REG),Cast.ZregToNat RSP,rsp))
    ; write'mem64(w,rsp)
    )
  end;

fun x64_push imm_rm = x64_push_aux(EA(ea_Zimm_rm(Z64,imm_rm)));

fun x64_push_rip () = x64_push_aux (!RIP);

fun x64_drop imm =
  ( if not((BitsN.bits(7,0) imm) = (BitsN.B(0x0,8)))
      then raise FAILURE ("x64_drop")
    else ()
  ; REG :=
    (Map.update
       ((!REG),Cast.ZregToNat RSP,
        BitsN.+(Map.lookup((!REG),Cast.ZregToNat RSP),imm)))
  );

fun dfn'Zbinop (bop,(size,dst_src)) =
  let
    val (ea,(val_dst,val_src)) = read_dest_src_ea(size,dst_src)
  in
    write_binop(size,(bop,(val_dst,(val_src,ea))))
  end;

fun dfn'Zcall imm_rm =
  ( x64_push_rip (); jump_to_ea(ea_Zimm_rm(Z64,imm_rm)) );

fun dfn'Zcmpxchg (size,(rm,r)) =
  let
    val ea_src = Zea_r(size,r)
    val ea_acc = Zea_r(size,RAX)
    val ea_dst = ea_Zrm(size,rm)
    val val_dst = EA ea_dst
    val acc = EA ea_src
  in
    ( write_binop(size,(Zcmp,(acc,(val_dst,ea_src))))
    ; if acc = val_dst
        then write'EA(EA ea_src,ea_dst)
      else write'EA(val_dst,ea_acc)
    )
  end;

fun dfn'Zdiv (size,rm) =
  let
    val w = value_width size
    val ea_eax = Zea_r(size,RAX)
    val ea_edx = Zea_r(size,RDX)
    val n = Nat.+(Nat.*(BitsN.toNat(EA ea_edx),w),BitsN.toNat(EA ea_eax))
    val d = BitsN.toNat(EA(ea_Zrm(size,rm)))
    val q = Nat.div(n,d)
    val r = Nat.mod(n,d)
  in
    ( if (d = 0) orelse (Nat.<=(w,q))
        then raise FAILURE ("division")
      else ()
    ; write'EA(BitsN.fromNat(q,64),ea_eax)
    ; write'EA(BitsN.fromNat(r,64),ea_edx)
    ; erase_eflags ()
    )
  end;

fun dfn'Zjcc (cond,imm) =
  if read_cond cond then RIP := (BitsN.+((!RIP),imm)) else ();

fun dfn'Zjmp rm = RIP := (EA(ea_Zrm(Z64,rm)));

fun dfn'Zlea (size,dst_src) =
  let
    val ea_src = ea_Zsrc(size,dst_src)
    val ea_dst = ea_Zdest(size,dst_src)
  in
    write'EA(get_ea_address ea_src,ea_dst)
  end;

fun dfn'Zleave () =
  ( REG :=
    (Map.update
       ((!REG),Cast.ZregToNat RSP,Map.lookup((!REG),Cast.ZregToNat RBP)))
  ; x64_pop(Zr RBP)
  );

fun dfn'Zloop (cond,imm) =
  let
    val ecx1 =
      BitsN.-(Map.lookup((!REG),Cast.ZregToNat RCX),BitsN.B(0x1,64))
  in
    ( REG := (Map.update((!REG),Cast.ZregToNat RCX,ecx1))
    ; if (not(ecx1 = (BitsN.B(0x0,64)))) andalso (read_cond cond)
        then RIP := (BitsN.+((!RIP),imm))
      else ()
    )
  end;

fun dfn'Zmonop (mop,(size,rm)) =
  let val ea = ea_Zrm(size,rm) in write_monop(size,(mop,(EA ea,ea))) end;

fun dfn'Zmov (cond,(size,dst_src)) =
  if read_cond cond
    then let
           val ea_src = ea_Zsrc(size,dst_src)
           val ea_dst = ea_Zdest(size,dst_src)
         in
           write'EA(EA ea_src,ea_dst)
         end
  else ();

fun dfn'Zmovsx (size1,(dst_src,size2)) =
  let
    val x = ea_Zdest(size2,dst_src)
  in
    write'EA(SignExtension(EA(ea_Zsrc(size1,dst_src)),(size1,size2)),x)
  end;

fun dfn'Zmovzx (size1,(dst_src,size2)) =
  let
    val x = ea_Zdest(size2,dst_src)
  in
    write'EA(EA(ea_Zsrc(size1,dst_src)),x)
  end;

fun dfn'Zmul (size,rm) =
  let
    val ea_eax = Zea_r(size,RAX)
    val eax = EA ea_eax
    val val_src = EA(ea_Zrm(size,rm))
  in
    ( case size of
         Z8 _ =>
           let
             val x = Zea_r(Z16,RAX)
           in
             write'EA(BitsN.*(eax,val_src),x)
           end
       | _ =>
         ( write'EA(BitsN.*(eax,val_src),ea_eax)
         ; let
             val ea_edx = Zea_r(size,RDX)
           in
             write'EA
               (BitsN.fromNat
                  (Nat.div
                     (Nat.*(BitsN.toNat eax,BitsN.toNat val_src),
                      value_width size),64),ea_edx)
           end
         )
    ; erase_eflags ()
    )
  end;

val dfn'Znop = ()

fun dfn'Zpop rm = x64_pop rm;

fun dfn'Zpush imm_rm = x64_push imm_rm;

fun dfn'Zret imm = ( x64_pop_rip (); x64_drop imm );

fun dfn'Zset (cond,(have_rex,rm)) =
  let
    val x = ea_Zrm(Z8 have_rex,rm)
  in
    write'EA(BitsN.fromBool 64 (read_cond cond),x)
  end;

fun dfn'Zxadd (size,(rm,r)) =
  let
    val ea_src = Zea_r(size,r)
    val ea_dst = ea_Zrm(size,rm)
    val val_src = EA ea_src
    val val_dst = EA ea_dst
  in
    ( write'EA(val_dst,ea_src)
    ; write_binop(size,(Zadd,(val_src,(val_dst,ea_dst))))
    )
  end;

fun dfn'Zxchg (size,(rm,r)) =
  let
    val ea_src = Zea_r(size,r)
    val ea_dst = ea_Zrm(size,rm)
    val val_src = EA ea_src
    val val_dst = EA ea_dst
  in
    ( write'EA(val_dst,ea_src); write'EA(val_src,ea_dst) )
  end;

fun dfn'Zcmc () = write'CF(not(CF ()));

fun dfn'Zclc () = write'CF false;

fun dfn'Zstc () = write'CF true;

fun Run v0 =
  case v0 of
     Zclc => dfn'Zclc ()
   | Zcmc => dfn'Zcmc ()
   | Zleave => dfn'Zleave ()
   | Znop => dfn'Znop
   | Zstc => dfn'Zstc ()
   | Zbinop v1 => dfn'Zbinop v1
   | Zcall v2 => dfn'Zcall v2
   | Zcmpxchg v3 => dfn'Zcmpxchg v3
   | Zdiv v4 => dfn'Zdiv v4
   | Zjcc v5 => dfn'Zjcc v5
   | Zjmp v6 => dfn'Zjmp v6
   | Zlea v7 => dfn'Zlea v7
   | Zloop v8 => dfn'Zloop v8
   | Zmonop v9 => dfn'Zmonop v9
   | Zmov v10 => dfn'Zmov v10
   | Zmovsx v11 => dfn'Zmovsx v11
   | Zmovzx v12 => dfn'Zmovzx v12
   | Zmul v13 => dfn'Zmul v13
   | Zpop v14 => dfn'Zpop v14
   | Zpush v15 => dfn'Zpush v15
   | Zret v16 => dfn'Zret v16
   | Zset v17 => dfn'Zset v17
   | Zxadd v18 => dfn'Zxadd v18
   | Zxchg v19 => dfn'Zxchg v19;

fun oimmediate8 strm =
  case strm of
     Option.SOME(b :: t) => (BitsN.signExtend 64 b,Option.SOME t)
   | _ => (BitsN.B(0x0,64),NONE);

fun immediate8 strm = oimmediate8(Option.SOME strm);

fun immediate16 strm =
  case strm of
     b1 :: (b2 :: t) =>
       (BitsN.signExtend 64 (BitsN.@@(b2,b1)),Option.SOME t)
   | _ => (BitsN.B(0x0,64),NONE);

fun immediate32 strm =
  case strm of
     b1 :: (b2 :: (b3 :: (b4 :: t))) =>
       (BitsN.signExtend 64 (BitsN.concat[b4,b3,b2,b1]),Option.SOME t)
   | _ => (BitsN.B(0x0,64),NONE);

fun immediate64 strm =
  case strm of
     b1 :: (b2 :: (b3 :: (b4 :: (b5 :: (b6 :: (b7 :: (b8 :: t))))))) =>
       (BitsN.concat[b8,b7,b6,b5,b4,b3,b2,b1],Option.SOME t)
   | _ => (BitsN.B(0x0,64),NONE);

fun immediate (size,strm) =
  case size of
     Z8 _ => immediate8 strm
   | Z16 => immediate16 strm
   | _ => immediate32 strm;

fun oimmediate (size,strm) =
  case strm of
     Option.SOME s => immediate(size,s)
   | NONE => (BitsN.B(0x0,64),NONE);

fun full_immediate (size,strm) =
  if size = Z64 then immediate64 strm else immediate(size,strm);

fun rec'REX x =
  {B = BitsN.bit(x,0), R = BitsN.bit(x,2), W = BitsN.bit(x,3),
   X = BitsN.bit(x,1)};

fun reg'REX x =
  case x of
     {B = B, R = R, W = W, X = X} =>
       BitsN.concat
         [BitsN.fromBit W,BitsN.fromBit R,BitsN.fromBit X,BitsN.fromBit B];

fun write'rec'REX (_,x) = reg'REX x;

fun write'reg'REX (_,x) = rec'REX x;

fun RexReg (b,r) =
  (Cast.natToZreg o BitsN.toNat) (BitsN.@@(BitsN.fromBit b,r));

fun readDisplacement (Mod,strm) =
  if Mod = (BitsN.B(0x1,2))
    then immediate8 strm
  else if Mod = (BitsN.B(0x2,2))
    then immediate32 strm
  else (BitsN.B(0x0,64),Option.SOME strm);

fun readSibDisplacement (w,(Mod,strm)) =
  if Mod = (BitsN.B(0x1,2)) then immediate8 strm else immediate32 strm;

fun readSIB (REX,(Mod,strm)) =
  case strm of
     v'0 :: v'1 =>
       (case (boolify'8 v'0,v'1) of
           ((SS'1,
             (SS'0,(Index'2,(Index'1,(Index'0,(Base'2,(Base'1,Base'0))))))),
            strm1) =>
             let
               val base =
                 RexReg
                   (#B(REX : REX),
                    BitsN.fromBitstring([Base'2,Base'1,Base'0],3))
               val index =
                 RexReg
                   (#X(REX : REX),
                    BitsN.fromBitstring([Index'2,Index'1,Index'0],3))
               val scaled_index =
                 if index = RSP
                   then NONE
                 else Option.SOME
                        (BitsN.fromBitstring([SS'1,SS'0],2),index)
             in
               if base = RBP
                 then let
                        val (displacement,strm2) =
                          readSibDisplacement(#W(REX : REX),(Mod,strm1))
                        val base =
                          if Mod = (BitsN.B(0x0,2))
                            then ZnoBase
                          else ZregBase base
                      in
                        (Zm(scaled_index,(base,displacement)),strm2)
                      end
               else let
                      val (displacement,strm2) =
                        readDisplacement(Mod,strm1)
                    in
                      (Zm(scaled_index,(ZregBase base,displacement)),strm2)
                    end
             end)
   | _ => (Zm(NONE,(ZnoBase,BitsN.B(0x0,64))),NONE);

fun readModRM (REX,strm) =
  case strm of
     v'0 :: v'1 =>
       (case (boolify'8 v'0,v'1) of
           ((false,
             (false,(RegOpc'2,(RegOpc'1,(RegOpc'0,(true,(false,true))))))),
            strm1) =>
             let
               val (displacement,strm2) = immediate32 strm1
             in
               (RexReg
                  (#R(REX : REX),
                   BitsN.fromBitstring([RegOpc'2,RegOpc'1,RegOpc'0],3)),
                (Zm(NONE,(ZripBase,displacement)),strm2))
             end
         | ((true,(true,(REG'2,(REG'1,(REG'0,(RM'2,(RM'1,RM'0))))))),strm1) =>
           (RexReg
              (#R(REX : REX),BitsN.fromBitstring([REG'2,REG'1,REG'0],3)),
            (Zr(RexReg
                  (#B(REX : REX),BitsN.fromBitstring([RM'2,RM'1,RM'0],3))),
             Option.SOME strm1))
         | ((Mod'1,
           (Mod'0,(RegOpc'2,(RegOpc'1,(RegOpc'0,(true,(false,false))))))),
          strm1) =>
           let
             val (sib,strm2) =
               readSIB(REX,(BitsN.fromBitstring([Mod'1,Mod'0],2),strm1))
           in
             (RexReg
                (#R(REX : REX),
                 BitsN.fromBitstring([RegOpc'2,RegOpc'1,RegOpc'0],3)),
              (sib,strm2))
           end
         | ((Mod'1,
           (Mod'0,(RegOpc'2,(RegOpc'1,(RegOpc'0,(RM'2,(RM'1,RM'0))))))),
          strm1) =>
           let
             val (displacement,strm2) =
               readDisplacement
                 (BitsN.fromBitstring([Mod'1,Mod'0],2),strm1)
           in
             (RexReg
                (#R(REX : REX),
                 BitsN.fromBitstring([RegOpc'2,RegOpc'1,RegOpc'0],3)),
              (Zm(NONE,
                  (ZregBase
                     (RexReg
                        (#B(REX : REX),
                         BitsN.fromBitstring([RM'2,RM'1,RM'0],3))),
                   displacement)),strm2))
           end)
   | _ => (RAX,(Zm(NONE,(ZnoBase,BitsN.B(0x0,64))),NONE));

fun readOpcodeModRM (REX,strm) =
  let
    val (opcode,(rm,strm1)) = readModRM(REX,strm)
  in
    (BitsN.fromNat(Nat.mod(Cast.ZregToNat opcode,8),3),(rm,strm1))
  end;

fun prefixGroup b =
  case b of
     BitsN.B(0xF0,_) => 1
   | BitsN.B(0xF2,_) => 1
   | BitsN.B(0xF3,_) => 1
   | BitsN.B(0x26,_) => 2
   | BitsN.B(0x2E,_) => 2
   | BitsN.B(0x36,_) => 2
   | BitsN.B(0x3E,_) => 2
   | BitsN.B(0x64,_) => 2
   | BitsN.B(0x65,_) => 2
   | BitsN.B(0x66,_) => 3
   | BitsN.B(0x67,_) => 4
   | _ => (if (BitsN.bits(7,4) b) = (BitsN.B(0x4,4)) then 5 else 0);

fun readPrefix (s,(p,strm)) =
  case strm of
     h :: strm1 =>
       let
         val group = prefixGroup h
       in
         if group = 0
           then Option.SOME(p,(false,(rec'REX(BitsN.B(0x0,4)),strm)))
         else if group = 5
           then Option.SOME(p,(true,(rec'REX(BitsN.bits(3,0) h),strm1)))
         else if Set.mem(group,s)
           then NONE
         else readPrefix(Set.insert(group,s),(h :: p,strm1))
       end
   | [] =>
     Option.SOME
       (p,(false,({B = false, R = false, W = false, X = false},strm)));

fun readPrefixes strm = readPrefix([],([],strm));

fun OpSize (have_rex,(w,(v,override))) =
  if v = (BitsN.B(0x0,1))
    then Z8 have_rex
  else if w then Z64 else if override then Z16 else Z32;

fun isZm rm = case rm of Zm _ => true | _ => false;

fun x64_decode strm =
  case readPrefixes strm of
     NONE => Zdec_fail("Bad prefix")
   | Option.SOME(p,(have_rex,(REX,strm1))) =>
     let
       val prefixes = Set.mk p
       val op_size_override = Set.mem(BitsN.B(0x66,8),prefixes)
     in
       if (#W(REX : REX)) andalso op_size_override
         then Zdec_fail("REX.W together with override prefix")
       else if Set.mem(BitsN.B(0x67,8),prefixes)
         then Zdec_fail("address override prefix not supported")
       else case strm1 of
               v'0 :: v'1 =>
                 (case (boolify'8 v'0,v'1) of
                     ((false,
                       (false,(opc'2,(opc'1,(opc'0,(false,(x'0,v'0))))))),
                      strm2) =>
                       let
                         val (reg,(rm,strm3)) = readModRM(REX,strm2)
                         val size =
                           OpSize
                             (have_rex,
                              (#W(REX : REX),
                               (BitsN.fromBitstring([v'0],1),
                                op_size_override)))
                         val binop =
                           (Cast.natToZbinop_name o BitsN.toNat)
                             (BitsN.fromBitstring([opc'2,opc'1,opc'0],3))
                         val src_dst =
                           if (BitsN.fromBitstring([x'0],1)) =
                              (BitsN.B(0x0,1))
                             then Zrm_r(rm,reg)
                           else Zr_rm(reg,rm)
                       in
                         Zfull_inst
                           (p,(Zbinop(binop,(size,src_dst)),strm3))
                       end
                   | ((false,
                     (false,(opc'2,(opc'1,(opc'0,(true,(false,v'0))))))),
                    strm2) =>
                     let
                       val size =
                         OpSize
                           (have_rex,
                            (#W(REX : REX),
                             (BitsN.fromBitstring([v'0],1),
                              op_size_override)))
                       val (imm,strm3) = immediate(size,strm2)
                     in
                       Zfull_inst
                         (p,
                          (Zbinop
                             ((Cast.natToZbinop_name o BitsN.toNat)
                                (BitsN.fromBitstring
                                   ([opc'2,opc'1,opc'0],3)),
                              (size,Zrm_i(Zr RAX,imm))),strm3))
                     end
                   | ((false,(true,(false,(true,(b'0,(r'2,(r'1,r'0))))))),
                    strm2) =>
                     let
                       val reg =
                         Zr((Cast.natToZreg o BitsN.toNat)
                              (BitsN.@@
                                 (BitsN.fromBit(#B(REX : REX)),
                                  BitsN.fromBitstring([r'2,r'1,r'0],3))))
                     in
                       Zfull_inst
                         (p,
                          (if (BitsN.fromBitstring([b'0],1)) =
                              (BitsN.B(0x0,1))
                             then Zpush(Zrm reg)
                           else Zpop reg,Option.SOME strm2))
                     end
                   | ((false,
                     (true,(true,(false,(false,(false,(true,true))))))),
                    strm2) =>
                     let
                       val (reg,(rm,strm3)) = readModRM(REX,strm2)
                     in
                       Zfull_inst
                         (p,(Zmovsx(Z32,(Zr_rm(reg,rm),Z64)),strm3))
                     end
                   | ((false,
                     (true,(true,(false,(true,(false,(b'0,false))))))),
                    strm2) =>
                     let
                       val (imm,strm3) =
                         if (BitsN.fromBitstring([b'0],1)) =
                            (BitsN.B(0x1,1))
                           then immediate8 strm2
                         else immediate32 strm2
                     in
                       Zfull_inst(p,(Zpush(Zimm imm),strm3))
                     end
                   | ((false,(true,(true,(true,(c'3,(c'2,(c'1,c'0))))))),
                    strm2) =>
                     let
                       val (imm,strm3) = immediate8 strm2
                     in
                       Zfull_inst
                         (p,
                          (Zjcc
                             ((Cast.natToZcond o BitsN.toNat)
                                (BitsN.fromBitstring([c'3,c'2,c'1,c'0],4)),
                              imm),strm3))
                     end
                   | ((true,
                     (false,(false,(false,(false,(false,(false,v'0))))))),
                    strm2) =>
                     let
                       val size =
                         OpSize
                           (have_rex,
                            (#W(REX : REX),
                             (BitsN.fromBitstring([v'0],1),
                              op_size_override)))
                       val (opcode,(rm,strm3)) =
                         readOpcodeModRM(REX,strm2)
                       val (imm,strm4) = oimmediate(size,strm3)
                       val binop =
                         (Cast.natToZbinop_name o BitsN.toNat) opcode
                     in
                       Zfull_inst
                         (p,(Zbinop(binop,(size,Zrm_i(rm,imm))),strm4))
                     end
                   | ((true,
                     (false,(false,(false,(false,(false,(true,true))))))),
                    strm2) =>
                     let
                       val size =
                         OpSize
                           (false,
                            (#W(REX : REX),
                             (BitsN.B(0x1,1),op_size_override)))
                       val (opcode,(rm,strm3)) =
                         readOpcodeModRM(REX,strm2)
                       val (imm,strm4) = oimmediate8 strm3
                       val binop =
                         (Cast.natToZbinop_name o BitsN.toNat) opcode
                     in
                       Zfull_inst
                         (p,(Zbinop(binop,(size,Zrm_i(rm,imm))),strm4))
                     end
                   | ((true,
                     (false,(false,(false,(false,(true,(false,v'0))))))),
                    strm2) =>
                     let
                       val size =
                         OpSize
                           (have_rex,
                            (#W(REX : REX),
                             (BitsN.fromBitstring([v'0],1),
                              op_size_override)))
                       val (reg,(rm,strm3)) = readModRM(REX,strm2)
                     in
                       Zfull_inst
                         (p,(Zbinop(Ztest,(size,Zrm_r(rm,reg))),strm3))
                     end
                   | ((true,
                     (false,(false,(false,(false,(true,(true,v'0))))))),
                    strm2) =>
                     let
                       val size =
                         OpSize
                           (have_rex,
                            (#W(REX : REX),
                             (BitsN.fromBitstring([v'0],1),
                              op_size_override)))
                       val (reg,(rm,strm3)) = readModRM(REX,strm2)
                     in
                       Zfull_inst(p,(Zxchg(size,(rm,reg)),strm3))
                     end
                   | ((true,
                     (false,(false,(false,(true,(false,(x'0,v'0))))))),
                    strm2) =>
                     let
                       val (reg,(rm,strm3)) = readModRM(REX,strm2)
                       val size =
                         OpSize
                           (have_rex,
                            (#W(REX : REX),
                             (BitsN.fromBitstring([v'0],1),
                              op_size_override)))
                       val src_dst =
                         if (BitsN.fromBitstring([x'0],1)) =
                            (BitsN.B(0x0,1))
                           then Zrm_r(rm,reg)
                         else Zr_rm(reg,rm)
                     in
                       Zfull_inst(p,(Zmov(Z_ALWAYS,(size,src_dst)),strm3))
                     end
                   | ((true,
                     (false,(false,(false,(true,(true,(false,true))))))),
                    strm2) =>
                     let
                       val size =
                         OpSize
                           (true,
                            (#W(REX : REX),
                             (BitsN.B(0x1,1),op_size_override)))
                       val (reg,(rm,strm3)) = readModRM(REX,strm2)
                     in
                       if isZm rm
                         then Zfull_inst
                                (p,(Zlea(size,Zr_rm(reg,rm)),strm3))
                       else Zdec_fail("LEA with register argument")
                     end
                   | ((true,
                     (false,(false,(false,(true,(true,(true,true))))))),
                    strm2) =>
                     let
                       val (opcode,(rm,strm3)) =
                         readOpcodeModRM(REX,strm2)
                     in
                       if opcode = (BitsN.B(0x0,3))
                         then Zfull_inst(p,(Zpop rm,strm3))
                       else Zdec_fail("Unsupported opcode: Group 1a")
                     end
                   | ((true,(false,(false,(true,(false,(r'2,(r'1,r'0))))))),
                    strm2) =>
                     let
                       val size =
                         OpSize
                           (true,
                            (#W(REX : REX),
                             (BitsN.B(0x1,1),op_size_override)))
                       val reg =
                         RexReg
                           (#B(REX : REX),
                            BitsN.fromBitstring([r'2,r'1,r'0],3))
                     in
                       if reg = RAX
                         then Zfull_inst(p,(Znop,Option.SOME strm2))
                       else Zfull_inst
                              (p,
                               (Zxchg(size,(Zr RAX,reg)),Option.SOME strm2))
                     end
                   | ((true,
                     (false,(true,(false,(true,(false,(false,v'0))))))),
                    strm2) =>
                     let
                       val size =
                         OpSize
                           (true,
                            (#W(REX : REX),
                             (BitsN.fromBitstring([v'0],1),
                              op_size_override)))
                       val (imm,strm3) = immediate(size,strm2)
                     in
                       Zfull_inst
                         (p,(Zbinop(Ztest,(size,Zrm_i(Zr RAX,imm))),strm3))
                     end
                   | ((true,(false,(true,(true,(v'0,(r'2,(r'1,r'0))))))),
                    strm2) =>
                     let
                       val size =
                         OpSize
                           (have_rex,
                            (#W(REX : REX),
                             (BitsN.fromBitstring([v'0],1),
                              op_size_override)))
                       val (imm,strm3) = full_immediate(size,strm2)
                       val reg =
                         (Cast.natToZreg o BitsN.toNat)
                           (BitsN.@@
                              (BitsN.fromBit(#B(REX : REX)),
                               BitsN.fromBitstring([r'2,r'1,r'0],3)))
                     in
                       Zfull_inst
                         (p,
                          (Zmov(Z_ALWAYS,(size,Zrm_i(Zr reg,imm))),strm3))
                     end
                   | ((true,
                     (true,(false,(false,(false,(false,(false,v'0))))))),
                    strm2) =>
                     let
                       val size =
                         OpSize
                           (have_rex,
                            (#W(REX : REX),
                             (BitsN.fromBitstring([v'0],1),
                              op_size_override)))
                       val (opcode,(rm,strm3)) =
                         readOpcodeModRM(REX,strm2)
                       val (imm,strm4) = oimmediate8 strm3
                       val binop =
                         Cast.natToZbinop_name
                           (Nat.+(BitsN.toNat opcode,8))
                     in
                       if opcode = (BitsN.B(0x6,3))
                         then Zdec_fail
                                ("Unsupported opcode: Shift Group 2")
                       else Zfull_inst
                              (p,
                               (Zbinop(binop,(size,Zrm_i(rm,imm))),strm4))
                     end
                   | ((true,
                     (true,(false,(false,(false,(false,(true,v'0))))))),
                    strm2) =>
                     (if (BitsN.fromBitstring([v'0],1)) = (BitsN.B(0x0,1))
                        then let
                               val (imm,strm3) = immediate16 strm2
                             in
                               Zfull_inst(p,(Zret imm,strm3))
                             end
                      else Zfull_inst
                             (p,(Zret(BitsN.B(0x0,64)),Option.SOME strm2)))
                   | ((true,
                     (true,(false,(false,(false,(true,(true,v'0))))))),
                    strm2) =>
                     let
                       val size =
                         OpSize
                           (have_rex,
                            (#W(REX : REX),
                             (BitsN.fromBitstring([v'0],1),
                              op_size_override)))
                       val (opcode,(rm,strm3)) =
                         readOpcodeModRM(REX,strm2)
                       val (imm,strm4) = oimmediate(size,strm3)
                     in
                       if opcode = (BitsN.B(0x0,3))
                         then Zfull_inst
                                (p,
                                 (Zmov(Z_ALWAYS,(size,Zrm_i(rm,imm))),
                                  strm4))
                       else Zdec_fail("Unsupported opcode: Group 11")
                     end
                   | ((true,
                     (true,(false,(false,(true,(false,(false,true))))))),
                    strm2) => Zfull_inst(p,(Zleave,Option.SOME strm2))
                   | ((true,
                     (true,(false,(true,(false,(false,(b'0,v'0))))))),
                    strm2) =>
                     let
                       val size =
                         OpSize
                           (have_rex,
                            (#W(REX : REX),
                             (BitsN.fromBitstring([v'0],1),
                              op_size_override)))
                       val (opcode,(rm,strm3)) =
                         readOpcodeModRM(REX,strm2)
                       val shift =
                         if (BitsN.fromBitstring([b'0],1)) =
                            (BitsN.B(0x0,1))
                           then Zrm_i(rm,BitsN.B(0x1,64))
                         else Zrm_r(rm,RCX)
                       val binop =
                         Cast.natToZbinop_name
                           (Nat.+(BitsN.toNat opcode,8))
                     in
                       if opcode = (BitsN.B(0x6,3))
                         then Zdec_fail
                                ("Unsupported opcode: Shift Group 2")
                       else Zfull_inst
                              (p,(Zbinop(binop,(size,shift)),strm3))
                     end
                   | ((true,
                     (true,(true,(false,(false,(false,(false,b'0))))))),
                    strm2) =>
                     let
                       val (imm,strm3) = immediate8 strm2
                       val cond =
                         if (BitsN.fromBitstring([b'0],1)) =
                            (BitsN.B(0x0,1))
                           then Z_NE
                         else Z_E
                     in
                       Zfull_inst(p,(Zloop(cond,imm),strm3))
                     end
                   | ((true,
                     (true,(true,(false,(false,(false,(true,false))))))),
                    strm2) =>
                     let
                       val (imm,strm3) = immediate8 strm2
                     in
                       Zfull_inst(p,(Zloop(Z_ALWAYS,imm),strm3))
                     end
                   | ((true,
                     (true,(true,(false,(true,(false,(false,false))))))),
                    strm2) =>
                     let
                       val (imm,strm3) = immediate32 strm2
                     in
                       Zfull_inst(p,(Zcall(Zimm imm),strm3))
                     end
                   | ((true,
                     (true,(true,(false,(true,(false,(b'0,true))))))),
                    strm2) =>
                     let
                       val (imm,strm3) =
                         if (BitsN.fromBitstring([b'0],1)) =
                            (BitsN.B(0x0,1))
                           then immediate32 strm2
                         else immediate8 strm2
                     in
                       Zfull_inst(p,(Zjcc(Z_ALWAYS,imm),strm3))
                     end
                   | ((true,
                     (true,(true,(true,(false,(true,(false,true))))))),
                    strm2) => Zfull_inst(p,(Zcmc,Option.SOME strm2))
                   | ((true,(true,(true,(true,(false,(true,(true,v'0))))))),
                    strm2) =>
                     let
                       val size =
                         OpSize
                           (have_rex,
                            (#W(REX : REX),
                             (BitsN.fromBitstring([v'0],1),
                              op_size_override)))
                       val (opcode,(rm,strm3)) =
                         readOpcodeModRM(REX,strm2)
                     in
                       case opcode of
                          BitsN.B(0x0,_) =>
                            let
                              val (imm,strm4) = oimmediate(size,strm3)
                            in
                              Zfull_inst
                                (p,
                                 (Zbinop(Ztest,(size,Zrm_i(rm,imm))),strm4))
                            end
                        | BitsN.B(0x2,_) =>
                          Zfull_inst(p,(Zmonop(Znot,(size,rm)),strm3))
                        | BitsN.B(0x3,_) =>
                          Zfull_inst(p,(Zmonop(Zneg,(size,rm)),strm3))
                        | BitsN.B(0x4,_) =>
                          Zfull_inst(p,(Zmul(size,rm),strm3))
                        | BitsN.B(0x6,_) =>
                          Zfull_inst(p,(Zdiv(size,rm),strm3))
                        | _ =>
                          Zdec_fail("Unsupported opcode: Unary Group 3")
                     end
                   | ((true,
                     (true,(true,(true,(true,(false,(false,false))))))),
                    strm2) => Zfull_inst(p,(Zclc,Option.SOME strm2))
                   | ((true,
                     (true,(true,(true,(true,(false,(false,true))))))),
                    strm2) => Zfull_inst(p,(Zstc,Option.SOME strm2))
                   | ((true,
                     (true,(true,(true,(true,(true,(true,false))))))),
                    strm2) =>
                     let
                       val (opcode,(rm,strm3)) =
                         readOpcodeModRM(REX,strm2)
                     in
                       if opcode = (BitsN.B(0x0,3))
                         then Zfull_inst
                                (p,(Zmonop(Zinc,(Z8 have_rex,rm)),strm3))
                       else if opcode = (BitsN.B(0x1,3))
                         then Zfull_inst
                                (p,(Zmonop(Zdec,(Z8 have_rex,rm)),strm3))
                       else Zdec_fail
                              ("Unsupported opcode: INC/DEC Group 4")
                     end
                   | ((true,(true,(true,(true,(true,(true,(true,true))))))),
                    strm2) =>
                     let
                       val size =
                         OpSize
                           (have_rex,
                            (#W(REX : REX),
                             (BitsN.B(0x1,1),op_size_override)))
                       val (opcode,(rm,strm3)) =
                         readOpcodeModRM(REX,strm2)
                     in
                       case opcode of
                          BitsN.B(0x0,_) =>
                            Zfull_inst(p,(Zmonop(Zinc,(size,rm)),strm3))
                        | BitsN.B(0x1,_) =>
                          Zfull_inst(p,(Zmonop(Zdec,(size,rm)),strm3))
                        | BitsN.B(0x2,_) =>
                          Zfull_inst(p,(Zcall(Zrm rm),strm3))
                        | BitsN.B(0x4,_) => Zfull_inst(p,(Zjmp rm,strm3))
                        | BitsN.B(0x6,_) =>
                          Zfull_inst(p,(Zpush(Zrm rm),strm3))
                        | _ =>
                          Zdec_fail("Unsupported opcode: INC/DEC Group 5")
                     end
                   | ((false,
                     (false,(false,(false,(true,(true,(true,true))))))),
                    (BitsN.B(0x38,_)) :: (opc :: _)) =>
                     Zdec_fail
                       (("Unsupported opcode: 0F 38 ")
                          ^
                          (BitsN.toHexString opc))
                   | ((false,
                     (false,(false,(false,(true,(true,(true,true))))))),
                    (BitsN.B(0x3A,_)) :: (opc :: _)) =>
                     Zdec_fail
                       (("Unsupported opcode: 0F 3A ")
                          ^
                          (BitsN.toHexString opc))
                   | ((false,
                     (false,(false,(false,(true,(true,(true,true))))))),
                    opc :: strm2) =>
                     (case boolify'8 opc of
                         (false,
                          (true,(false,(false,(c'3,(c'2,(c'1,c'0))))))) =>
                           let
                             val size =
                               OpSize
                                 (true,
                                  (#W(REX : REX),
                                   (BitsN.B(0x1,1),op_size_override)))
                             val (reg,(rm,strm3)) = readModRM(REX,strm2)
                           in
                             Zfull_inst
                               (p,
                                (Zmov
                                   ((Cast.natToZcond o BitsN.toNat)
                                      (BitsN.fromBitstring
                                         ([c'3,c'2,c'1,c'0],4)),
                                    (size,Zr_rm(reg,rm))),strm3))
                           end
                       | (true,
                        (false,(false,(false,(c'3,(c'2,(c'1,c'0))))))) =>
                         let
                           val (imm,strm3) = immediate32 strm2
                         in
                           Zfull_inst
                             (p,
                              (Zjcc
                                 ((Cast.natToZcond o BitsN.toNat)
                                    (BitsN.fromBitstring
                                       ([c'3,c'2,c'1,c'0],4)),imm),strm3))
                         end
                       | (true,
                        (false,(false,(true,(c'3,(c'2,(c'1,c'0))))))) =>
                         let
                           val (_,(rm,strm3)) = readModRM(REX,strm2)
                         in
                           Zfull_inst
                             (p,
                              (Zset
                                 ((Cast.natToZcond o BitsN.toNat)
                                    (BitsN.fromBitstring
                                       ([c'3,c'2,c'1,c'0],4)),
                                  (have_rex,rm)),strm3))
                         end
                       | (true,
                        (false,(true,(true,(false,(false,(false,v'0))))))) =>
                         let
                           val size =
                             OpSize
                               (have_rex,
                                (#W(REX : REX),
                                 (BitsN.fromBitstring([v'0],1),
                                  op_size_override)))
                           val (reg,(rm,strm3)) = readModRM(REX,strm2)
                         in
                           Zfull_inst(p,(Zcmpxchg(size,(rm,reg)),strm3))
                         end
                       | (true,
                        (true,(false,(false,(false,(false,(false,v'0))))))) =>
                         let
                           val size =
                             OpSize
                               (have_rex,
                                (#W(REX : REX),
                                 (BitsN.fromBitstring([v'0],1),
                                  op_size_override)))
                           val (reg,(rm,strm3)) = readModRM(REX,strm2)
                         in
                           Zfull_inst(p,(Zxadd(size,(rm,reg)),strm3))
                         end
                       | (true,
                        (false,(true,(true,(s'0,(true,(true,v'0))))))) =>
                         let
                           val size2 =
                             OpSize
                               (have_rex,
                                (#W(REX : REX),
                                 (BitsN.B(0x1,1),op_size_override)))
                           val size =
                             if (BitsN.fromBitstring([v'0],1)) =
                                (BitsN.B(0x1,1))
                               then Z16
                             else Z8 have_rex
                           val (reg,(rm,strm3)) = readModRM(REX,strm2)
                           val arg = (size,(Zr_rm(reg,rm),size2))
                           val instr =
                             if (BitsN.fromBitstring([s'0],1)) =
                                (BitsN.B(0x1,1))
                               then Zmovsx arg
                             else Zmovzx arg
                         in
                           Zfull_inst(p,(instr,strm3))
                         end
                       | _ =>
                         Zdec_fail
                           (("Unsupported opcode: 0F ")
                              ^
                              (BitsN.toHexString opc)))
                   | ((opc'7,
                     (opc'6,(opc'5,(opc'4,(opc'3,(opc'2,(opc'1,opc'0))))))),
                    _) =>
                     Zdec_fail
                       (("Unsupported opcode: ")
                          ^
                          (BitsN.toHexString
                             (BitsN.fromBitstring
                                ([opc'7,opc'6,opc'5,opc'4,opc'3,opc'2,
                                  opc'1,opc'0],8)))))
             | [] => Zdec_fail("No opcode")
     end;

fun x64_fetch () =
  let
    val strm = ref []
  in
    ( L3.for
        (19,0,
         fn i =>
           strm :=
           ((Map.lookup
               ((!MEM),BitsN.toNat(BitsN.+((!RIP),BitsN.fromNat(i,64)))))
              ::
              (!strm)))
    ; (!strm)
    )
  end;

fun x64_next () =
  case x64_decode(x64_fetch ()) of
     Zfull_inst(_,(i,Option.SOME strm1)) =>
       let
         val len = Nat.-(20,L3.length strm1)
       in
         ( RIP := (BitsN.+((!RIP),BitsN.fromNat(len,64))); Run i )
       end
   | Zfull_inst(_,(_,NONE)) => raise FAILURE ("not enough bytes")
   | Zdec_fail s => raise FAILURE s;

fun e_imm8 imm =
  if (BitsN.<=(BitsN.B(0xFFFFFFFFFFFFFF80,64),imm)) andalso
     (BitsN.<=(imm,BitsN.B(0x7F,64)))
    then [BitsN.bits(7,0) imm]
  else [];

fun e_imm16 imm =
  if (BitsN.<=(BitsN.B(0xFFFFFFFFFFFF8000,64),imm)) andalso
     (BitsN.<=(imm,BitsN.B(0x7FFF,64)))
    then [BitsN.bits(7,0) imm,BitsN.bits(15,8) imm]
  else [];

fun e_imm32 imm =
  if (BitsN.<=(BitsN.B(0xFFFFFFFF80000000,64),imm)) andalso
     (BitsN.<=(imm,BitsN.B(0x7FFFFFFF,64)))
    then [BitsN.bits(7,0) imm,BitsN.bits(15,8) imm,BitsN.bits(23,16) imm,
          BitsN.bits(31,24) imm]
  else [];

fun e_imm64 imm =
  [BitsN.bits(7,0) imm,BitsN.bits(15,8) imm,BitsN.bits(23,16) imm,
   BitsN.bits(31,24) imm,BitsN.bits(39,32) imm,BitsN.bits(47,40) imm,
   BitsN.bits(55,48) imm,BitsN.bits(63,56) imm];

fun e_imm imm =
  case e_imm8 imm of
     [] =>
       (case e_imm16 imm of
           [] => (case e_imm32 imm of [] => e_imm64 imm | l => l)
         | l => l)
   | l => l;

fun e_imm_8_32 imm =
  case e_imm8 imm of
     [] => (case e_imm32 imm of [] => (8,[]) | l => (4,l))
   | l => (1,l);

fun e_ModRM (r,rm) =
  case rm of
     Zm(NONE,(ZripBase,displacement)) =>
       Option.SOME
         (BitsN.concat[BitsN.B(0x0,1),BitsN.bits(3,3) r,BitsN.B(0x0,2)],
          (BitsN.concat[BitsN.B(0x0,2),BitsN.bits(2,0) r,BitsN.B(0x5,3)])
            ::
            (e_imm32 displacement))
   | Zr rm =>
     let
       val rm = BitsN.fromNat(Cast.ZregToNat rm,4)
     in
       Option.SOME
         (BitsN.concat
            [BitsN.B(0x0,1),BitsN.bits(3,3) r,BitsN.B(0x0,1),
             BitsN.bits(3,3) rm],
          [BitsN.concat
             [BitsN.B(0x3,2),BitsN.bits(2,0) r,BitsN.bits(2,0) rm]])
     end
   | Zm(NONE,(ZnoBase,imm)) =>
     (case e_imm32 imm of
         [] => NONE
       | l =>
         Option.SOME
           (BitsN.concat[BitsN.B(0x0,1),BitsN.bits(3,3) r,BitsN.B(0x0,2)],
            [BitsN.concat[BitsN.B(0x0,2),BitsN.bits(2,0) r,BitsN.B(0x4,3)],
             BitsN.B(0x25,8)]
              @
              l))
   | Zm(Option.SOME(ss,index),(ZnoBase,imm)) =>
     let
       val i = BitsN.fromNat(Cast.ZregToNat index,4)
     in
       case e_imm32 imm of
          [] => NONE
        | l =>
          Option.SOME
            (BitsN.concat
               [BitsN.B(0x0,1),BitsN.bits(3,3) r,BitsN.bits(3,3) i,
                BitsN.B(0x0,1)],
             [BitsN.concat
                [BitsN.B(0x0,2),BitsN.bits(2,0) r,BitsN.B(0x4,3)],
              BitsN.concat[ss,BitsN.bits(2,0) i,BitsN.B(0x5,3)]]
               @
               l)
     end
   | Zm(Option.SOME(ss,index),(ZregBase base,imm)) =>
     let
       val b = BitsN.fromNat(Cast.ZregToNat base,4)
       val i = BitsN.fromNat(Cast.ZregToNat index,4)
       val b20 = BitsN.bits(2,0) b
       val (s,l) =
         if (imm = (BitsN.B(0x0,64))) andalso
            (not(b20 = (BitsN.B(0x5,3))))
           then (0,[])
         else e_imm_8_32 imm
     in
       if Set.mem(s,[0,1,4])
         then Option.SOME
                (BitsN.concat
                   [BitsN.B(0x0,1),BitsN.bits(3,3) r,BitsN.bits(3,3) i,
                    BitsN.bits(3,3) b],
                 [BitsN.concat
                    [case s of
                        0 => BitsN.B(0x0,2)
                      | 1 => BitsN.B(0x1,2)
                      | _ => BitsN.B(0x2,2),BitsN.bits(2,0) r,
                     BitsN.B(0x4,3)],
                  BitsN.concat[ss,BitsN.bits(2,0) i,b20]]
                   @
                   l)
       else NONE
     end
   | Zm(NONE,(ZregBase base,imm)) =>
     let
       val base = BitsN.fromNat(Cast.ZregToNat base,4)
       val base20 = BitsN.bits(2,0) base
       val (s,l) =
         if (imm = (BitsN.B(0x0,64))) andalso
            (not(base20 = (BitsN.B(0x5,3))))
           then (0,[])
         else e_imm_8_32 imm
     in
       if Set.mem(s,[0,1,4])
         then Option.SOME
                (BitsN.concat
                   [BitsN.B(0x0,1),BitsN.bits(3,3) r,BitsN.B(0x0,1),
                    BitsN.bits(3,3) base],
                 ((BitsN.concat
                     [case s of
                         0 => BitsN.B(0x0,2)
                       | 1 => BitsN.B(0x1,2)
                       | _ => BitsN.B(0x2,2),BitsN.bits(2,0) r,base20])
                    ::
                    (if base20 = (BitsN.B(0x4,3))
                       then [BitsN.@@(BitsN.B(0x4,5),base20)]
                     else []))
                   @
                   l)
       else NONE
     end
   | _ => NONE;

fun rex_prefix rex =
  if rex = (BitsN.B(0x0,4)) then [] else [BitsN.@@(BitsN.B(0x4,4),rex)];

fun e_opsize (sz,rex) =
  case sz of
     Z8 have_rex =>
       let
         val p = rex_prefix rex
       in
         (if have_rex andalso (p = []) then [BitsN.B(0x40,8)] else p,
          BitsN.B(0x0,8))
       end
   | Z16 =>
     ([BitsN.B(0x66,8)] @ (rex_prefix(BitsN.&&(rex,BitsN.B(0x7,4)))),
      BitsN.B(0x1,8))
   | Z32 => (rex_prefix(BitsN.&&(rex,BitsN.B(0x7,4))),BitsN.B(0x1,8))
   | Z64 => (rex_prefix(BitsN.||(rex,BitsN.B(0x8,4))),BitsN.B(0x1,8));

fun e_opsize_imm (sz,(rex,(imm,normal))) =
  let
    val (prefixes,v) = e_opsize(sz,rex)
  in
    case if (sz = Z64) andalso normal then Z32 else sz of
       Z8 _ =>
         (case e_imm8 imm of
             [] => NONE
           | l =>
             (if v = (BitsN.B(0x0,8))
                then Option.SOME(prefixes,(v,l))
              else NONE))
     | Z16 =>
       (case e_imm16 imm of
           [] => NONE
         | l =>
           (if v = (BitsN.B(0x1,8))
              then Option.SOME(prefixes,(v,l))
            else NONE))
     | Z32 =>
       (case e_imm32 imm of
           [] => NONE
         | l =>
           (if v = (BitsN.B(0x1,8))
              then Option.SOME(prefixes,(v,l))
            else NONE))
     | Z64 =>
       if v = (BitsN.B(0x1,8))
         then Option.SOME(prefixes,(v,e_imm64 imm))
       else NONE
  end;

fun e_opc (opc1,(opc2,rm)) =
  case e_ModRM(BitsN.fromNat(BitsN.toNat opc2,4),rm) of
     NONE => []
   | Option.SOME(rex,strm) => (rex_prefix rex) @ (opc1 :: strm);

fun e_gen_rm_reg (sz,(rm,(r,(p,(opc,mo))))) =
  case e_ModRM(r,rm) of
     NONE => []
   | Option.SOME(rex,strm) =>
     let
       val (prefixes,v) = e_opsize(sz,rex)
       val m = case mo of Option.SOME x => x | NONE => v
     in
       List.concat[prefixes,p,[BitsN.||(opc,m)],strm]
     end;

fun e_rm_reg (sz,(rm,(r,(p,opc)))) =
  e_gen_rm_reg(sz,(rm,(r,(p,(opc,NONE)))));

fun e_rm_imm (sz,(rm,(imm,(opc1,opc2)))) =
  case e_ModRM(opc1,rm) of
     NONE => []
   | Option.SOME(rex,strm) =>
     (case e_opsize_imm(sz,(rex,(imm,true))) of
         Option.SOME(prefixes,(v,l)) =>
           List.concat[prefixes,[BitsN.||(opc2,v)],strm,l]
       | NONE => []);

fun e_rm_imm8 (sz,(rm,(imm,(opc1,opc2)))) =
  case e_ModRM(opc1,rm) of
     NONE => []
   | Option.SOME(rex,strm) =>
     let
       val (prefixes,v) = e_opsize(sz,rex)
     in
       case e_imm8 imm of
          [] => []
        | l => List.concat[prefixes,[BitsN.||(opc2,v)],strm,l]
     end;

fun e_rax_imm (sz,(imm,opc)) =
  case e_opsize_imm(sz,(BitsN.B(0x0,4),(imm,true))) of
     Option.SOME(prefixes,(v,l)) =>
       List.concat[prefixes,[BitsN.||(opc,v)],l]
   | NONE => [];

fun e_jcc_rel32 i =
  case i of
     Zjcc(cond,imm) =>
       (case (e_imm32 imm,cond) of
           ([],_) => []
         | (l,Z_ALWAYS) => (BitsN.B(0xE9,8)) :: l
         | (l,_) =>
           [BitsN.B(0xF,8),
            BitsN.@@(BitsN.B(0x8,4),BitsN.fromNat(Cast.ZcondToNat cond,4))]
             @
             l)
   | _ => [];

fun not_byte sz = case sz of Z8 _ => false | _ => true;

fun is_rax rm = case rm of Zr RAX => true | _ => false;

fun encode i =
  case i of
     Zbinop(bop,(sz,Zrm_i(rm,imm))) =>
       (if bop = Ztest
          then if is_rax rm
                 then e_rax_imm(sz,(imm,BitsN.B(0xA8,8)))
               else e_rm_imm
                      (sz,(rm,(imm,(BitsN.B(0x0,4),BitsN.B(0xF6,8)))))
        else let
               val opc = BitsN.fromNat(Cast.Zbinop_nameToNat bop,4)
             in
               if BitsN.bit(opc,3)
                 then if imm = (BitsN.B(0x1,64))
                        then e_rm_reg
                               (sz,
                                (rm,
                                 (BitsN.&&(opc,BitsN.B(0x7,4)),
                                  ([],BitsN.B(0xD0,8)))))
                      else e_rm_imm8
                             (sz,
                              (rm,
                               (imm,
                                (BitsN.&&(opc,BitsN.B(0x7,4)),
                                 BitsN.B(0xC0,8)))))
               else if (not_byte sz) andalso (not((e_imm8 imm) = []))
                 then e_rm_imm8(sz,(rm,(imm,(opc,BitsN.B(0x83,8)))))
               else if is_rax rm
                 then e_rax_imm
                        (sz,
                         (imm,
                          BitsN.concat
                            [BitsN.B(0x0,2),BitsN.bits(2,0) opc,
                             BitsN.B(0x4,3)]))
               else e_rm_imm(sz,(rm,(imm,(opc,BitsN.B(0x80,8)))))
             end)
   | Zbinop(bop,(sz,Zrm_r(rm,r))) =>
     (if bop = Ztest
        then e_rm_reg
               (sz,
                (rm,
                 (BitsN.fromNat(Cast.ZregToNat r,4),([],BitsN.B(0x84,8)))))
      else let
             val opc = BitsN.fromNat(Cast.Zbinop_nameToNat bop,4)
           in
             if BitsN.bit(opc,3)
               then if r = RCX
                      then e_rm_reg
                             (sz,
                              (rm,
                               (BitsN.&&(opc,BitsN.B(0x7,4)),
                                ([],BitsN.B(0xD2,8)))))
                    else []
             else e_rm_reg
                    (sz,
                     (rm,
                      (BitsN.fromNat(Cast.ZregToNat r,4),
                       ([],
                        BitsN.concat
                          [BitsN.B(0x0,2),BitsN.bits(2,0) opc,
                           BitsN.B(0x0,3)]))))
           end)
   | Zbinop(bop,(sz,Zr_rm(r,rm))) =>
     let
       val opc = BitsN.fromNat(Cast.Zbinop_nameToNat bop,4)
     in
       if BitsN.bit(opc,3)
         then []
       else e_rm_reg
              (sz,
               (rm,
                (BitsN.fromNat(Cast.ZregToNat r,4),
                 ([],
                  BitsN.concat
                    [BitsN.B(0x0,2),BitsN.bits(2,0) opc,BitsN.B(0x2,3)]))))
     end
   | Zcall(Zrm rm) => e_opc(BitsN.B(0xFF,8),(BitsN.B(0x2,3),rm))
   | Zcall(Zimm imm) =>
     (case e_imm32 imm of [] => [] | l => (BitsN.B(0xE8,8)) :: l)
   | Zcmc => [BitsN.B(0xF5,8)]
   | Zclc => [BitsN.B(0xF8,8)]
   | Zstc => [BitsN.B(0xF9,8)]
   | Zcmpxchg(sz,(rm,r)) =>
     e_rm_reg
       (sz,
        (rm,
         (BitsN.fromNat(Cast.ZregToNat r,4),
          ([BitsN.B(0xF,8)],BitsN.B(0xB0,8)))))
   | Zdiv(sz,rm) =>
     e_rm_reg(sz,(rm,(BitsN.B(0x6,4),([],BitsN.B(0xF6,8)))))
   | Zjcc(cond,imm) =>
     let
       val (s,l) = e_imm_8_32 imm
     in
       if cond = Z_ALWAYS
         then if s = 1
                then (BitsN.B(0xEB,8)) :: l
              else if s = 4 then (BitsN.B(0xE9,8)) :: l else []
       else if s = 1
         then (BitsN.@@
                 (BitsN.B(0x7,4),BitsN.fromNat(Cast.ZcondToNat cond,4)))
                ::
                l
       else if s = 4
         then [BitsN.B(0xF,8),
               BitsN.@@
                 (BitsN.B(0x8,4),BitsN.fromNat(Cast.ZcondToNat cond,4))]
                @
                l
       else []
     end
   | Zjmp rm => e_opc(BitsN.B(0xFF,8),(BitsN.B(0x4,3),rm))
   | Zlea(Z8 _,_) => []
   | Zlea(sz,Zr_rm(r,Zm m)) =>
     e_rm_reg
       (sz,(Zm m,(BitsN.fromNat(Cast.ZregToNat r,4),([],BitsN.B(0x8D,8)))))
   | Zlea _ => []
   | Zleave => [BitsN.B(0xC9,8)]
   | Zloop(cond,imm) =>
     (case (cond,e_imm8 imm) of
         (_,[]) => []
       | (Z_NE,l) => (BitsN.B(0xE0,8)) :: l
       | (Z_E,l) => (BitsN.B(0xE1,8)) :: l
       | (Z_ALWAYS,l) => (BitsN.B(0xE2,8)) :: l
       | _ => [])
   | Zmonop(Zinc,(Z8 _,rm)) => e_opc(BitsN.B(0xFE,8),(BitsN.B(0x0,3),rm))
   | Zmonop(Zdec,(Z8 _,rm)) => e_opc(BitsN.B(0xFE,8),(BitsN.B(0x1,3),rm))
   | Zmonop(Zinc,(sz,rm)) =>
     e_rm_reg(sz,(rm,(BitsN.B(0x0,4),([],BitsN.B(0xFF,8)))))
   | Zmonop(Zdec,(sz,rm)) =>
     e_rm_reg(sz,(rm,(BitsN.B(0x1,4),([],BitsN.B(0xFF,8)))))
   | Zmonop(Znot,(sz,rm)) =>
     e_rm_reg(sz,(rm,(BitsN.B(0x2,4),([],BitsN.B(0xF6,8)))))
   | Zmonop(Zneg,(sz,rm)) =>
     e_rm_reg(sz,(rm,(BitsN.B(0x3,4),([],BitsN.B(0xF6,8)))))
   | Zmov(Z_ALWAYS,(sz,Zrm_r(rm,r))) =>
     e_rm_reg
       (sz,(rm,(BitsN.fromNat(Cast.ZregToNat r,4),([],BitsN.B(0x88,8)))))
   | Zmov(Z_ALWAYS,(sz,Zr_rm(r,rm))) =>
     e_rm_reg
       (sz,(rm,(BitsN.fromNat(Cast.ZregToNat r,4),([],BitsN.B(0x8A,8)))))
   | Zmov(Z_ALWAYS,(sz,Zrm_i(Zr reg,imm))) =>
     let
       val r = BitsN.fromNat(Cast.ZregToNat reg,4)
       val rex = if BitsN.bit(r,3) then BitsN.B(0x1,4) else BitsN.B(0x0,4)
     in
       case e_opsize_imm(sz,(rex,(imm,false))) of
          Option.SOME(prefixes,(v,l)) =>
            List.concat
              [prefixes,
               [BitsN.concat
                  [BitsN.B(0xB,4),BitsN.fromNat(BitsN.toNat v,1),
                   BitsN.bits(2,0) r]],l]
        | NONE => []
     end
   | Zmov(Z_ALWAYS,(sz,Zrm_i(rm,imm))) =>
     e_rm_imm(sz,(rm,(imm,(BitsN.B(0x0,4),BitsN.B(0xC6,8)))))
   | Zmov(cond,(Z8 _,_)) => []
   | Zmov(cond,(sz,Zr_rm(r,rm))) =>
     e_gen_rm_reg
       (sz,
        (rm,
         (BitsN.fromNat(Cast.ZregToNat r,4),
          ([BitsN.B(0xF,8)],
           (BitsN.B(0x40,8),
            Option.SOME(BitsN.fromNat(Cast.ZcondToNat cond,8)))))))
   | Zmov _ => []
   | Zmovsx(Z32,(Zr_rm(r,rm),Z64)) =>
     e_rm_reg
       (Z64,(rm,(BitsN.fromNat(Cast.ZregToNat r,4),([],BitsN.B(0x63,8)))))
   | Zmovsx(sz1,(Zr_rm(r,rm),sz2)) =>
     (if Nat.<(Zsize_width sz1,Zsize_width sz2)
        then let
               val v =
                 if sz1 = Z16 then BitsN.B(0x1,8) else BitsN.B(0x0,8)
             in
               e_gen_rm_reg
                 (sz2,
                  (rm,
                   (BitsN.fromNat(Cast.ZregToNat r,4),
                    ([BitsN.B(0xF,8)],(BitsN.B(0xBE,8),Option.SOME v)))))
             end
      else [])
   | Zmovsx _ => []
   | Zmovzx(sz1,(Zr_rm(r,rm),sz2)) =>
     (if (Nat.<(Zsize_width sz1,Zsize_width sz2)) andalso (not(sz1 = Z32))
        then let
               val v =
                 if sz1 = Z16 then BitsN.B(0x1,8) else BitsN.B(0x0,8)
             in
               e_gen_rm_reg
                 (sz2,
                  (rm,
                   (BitsN.fromNat(Cast.ZregToNat r,4),
                    ([BitsN.B(0xF,8)],(BitsN.B(0xB6,8),Option.SOME v)))))
             end
      else [])
   | Zmovzx _ => []
   | Zmul(sz,rm) =>
     e_rm_reg(sz,(rm,(BitsN.B(0x4,4),([],BitsN.B(0xF6,8)))))
   | Znop => [BitsN.B(0x90,8)]
   | Zpop(Zr reg) =>
     let
       val r = BitsN.fromNat(Cast.ZregToNat reg,4)
     in
       (if BitsN.bit(r,3) then [BitsN.B(0x49,8)] else [])
         @
         [BitsN.@@(BitsN.B(0xB,5),BitsN.bits(2,0) r)]
     end
   | Zpop rm => e_opc(BitsN.B(0x8F,8),(BitsN.B(0x0,3),rm))
   | Zpush(Zrm(Zr reg)) =>
     let
       val r = BitsN.fromNat(Cast.ZregToNat reg,4)
     in
       (if BitsN.bit(r,3) then [BitsN.B(0x49,8)] else [])
         @
         [BitsN.@@(BitsN.B(0xA,5),BitsN.bits(2,0) r)]
     end
   | Zpush(Zrm rm) => e_opc(BitsN.B(0xFF,8),(BitsN.B(0x6,3),rm))
   | Zpush(Zimm imm) =>
     let
       val (s,l) = e_imm_8_32 imm
     in
       if s = 1
         then (BitsN.B(0x6A,8)) :: l
       else if s = 4 then (BitsN.B(0x68,8)) :: l else []
     end
   | Zret(BitsN.B(0x0,64)) => [BitsN.B(0xC3,8)]
   | Zret imm =>
     (case e_imm16 imm of [] => [] | l => (BitsN.B(0xC2,8)) :: l)
   | Zset(Z_ALWAYS,(have_rex,rm)) => []
   | Zset(cond,(have_rex,rm)) =>
     e_rm_reg
       (Z8 have_rex,
        (rm,
         (BitsN.B(0x0,4),
          ([BitsN.B(0xF,8)],
           BitsN.@@(BitsN.B(0x9,4),BitsN.fromNat(Cast.ZcondToNat cond,4))))))
   | Zxadd(sz,(rm,r)) =>
     e_rm_reg
       (sz,
        (rm,
         (BitsN.fromNat(Cast.ZregToNat r,4),
          ([BitsN.B(0xF,8)],BitsN.B(0xC0,8)))))
   | Zxchg(sz,(rm,reg)) =>
     (if (not_byte sz) andalso ((reg = RAX) orelse (is_rax rm))
        then let
               val r = BitsN.fromNat(Cast.ZregToNat reg,4)
               val rex =
                 if BitsN.bit(r,3) then BitsN.B(0x1,4) else BitsN.B(0x0,4)
               val (prefixes,v) = e_opsize(sz,rex)
             in
               if v = (BitsN.B(0x1,8))
                 then prefixes
                        @
                        [BitsN.@@(BitsN.B(0x12,5),BitsN.bits(2,0) r)]
               else []
             end
      else e_rm_reg
             (sz,
              (rm,
               (BitsN.fromNat(Cast.ZregToNat reg,4),([],BitsN.B(0x86,8))))));

fun stripLeftSpaces s = L3.snd(L3.splitl(fn c => Char.isSpace c,s));

fun stripSpaces s =
  L3.fst(L3.splitr(fn c => Char.isSpace c,stripLeftSpaces s));

fun p_number s =
  case String.explode(stripSpaces s) of
     #"0" :: (#"b" :: t) => Nat.fromBinString(String.implode t)
   | #"0" :: (#"x" :: t) => Nat.fromHexString(String.implode t)
   | _ => Nat.fromString s;

fun p_bin_or_hex_number s =
  case String.explode(stripSpaces s) of
     #"0" :: (#"b" :: t) => Nat.fromBinString(String.implode t)
   | #"0" :: (#"x" :: t) => Nat.fromHexString(String.implode t)
   | t => Nat.fromHexString(String.implode t);

fun p_signed_number s =
  case String.explode(stripSpaces s) of
     #"-" :: t =>
       (case p_number(String.implode t) of
           Option.SOME n => Option.SOME(IntInf.~(Nat.toInt n))
         | NONE => NONE)
   | #"+" :: t =>
     (case p_number(String.implode t) of
         Option.SOME n => Option.SOME(Nat.toInt n)
       | NONE => NONE)
   | t =>
     (case p_number(String.implode t) of
         Option.SOME n => Option.SOME(Nat.toInt n)
       | NONE => NONE);

fun p_imm8 s =
  case p_signed_number s of
     Option.SOME n =>
       (if (IntInf.<=(IntInf.~ 128,n)) andalso (IntInf.<=(n,255))
          then Option.SOME(BitsN.signExtend 64 (BitsN.fromInt(n,8)))
        else NONE)
   | NONE => NONE;

fun p_imm16 s =
  case p_signed_number s of
     Option.SOME n =>
       (if (IntInf.<=(IntInf.~ 32768,n)) andalso (IntInf.<=(n,65535))
          then Option.SOME(BitsN.signExtend 64 (BitsN.fromInt(n,16)))
        else NONE)
   | NONE => NONE;

fun p_imm32 s =
  case p_signed_number s of
     Option.SOME n =>
       (if (IntInf.<=(IntInf.~ 2147483648,n)) andalso
           (IntInf.<=(n,4294967295))
          then Option.SOME(BitsN.signExtend 64 (BitsN.fromInt(n,32)))
        else NONE)
   | NONE => NONE;

fun p_imm64 s =
  case p_signed_number s of
     Option.SOME n =>
       (if (IntInf.<=(IntInf.~ 9223372036854775808,n)) andalso
           (IntInf.<=(n,18446744073709551615))
          then Option.SOME(BitsN.fromInt(n,64))
        else NONE)
   | NONE => NONE;

fun p_imm_of_size (sz,s) =
  case sz of
     Z8 _ => p_imm8 s
   | Z16 => p_imm16 s
   | Z32 => p_imm32 s
   | Z64 => p_imm64 s;

fun readBytes (acc,l) =
  case l of
     [] => Option.SOME(List.rev acc)
   | h :: t =>
     (case p_bin_or_hex_number h of
         Option.SOME n =>
           (if Nat.<=(n,255)
              then readBytes((BitsN.fromNat(n,8)) :: acc,t)
            else NONE)
       | NONE => NONE);

fun p_bytes s =
  readBytes([],L3.uncurry String.tokens (fn c => Char.isSpace c,s));

fun p_label s =
  case L3.uncurry String.tokens (fn c => Char.isSpace c,s) of
     [t] =>
       let
         val (l,r) =
           L3.splitl
             (fn c => (Char.isAlphaNum c) orelse (Set.mem(c,[#"_",#"."])),
              t)
       in
         if (r = ("")) andalso
            ((not(l = (""))) andalso (not(Char.isDigit(L3.strHd l))))
           then Option.SOME l
         else NONE
       end
   | _ => NONE;

fun p_register s =
  case stripSpaces s of
     "al" => Option.SOME(Z8 false,RAX)
   | "cl" => Option.SOME(Z8 false,RCX)
   | "dl" => Option.SOME(Z8 false,RDX)
   | "bl" => Option.SOME(Z8 false,RBX)
   | "ah" => Option.SOME(Z8 false,RSP)
   | "ch" => Option.SOME(Z8 false,RBP)
   | "dh" => Option.SOME(Z8 false,RSI)
   | "bh" => Option.SOME(Z8 false,RDI)
   | "spl" => Option.SOME(Z8 true,RSP)
   | "bpl" => Option.SOME(Z8 true,RBP)
   | "sil" => Option.SOME(Z8 true,RSI)
   | "dil" => Option.SOME(Z8 true,RDI)
   | "r8b" => Option.SOME(Z8 false,zR8)
   | "r9b" => Option.SOME(Z8 false,zR9)
   | "r10b" => Option.SOME(Z8 false,zR10)
   | "r11b" => Option.SOME(Z8 false,zR11)
   | "r12b" => Option.SOME(Z8 false,zR12)
   | "r13b" => Option.SOME(Z8 false,zR13)
   | "r14b" => Option.SOME(Z8 false,zR14)
   | "r15b" => Option.SOME(Z8 false,zR15)
   | "ax" => Option.SOME(Z16,RAX)
   | "cx" => Option.SOME(Z16,RCX)
   | "dx" => Option.SOME(Z16,RDX)
   | "bx" => Option.SOME(Z16,RBX)
   | "sp" => Option.SOME(Z16,RSP)
   | "bp" => Option.SOME(Z16,RBP)
   | "si" => Option.SOME(Z16,RSI)
   | "di" => Option.SOME(Z16,RDI)
   | "r8w" => Option.SOME(Z16,zR8)
   | "r9w" => Option.SOME(Z16,zR9)
   | "r10w" => Option.SOME(Z16,zR10)
   | "r11w" => Option.SOME(Z16,zR11)
   | "r12w" => Option.SOME(Z16,zR12)
   | "r13w" => Option.SOME(Z16,zR13)
   | "r14w" => Option.SOME(Z16,zR14)
   | "r15w" => Option.SOME(Z16,zR15)
   | "eax" => Option.SOME(Z32,RAX)
   | "ecx" => Option.SOME(Z32,RCX)
   | "edx" => Option.SOME(Z32,RDX)
   | "ebx" => Option.SOME(Z32,RBX)
   | "esp" => Option.SOME(Z32,RSP)
   | "ebp" => Option.SOME(Z32,RBP)
   | "esi" => Option.SOME(Z32,RSI)
   | "edi" => Option.SOME(Z32,RDI)
   | "r8d" => Option.SOME(Z32,zR8)
   | "r9d" => Option.SOME(Z32,zR9)
   | "r10d" => Option.SOME(Z32,zR10)
   | "r11d" => Option.SOME(Z32,zR11)
   | "r12d" => Option.SOME(Z32,zR12)
   | "r13d" => Option.SOME(Z32,zR13)
   | "r14d" => Option.SOME(Z32,zR14)
   | "r15d" => Option.SOME(Z32,zR15)
   | "rax" => Option.SOME(Z64,RAX)
   | "rcx" => Option.SOME(Z64,RCX)
   | "rdx" => Option.SOME(Z64,RDX)
   | "rbx" => Option.SOME(Z64,RBX)
   | "rsp" => Option.SOME(Z64,RSP)
   | "rbp" => Option.SOME(Z64,RBP)
   | "rsi" => Option.SOME(Z64,RSI)
   | "rdi" => Option.SOME(Z64,RDI)
   | "r8" => Option.SOME(Z64,zR8)
   | "r9" => Option.SOME(Z64,zR9)
   | "r10" => Option.SOME(Z64,zR10)
   | "r11" => Option.SOME(Z64,zR11)
   | "r12" => Option.SOME(Z64,zR12)
   | "r13" => Option.SOME(Z64,zR13)
   | "r14" => Option.SOME(Z64,zR14)
   | "r15" => Option.SOME(Z64,zR15)
   | _ => NONE;

fun p_scale s =
  case stripSpaces s of
     "1" => Option.SOME(BitsN.B(0x0,2))
   | "2" => Option.SOME(BitsN.B(0x1,2))
   | "4" => Option.SOME(BitsN.B(0x2,2))
   | "8" => Option.SOME(BitsN.B(0x3,2))
   | _ => NONE;

fun p_scale_index s =
  case L3.uncurry String.fields (fn c => c = #"*",stripSpaces s) of
     [v1,v2] =>
       (case p_register v1 of
           Option.SOME(sz,r) =>
             (case p_scale v2 of
                 Option.SOME n =>
                   (if sz = Z64 then Option.SOME(n,r) else NONE)
               | NONE => NONE)
         | NONE =>
           (case p_scale v1 of
               Option.SOME n =>
                 (case p_register v2 of
                     Option.SOME(sz,r) =>
                       (if sz = Z64 then Option.SOME(n,r) else NONE)
                   | NONE => NONE)
             | NONE => NONE))
   | _ => NONE;

fun p_disp (b,s) =
  case p_imm32 s of Option.SOME imm => Option.SOME(b,imm) | NONE => NONE;

fun p_rip_disp s =
  let
    val (l,r) =
      L3.splitl(fn c => not(Set.mem(c,[#"+",#"-"])),stripLeftSpaces s)
  in
    if l = ("")
      then if r = ("")
             then NONE
           else case p_rip_disp(L3.strTl r) of
                   Option.SOME(ripfirst,imm) =>
                     (if (L3.strHd r) = #"+"
                        then Option.SOME(ripfirst,imm)
                      else if ripfirst
                        then NONE
                      else Option.SOME(false,BitsN.neg imm))
                 | NONE => NONE
    else if r = ("")
      then if (stripSpaces l) = ("rip")
             then Option.SOME(true,BitsN.B(0x0,64))
           else NONE
    else if (stripSpaces l) = ("rip")
      then p_disp(true,r)
    else if (stripSpaces(L3.strTl r)) = ("rip")
      then p_disp(false,l)
    else NONE
  end;

fun p_parts (m,s) =
  let
    val (v'0,(v'1,(v'2,v'3))) = (stripLeftSpaces s,m)
  in
    case (String.explode v'0,(v'1,(v'2,v'3))) of
       ([],_) => m
     | (#"-" :: t,(si,(b,disp))) =>
       let
         val (l,r) =
           L3.splitl(fn c => not(Set.mem(c,[#"+",#"-"])),String.implode t)
       in
         case (p_imm32(("-") ^ l),disp) of
            (NONE,_) => (NONE,(NONE,NONE))
          | (Option.SOME imm2,Option.SOME imm1) =>
            p_parts((si,(b,Option.SOME(BitsN.+(imm2,imm1)))),r)
          | (Option.SOME imm,NONE) => p_parts((si,(b,Option.SOME imm)),r)
       end
     | (#"+" :: t,(si,(b,disp))) =>
       let
         val (l,r) =
           L3.splitl(fn c => not(Set.mem(c,[#"+",#"-"])),String.implode t)
       in
         case (p_imm32 l,disp) of
            (NONE,_) =>
              (case (p_register l,(si,b)) of
                  (Option.SOME(sz,rg),(_,NONE)) =>
                    (if sz = Z64
                       then p_parts((si,(Option.SOME rg,disp)),r)
                     else (NONE,(NONE,NONE)))
                | (Option.SOME(sz,rg),(NONE,Option.SOME _)) =>
                  (if sz = Z64
                     then p_parts
                            ((Option.SOME(BitsN.B(0x0,2),rg),(b,disp)),r)
                   else (NONE,(NONE,NONE)))
                | (NONE,(NONE,_)) =>
                  (case p_scale_index l of
                      NONE => (NONE,(NONE,NONE))
                    | si => p_parts((si,(b,disp)),r))
                | (NONE,(Option.SOME(n1,r1),NONE)) =>
                  (case p_scale_index l of
                      NONE => (NONE,(NONE,NONE))
                    | Option.SOME(n2,r2) =>
                      (if n1 = (BitsN.B(0x0,2))
                         then p_parts
                                ((Option.SOME(n2,r2),(Option.SOME r1,disp)),
                                 r)
                       else if n2 = (BitsN.B(0x0,2))
                         then p_parts
                                ((Option.SOME(n1,r1),(Option.SOME r2,disp)),
                                 r)
                       else (NONE,(NONE,NONE))))
                | _ => (NONE,(NONE,NONE)))
          | (Option.SOME imm2,Option.SOME imm1) =>
            p_parts((si,(b,Option.SOME(BitsN.+(imm2,imm1)))),r)
          | (Option.SOME imm,NONE) => p_parts((si,(b,Option.SOME imm)),r)
       end
     | (t,(si,(b,disp))) =>
       let
         val (l,r) =
           L3.splitl(fn c => not(Set.mem(c,[#"+",#"-"])),String.implode t)
       in
         case (p_imm32 l,disp) of
            (NONE,_) =>
              (case (p_register l,(si,b)) of
                  (Option.SOME(sz,rg),(_,NONE)) =>
                    (if sz = Z64
                       then p_parts((si,(Option.SOME rg,disp)),r)
                     else (NONE,(NONE,NONE)))
                | (Option.SOME(sz,rg),(NONE,Option.SOME _)) =>
                  (if sz = Z64
                     then p_parts
                            ((Option.SOME(BitsN.B(0x0,2),rg),(b,disp)),r)
                   else (NONE,(NONE,NONE)))
                | (NONE,(NONE,_)) =>
                  (case p_scale_index l of
                      NONE => (NONE,(NONE,NONE))
                    | si => p_parts((si,(b,disp)),r))
                | (NONE,(Option.SOME(n1,r1),NONE)) =>
                  (case p_scale_index l of
                      NONE => (NONE,(NONE,NONE))
                    | Option.SOME(n2,r2) =>
                      (if n1 = (BitsN.B(0x0,2))
                         then p_parts
                                ((Option.SOME(n2,r2),(Option.SOME r1,disp)),
                                 r)
                       else if n2 = (BitsN.B(0x0,2))
                         then p_parts
                                ((Option.SOME(n1,r1),(Option.SOME r2,disp)),
                                 r)
                       else (NONE,(NONE,NONE))))
                | _ => (NONE,(NONE,NONE)))
          | (Option.SOME imm2,Option.SOME imm1) =>
            p_parts((si,(b,Option.SOME(BitsN.+(imm2,imm1)))),r)
          | (Option.SOME imm,NONE) => p_parts((si,(b,Option.SOME imm)),r)
       end
  end;

fun p_mem s =
  let
    val (si,(b,disp)) =
      case p_parts((NONE,(NONE,NONE)),s) of
         (Option.SOME(BitsN.B(0x0,_),r),(NONE,disp)) =>
           (NONE,(Option.SOME r,disp))
       | (Option.SOME(BitsN.B(0x0,_),RSP),(Option.SOME r,disp)) =>
         (Option.SOME(BitsN.B(0x0,2),r),(Option.SOME RSP,disp))
       | x => x
  in
    if (si = NONE) andalso ((b = NONE) andalso (disp = NONE))
      then NONE
    else Option.SOME
           (si,
            (case b of Option.SOME r => ZregBase r | NONE => ZnoBase,
             case disp of Option.SOME imm => imm | NONE => BitsN.B(0x0,64)))
  end;

fun p_rm s =
  case String.explode(stripSpaces s) of
     #"[" :: r =>
       let
         val (l,r) =
           L3.splitr(fn c => c = #"]",stripSpaces(String.implode r))
       in
         if r = ("]")
           then case p_mem l of
                   Option.SOME v => Option.SOME(Z64,Zm v)
                 | NONE =>
                   (case p_rip_disp l of
                       Option.SOME(_,imm) =>
                         Option.SOME(Z64,Zm(NONE,(ZripBase,imm)))
                     | NONE => NONE)
         else NONE
       end
   | r =>
     (case p_register(String.implode r) of
         Option.SOME(sz,r) => Option.SOME(sz,Zr r)
       | NONE => NONE);

fun checkSizeDelim (sz,s) =
  case String.explode s of
     [] => Option.SOME sz
   | h :: _ =>
     (if (Char.isSpace h) orelse (h = #"[") then Option.SOME sz else NONE);

fun p_sz s =
  case String.explode(stripLeftSpaces s) of
     #"b" :: (#"y" :: (#"t" :: (#"e" :: r))) =>
       let val r = String.implode r in (checkSizeDelim(Z8 false,r),r) end
   | #"w" :: (#"o" :: (#"r" :: (#"d" :: r))) =>
     let val r = String.implode r in (checkSizeDelim(Z16,r),r) end
   | #"d" :: (#"w" :: (#"o" :: (#"r" :: (#"d" :: r)))) =>
     let val r = String.implode r in (checkSizeDelim(Z32,r),r) end
   | #"q" :: (#"w" :: (#"o" :: (#"r" :: (#"d" :: r)))) =>
     let val r = String.implode r in (checkSizeDelim(Z64,r),r) end
   | r => (NONE,String.implode r);

fun s_sz sz =
  case sz of
     Z8 _ => "byte"
   | Z16 => "word"
   | Z32 => "dword"
   | Z64 => "qword";

fun p_sz_rm s =
  let
    val (sz1,r) = p_sz s
  in
    case p_rm r of
       Option.SOME(sz2,Zr r) =>
         (case (sz1,sz2) of
             (Option.SOME(Z8 _),Z8 _) => ""
           | (NONE,_) => ""
           | (Option.SOME s1,_) =>
             (if s1 = sz2 then "" else "cannot override register size"),
          (sz2,Zr r))
     | Option.SOME(sz2,x) =>
       (case sz1 of
           NONE => ("any size",(sz2,x))
         | Option.SOME s1 => ("",(s1,x)))
     | NONE => ("syntax error",(Z16,Zr RAX))
  end;

fun p_rm_of_size (sz,s) =
  case p_sz_rm s of
     ("any size",(_,rm)) => ("",rm)
   | ("",(sz2,rm)) =>
     let
       val sz_sz = s_sz sz
     in
       if sz_sz = (s_sz sz2)
         then ("",rm)
       else (String.concat["expecting a ",sz_sz," value"],Zr RAX)
     end
   | (err,_) => (err,Zr RAX);

fun p_rm32 s = p_rm_of_size(Z32,s);

fun p_rm64 s = p_rm_of_size(Z64,s);

fun p_imm_rm s =
  case p_imm32 s of
     Option.SOME imm => ("",Zimm imm)
   | NONE => let val (err,rm) = p_rm64 s in (err,Zrm rm) end;

fun p_dest_src (nfull_imm,(a,b)) =
  case p_sz_rm a of
     ("",(sz,Zr r)) =>
       (case p_imm_of_size(sz,b) of
           Option.SOME imm =>
             (if (sz = Z64) andalso
                 (nfull_imm andalso
                  (not((BitsN.signExtend 64 (BitsN.bits(31,0) imm)) = imm)))
                then ("syntax error: bad immediate",NONE)
              else ("",Option.SOME(sz,Zrm_i(Zr r,imm))))
         | NONE =>
           (case p_rm_of_size(sz,b) of
               ("",Zr r2) => ("",Option.SOME(sz,Zrm_r(Zr r,r2)))
             | ("",rm) => ("",Option.SOME(sz,Zr_rm(r,rm)))
             | (err,_) => (err,NONE)))
   | (message,(sz,Zm m)) =>
     (case p_register b of
         Option.SOME(sz2,r) =>
           (if (message = ("any size")) orelse (sz = sz2)
              then ("",Option.SOME(sz2,Zrm_r(Zm m,r)))
            else ("inconsistent sizes",NONE))
       | NONE =>
         (case p_imm_of_size(sz,b) of
             Option.SOME imm =>
               (if (sz = Z64) andalso
                   (not((BitsN.signExtend 64 (BitsN.bits(31,0) imm)) = imm))
                  then ("syntax error: bad immediate",NONE)
                else ("",Option.SOME(sz,Zrm_i(Zm m,imm))))
           | NONE => ("syntax error",NONE)))
   | (err,_) => (err,NONE);

fun p_cond s =
  case s of
     "o" => Option.SOME Z_O
   | "b" => Option.SOME Z_B
   | "c" => Option.SOME Z_B
   | "nae" => Option.SOME Z_B
   | "e" => Option.SOME Z_E
   | "z" => Option.SOME Z_E
   | "a" => Option.SOME Z_A
   | "nbe" => Option.SOME Z_A
   | "s" => Option.SOME Z_S
   | "p" => Option.SOME Z_P
   | "pe" => Option.SOME Z_P
   | "l" => Option.SOME Z_L
   | "nge" => Option.SOME Z_L
   | "g" => Option.SOME Z_G
   | "nle" => Option.SOME Z_G
   | "no" => Option.SOME Z_NO
   | "nb" => Option.SOME Z_NB
   | "nc" => Option.SOME Z_NB
   | "ae" => Option.SOME Z_NB
   | "ne" => Option.SOME Z_NE
   | "nz" => Option.SOME Z_NE
   | "na" => Option.SOME Z_NA
   | "be" => Option.SOME Z_NA
   | "ns" => Option.SOME Z_NS
   | "np" => Option.SOME Z_NP
   | "po" => Option.SOME Z_NP
   | "nl" => Option.SOME Z_NL
   | "ge" => Option.SOME Z_NL
   | "ng" => Option.SOME Z_NG
   | "le" => Option.SOME Z_NG
   | "" => Option.SOME Z_ALWAYS
   | _ => NONE;

fun p_binop (bop,(a,b)) =
  case p_dest_src(true,(a,b)) of
     ("",Option.SOME(sz,dst_src)) => OK(Zbinop(bop,(sz,dst_src)))
   | ("",NONE) => FAIL("syntax error")
   | (err,_) => FAIL err;

fun p_monop (opc,s) =
  let
    val (err,sz_rm) = p_sz_rm s
  in
    if (err = ("")) orelse (err = ("any size"))
      then OK(case opc of
                 0 => Zdiv sz_rm
               | 1 => Zmul sz_rm
               | 2 => Zmonop(Zdec,sz_rm)
               | 3 => Zmonop(Zinc,sz_rm)
               | 4 => Zmonop(Znot,sz_rm)
               | _ => Zmonop(Zneg,sz_rm))
    else FAIL err
  end;

fun p_xop (opc,(a,b)) =
  case p_register b of
     Option.SOME(sz,r) =>
       let
         val (err,rm) =
           case p_rm a of
              Option.SOME(sz2,Zr r2) =>
                (if sz2 = sz then "" else "sizes do not match",Zr r2)
            | Option.SOME(Z64,m) => ("",m)
            | _ => ("syntax error",Zm(NONE,(ZnoBase,BitsN.B(0x0,64))))
       in
         if err = ("")
           then let
                  val arg = (sz,(rm,r))
                in
                  OK(case opc of
                        0 => Zxadd arg
                      | 1 => Zxchg arg
                      | _ => Zcmpxchg arg)
                end
         else FAIL err
       end
   | NONE => FAIL("syntax error");

fun p_tokens s =
  let
    val (l,r) =
      L3.splitl
        (fn c => not(Char.isSpace c),
         L3.lowercase(L3.snd(L3.splitl(fn c => Char.isSpace c,s))))
    val r = L3.uncurry String.fields (fn c => c = #",",r)
    val r =
      if ((L3.length r) = 1) andalso ((stripSpaces(List.hd r)) = (""))
        then []
      else r
  in
    l :: r
  end;

fun instructionFromString s =
  case p_tokens s of
     v'0 :: v'1 =>
       (case v'1 of
           v'4 :: v'5 =>
             (case ((String.explode v'4,v'5),String.explode v'0) of
                 ((a,[b]),[#"o",#"r"]) =>
                   p_binop(Zor,(String.implode a,b))
               | ((a,[b]),[#"a",#"d",#"d"]) =>
                 p_binop(Zadd,(String.implode a,b))
               | ((a,[b]),[#"a",#"d",#"c"]) =>
                 p_binop(Zadc,(String.implode a,b))
               | ((a,[b]),[#"s",#"b",#"b"]) =>
                 p_binop(Zsbb,(String.implode a,b))
               | ((a,[b]),[#"a",#"n",#"d"]) =>
                 p_binop(Zand,(String.implode a,b))
               | ((a,[b]),[#"s",#"u",#"b"]) =>
                 p_binop(Zsub,(String.implode a,b))
               | ((a,[b]),[#"x",#"o",#"r"]) =>
                 p_binop(Zxor,(String.implode a,b))
               | ((a,[b]),[#"c",#"m",#"p"]) =>
                 p_binop(Zcmp,(String.implode a,b))
               | ((a,[b]),[#"r",#"o",#"l"]) =>
                 p_binop(Zrol,(String.implode a,b))
               | ((a,[b]),[#"r",#"o",#"r"]) =>
                 p_binop(Zror,(String.implode a,b))
               | ((a,[b]),[#"r",#"c",#"l"]) =>
                 p_binop(Zrcl,(String.implode a,b))
               | ((a,[b]),[#"r",#"c",#"r"]) =>
                 p_binop(Zrcr,(String.implode a,b))
               | ((a,[b]),[#"s",#"h",#"l"]) =>
                 p_binop(Zshl,(String.implode a,b))
               | ((a,[b]),[#"s",#"h",#"r"]) =>
                 p_binop(Zshr,(String.implode a,b))
               | ((a,[b]),[#"s",#"a",#"r"]) =>
                 p_binop(Zsar,(String.implode a,b))
               | ((a,[b]),[#"t",#"e",#"s",#"t"]) =>
                 p_binop(Ztest,(String.implode a,b))
               | ((a,[]),#"s" :: (#"e" :: (#"t" :: cond))) =>
                 (case p_cond(String.implode cond) of
                     Option.SOME c =>
                       (case p_sz_rm(String.implode a) of
                           ("",(Z8 have_rex,rm)) =>
                             OK(Zset(c,(have_rex,rm)))
                         | ("any size",(Z8 have_rex,rm)) =>
                           OK(Zset(c,(have_rex,rm)))
                         | ("any size",_) =>
                           FAIL("SETcc requires byte source")
                         | (err,_) => FAIL err)
                   | NONE => FAIL("Unrecognised op-code"))
               | ((a,[]),[#"c",#"a",#"l",#"l"]) =>
                 let
                   val a = String.implode a
                 in
                   case p_imm_rm a of
                      ("",Zimm imm) =>
                        OK(Zcall(Zimm(BitsN.-(imm,BitsN.B(0x5,64)))))
                    | ("",Zrm rm) => OK(Zcall(Zrm rm))
                    | (err,_) =>
                      (case p_label a of
                          Option.SOME l =>
                            PENDING(l,Zcall(Zimm(BitsN.B(0x0,64))))
                        | NONE => FAIL err)
                 end
               | ((a,[]),[#"p",#"u",#"s",#"h"]) =>
                 (case p_imm_rm(String.implode a) of
                     ("",x) => OK(Zpush x)
                   | (err,_) => FAIL err)
               | ((a,[]),[#"p",#"o",#"p"]) =>
                 (case p_rm64(String.implode a) of
                     ("",rm) => OK(Zpop rm)
                   | (err,_) => FAIL err)
               | ((a,[]),#"j" :: cond) =>
                 let
                   val a = String.implode a
                   val cond = String.implode cond
                   val condition =
                     if cond = ("mp")
                       then Option.SOME Z_ALWAYS
                     else if cond = ("") then NONE else p_cond cond
                 in
                   case condition of
                      Option.SOME c =>
                        (case p_imm_rm a of
                            ("",Zrm rm) =>
                              (if c = Z_ALWAYS
                                 then OK(Zjmp rm)
                               else FAIL("syntax error"))
                          | ("",Zimm imm) =>
                            let
                              val ast =
                                Zjcc(c,BitsN.-(imm,BitsN.B(0x2,64)))
                            in
                              if (L3.length(encode ast)) = 2
                                then OK ast
                              else OK(Zjcc
                                        (c,
                                         BitsN.-
                                           (imm,
                                            if c = Z_ALWAYS
                                              then BitsN.B(0x5,64)
                                            else BitsN.B(0x6,64))))
                            end
                          | (err,_) =>
                            let
                              val (sz,b) = p_sz a
                              val far =
                                case sz of
                                   Option.SOME Z32 => true
                                 | _ => false
                            in
                              case p_label b of
                                 Option.SOME l =>
                                   PENDING
                                     (l,Zjcc(c,BitsN.fromBool 64 far))
                               | NONE => FAIL err
                            end)
                    | NONE => FAIL("Unrecognised op-code")
                 end
               | ((a,[]),[#"d",#"i",#"v"]) => p_monop(0,String.implode a)
               | ((a,[]),[#"m",#"u",#"l"]) => p_monop(1,String.implode a)
               | ((a,[]),[#"d",#"e",#"c"]) => p_monop(2,String.implode a)
               | ((a,[]),[#"i",#"n",#"c"]) => p_monop(3,String.implode a)
               | ((a,[]),[#"n",#"o",#"t"]) => p_monop(4,String.implode a)
               | ((a,[]),[#"n",#"e",#"g"]) => p_monop(5,String.implode a)
               | ((i,[]),[#"r",#"e",#"t"]) =>
                 (case p_imm16(String.implode i) of
                     Option.SOME imm => OK(Zret imm)
                   | NONE => FAIL("syntax error: bad immediate"))
               | ((i,[]),#"l" :: (#"o" :: (#"o" :: (#"p" :: cond)))) =>
                 let
                   val i = String.implode i
                 in
                   case p_cond(String.implode cond) of
                      Option.SOME c =>
                        (if Set.mem(c,[Z_ALWAYS,Z_E,Z_NE])
                           then case p_imm8 i of
                                   Option.SOME imm =>
                                     OK(Zloop
                                          (c,BitsN.-(imm,BitsN.B(0x2,64))))
                                 | NONE =>
                                   (case p_label i of
                                       Option.SOME l =>
                                         PENDING
                                           (l,Zloop(c,BitsN.B(0x0,64)))
                                     | NONE =>
                                       FAIL("syntax error: bad immediate"))
                         else FAIL("bad condition"))
                    | NONE => FAIL("Unrecognised op-code")
                 end
               | ((a,[b]),[#"m",#"o",#"v",#"z",#"x"]) =>
                 (case p_register(String.implode a) of
                     Option.SOME(sz2,r) =>
                       let
                         val (message,(sz1,rm)) = p_sz_rm b
                       in
                         if (message = ("")) orelse
                            (message = ("any size"))
                           then OK(Zmovzx(sz1,(Zr_rm(r,rm),sz2)))
                         else FAIL message
                       end
                   | NONE => FAIL("syntax error"))
               | ((a,[b]),[#"m",#"o",#"v",#"s",#"x"]) =>
                 (case p_register(String.implode a) of
                     Option.SOME(sz2,r) =>
                       let
                         val (message,(sz1,rm)) = p_sz_rm b
                       in
                         if (message = ("")) orelse
                            (message = ("any size"))
                           then if (sz1 = Z32) andalso (sz2 = Z64)
                                  then FAIL
                                         ("movsx used instead of movsxd")
                                else OK(Zmovsx(sz1,(Zr_rm(r,rm),sz2)))
                         else FAIL message
                       end
                   | NONE => FAIL("syntax error"))
               | ((a,[b]),[#"m",#"o",#"v",#"s",#"x",#"d"]) =>
                 (case p_register(String.implode a) of
                     Option.SOME(Z64,r) =>
                       (case p_rm32 b of
                           ("",rm) => OK(Zmovsx(Z32,(Zr_rm(r,rm),Z64)))
                         | (err,_) => FAIL err)
                   | Option.SOME _ =>
                     FAIL("destination must be a 64-bit register")
                   | NONE => FAIL("syntax error"))
               | ((a,[b]),[#"m",#"o",#"v"]) =>
                 (case p_dest_src(false,(String.implode a,b)) of
                     ("",Option.SOME(sz,dst_src)) =>
                       OK(Zmov(Z_ALWAYS,(sz,dst_src)))
                   | ("",NONE) => FAIL("syntax error")
                   | (err,_) => FAIL err)
               | ((a,[b]),#"c" :: (#"m" :: (#"o" :: (#"v" :: cond)))) =>
                 (case p_cond(String.implode cond) of
                     Option.SOME Z_ALWAYS => FAIL("Unrecognised op-code")
                   | Option.SOME c =>
                     (case p_dest_src(true,(String.implode a,b)) of
                         ("",Option.SOME(sz,Zrm_r(Zr r1,r2))) =>
                           OK(Zmov(c,(sz,Zr_rm(r1,Zr r2))))
                       | ("",Option.SOME(sz,Zr_rm(r,rm))) =>
                         OK(Zmov(c,(sz,Zr_rm(r,rm))))
                       | ("",_) => FAIL("syntax error")
                       | (err,_) => FAIL err)
                   | NONE => FAIL("Unrecognised op-code"))
               | ((a,[b]),[#"l",#"e",#"a"]) =>
                 (case p_register(String.implode a) of
                     Option.SOME(sz,r) =>
                       (case p_rm b of
                           Option.SOME(Z64,Zm m) =>
                             OK(Zlea(sz,Zr_rm(r,Zm m)))
                         | _ => FAIL("syntax error"))
                   | NONE => FAIL("syntax error"))
               | ((a,[b]),[#"x",#"a",#"d",#"d"]) =>
                 p_xop(0,(String.implode a,b))
               | ((a,[b]),[#"x",#"c",#"h",#"g"]) =>
                 p_xop(1,(String.implode a,b))
               | ((a,[b]),[#"c",#"m",#"p",#"x",#"c",#"h",#"g"]) =>
                 p_xop(2,(String.implode a,b))
               | ((s :: l,[]),[#"b",#"y",#"t",#"e",#"s"]) =>
                 (if Char.isSpace s
                    then case p_bytes(String.implode l) of
                            Option.SOME bs => STREAM bs
                          | NONE => FAIL("bad byte list")
                  else FAIL("syntax error"))
               | ((v'7,v'8),v'2) =>
                 FAIL("Unrecognised op-code or wrong number of args"))
         | [] =>
           (case v'0 of
               "cmc" => OK Zcmc
             | "clc" => OK Zclc
             | "stc" => OK Zstc
             | "leave" => OK Zleave
             | "nop" => OK Znop
             | "ret" => OK(Zret(BitsN.B(0x0,64)))
             | v'2 => FAIL("Unrecognised op-code or wrong number of args")))
   | _ => FAIL("Unrecognised op-code or wrong number of args");

fun s_register (sz,r) =
  case (sz,r) of
     (Z8 _,RAX) => "al"
   | (Z8 _,RCX) => "cl"
   | (Z8 _,RDX) => "dl"
   | (Z8 _,RBX) => "bl"
   | (Z8 false,RSP) => "ah"
   | (Z8 false,RBP) => "ch"
   | (Z8 false,RSI) => "dh"
   | (Z8 false,RDI) => "bh"
   | (Z8 true,RSP) => "spl"
   | (Z8 true,RBP) => "bpl"
   | (Z8 true,RSI) => "sil"
   | (Z8 true,RDI) => "dil"
   | (Z8 _,zR8) => "r8b"
   | (Z8 _,zR9) => "r9b"
   | (Z8 _,zR10) => "r10b"
   | (Z8 _,zR11) => "r11b"
   | (Z8 _,zR12) => "r12b"
   | (Z8 _,zR13) => "r13b"
   | (Z8 _,zR14) => "r14b"
   | (Z8 _,zR15) => "r15b"
   | (Z16,RAX) => "ax"
   | (Z16,RCX) => "cx"
   | (Z16,RDX) => "dx"
   | (Z16,RBX) => "bx"
   | (Z16,RSP) => "sp"
   | (Z16,RBP) => "bp"
   | (Z16,RSI) => "si"
   | (Z16,RDI) => "di"
   | (Z16,zR8) => "r8w"
   | (Z16,zR9) => "r9w"
   | (Z16,zR10) => "r10w"
   | (Z16,zR11) => "r11w"
   | (Z16,zR12) => "r12w"
   | (Z16,zR13) => "r13w"
   | (Z16,zR14) => "r14w"
   | (Z16,zR15) => "r15w"
   | (Z32,RAX) => "eax"
   | (Z32,RCX) => "ecx"
   | (Z32,RDX) => "edx"
   | (Z32,RBX) => "ebx"
   | (Z32,RSP) => "esp"
   | (Z32,RBP) => "ebp"
   | (Z32,RSI) => "esi"
   | (Z32,RDI) => "edi"
   | (Z32,zR8) => "r8d"
   | (Z32,zR9) => "r9d"
   | (Z32,zR10) => "r10d"
   | (Z32,zR11) => "r11d"
   | (Z32,zR12) => "r12d"
   | (Z32,zR13) => "r13d"
   | (Z32,zR14) => "r14d"
   | (Z32,zR15) => "r15d"
   | (Z64,RAX) => "rax"
   | (Z64,RCX) => "rcx"
   | (Z64,RDX) => "rdx"
   | (Z64,RBX) => "rbx"
   | (Z64,RSP) => "rsp"
   | (Z64,RBP) => "rbp"
   | (Z64,RSI) => "rsi"
   | (Z64,RDI) => "rdi"
   | (Z64,zR8) => "r8"
   | (Z64,zR9) => "r9"
   | (Z64,zR10) => "r10"
   | (Z64,zR11) => "r11"
   | (Z64,zR12) => "r12"
   | (Z64,zR13) => "r13"
   | (Z64,zR14) => "r14"
   | (Z64,zR15) => "r15";

fun s_qword q =
  if BitsN.<(q,BitsN.B(0x0,64))
    then ("-0x") ^ (BitsN.toHexString(BitsN.neg q))
  else ("0x") ^ (BitsN.toHexString q);

fun s_qword0 q =
  if q = (BitsN.B(0x0,64))
    then ""
  else if BitsN.<(q,BitsN.B(0x0,64))
    then ("-0x") ^ (BitsN.toHexString(BitsN.neg q))
  else ("+0x") ^ (BitsN.toHexString q);

fun s_sib (scale,idx) =
  (s_register(Z64,idx))
    ^
    (if scale = (BitsN.B(0x0,2))
       then ""
     else ("*") ^ (Nat.toString(Nat.pow(2,BitsN.toNat scale))));

fun s_rm (sz,rm) =
  case rm of
     Zr r => s_register(sz,r)
   | Zm(NONE,(ZripBase,imm)) => String.concat["[rip",s_qword0 imm,"]"]
   | Zm(NONE,(ZnoBase,imm)) => String.concat["[",s_qword imm,"]"]
   | Zm(NONE,(ZregBase base,imm)) =>
     String.concat["[",s_register(Z64,base),s_qword0 imm,"]"]
   | Zm(Option.SOME(scale,idx),(ZnoBase,imm)) =>
     String.concat["[",s_sib(scale,idx),s_qword0 imm,"]"]
   | Zm(Option.SOME(scale,idx),(ZregBase base,imm)) =>
     String.concat
       ["[",s_register(Z64,base),"+",s_sib(scale,idx),s_qword0 imm,"]"]
   | Zm _ => "[invalid]";

fun s_imm_rm x =
  case x of Zrm rm => s_rm(Z64,rm) | Zimm imm => s_qword imm;

fun s_sz_rm (sz,rm) =
  case rm of
     Zr _ => s_rm(sz,rm)
   | _ =>
     (if sz = Z64
        then s_rm(sz,rm)
      else String.concat[s_sz sz," ",s_rm(Z64,rm)]);

fun s_dest_src (sz,ds) =
  case ds of
     Zrm_r(rm,r) => String.concat[s_rm(sz,rm),", ",s_register(sz,r)]
   | Zr_rm(r,rm) => String.concat[s_register(sz,r),", ",s_rm(sz,rm)]
   | Zrm_i(rm,i) => String.concat[s_sz_rm(sz,rm),", ",s_qword i];

fun s_cond c =
  case c of
     Z_O => "o"
   | Z_B => "b"
   | Z_E => "e"
   | Z_A => "a"
   | Z_S => "s"
   | Z_P => "p"
   | Z_L => "l"
   | Z_G => "g"
   | Z_NO => "no"
   | Z_NB => "nb"
   | Z_NE => "ne"
   | Z_NA => "na"
   | Z_NS => "ns"
   | Z_NP => "np"
   | Z_NL => "nl"
   | Z_NG => "ng"
   | Z_ALWAYS => "";

fun s_binop n = L3.strTl(Cast.Zbinop_nameToString n);

fun instructionToString (i,width) =
  case i of
     Zbinop(bop,(sz,dst_src)) =>
       (L3.strTl(Cast.Zbinop_nameToString bop),s_dest_src(sz,dst_src))
   | Zcall(Zimm imm) =>
     ("call",s_qword(BitsN.+(imm,BitsN.fromNat(width,64))))
   | Zcall(Zrm rm) => ("call",s_rm(Z64,rm))
   | Zcmc => ("cmc","")
   | Zclc => ("clc","")
   | Zstc => ("stc","")
   | Zcmpxchg(sz,(rm,r)) =>
     ("cmpxchg",String.concat[s_rm(sz,rm),", ",s_register(sz,r)])
   | Zdiv sz_rm => ("div",s_sz_rm sz_rm)
   | Zjcc(Z_ALWAYS,imm) =>
     ("jmp",s_qword(BitsN.+(imm,BitsN.fromNat(width,64))))
   | Zjcc(cond,imm) =>
     (("j") ^ (s_cond cond),s_qword(BitsN.+(imm,BitsN.fromNat(width,64))))
   | Zjmp rm => ("jmp",s_rm(Z64,rm))
   | Zlea(Z8 _,_) => ("?lea?","")
   | Zlea(sz,Zr_rm(r,Zm m)) =>
     ("lea",String.concat[s_register(sz,r),", ",s_rm(Z64,Zm m)])
   | Zlea _ => ("?lea?","")
   | Zleave => ("leave","")
   | Zloop(Z_NE,imm) =>
     ("loopne",s_qword(BitsN.+(imm,BitsN.fromNat(width,64))))
   | Zloop(Z_E,imm) =>
     ("loope",s_qword(BitsN.+(imm,BitsN.fromNat(width,64))))
   | Zloop(Z_ALWAYS,imm) =>
     ("loop",s_qword(BitsN.+(imm,BitsN.fromNat(width,64))))
   | Zloop _ => ("?loop?","")
   | Zmonop(mop,sz_rm) =>
     (case mop of
         Zdec => "dec"
       | Zinc => "inc"
       | Znot => "not"
       | Zneg => "neg",s_sz_rm sz_rm)
   | Zmov(Z_ALWAYS,(sz,dst_src)) => ("mov",s_dest_src(sz,dst_src))
   | Zmov(cond,(sz,Zr_rm(r,rm))) =>
     (("cmov") ^ (s_cond cond),
      String.concat[s_register(sz,r),", ",s_rm(sz,rm)])
   | Zmov _ => ("?mov?","")
   | Zmovsx(Z32,(Zr_rm(r,rm),Z64)) =>
     ("movsxd",String.concat[s_register(Z64,r),", ",s_sz_rm(Z32,rm)])
   | Zmovsx(Z32,_) => ("?movsx?","")
   | Zmovsx(Z64,_) => ("?movsx?","")
   | Zmovsx(sz1,(Zr_rm(r,rm),sz2)) =>
     ("movsx",String.concat[s_register(sz2,r),", ",s_sz_rm(sz1,rm)])
   | Zmovsx _ => ("?movsx?","")
   | Zmovzx(Z32,_) => ("?movzx?","")
   | Zmovzx(Z64,_) => ("?movzx?","")
   | Zmovzx(sz1,(Zr_rm(r,rm),sz2)) =>
     ("movzx",String.concat[s_register(sz2,r),", ",s_sz_rm(sz1,rm)])
   | Zmovzx _ => ("?movzx?","")
   | Zmul sz_rm => ("mul",s_sz_rm sz_rm)
   | Znop => ("nop","")
   | Zpop rm => ("pop",s_rm(Z64,rm))
   | Zpush x => ("push",s_imm_rm x)
   | Zret imm => ("ret",s_qword0 imm)
   | Zset(cond,(have_rex,rm)) =>
     (("set") ^ (s_cond cond),s_rm(Z8 have_rex,rm))
   | Zxadd(sz,(rm,r)) =>
     ("xadd",String.concat[s_rm(sz,rm),", ",s_register(sz,r)])
   | Zxchg(sz,(rm,r)) =>
     ("xchg",String.concat[s_rm(sz,rm),", ",s_register(sz,r)]);

fun s_byte b = L3.padLeftString(#"0",(2,BitsN.toHexString b));

fun writeBytesAux (acc,l) =
  case l of
     h :: t => writeBytesAux(String.concat[acc," ",s_byte h],t)
   | _ => acc;

fun writeBytes l = L3.strTl(writeBytesAux("",l));

fun joinString (s1,s2) =
  if s2 = ("") then s1 else String.concat[s1," ",s2];

end