(* m0 - generated by L3 - Thu Mar 30 14:42:28 2017 *)

structure m0 :> m0 =
struct

structure Map = MutableMap

(* -------------------------------------------------------------------------
   Type declarations
   ------------------------------------------------------------------------- *)

type PRIMASK = { PM: bool, primask'rst: BitsN.nbit }

type PSR =
  { C: bool, ExceptionNumber: BitsN.nbit, N: bool, T: bool, V: bool,
    Z: bool, psr'rst: BitsN.nbit }

type CONTROL = { SPSEL: bool, control'rst: bool, nPRIV: bool }

type AIRCR =
  { ENDIANNESS: bool, SYSRESETREQ: bool, VECTCLRACTIVE: bool,
    VECTKEY: BitsN.nbit, aircr'rst: BitsN.nbit }

type CCR = { STKALIGN: bool, UNALIGN_TRP: bool, ccr'rst: BitsN.nbit }

type SHPR2 = { PRI_11: BitsN.nbit, shpr2'rst: BitsN.nbit }

type SHPR3 =
  { PRI_14: BitsN.nbit, PRI_15: BitsN.nbit, shpr3'rst: BitsN.nbit }

type IPR =
  { PRI_N0: BitsN.nbit, PRI_N1: BitsN.nbit, PRI_N2: BitsN.nbit,
    PRI_N3: BitsN.nbit, ipr'rst: BitsN.nbit }

datatype Mode = Mode_Thread | Mode_Handler

datatype ARM_Exception
  = ExternalInterrupt of BitsN.nbit
  | HardFault
  | NMI
  | PendSV
  | Reset
  | SVCall
  | SysTick

datatype RName
  = RName_0 | RName_1 | RName_2 | RName_3 | RName_4 | RName_5 | RName_6
  | RName_7 | RName_8 | RName_9 | RName_10 | RName_11 | RName_12
  | RName_SP_main | RName_SP_process | RName_LR | RName_PC

datatype SRType
  = SRType_LSL | SRType_LSR | SRType_ASR | SRType_ROR | SRType_RRX

datatype offset
  = immediate_form of BitsN.nbit | register_form of BitsN.nbit

datatype Hint
  = Breakpoint of BitsN.nbit
  | DataMemoryBarrier of BitsN.nbit
  | DataSynchronizationBarrier of BitsN.nbit
  | InstructionSynchronizationBarrier of BitsN.nbit
  | SendEvent of unit
  | WaitForEvent of unit
  | WaitForInterrupt of unit
  | Yield of unit

datatype System
  = ChangeProcessorState of bool
  | MoveToRegisterFromSpecial of BitsN.nbit * BitsN.nbit
  | MoveToSpecialRegister of BitsN.nbit * BitsN.nbit
  | SupervisorCall of BitsN.nbit

datatype Store
  = Push of BitsN.nbit
  | StoreByte of BitsN.nbit * (BitsN.nbit * offset)
  | StoreHalf of BitsN.nbit * (BitsN.nbit * offset)
  | StoreMultiple of BitsN.nbit * BitsN.nbit
  | StoreWord of BitsN.nbit * (BitsN.nbit * offset)

datatype Load
  = LoadByte of bool * (BitsN.nbit * (BitsN.nbit * offset))
  | LoadHalf of bool * (BitsN.nbit * (BitsN.nbit * offset))
  | LoadLiteral of BitsN.nbit * BitsN.nbit
  | LoadMultiple of bool * (BitsN.nbit * BitsN.nbit)
  | LoadWord of BitsN.nbit * (BitsN.nbit * offset)

datatype Media
  = ByteReverse of BitsN.nbit * BitsN.nbit
  | ByteReversePackedHalfword of BitsN.nbit * BitsN.nbit
  | ByteReverseSignedHalfword of BitsN.nbit * BitsN.nbit
  | ExtendByte of bool * (BitsN.nbit * BitsN.nbit)
  | ExtendHalfword of bool * (BitsN.nbit * BitsN.nbit)

datatype Multiply = Multiply32 of BitsN.nbit * (BitsN.nbit * BitsN.nbit)

datatype Data
  = ArithLogicImmediate of
      BitsN.nbit * (bool * (BitsN.nbit * (BitsN.nbit * BitsN.nbit)))
  | CompareImmediate of BitsN.nbit * BitsN.nbit
  | Move of BitsN.nbit * BitsN.nbit
  | Register of
      BitsN.nbit * (bool * (BitsN.nbit * (BitsN.nbit * BitsN.nbit)))
  | ShiftImmediate of
      bool * (bool * (BitsN.nbit * (BitsN.nbit * (SRType * Nat.nat))))
  | ShiftRegister of BitsN.nbit * (BitsN.nbit * (SRType * BitsN.nbit))
  | TestCompareRegister of BitsN.nbit * (BitsN.nbit * BitsN.nbit)

datatype Branch
  = BranchExchange of BitsN.nbit
  | BranchLinkExchangeRegister of BitsN.nbit
  | BranchLinkImmediate of BitsN.nbit
  | BranchTarget of BitsN.nbit

datatype instruction
  = Branch of Branch
  | Data of Data
  | Hint of Hint
  | Load of Load
  | Media of Media
  | Multiply of Multiply
  | NoOperation of unit
  | Store of Store
  | System of System
  | Undefined of BitsN.nbit

datatype MachineCode
  = Thumb of BitsN.nbit | Thumb2 of BitsN.nbit * BitsN.nbit

datatype enc = Enc_Thumb | Enc_Narrow | Enc_Wide

datatype maybeMachineCode
  = BadCode of string
  | Thumb16 of BitsN.nbit
  | Thumb32 of BitsN.nbit * BitsN.nbit

datatype maybe_instruction
  = FAIL of string
  | HALFWORD of BitsN.nbit
  | OK of (BitsN.nbit * string) * instruction
  | PENDING of string * ((BitsN.nbit * string) * instruction)

datatype nat_or_reg = NAT of Nat.nat | REGISTER of BitsN.nbit

(* -------------------------------------------------------------------------
   Casting maps (for enumerated types)
   ------------------------------------------------------------------------- *)

structure Cast =
struct
fun natToMode x =
  case Nat.toInt x of
     0 => Mode_Thread | 1 => Mode_Handler | _ => raise Fail "natToMode"

fun natToRName x =
  case Nat.toInt x of
     0 => RName_0
   | 1 => RName_1
   | 2 => RName_2
   | 3 => RName_3
   | 4 => RName_4
   | 5 => RName_5
   | 6 => RName_6
   | 7 => RName_7
   | 8 => RName_8
   | 9 => RName_9
   | 10 => RName_10
   | 11 => RName_11
   | 12 => RName_12
   | 13 => RName_SP_main
   | 14 => RName_SP_process
   | 15 => RName_LR
   | 16 => RName_PC
   | _ => raise Fail "natToRName"

fun natToSRType x =
  case Nat.toInt x of
     0 => SRType_LSL
   | 1 => SRType_LSR
   | 2 => SRType_ASR
   | 3 => SRType_ROR
   | 4 => SRType_RRX
   | _ => raise Fail "natToSRType"

fun natToenc x =
  case Nat.toInt x of
     0 => Enc_Thumb
   | 1 => Enc_Narrow
   | 2 => Enc_Wide
   | _ => raise Fail "natToenc"

fun ModeToNat x =
  case x of
     Mode_Thread => 0 | Mode_Handler => 1

fun RNameToNat x =
  case x of
     RName_0 => 0
   | RName_1 => 1
   | RName_2 => 2
   | RName_3 => 3
   | RName_4 => 4
   | RName_5 => 5
   | RName_6 => 6
   | RName_7 => 7
   | RName_8 => 8
   | RName_9 => 9
   | RName_10 => 10
   | RName_11 => 11
   | RName_12 => 12
   | RName_SP_main => 13
   | RName_SP_process => 14
   | RName_LR => 15
   | RName_PC => 16

fun SRTypeToNat x =
  case x of
     SRType_LSL => 0
   | SRType_LSR => 1
   | SRType_ASR => 2
   | SRType_ROR => 3
   | SRType_RRX => 4

fun encToNat x =
  case x of
     Enc_Thumb => 0 | Enc_Narrow => 1 | Enc_Wide => 2

fun ModeToString x =
  case x of
     Mode_Thread => "Mode_Thread" | Mode_Handler => "Mode_Handler"

fun RNameToString x =
  case x of
     RName_0 => "RName_0"
   | RName_1 => "RName_1"
   | RName_2 => "RName_2"
   | RName_3 => "RName_3"
   | RName_4 => "RName_4"
   | RName_5 => "RName_5"
   | RName_6 => "RName_6"
   | RName_7 => "RName_7"
   | RName_8 => "RName_8"
   | RName_9 => "RName_9"
   | RName_10 => "RName_10"
   | RName_11 => "RName_11"
   | RName_12 => "RName_12"
   | RName_SP_main => "RName_SP_main"
   | RName_SP_process => "RName_SP_process"
   | RName_LR => "RName_LR"
   | RName_PC => "RName_PC"

fun SRTypeToString x =
  case x of
     SRType_LSL => "SRType_LSL"
   | SRType_LSR => "SRType_LSR"
   | SRType_ASR => "SRType_ASR"
   | SRType_ROR => "SRType_ROR"
   | SRType_RRX => "SRType_RRX"

fun encToString x =
  case x of
     Enc_Thumb => "Enc_Thumb"
   | Enc_Narrow => "Enc_Narrow"
   | Enc_Wide => "Enc_Wide"

fun stringToMode x =
  case x of
     "Mode_Thread" => Mode_Thread
   | "Mode_Handler" => Mode_Handler
   | _ => raise Fail "stringToMode"

fun stringToRName x =
  case x of
     "RName_0" => RName_0
   | "RName_1" => RName_1
   | "RName_2" => RName_2
   | "RName_3" => RName_3
   | "RName_4" => RName_4
   | "RName_5" => RName_5
   | "RName_6" => RName_6
   | "RName_7" => RName_7
   | "RName_8" => RName_8
   | "RName_9" => RName_9
   | "RName_10" => RName_10
   | "RName_11" => RName_11
   | "RName_12" => RName_12
   | "RName_SP_main" => RName_SP_main
   | "RName_SP_process" => RName_SP_process
   | "RName_LR" => RName_LR
   | "RName_PC" => RName_PC
   | _ => raise Fail "stringToRName"

fun stringToSRType x =
  case x of
     "SRType_LSL" => SRType_LSL
   | "SRType_LSR" => SRType_LSR
   | "SRType_ASR" => SRType_ASR
   | "SRType_ROR" => SRType_ROR
   | "SRType_RRX" => SRType_RRX
   | _ => raise Fail "stringToSRType"

fun stringToenc x =
  case x of
     "Enc_Thumb" => Enc_Thumb
   | "Enc_Narrow" => Enc_Narrow
   | "Enc_Wide" => Enc_Wide
   | _ => raise Fail "stringToenc"
end

(* -------------------------------------------------------------------------
   Record update functions
   ------------------------------------------------------------------------- *)

fun PRIMASK_PM_rupd ({PM, primask'rst}: PRIMASK, x') =
  {PM = x', primask'rst = primask'rst}: PRIMASK

fun PRIMASK_primask'rst_rupd ({PM, primask'rst}: PRIMASK, x') =
  {PM = PM, primask'rst = x'}: PRIMASK

fun PSR_C_rupd ({C, ExceptionNumber, N, T, V, Z, psr'rst}: PSR, x') =
  {C = x', ExceptionNumber = ExceptionNumber, N = N, T = T, V = V, Z = Z,
   psr'rst = psr'rst}: PSR

fun PSR_ExceptionNumber_rupd ({C, ExceptionNumber, N, T, V, Z, psr'rst}
  : PSR, x') =
  {C = C, ExceptionNumber = x', N = N, T = T, V = V, Z = Z,
   psr'rst = psr'rst}: PSR

fun PSR_N_rupd ({C, ExceptionNumber, N, T, V, Z, psr'rst}: PSR, x') =
  {C = C, ExceptionNumber = ExceptionNumber, N = x', T = T, V = V, Z = Z,
   psr'rst = psr'rst}: PSR

fun PSR_T_rupd ({C, ExceptionNumber, N, T, V, Z, psr'rst}: PSR, x') =
  {C = C, ExceptionNumber = ExceptionNumber, N = N, T = x', V = V, Z = Z,
   psr'rst = psr'rst}: PSR

fun PSR_V_rupd ({C, ExceptionNumber, N, T, V, Z, psr'rst}: PSR, x') =
  {C = C, ExceptionNumber = ExceptionNumber, N = N, T = T, V = x', Z = Z,
   psr'rst = psr'rst}: PSR

fun PSR_Z_rupd ({C, ExceptionNumber, N, T, V, Z, psr'rst}: PSR, x') =
  {C = C, ExceptionNumber = ExceptionNumber, N = N, T = T, V = V, Z = x',
   psr'rst = psr'rst}: PSR

fun PSR_psr'rst_rupd ({C, ExceptionNumber, N, T, V, Z, psr'rst}
  : PSR, x') =
  {C = C, ExceptionNumber = ExceptionNumber, N = N, T = T, V = V, Z = Z,
   psr'rst = x'}: PSR

fun CONTROL_SPSEL_rupd ({SPSEL, control'rst, nPRIV}: CONTROL, x') =
  {SPSEL = x', control'rst = control'rst, nPRIV = nPRIV}: CONTROL

fun CONTROL_control'rst_rupd ({SPSEL, control'rst, nPRIV}: CONTROL, x') =
  {SPSEL = SPSEL, control'rst = x', nPRIV = nPRIV}: CONTROL

fun CONTROL_nPRIV_rupd ({SPSEL, control'rst, nPRIV}: CONTROL, x') =
  {SPSEL = SPSEL, control'rst = control'rst, nPRIV = x'}: CONTROL

fun AIRCR_ENDIANNESS_rupd ({ENDIANNESS, SYSRESETREQ, VECTCLRACTIVE,
   VECTKEY, aircr'rst}: AIRCR, x') =
  {ENDIANNESS = x', SYSRESETREQ = SYSRESETREQ,
   VECTCLRACTIVE = VECTCLRACTIVE, VECTKEY = VECTKEY, aircr'rst = aircr'rst}
  : AIRCR

fun AIRCR_SYSRESETREQ_rupd ({ENDIANNESS, SYSRESETREQ, VECTCLRACTIVE,
   VECTKEY, aircr'rst}: AIRCR, x') =
  {ENDIANNESS = ENDIANNESS, SYSRESETREQ = x',
   VECTCLRACTIVE = VECTCLRACTIVE, VECTKEY = VECTKEY, aircr'rst = aircr'rst}
  : AIRCR

fun AIRCR_VECTCLRACTIVE_rupd ({ENDIANNESS, SYSRESETREQ, VECTCLRACTIVE,
   VECTKEY, aircr'rst}: AIRCR, x') =
  {ENDIANNESS = ENDIANNESS, SYSRESETREQ = SYSRESETREQ, VECTCLRACTIVE = x',
   VECTKEY = VECTKEY, aircr'rst = aircr'rst}: AIRCR

fun AIRCR_VECTKEY_rupd ({ENDIANNESS, SYSRESETREQ, VECTCLRACTIVE, VECTKEY,
   aircr'rst}: AIRCR, x') =
  {ENDIANNESS = ENDIANNESS, SYSRESETREQ = SYSRESETREQ,
   VECTCLRACTIVE = VECTCLRACTIVE, VECTKEY = x', aircr'rst = aircr'rst}
  : AIRCR

fun AIRCR_aircr'rst_rupd ({ENDIANNESS, SYSRESETREQ, VECTCLRACTIVE,
   VECTKEY, aircr'rst}: AIRCR, x') =
  {ENDIANNESS = ENDIANNESS, SYSRESETREQ = SYSRESETREQ,
   VECTCLRACTIVE = VECTCLRACTIVE, VECTKEY = VECTKEY, aircr'rst = x'}
  : AIRCR

fun CCR_STKALIGN_rupd ({STKALIGN, UNALIGN_TRP, ccr'rst}: CCR, x') =
  {STKALIGN = x', UNALIGN_TRP = UNALIGN_TRP, ccr'rst = ccr'rst}: CCR

fun CCR_UNALIGN_TRP_rupd ({STKALIGN, UNALIGN_TRP, ccr'rst}: CCR, x') =
  {STKALIGN = STKALIGN, UNALIGN_TRP = x', ccr'rst = ccr'rst}: CCR

fun CCR_ccr'rst_rupd ({STKALIGN, UNALIGN_TRP, ccr'rst}: CCR, x') =
  {STKALIGN = STKALIGN, UNALIGN_TRP = UNALIGN_TRP, ccr'rst = x'}: CCR

fun SHPR2_PRI_11_rupd ({PRI_11, shpr2'rst}: SHPR2, x') =
  {PRI_11 = x', shpr2'rst = shpr2'rst}: SHPR2

fun SHPR2_shpr2'rst_rupd ({PRI_11, shpr2'rst}: SHPR2, x') =
  {PRI_11 = PRI_11, shpr2'rst = x'}: SHPR2

fun SHPR3_PRI_14_rupd ({PRI_14, PRI_15, shpr3'rst}: SHPR3, x') =
  {PRI_14 = x', PRI_15 = PRI_15, shpr3'rst = shpr3'rst}: SHPR3

fun SHPR3_PRI_15_rupd ({PRI_14, PRI_15, shpr3'rst}: SHPR3, x') =
  {PRI_14 = PRI_14, PRI_15 = x', shpr3'rst = shpr3'rst}: SHPR3

fun SHPR3_shpr3'rst_rupd ({PRI_14, PRI_15, shpr3'rst}: SHPR3, x') =
  {PRI_14 = PRI_14, PRI_15 = PRI_15, shpr3'rst = x'}: SHPR3

fun IPR_PRI_N0_rupd ({PRI_N0, PRI_N1, PRI_N2, PRI_N3, ipr'rst}: IPR, x') =
  {PRI_N0 = x', PRI_N1 = PRI_N1, PRI_N2 = PRI_N2, PRI_N3 = PRI_N3,
   ipr'rst = ipr'rst}: IPR

fun IPR_PRI_N1_rupd ({PRI_N0, PRI_N1, PRI_N2, PRI_N3, ipr'rst}: IPR, x') =
  {PRI_N0 = PRI_N0, PRI_N1 = x', PRI_N2 = PRI_N2, PRI_N3 = PRI_N3,
   ipr'rst = ipr'rst}: IPR

fun IPR_PRI_N2_rupd ({PRI_N0, PRI_N1, PRI_N2, PRI_N3, ipr'rst}: IPR, x') =
  {PRI_N0 = PRI_N0, PRI_N1 = PRI_N1, PRI_N2 = x', PRI_N3 = PRI_N3,
   ipr'rst = ipr'rst}: IPR

fun IPR_PRI_N3_rupd ({PRI_N0, PRI_N1, PRI_N2, PRI_N3, ipr'rst}: IPR, x') =
  {PRI_N0 = PRI_N0, PRI_N1 = PRI_N1, PRI_N2 = PRI_N2, PRI_N3 = x',
   ipr'rst = ipr'rst}: IPR

fun IPR_ipr'rst_rupd ({PRI_N0, PRI_N1, PRI_N2, PRI_N3, ipr'rst}
  : IPR, x') =
  {PRI_N0 = PRI_N0, PRI_N1 = PRI_N1, PRI_N2 = PRI_N2, PRI_N3 = PRI_N3,
   ipr'rst = x'}: IPR

(* -------------------------------------------------------------------------
   Exceptions
   ------------------------------------------------------------------------- *)

exception ASSERT of string

exception UNPREDICTABLE of string

(* -------------------------------------------------------------------------
   Global variables (state)
   ------------------------------------------------------------------------- *)

val AIRCR = ref
  ({ENDIANNESS = false, SYSRESETREQ = false, VECTCLRACTIVE = false,
    VECTKEY = BitsN.B(0x0,16), aircr'rst = BitsN.B(0x0,13)}): AIRCR ref

val CCR = ref
  ({STKALIGN = false, UNALIGN_TRP = false, ccr'rst = BitsN.B(0x0,30)})
  : CCR ref

val CONTROL = ref ({SPSEL = false, control'rst = false, nPRIV = false})
  : CONTROL ref

val CurrentMode = ref (Mode_Handler): Mode ref

val ExceptionActive = ref (Map.mkMap(SOME 64,false)): (bool Map.map) ref

val MEM = ref (Map.mkMap(SOME 4294967296,BitsN.B(0x0,8)))
  : (BitsN.nbit Map.map) ref

val NVIC_IPR = ref
  (Map.mkMap
     (SOME 8,
      {PRI_N0 = BitsN.B(0x0,2), PRI_N1 = BitsN.B(0x0,2),
       PRI_N2 = BitsN.B(0x0,2), PRI_N3 = BitsN.B(0x0,2),
       ipr'rst = BitsN.B(0x0,24)})): (IPR Map.map) ref

val PRIMASK = ref ({PM = false, primask'rst = BitsN.B(0x0,31)})
  : PRIMASK ref

val PSR = ref
  ({C = false, ExceptionNumber = BitsN.B(0x0,6), N = false, T = false,
    V = false, Z = false, psr'rst = BitsN.B(0x0,21)}): PSR ref

val REG = ref (Map.mkMap(SOME 17,BitsN.B(0x0,32)))
  : (BitsN.nbit Map.map) ref

val SHPR2 = ref ({PRI_11 = BitsN.B(0x0,2), shpr2'rst = BitsN.B(0x0,30)})
  : SHPR2 ref

val SHPR3 = ref
  ({PRI_14 = BitsN.B(0x0,2), PRI_15 = BitsN.B(0x0,2),
    shpr3'rst = BitsN.B(0x0,28)}): SHPR3 ref

val VTOR = ref (BitsN.B(0x0,32)): BitsN.nbit ref

val count = ref (0): Nat.nat ref

val pcinc = ref (BitsN.B(0x0,32)): BitsN.nbit ref

val pending = ref (NONE): (ARM_Exception option) ref

(* -------------------------------------------------------------------------
   Main specification
   ------------------------------------------------------------------------- *)

local
  fun tuple'16 [t0,t1,t2,t3,t4,t5,t6,t7,t8,t9,t10,t11,t12,t13,t14,t15] =
    (t0,
     (t1,
      (t2,
       (t3,(t4,(t5,(t6,(t7,(t8,(t9,(t10,(t11,(t12,(t13,(t14,t15)))))))))))))))
    | tuple'16 (_: bool list) = raise Fail "tuple'16"
in
  val boolify'16 = tuple'16 o BitsN.toList
end

local
  fun tuple'4 [t0,t1,t2,t3] = (t0,(t1,(t2,t3)))
    | tuple'4 (_: bool list) = raise Fail "tuple'4"
in
  val boolify'4 = tuple'4 o BitsN.toList
end

fun rec'PRIMASK x =
  {PM = BitsN.bit(x,0), primask'rst = BitsN.bits(31,1) x};

fun reg'PRIMASK x =
  case x of
     {PM = PM, primask'rst = primask'rst} =>
       BitsN.@@(primask'rst,BitsN.fromBit PM);

fun write'rec'PRIMASK (_,x) = reg'PRIMASK x;

fun write'reg'PRIMASK (_,x) = rec'PRIMASK x;

fun rec'PSR x =
  {C = BitsN.bit(x,29), ExceptionNumber = BitsN.bits(5,0) x,
   N = BitsN.bit(x,31), T = BitsN.bit(x,24), V = BitsN.bit(x,28),
   Z = BitsN.bit(x,30),
   psr'rst = BitsN.@@(BitsN.bits(23,6) x,BitsN.bits(27,25) x)};

fun reg'PSR x =
  case x of
     {C = C, ExceptionNumber = ExceptionNumber, N = N, T = T, V = V,
      Z = Z, psr'rst = psr'rst} =>
       BitsN.concat
         [BitsN.fromBit N,BitsN.fromBit Z,BitsN.fromBit C,BitsN.fromBit V,
          BitsN.bits(2,0) psr'rst,BitsN.fromBit T,
          BitsN.bits(20,3) psr'rst,ExceptionNumber];

fun write'rec'PSR (_,x) = reg'PSR x;

fun write'reg'PSR (_,x) = rec'PSR x;

fun rec'CONTROL x =
  {SPSEL = BitsN.bit(x,1), control'rst = BitsN.bit(x,2),
   nPRIV = BitsN.bit(x,0)};

fun reg'CONTROL x =
  case x of
     {SPSEL = SPSEL, control'rst = control'rst, nPRIV = nPRIV} =>
       BitsN.concat
         [BitsN.fromBit control'rst,BitsN.fromBit SPSEL,
          BitsN.fromBit nPRIV];

fun write'rec'CONTROL (_,x) = reg'CONTROL x;

fun write'reg'CONTROL (_,x) = rec'CONTROL x;

fun rec'AIRCR x =
  {ENDIANNESS = BitsN.bit(x,15), SYSRESETREQ = BitsN.bit(x,2),
   VECTCLRACTIVE = BitsN.bit(x,1), VECTKEY = BitsN.bits(31,16) x,
   aircr'rst = BitsN.@@(BitsN.bits(0,0) x,BitsN.bits(14,3) x)};

fun reg'AIRCR x =
  case x of
     {ENDIANNESS = ENDIANNESS, SYSRESETREQ = SYSRESETREQ,
      VECTCLRACTIVE = VECTCLRACTIVE, VECTKEY = VECTKEY,
      aircr'rst = aircr'rst} =>
       BitsN.concat
         [VECTKEY,BitsN.fromBit ENDIANNESS,BitsN.bits(11,0) aircr'rst,
          BitsN.fromBit SYSRESETREQ,BitsN.fromBit VECTCLRACTIVE,
          BitsN.bits(12,12) aircr'rst];

fun write'rec'AIRCR (_,x) = reg'AIRCR x;

fun write'reg'AIRCR (_,x) = rec'AIRCR x;

fun rec'CCR x =
  {STKALIGN = BitsN.bit(x,9), UNALIGN_TRP = BitsN.bit(x,3),
   ccr'rst =
     BitsN.concat[BitsN.bits(2,0) x,BitsN.bits(8,4) x,BitsN.bits(31,10) x]};

fun reg'CCR x =
  case x of
     {STKALIGN = STKALIGN, UNALIGN_TRP = UNALIGN_TRP, ccr'rst = ccr'rst} =>
       BitsN.concat
         [BitsN.bits(21,0) ccr'rst,BitsN.fromBit STKALIGN,
          BitsN.bits(26,22) ccr'rst,BitsN.fromBit UNALIGN_TRP,
          BitsN.bits(29,27) ccr'rst];

fun write'rec'CCR (_,x) = reg'CCR x;

fun write'reg'CCR (_,x) = rec'CCR x;

fun rec'SHPR2 x =
  {PRI_11 = BitsN.bits(31,30) x, shpr2'rst = BitsN.bits(29,0) x};

fun reg'SHPR2 x =
  case x of
     {PRI_11 = PRI_11, shpr2'rst = shpr2'rst} =>
       BitsN.@@(PRI_11,shpr2'rst);

fun write'rec'SHPR2 (_,x) = reg'SHPR2 x;

fun write'reg'SHPR2 (_,x) = rec'SHPR2 x;

fun rec'SHPR3 x =
  {PRI_14 = BitsN.bits(23,22) x, PRI_15 = BitsN.bits(31,30) x,
   shpr3'rst = BitsN.@@(BitsN.bits(21,0) x,BitsN.bits(29,24) x)};

fun reg'SHPR3 x =
  case x of
     {PRI_14 = PRI_14, PRI_15 = PRI_15, shpr3'rst = shpr3'rst} =>
       BitsN.concat
         [PRI_15,BitsN.bits(5,0) shpr3'rst,PRI_14,
          BitsN.bits(27,6) shpr3'rst];

fun write'rec'SHPR3 (_,x) = reg'SHPR3 x;

fun write'reg'SHPR3 (_,x) = rec'SHPR3 x;

fun rec'IPR x =
  {PRI_N0 = BitsN.bits(7,6) x, PRI_N1 = BitsN.bits(15,14) x,
   PRI_N2 = BitsN.bits(23,22) x, PRI_N3 = BitsN.bits(31,30) x,
   ipr'rst =
     BitsN.concat
       [BitsN.bits(5,0) x,BitsN.bits(13,8) x,BitsN.bits(21,16) x,
        BitsN.bits(29,24) x]};

fun reg'IPR x =
  case x of
     {PRI_N0 = PRI_N0, PRI_N1 = PRI_N1, PRI_N2 = PRI_N2, PRI_N3 = PRI_N3,
      ipr'rst = ipr'rst} =>
       BitsN.concat
         [PRI_N3,BitsN.bits(5,0) ipr'rst,PRI_N2,BitsN.bits(11,6) ipr'rst,
          PRI_N1,BitsN.bits(17,12) ipr'rst,PRI_N0,
          BitsN.bits(23,18) ipr'rst];

fun write'rec'IPR (_,x) = reg'IPR x;

fun write'reg'IPR (_,x) = rec'IPR x;

fun ProcessorID () = 0;

fun ConditionPassed cond =
  let
    val result =
      case BitsN.bits(3,1) cond of
         BitsN.B(0x0,_) => #Z((!PSR) : PSR)
       | BitsN.B(0x1,_) => #C((!PSR) : PSR)
       | BitsN.B(0x2,_) => #N((!PSR) : PSR)
       | BitsN.B(0x3,_) => #V((!PSR) : PSR)
       | BitsN.B(0x4,_) =>
         (#C((!PSR) : PSR)) andalso (not(#Z((!PSR) : PSR)))
       | BitsN.B(0x5,_) => (#N((!PSR) : PSR)) = (#V((!PSR) : PSR))
       | BitsN.B(0x6,_) =>
         ((#N((!PSR) : PSR)) = (#V((!PSR) : PSR))) andalso
         (not(#Z((!PSR) : PSR)))
       | BitsN.B(0x7,_) => true
       | _ => raise General.Bind
  in
    if (BitsN.bit(cond,0)) andalso (not(cond = (BitsN.B(0xF,4))))
      then not result
    else result
  end;

fun Raise e = pending := (Option.SOME e);

fun CurrentModeIsPrivileged () =
  ((!CurrentMode) = Mode_Handler) orelse
  (not(#nPRIV((!CONTROL) : CONTROL)));

fun LookUpSP () =
  if #SPSEL((!CONTROL) : CONTROL) then RName_SP_process else RName_SP_main;

fun R n =
  if n = (BitsN.B(0xF,4))
    then BitsN.+
           (Map.lookup((!REG),Cast.RNameToNat RName_PC),BitsN.B(0x4,32))
  else if n = (BitsN.B(0xE,4))
    then Map.lookup((!REG),Cast.RNameToNat RName_LR)
  else if n = (BitsN.B(0xD,4))
    then Map.lookup((!REG),Cast.RNameToNat(LookUpSP ()))
  else Map.lookup
         ((!REG),Cast.RNameToNat((Cast.natToRName o BitsN.toNat) n));

fun write'R (value,n) =
  if n = (BitsN.B(0xF,4))
    then raise ASSERT ("n >= 0 and n <= 14")
  else if n = (BitsN.B(0xE,4))
    then REG := (Map.update((!REG),Cast.RNameToNat RName_LR,value))
  else if n = (BitsN.B(0xD,4))
    then let
           val x = LookUpSP ()
         in
           REG :=
           (Map.update
              ((!REG),Cast.RNameToNat x,
               BitsN.@@(BitsN.bits(31,2) value,BitsN.B(0x0,2))))
         end
  else let
         val x = (Cast.natToRName o BitsN.toNat) n
       in
         REG := (Map.update((!REG),Cast.RNameToNat x,value))
       end;

fun SP_main () = Map.lookup((!REG),Cast.RNameToNat RName_SP_main);

fun write'SP_main value =
  REG := (Map.update((!REG),Cast.RNameToNat RName_SP_main,value));

fun SP_process () = Map.lookup((!REG),Cast.RNameToNat RName_SP_process);

fun write'SP_process value =
  REG := (Map.update((!REG),Cast.RNameToNat RName_SP_process,value));

fun SP () = R(BitsN.B(0xD,4));

fun write'SP value = write'R(value,BitsN.B(0xD,4));

fun LR () = R(BitsN.B(0xE,4));

fun write'LR value = write'R(value,BitsN.B(0xE,4));

fun PC () = R(BitsN.B(0xF,4));

fun write'PC value =
  REG := (Map.update((!REG),Cast.RNameToNat RName_PC,value));

fun mem1 address =
  BitsN.toBitstring(Map.lookup((!MEM),BitsN.toNat address));

fun mem (address,size) =
  case size of
     1 => Bitstring.bits(7,0) (mem1(BitsN.+(address,BitsN.B(0x0,32))))
   | 2 =>
     Bitstring.bits(15,0)
       ((mem1(BitsN.+(address,BitsN.B(0x1,32))))
          @
          (mem1(BitsN.+(address,BitsN.B(0x0,32)))))
   | 4 =>
     Bitstring.bits(31,0)
       (List.concat
          [mem1(BitsN.+(address,BitsN.B(0x3,32))),
           mem1(BitsN.+(address,BitsN.B(0x2,32))),
           mem1(BitsN.+(address,BitsN.B(0x1,32))),
           mem1(BitsN.+(address,BitsN.B(0x0,32)))])
   | _ => raise ASSERT ("mem: size in {1, 2, 4}");

fun write'mem (value,(address,size)) =
  case size of
     1 =>
       let
         val x = BitsN.+(address,BitsN.B(0x0,32))
       in
         MEM :=
         (Map.update
            ((!MEM),BitsN.toNat x,
             BitsN.fromBitstring(Bitstring.bits(7,0) value,8)))
       end
   | 2 =>
     ( let
         val x = BitsN.+(address,BitsN.B(0x0,32))
       in
         MEM :=
         (Map.update
            ((!MEM),BitsN.toNat x,
             BitsN.fromBitstring(Bitstring.bits(7,0) value,8)))
       end
     ; let
         val x = BitsN.+(address,BitsN.B(0x1,32))
       in
         MEM :=
         (Map.update
            ((!MEM),BitsN.toNat x,
             BitsN.fromBitstring(Bitstring.bits(15,8) value,8)))
       end
     )
   | 4 =>
     ( let
         val x = BitsN.+(address,BitsN.B(0x0,32))
       in
         MEM :=
         (Map.update
            ((!MEM),BitsN.toNat x,
             BitsN.fromBitstring(Bitstring.bits(7,0) value,8)))
       end
     ; let
         val x = BitsN.+(address,BitsN.B(0x1,32))
       in
         MEM :=
         (Map.update
            ((!MEM),BitsN.toNat x,
             BitsN.fromBitstring(Bitstring.bits(15,8) value,8)))
       end
     ; let
         val x = BitsN.+(address,BitsN.B(0x2,32))
       in
         MEM :=
         (Map.update
            ((!MEM),BitsN.toNat x,
             BitsN.fromBitstring(Bitstring.bits(23,16) value,8)))
       end
     ; let
         val x = BitsN.+(address,BitsN.B(0x3,32))
       in
         MEM :=
         (Map.update
            ((!MEM),BitsN.toNat x,
             BitsN.fromBitstring(Bitstring.bits(31,24) value,8)))
       end
     )
   | _ => raise ASSERT ("mem: size in {1, 2, 4}");

fun BigEndianReverse (value,n) =
  case n of
     1 => Bitstring.bits(7,0) value
   | 2 => (Bitstring.bits(7,0) value) @ (Bitstring.bits(15,8) value)
   | 4 =>
     List.concat
       [Bitstring.bits(7,0) value,Bitstring.bits(15,8) value,
        Bitstring.bits(23,16) value,Bitstring.bits(31,24) value]
   | _ => raise ASSERT ("BigEndianReverse: n in {1, 2, 4}");

fun Align N (w,n) = BitsN.fromNat(Nat.*(n,Nat.div(BitsN.toNat w,n)),N);

fun Aligned N (w,n) = w = (Align N (w,n));

fun MemA N (address,size) =
  if not(Aligned 32 (address,size))
    then ( Raise HardFault; BitsN.fromNat(0,N) )
  else let
         val value = mem(address,size)
       in
         BitsN.fromBitstring
           (if #ENDIANNESS((!AIRCR) : AIRCR)
              then BigEndianReverse(value,size)
            else value,N)
       end;

fun write'MemA N (value,(address,size)) =
  if not(Aligned 32 (address,size))
    then Raise HardFault
  else let
         val x = (address,size)
       in
         write'mem
           (if #ENDIANNESS((!AIRCR) : AIRCR)
              then BigEndianReverse(BitsN.toBitstring value,size)
            else BitsN.toBitstring value,x)
       end;

fun MemU N (address,size) = MemA N (address,size);

fun write'MemU N (value,(address,size)) =
  let val x = (address,size) in write'MemA N (value,x) end;

fun ExcNumber e =
  case e of
     Reset => BitsN.B(0x1,6)
   | NMI => BitsN.B(0x2,6)
   | HardFault => BitsN.B(0x3,6)
   | SVCall => BitsN.B(0xB,6)
   | PendSV => BitsN.B(0xE,6)
   | SysTick => BitsN.B(0xF,6)
   | ExternalInterrupt n => BitsN.+(BitsN.B(0x10,6),n);

fun TakeReset () =
  let
    val vectortable = (!VTOR)
  in
    ( L3.for
        (0,12,
         fn i =>
           let
             val x = BitsN.fromNat(i,4)
           in
             write'R(BitsN.B(0x0,32),x)
           end)
    ; write'SP_main(MemA 32 (vectortable,4))
    ; write'SP_process(BitsN.@@(BitsN.B(0x0,30),BitsN.B(0x0,2)))
    ; write'LR(BitsN.B(0x0,32))
    ; write'PC(MemA 32 (BitsN.+(vectortable,BitsN.B(0x4,32)),4))
    ; let
        val CurrentMode = Mode_Thread
      in
        ( PSR :=
          {C = false, ExceptionNumber = BitsN.B(0x0,6), N = false,
           T = false, V = false, Z = false, psr'rst = BitsN.B(0x0,21)}
        ; PSR := (PSR_ExceptionNumber_rupd((!PSR),BitsN.B(0x0,6)))
        ; PRIMASK := (PRIMASK_PM_rupd((!PRIMASK),false))
        ; CONTROL := (CONTROL_SPSEL_rupd((!CONTROL),false))
        ; CONTROL := (CONTROL_nPRIV_rupd((!CONTROL),false))
        ; L3.for
            (0,63,
             fn i =>
               let
                 val x = BitsN.fromNat(i,6)
               in
                 ExceptionActive :=
                 (Map.update((!ExceptionActive),BitsN.toNat x,false))
               end)
        )
      end
    )
  end;

fun ExceptionPriority n =
  if n = 2
    then IntInf.~ 2
  else if n = 1
    then IntInf.~ 1
  else if n = 11
    then BitsN.toInt(#PRI_11((!SHPR2) : SHPR2))
  else if n = 14
    then BitsN.toInt(#PRI_14((!SHPR3) : SHPR3))
  else if n = 15
    then BitsN.toInt(#PRI_15((!SHPR3) : SHPR3))
  else if Nat.>=(n,16)
    then let
           val r =
             Map.lookup
               ((!NVIC_IPR),
                BitsN.toNat(BitsN.fromNat(Nat.div(Nat.-(n,16),4),3)))
         in
           case BitsN.fromNat(Nat.mod(n,4),2) of
              BitsN.B(0x0,_) => BitsN.toInt(#PRI_N0(r : IPR))
            | BitsN.B(0x1,_) => BitsN.toInt(#PRI_N1(r : IPR))
            | BitsN.B(0x2,_) => BitsN.toInt(#PRI_N2(r : IPR))
            | BitsN.B(0x3,_) => BitsN.toInt(#PRI_N3(r : IPR))
            | _ => raise General.Bind
         end
  else 4;

fun ExecutionPriority () =
  let
    val highestpri = ref 4
  in
    let
      val boostedpri = ref 4
    in
      ( L3.for
          (2,48,
           fn i =>
             if Map.lookup
                  ((!ExceptionActive),BitsN.toNat(BitsN.fromNat(i,6)))
               then let
                      val p = ExceptionPriority i
                    in
                      if IntInf.<(p,(!highestpri))
                        then highestpri := p
                      else ()
                    end
             else ())
      ; if #PM((!PRIMASK) : PRIMASK) then boostedpri := 0 else ()
      ; IntInf.min((!boostedpri),(!highestpri))
      )
    end
  end;

fun ReturnAddress () = PC ();

fun PushStack () =
  let
    val frameptralign = ref (BitsN.B(0x0,1))
  in
    let
      val frameptr = ref (BitsN.B(0x0,32))
    in
      ( if (#SPSEL((!CONTROL) : CONTROL)) andalso
           ((!CurrentMode) = Mode_Thread)
          then ( frameptralign := (BitsN.bits(2,2) (SP_process ()))
               ; write'SP_process
                   (BitsN.&&
                      (BitsN.-(SP_process (),BitsN.B(0x20,32)),
                       BitsN.~(BitsN.zeroExtend 32 (BitsN.B(0x4,3)))))
               ; frameptr := (SP_process ())
               )
        else ( frameptralign := (BitsN.bits(2,2) (SP_main ()))
             ; write'SP_process
                 (BitsN.&&
                    (BitsN.-(SP_main (),BitsN.B(0x20,32)),
                     BitsN.~(BitsN.zeroExtend 32 (BitsN.B(0x4,3)))))
             ; frameptr := (SP_main ())
             )
      ; let
          val x = ((!frameptr),4)
        in
          write'MemA 32 (R(BitsN.B(0x0,4)),x)
        end
      ; let
          val x = (BitsN.+((!frameptr),BitsN.B(0x4,32)),4)
        in
          write'MemA 32 (R(BitsN.B(0x1,4)),x)
        end
      ; let
          val x = (BitsN.+((!frameptr),BitsN.B(0x8,32)),4)
        in
          write'MemA 32 (R(BitsN.B(0x2,4)),x)
        end
      ; let
          val x = (BitsN.+((!frameptr),BitsN.B(0xC,32)),4)
        in
          write'MemA 32 (R(BitsN.B(0x3,4)),x)
        end
      ; let
          val x = (BitsN.+((!frameptr),BitsN.B(0x10,32)),4)
        in
          write'MemA 32 (R(BitsN.B(0xC,4)),x)
        end
      ; let
          val x = (BitsN.+((!frameptr),BitsN.B(0x14,32)),4)
        in
          write'MemA 32 (LR (),x)
        end
      ; let
          val x = (BitsN.+((!frameptr),BitsN.B(0x14,32)),4)
        in
          write'MemA 32 (ReturnAddress (),x)
        end
      ; let
          val x = (BitsN.+((!frameptr),BitsN.B(0x1C,32)),4)
        in
          write'MemA 32
            (BitsN.concat
               [BitsN.bits(31,10) (reg'PSR (!PSR)),(!frameptralign),
                BitsN.bits(8,0) (reg'PSR (!PSR))],x)
        end
      ; if (!CurrentMode) = Mode_Handler
          then write'LR(BitsN.B(0xFFFFFFF1,32))
        else if not(#SPSEL((!CONTROL) : CONTROL))
          then write'LR(BitsN.B(0xFFFFFFF9,32))
        else write'LR(BitsN.B(0xFFFFFFFD,32))
      )
    end
  end;

fun ExceptionTaken ExceptionNumber =
  let
    val vectortable = (!VTOR)
  in
    ( L3.for
        (0,3,
         fn i =>
           let
             val x = BitsN.fromNat(i,4)
           in
             write'R(BitsN.B(0x0,32),x)
           end)
    ; write'R(BitsN.B(0x0,32),BitsN.B(0xC,4))
    ; write'PC
        (MemA 32
           (BitsN.+
              (vectortable,
               BitsN.*
                 (BitsN.B(0x4,32),
                  BitsN.fromNat(BitsN.toNat ExceptionNumber,32))),4))
    ; PSR :=
      {C = false, ExceptionNumber = BitsN.B(0x0,6), N = false, T = false,
       V = false, Z = false, psr'rst = BitsN.B(0x0,21)}
    ; CurrentMode := Mode_Handler
    ; PSR := (PSR_ExceptionNumber_rupd((!PSR),ExceptionNumber))
    ; CONTROL := (CONTROL_SPSEL_rupd((!CONTROL),false))
    ; ExceptionActive :=
      (Map.update((!ExceptionActive),BitsN.toNat ExceptionNumber,true))
    )
  end;

fun ExceptionEntry () =
  case (!pending) of
     Option.SOME e => ( PushStack (); ExceptionTaken(ExcNumber e) )
   | NONE => ();

fun PopStack (frameptr,EXC_RETURN) =
  ( write'R(MemA 32 (frameptr,4),BitsN.B(0x0,4))
  ; write'R(MemA 32 (BitsN.+(frameptr,BitsN.B(0x4,32)),4),BitsN.B(0x1,4))
  ; write'R(MemA 32 (BitsN.+(frameptr,BitsN.B(0x8,32)),4),BitsN.B(0x2,4))
  ; write'R(MemA 32 (BitsN.+(frameptr,BitsN.B(0xC,32)),4),BitsN.B(0x3,4))
  ; write'R(MemA 32 (BitsN.+(frameptr,BitsN.B(0x10,32)),4),BitsN.B(0xC,4))
  ; write'LR(MemA 32 (BitsN.+(frameptr,BitsN.B(0x14,32)),4))
  ; write'PC(MemA 32 (BitsN.+(frameptr,BitsN.B(0x18,32)),4))
  ; let
      val psr = MemA 32 (BitsN.+(frameptr,BitsN.B(0x1C,32)),4)
      val spmask =
        BitsN.zeroExtend 32 (BitsN.@@(BitsN.bits(9,9) psr,BitsN.B(0x0,2)))
    in
      ( case boolify'4(BitsN.bits(3,0) EXC_RETURN) of
           (_,(false,(false,true))) =>
             write'SP_main
               (BitsN.||(BitsN.+(SP_main (),BitsN.B(0x20,32)),spmask))
         | (true,(true,(false,true))) =>
           write'SP_process
             (BitsN.||(BitsN.+(SP_process (),BitsN.B(0x20,32)),spmask))
         | _ => ()
      ; let
          val w = reg'PSR (!PSR)
        in
          PSR :=
          (write'reg'PSR
             ((!PSR),BitsN.bitFieldInsert(31,27) (w,BitsN.bits(31,27) psr)))
        end
      ; let
          val w = reg'PSR (!PSR)
        in
          PSR :=
          (write'reg'PSR
             ((!PSR),
              BitsN.bitFieldInsert(24,24)
                (w,BitsN.fromBit(BitsN.bit(psr,24)))))
        end
      ; let
          val w = reg'PSR (!PSR)
        in
          PSR :=
          (write'reg'PSR
             ((!PSR),BitsN.bitFieldInsert(5,0) (w,BitsN.bits(5,0) psr)))
        end
      )
    end
  );

fun DeActivate ReturningExceptionNumber =
  ExceptionActive :=
  (Map.update
     ((!ExceptionActive),BitsN.toNat ReturningExceptionNumber,false));

fun IsOnes N w = w = (BitsN.neg(BitsN.BV(0x1,N)));

fun ExceptionActiveBitCount () =
  let
    val count = ref 0
  in
    ( L3.for
        (0,63,
         fn i =>
           if Map.lookup
                ((!ExceptionActive),BitsN.toNat(BitsN.fromNat(i,6)))
             then count := (Nat.+((!count),1))
           else ())
    ; (!count)
    )
  end;

fun ExceptionReturn EXC_RETURN =
  ( if not((!CurrentMode) = Mode_Handler)
      then raise ASSERT ("CurrentMode == Mode_Handler")
    else ()
  ; if not(IsOnes 24 (BitsN.bits(27,4) EXC_RETURN))
      then raise UNPREDICTABLE ("ExceptionReturn")
    else ()
  ; let
      val ReturningExceptionNumber = #ExceptionNumber((!PSR) : PSR)
      val NestedActivation = ExceptionActiveBitCount ()
    in
      if not(Map.lookup
               ((!ExceptionActive),BitsN.toNat ReturningExceptionNumber))
        then raise UNPREDICTABLE ("ExceptionReturn")
      else let
             val frameptr = ref (BitsN.B(0x0,32))
           in
             ( case BitsN.bits(3,0) EXC_RETURN of
                  BitsN.B(0x1,_) =>
                    if NestedActivation = 1
                      then raise UNPREDICTABLE ("ExceptionReturn")
                    else ( frameptr := (SP_main ())
                         ; CurrentMode := Mode_Handler
                         ; CONTROL :=
                           (CONTROL_SPSEL_rupd((!CONTROL),false))
                         )
                | BitsN.B(0x9,_) =>
                  if not(NestedActivation = 1)
                    then raise UNPREDICTABLE ("ExceptionReturn")
                  else ( frameptr := (SP_main ())
                       ; CurrentMode := Mode_Thread
                       ; CONTROL := (CONTROL_SPSEL_rupd((!CONTROL),false))
                       )
                | BitsN.B(0xD,_) =>
                  if not(NestedActivation = 1)
                    then raise UNPREDICTABLE ("ExceptionReturn")
                  else ( frameptr := (SP_process ())
                       ; CurrentMode := Mode_Thread
                       ; CONTROL := (CONTROL_SPSEL_rupd((!CONTROL),true))
                       )
                | _ => raise UNPREDICTABLE ("ExceptionReturn")
             ; DeActivate ReturningExceptionNumber
             ; PopStack((!frameptr),EXC_RETURN)
             ; if (!CurrentMode) = Mode_Handler
                 then if (#ExceptionNumber((!PSR) : PSR)) =
                         (BitsN.B(0x0,6))
                        then raise UNPREDICTABLE ("ExceptionReturn")
                      else ()
               else if not((#ExceptionNumber((!PSR) : PSR)) =
                      (BitsN.B(0x0,6)))
                 then raise UNPREDICTABLE ("ExceptionReturn")
               else ()
             )
           end
    end
  );

fun CallSupervisor () = Raise SVCall;

fun BranchTo address = write'PC address;

fun BranchWritePC address =
  BranchTo(BitsN.@@(BitsN.bits(31,1) address,BitsN.B(0x0,1)));

fun BXWritePC address =
  if ((!CurrentMode) = Mode_Handler) andalso
     ((BitsN.bits(31,28) address) = (BitsN.B(0xF,4)))
    then ExceptionReturn(BitsN.bits(27,0) address)
  else ( if not(BitsN.bit(address,0)) then Raise HardFault else ()
       ; BranchTo(BitsN.@@(BitsN.bits(31,1) address,BitsN.B(0x0,1)))
       );

fun BLXWritePC address =
  ( if not(BitsN.bit(address,0)) then Raise HardFault else ()
  ; BranchTo(BitsN.@@(BitsN.bits(31,1) address,BitsN.B(0x0,1)))
  );

fun LoadWritePC address = BXWritePC address;

fun ALUWritePC address = BranchWritePC address;

fun IncPC () =
  BranchTo(BitsN.+(Map.lookup((!REG),Cast.RNameToNat RName_PC),(!pcinc)));

fun HighestSetBit N w =
  if w = (BitsN.BV(0x0,N)) then IntInf.~ 1 else BitsN.toInt(BitsN.log2 w);

fun CountLeadingZeroBits N w =
  Nat.fromInt
    (IntInf.-
       (IntInf.-(Nat.toInt(BitsN.size(BitsN.BV(0x0,N))),1),
        HighestSetBit N w));

fun LowestSetBit N w = CountLeadingZeroBits N (BitsN.reverse w);

fun BitCount N w =
  let
    val result = ref 0
  in
    ( L3.for
        (0,Nat.-(BitsN.size(BitsN.BV(0x0,N)),1),
         fn i =>
           if BitsN.bit(w,i) then result := (Nat.+((!result),1)) else ())
    ; (!result)
    )
  end;

fun SignExtendFrom N (w,p) =
  let
    val s = Nat.-(BitsN.size(BitsN.BV(0x0,N)),p)
  in
    BitsN.>>(BitsN.<<(w,s),s)
  end;

fun Extend (M,N) (unsigned,w) =
  if unsigned then BitsN.zeroExtend N w else BitsN.signExtend N w;

fun UInt N w = Nat.toInt(BitsN.toNat w);

fun LSL_C N (x,shift) =
  ( if shift = 0 then raise ASSERT ("LSL_C") else ()
  ; let
      val extended_x =
        (BitsN.toBitstring x) @ (Bitstring.replicate([false],shift))
    in
      (BitsN.<<(x,shift),
       Bitstring.bit(extended_x,BitsN.size(BitsN.BV(0x0,N))))
    end
  );

fun LSL N (x,shift) = if shift = 0 then x else L3.fst(LSL_C N (x,shift));

fun LSR_C N (x,shift) =
  ( if shift = 0 then raise ASSERT ("LSR_C") else ()
  ; (BitsN.>>+(x,shift),
     (Nat.<=(shift,BitsN.size(BitsN.BV(0x0,N)))) andalso
     (BitsN.bit(x,Nat.-(shift,1))))
  );

fun LSR N (x,shift) = if shift = 0 then x else L3.fst(LSR_C N (x,shift));

fun ASR_C N (x,shift) =
  ( if shift = 0 then raise ASSERT ("ASR_C") else ()
  ; (BitsN.>>(x,shift),
     BitsN.bit(x,Nat.-(Nat.min(BitsN.size(BitsN.BV(0x0,N)),shift),1)))
  );

fun ASR N (x,shift) = if shift = 0 then x else L3.fst(ASR_C N (x,shift));

fun ROR_C N (x,shift) =
  ( if shift = 0 then raise ASSERT ("ROR_C") else ()
  ; let val result = BitsN.#>>(x,shift) in (result,BitsN.msb result) end
  );

fun ROR N (x,shift) = if shift = 0 then x else L3.fst(ROR_C N (x,shift));

fun RRX_C N (x,carry_in) =
  let
    val result =
      BitsN.fromBitstring
        ((Bitstring.fromBool carry_in)
           @
           (Bitstring.bits(Nat.-(BitsN.size(BitsN.BV(0x0,N)),1),1)
              (BitsN.toBitstring x)),N)
  in
    (result,BitsN.bit(x,0))
  end;

fun RRX N (x,carry_in) = L3.fst(RRX_C N (x,carry_in));

fun DecodeImmShift (typ,imm5) =
  case typ of
     BitsN.B(0x0,_) => (SRType_LSL,BitsN.toNat imm5)
   | BitsN.B(0x1,_) =>
     (SRType_LSR,if imm5 = (BitsN.B(0x0,5)) then 32 else BitsN.toNat imm5)
   | BitsN.B(0x2,_) =>
     (SRType_ASR,if imm5 = (BitsN.B(0x0,5)) then 32 else BitsN.toNat imm5)
   | BitsN.B(0x3,_) =>
     if imm5 = (BitsN.B(0x0,5))
       then (SRType_RRX,1)
     else (SRType_ROR,BitsN.toNat imm5)
   | _ => raise General.Bind;

fun DecodeRegShift typ =
  case typ of
     BitsN.B(0x0,_) => SRType_LSL
   | BitsN.B(0x1,_) => SRType_LSR
   | BitsN.B(0x2,_) => SRType_ASR
   | BitsN.B(0x3,_) => SRType_ROR
   | _ => raise General.Bind;

fun Shift_C N (value,(typ,(amount,carry_in))) =
  if amount = 0
    then (value,carry_in)
  else case typ of
          SRType_LSL => LSL_C N (value,amount)
        | SRType_LSR => LSR_C N (value,amount)
        | SRType_ASR => ASR_C N (value,amount)
        | SRType_ROR => ROR_C N (value,amount)
        | SRType_RRX => RRX_C N (value,carry_in);

fun Shift N (value,(typ,(amount,carry_in))) =
  L3.fst(Shift_C N (value,(typ,(amount,carry_in))));

fun AddWithCarry N (x,(y,carry_in)) =
  let
    val unsigned_sum =
      Nat.+(Nat.+(BitsN.toNat x,BitsN.toNat y),Nat.fromBool carry_in)
    val signed_sum =
      IntInf.+
        (IntInf.+(BitsN.toInt x,BitsN.toInt y),IntExtra.fromBool carry_in)
    val result = BitsN.fromNat(unsigned_sum,N)
    val carry_out = not((BitsN.toNat result) = unsigned_sum)
    val overflow = not((BitsN.toInt result) = signed_sum)
  in
    (result,(carry_out,overflow))
  end;

fun DataProcessingALU (opc,(a,(b,c))) =
  case opc of
     BitsN.B(0x0,_) => (BitsN.&&(a,b),(c,false))
   | BitsN.B(0x8,_) => (BitsN.&&(a,b),(c,false))
   | BitsN.B(0x1,_) => (BitsN.??(a,b),(c,false))
   | BitsN.B(0x9,_) => (BitsN.??(a,b),(c,false))
   | BitsN.B(0x2,_) => AddWithCarry 32 (a,(BitsN.~ b,true))
   | BitsN.B(0xA,_) => AddWithCarry 32 (a,(BitsN.~ b,true))
   | BitsN.B(0x3,_) => AddWithCarry 32 (BitsN.~ a,(b,true))
   | BitsN.B(0x4,_) => AddWithCarry 32 (a,(b,false))
   | BitsN.B(0xB,_) => AddWithCarry 32 (a,(b,false))
   | BitsN.B(0x5,_) => AddWithCarry 32 (a,(b,c))
   | BitsN.B(0x6,_) => AddWithCarry 32 (a,(BitsN.~ b,c))
   | BitsN.B(0x7,_) => AddWithCarry 32 (BitsN.~ a,(b,c))
   | BitsN.B(0xC,_) => (BitsN.||(a,b),(c,false))
   | BitsN.B(0xD,_) => (b,(c,false))
   | BitsN.B(0xE,_) => (BitsN.&&(a,BitsN.~ b),(c,false))
   | BitsN.B(0xF,_) => (BitsN.~ b,(c,false))
   | _ => raise General.Bind;

fun ArithmeticOpcode opc =
  ((BitsN.bit(opc,2)) orelse (BitsN.bit(opc,1))) andalso
  (not((BitsN.bit(opc,3)) andalso (BitsN.bit(opc,2))));

fun dfn'BranchTarget imm32 =
  ( BranchWritePC(BitsN.+(PC (),imm32)); count := (Nat.+((!count),3)) );

fun dfn'BranchExchange m =
  ( BXWritePC(R m); count := (Nat.+((!count),3)) );

fun dfn'BranchLinkImmediate imm32 =
  let
    val next_instr_addr = PC ()
  in
    ( write'LR(BitsN.@@(BitsN.bits(31,1) next_instr_addr,BitsN.B(0x1,1)))
    ; BranchWritePC(BitsN.+(PC (),imm32))
    ; count := (Nat.+((!count),4))
    )
  end;

fun dfn'BranchLinkExchangeRegister m =
  let
    val target = R m
    val next_instr_addr = BitsN.-(PC (),BitsN.B(0x2,32))
  in
    ( write'LR(BitsN.@@(BitsN.bits(31,1) next_instr_addr,BitsN.B(0x1,1)))
    ; BLXWritePC target
    ; count := (Nat.+((!count),3))
    )
  end;

fun DataProcessing (opc,(setflags,(d,(n,(imm32,C))))) =
  let
    val rn =
      if (opc = (BitsN.B(0xD,4))) orelse (opc = (BitsN.B(0xF,4)))
        then BitsN.B(0x0,32)
      else if (Set.mem(opc,[BitsN.B(0x4,4),BitsN.B(0x2,4)])) andalso
         ((n = (BitsN.B(0xF,4))) andalso (not setflags))
        then Align 32 (PC (),4)
      else R n
    val (result,(carry,overflow)) = DataProcessingALU(opc,(rn,(imm32,C)))
  in
    ( if not((BitsN.bits(3,2) opc) = (BitsN.B(0x2,2)))
        then write'R(result,d)
      else ()
    ; if setflags
        then ( PSR := (PSR_N_rupd((!PSR),BitsN.bit(result,31)))
             ; PSR := (PSR_Z_rupd((!PSR),result = (BitsN.B(0x0,32))))
             ; PSR := (PSR_C_rupd((!PSR),carry))
             ; if ArithmeticOpcode opc
                 then PSR := (PSR_V_rupd((!PSR),overflow))
               else ()
             )
      else ()
    ; IncPC ()
    ; count := (Nat.+((!count),1))
    )
  end;

fun DataProcessingPC (opc,(n,(imm32,C))) =
  let
    val rn =
      if opc = (BitsN.B(0xD,4))
        then BitsN.B(0x0,32)
      else if n = (BitsN.B(0xF,4)) then PC () else R n
    val (result,(carry,overflow)) = DataProcessingALU(opc,(rn,(imm32,C)))
  in
    ( ALUWritePC result; count := (Nat.+((!count),3)) )
  end;

fun dfn'Move (d,imm32) =
  DataProcessing
    (BitsN.B(0xD,4),(true,(d,(BitsN.B(0xF,4),(imm32,#C((!PSR) : PSR))))));

fun dfn'CompareImmediate (n,imm32) =
  DataProcessing
    (BitsN.B(0xA,4),(true,(BitsN.B(0x0,4),(n,(imm32,#C((!PSR) : PSR))))));

fun dfn'ArithLogicImmediate (opc,(setflags,(d,(n,imm32)))) =
  DataProcessing(opc,(setflags,(d,(n,(imm32,#C((!PSR) : PSR))))));

fun doRegister (opc,(setflags,(d,(n,(m,(shift_t,shift_n)))))) =
  let
    val (shifted,carry) =
      Shift_C 32 (R m,(shift_t,(shift_n,#C((!PSR) : PSR))))
    val carry = if ArithmeticOpcode opc then #C((!PSR) : PSR) else carry
  in
    if d = (BitsN.B(0xF,4))
      then DataProcessingPC(opc,(n,(shifted,carry)))
    else DataProcessing(opc,(setflags,(d,(n,(shifted,carry)))))
  end;

fun dfn'Register (opc,(setflags,(d,(n,m)))) =
  doRegister(opc,(setflags,(d,(n,(m,(SRType_LSL,0))))));

fun dfn'TestCompareRegister (opc,(n,m)) =
  doRegister
    (BitsN.@@(BitsN.B(0x2,2),opc),
     (true,(BitsN.B(0x0,4),(n,(m,(SRType_LSL,0))))));

fun dfn'ShiftImmediate (negate,(setflags,(d,(m,(shift_t,shift_n))))) =
  if negate
    then doRegister
           (BitsN.B(0xF,4),
            (setflags,(d,(BitsN.B(0xF,4),(m,(shift_t,shift_n))))))
  else doRegister
         (BitsN.B(0xD,4),
          (setflags,(d,(BitsN.B(0x0,4),(m,(shift_t,shift_n))))));

fun dfn'ShiftRegister (d,(n,(shift_t,m))) =
  let
    val shift_n = BitsN.toNat(BitsN.bits(7,0) (R m))
    val (shifted,carry) =
      Shift_C 32 (R n,(shift_t,(shift_n,#C((!PSR) : PSR))))
  in
    DataProcessing
      (BitsN.B(0xD,4),(true,(d,(BitsN.B(0x0,4),(shifted,carry)))))
  end;

fun dfn'Multiply32 (d,(n,m)) =
  let
    val result = BitsN.*(R n,R m)
  in
    ( write'R(result,d)
    ; PSR := (PSR_N_rupd((!PSR),BitsN.bit(result,31)))
    ; PSR := (PSR_Z_rupd((!PSR),result = (BitsN.B(0x0,32))))
    ; IncPC ()
    ; count := (Nat.+((!count),1))
    )
  end;

fun dfn'ExtendByte (unsigned,(d,m)) =
  ( write'R(Extend (8,32) (unsigned,BitsN.bits(7,0) (R m)),d)
  ; IncPC ()
  ; count := (Nat.+((!count),1))
  );

fun dfn'ExtendHalfword (unsigned,(d,m)) =
  ( write'R(Extend (16,32) (unsigned,BitsN.bits(15,0) (R m)),d)
  ; IncPC ()
  ; count := (Nat.+((!count),1))
  );

fun dfn'ByteReverse (d,m) =
  let
    val Rm = R m
  in
    ( write'R
        (BitsN.concat
           [BitsN.bits(7,0) Rm,BitsN.bits(15,8) Rm,BitsN.bits(23,16) Rm,
            BitsN.bits(31,24) Rm],d)
    ; IncPC ()
    ; count := (Nat.+((!count),1))
    )
  end;

fun dfn'ByteReversePackedHalfword (d,m) =
  let
    val Rm = R m
  in
    ( write'R
        (BitsN.concat
           [BitsN.bits(23,16) Rm,BitsN.bits(31,24) Rm,BitsN.bits(7,0) Rm,
            BitsN.bits(15,8) Rm],d)
    ; IncPC ()
    ; count := (Nat.+((!count),1))
    )
  end;

fun dfn'ByteReverseSignedHalfword (d,m) =
  let
    val Rm = R m
  in
    ( write'R
        (BitsN.@@
           (BitsN.signExtend 24 (BitsN.bits(7,0) Rm),BitsN.bits(15,8) Rm),
         d)
    ; IncPC ()
    ; count := (Nat.+((!count),1))
    )
  end;

fun dfn'LoadWord (t,(n,m)) =
  let
    val offset =
      case m of
         register_form m =>
           Shift 32 (R m,(SRType_LSL,(0,#C((!PSR) : PSR))))
       | immediate_form imm32 => imm32
    val address = BitsN.+(R n,offset)
    val data = MemU 32 (address,4)
  in
    ( write'R(data,t); IncPC (); count := (Nat.+((!count),2)) )
  end;

fun dfn'LoadLiteral (t,imm32) =
  let
    val base = Align 32 (PC (),4)
    val address = BitsN.+(base,imm32)
  in
    ( write'R(MemU 32 (address,4),t)
    ; IncPC ()
    ; count := (Nat.+((!count),2))
    )
  end;

fun dfn'LoadByte (unsigned,(t,(n,m))) =
  let
    val offset =
      case m of
         register_form m =>
           Shift 32 (R m,(SRType_LSL,(0,#C((!PSR) : PSR))))
       | immediate_form imm32 => imm32
    val address = BitsN.+(R n,offset)
    val data = MemU 8 (address,1)
  in
    ( write'R(Extend (8,32) (unsigned,data),t)
    ; IncPC ()
    ; count := (Nat.+((!count),2))
    )
  end;

fun dfn'LoadHalf (unsigned,(t,(n,m))) =
  let
    val Rn = R n
    val offset =
      case m of
         register_form m =>
           Shift 32 (R m,(SRType_LSL,(0,#C((!PSR) : PSR))))
       | immediate_form imm32 => imm32
    val address = BitsN.+(R n,offset)
    val data = MemU 16 (address,2)
  in
    ( write'R(Extend (16,32) (unsigned,data),t)
    ; IncPC ()
    ; count := (Nat.+((!count),2))
    )
  end;

fun dfn'LoadMultiple (wback,(n,registers)) =
  let
    val Rn = R n
    val bitcount = BitCount 9 registers
  in
    let
      val address = ref Rn
    in
      ( L3.for
          (0,7,
           fn i =>
             if BitsN.bit(registers,i)
               then ( let
                        val x = BitsN.fromNat(i,4)
                      in
                        write'R(MemA 32 ((!address),4),x)
                      end
                    ; address := (BitsN.+((!address),BitsN.B(0x4,32)))
                    )
             else ())
      ; if BitsN.bit(registers,8)
          then ( LoadWritePC(MemA 32 ((!address),4))
               ; count := (Nat.+(Nat.+((!count),bitcount),4))
               )
        else ( IncPC (); count := (Nat.+(Nat.+((!count),bitcount),1)) )
      ; if wback andalso (not(BitsN.bit(registers,BitsN.toNat n)))
          then write'R
                 (BitsN.+
                    (Rn,
                     BitsN.*(BitsN.B(0x4,32),BitsN.fromNat(bitcount,32))),
                  n)
        else ()
      )
    end
  end;

fun dfn'StoreWord (t,(n,m)) =
  let
    val offset =
      case m of
         register_form m =>
           Shift 32 (R m,(SRType_LSL,(0,#C((!PSR) : PSR))))
       | immediate_form imm32 => imm32
    val address = BitsN.+(R n,offset)
  in
    ( let val x = (address,4) in write'MemU 32 (R t,x) end
    ; IncPC ()
    ; count := (Nat.+((!count),2))
    )
  end;

fun dfn'StoreByte (t,(n,m)) =
  let
    val offset =
      case m of
         register_form m =>
           Shift 32 (R m,(SRType_LSL,(0,#C((!PSR) : PSR))))
       | immediate_form imm32 => imm32
    val address = BitsN.+(R n,offset)
  in
    ( let
        val x = (address,1)
      in
        write'MemU 8 (BitsN.bits(7,0) (R t),x)
      end
    ; IncPC ()
    ; count := (Nat.+((!count),2))
    )
  end;

fun dfn'StoreHalf (t,(n,m)) =
  let
    val offset =
      case m of
         register_form m =>
           Shift 32 (R m,(SRType_LSL,(0,#C((!PSR) : PSR))))
       | immediate_form imm32 => imm32
    val address = BitsN.+(R n,offset)
  in
    ( let
        val x = (address,2)
      in
        write'MemU 16 (BitsN.bits(15,0) (R t),x)
      end
    ; IncPC ()
    ; count := (Nat.+((!count),2))
    )
  end;

fun dfn'StoreMultiple (n,registers) =
  let
    val Rn = R n
    val bitcount = BitCount 8 registers
    val lowest = LowestSetBit 8 registers
  in
    let
      val address = ref Rn
    in
      ( L3.for
          (0,7,
           fn i =>
             if BitsN.bit(registers,i)
               then ( if ((BitsN.fromNat(i,4)) = n) andalso
                         (not(i = lowest))
                        then let
                               val x = ((!address),4)
                             in
                               write'MemA 32 (BitsN.B(0x0,32),x)
                             end
                      else let
                             val x = ((!address),4)
                           in
                             write'MemA 32 (R(BitsN.fromNat(i,4)),x)
                           end
                    ; address := (BitsN.+((!address),BitsN.B(0x4,32)))
                    )
             else ())
      ; write'R
          (BitsN.+(Rn,BitsN.*(BitsN.B(0x4,32),BitsN.fromNat(bitcount,32))),
           n)
      ; IncPC ()
      ; count := (Nat.+(Nat.+((!count),bitcount),1))
      )
    end
  end;

fun dfn'Push registers =
  let
    val sp = SP ()
    val bitcount = BitCount 9 registers
    val length = BitsN.*(BitsN.B(0x4,32),BitsN.fromNat(bitcount,32))
  in
    let
      val address = ref (BitsN.-(sp,length))
    in
      ( L3.for
          (0,8,
           fn i =>
             if BitsN.bit(registers,i)
               then ( let
                        val x = ((!address),4)
                      in
                        write'MemA 32
                          (if i = 8 then LR () else R(BitsN.fromNat(i,4)),
                           x)
                      end
                    ; address := (BitsN.+((!address),BitsN.B(0x4,32)))
                    )
             else ())
      ; write'SP(BitsN.-(sp,length))
      ; IncPC ()
      ; count := (Nat.+(Nat.+((!count),bitcount),1))
      )
    end
  end;

fun dfn'SupervisorCall imm32 =
  ( CallSupervisor (); count := (Nat.+((!count),0)) );

fun dfn'ChangeProcessorState im =
  ( if CurrentModeIsPrivileged ()
      then PRIMASK := (PRIMASK_PM_rupd((!PRIMASK),im))
    else ()
  ; IncPC ()
  ; count := (Nat.+((!count),1))
  );

fun dfn'MoveToRegisterFromSpecial (SYSm,d) =
  ( write'R(BitsN.B(0x0,32),d)
  ; case BitsN.bits(7,3) SYSm of
       BitsN.B(0x0,_) =>
         ( if BitsN.bit(SYSm,0)
             then let
                    val w = R d
                  in
                    write'R
                      (BitsN.bitFieldInsert(8,0)
                         (w,BitsN.bits(8,0) (reg'PSR (!PSR))),d)
                  end
           else ()
         ; if BitsN.bit(SYSm,1)
             then let
                    val w = R d
                  in
                    write'R
                      (BitsN.bitFieldInsert(24,24) (w,BitsN.fromBit false),
                       d)
                  end
           else ()
         ; if not(BitsN.bit(SYSm,2))
             then let
                    val w = R d
                  in
                    write'R
                      (BitsN.bitFieldInsert(31,27)
                         (w,BitsN.bits(31,27) (reg'PSR (!PSR))),d)
                  end
           else ()
         )
     | BitsN.B(0x1,_) =>
       (case BitsN.bits(2,0) SYSm of
           BitsN.B(0x0,_) => write'R(SP_main (),d)
         | BitsN.B(0x1,_) => write'R(SP_process (),d)
         | _ => ())
     | BitsN.B(0x2,_) =>
       (case BitsN.bits(2,0) SYSm of
           BitsN.B(0x0,_) =>
             let
               val w = R d
             in
               write'R
                 (BitsN.bitFieldInsert(0,0)
                    (w,BitsN.fromBit(#PM((!PRIMASK) : PRIMASK))),d)
             end
         | BitsN.B(0x4,_) =>
           let
             val w = R d
           in
             write'R
               (BitsN.bitFieldInsert(1,0)
                  (w,BitsN.bits(1,0) (reg'CONTROL (!CONTROL))),d)
           end
         | _ => ())
     | _ => ()
  ; IncPC ()
  ; count := (Nat.+((!count),4))
  );

fun dfn'MoveToSpecialRegister (SYSm,n) =
  let
    val Rn = R n
  in
    ( case BitsN.bits(7,3) SYSm of
         BitsN.B(0x0,_) =>
           if not(BitsN.bit(SYSm,2))
             then let
                    val w = reg'PSR (!PSR)
                  in
                    PSR :=
                    (write'reg'PSR
                       ((!PSR),
                        BitsN.bitFieldInsert(31,27)
                          (w,BitsN.bits(31,27) Rn)))
                  end
           else ()
       | BitsN.B(0x1,_) =>
         if CurrentModeIsPrivileged ()
           then case BitsN.bits(2,0) SYSm of
                   BitsN.B(0x0,_) =>
                     write'SP_main
                       (BitsN.@@(BitsN.bits(31,2) Rn,BitsN.B(0x0,2)))
                 | BitsN.B(0x1,_) =>
                   write'SP_process
                     (BitsN.@@(BitsN.bits(31,2) Rn,BitsN.B(0x0,2)))
                 | _ => ()
         else ()
       | BitsN.B(0x2,_) =>
         if CurrentModeIsPrivileged ()
           then case BitsN.bits(2,0) SYSm of
                   BitsN.B(0x0,_) =>
                     PRIMASK :=
                     (PRIMASK_PM_rupd((!PRIMASK),BitsN.bit(Rn,0)))
                 | BitsN.B(0x4,_) =>
                   if (!CurrentMode) = Mode_Thread
                     then ( CONTROL :=
                            (CONTROL_SPSEL_rupd
                               ((!CONTROL),BitsN.bit(Rn,1)))
                          ; CONTROL :=
                            (CONTROL_nPRIV_rupd
                               ((!CONTROL),BitsN.bit(Rn,0)))
                          )
                   else ()
                 | _ => ()
         else ()
       | _ => ()
    ; IncPC ()
    ; count := (Nat.+((!count),4))
    )
  end;

fun dfn'Undefined imm32 = Raise HardFault;

fun dfn'NoOperation () = ( IncPC (); count := (Nat.+((!count),1)) );

fun dfn'Breakpoint imm32 = ( IncPC (); count := (Nat.+((!count),0)) );

fun dfn'DataMemoryBarrier option =
  ( IncPC (); count := (Nat.+((!count),4)) );

fun dfn'DataSynchronizationBarrier option =
  ( IncPC (); count := (Nat.+((!count),4)) );

fun dfn'InstructionSynchronizationBarrier option =
  ( IncPC (); count := (Nat.+((!count),4)) );

fun dfn'SendEvent () = ( IncPC (); count := (Nat.+((!count),1)) );

fun dfn'WaitForEvent () = ( IncPC (); count := (Nat.+((!count),2)) );

fun dfn'WaitForInterrupt () = ( IncPC (); count := (Nat.+((!count),2)) );

fun dfn'Yield () = ( IncPC (); count := (Nat.+((!count),1)) );

fun Run v0 =
  case v0 of
     NoOperation () => dfn'NoOperation ()
   | Undefined v49 => dfn'Undefined v49
   | Branch v1 =>
     (case v1 of
         BranchExchange v2 => dfn'BranchExchange v2
       | BranchLinkExchangeRegister v3 =>
         dfn'BranchLinkExchangeRegister v3
       | BranchLinkImmediate v4 => dfn'BranchLinkImmediate v4
       | BranchTarget v5 => dfn'BranchTarget v5)
   | Data v6 =>
     (case v6 of
         ArithLogicImmediate v7 => dfn'ArithLogicImmediate v7
       | CompareImmediate v8 => dfn'CompareImmediate v8
       | Move v9 => dfn'Move v9
       | Register v10 => dfn'Register v10
       | ShiftImmediate v11 => dfn'ShiftImmediate v11
       | ShiftRegister v12 => dfn'ShiftRegister v12
       | TestCompareRegister v13 => dfn'TestCompareRegister v13)
   | Hint v14 =>
     (case v14 of
         Breakpoint v15 => dfn'Breakpoint v15
       | DataMemoryBarrier v16 => dfn'DataMemoryBarrier v16
       | DataSynchronizationBarrier v17 =>
         dfn'DataSynchronizationBarrier v17
       | InstructionSynchronizationBarrier v18 =>
         dfn'InstructionSynchronizationBarrier v18
       | SendEvent () => dfn'SendEvent ()
       | WaitForEvent () => dfn'WaitForEvent ()
       | WaitForInterrupt () => dfn'WaitForInterrupt ()
       | Yield () => dfn'Yield ())
   | Load v23 =>
     (case v23 of
         LoadByte v24 => dfn'LoadByte v24
       | LoadHalf v25 => dfn'LoadHalf v25
       | LoadLiteral v26 => dfn'LoadLiteral v26
       | LoadMultiple v27 => dfn'LoadMultiple v27
       | LoadWord v28 => dfn'LoadWord v28)
   | Media v29 =>
     (case v29 of
         ByteReverse v30 => dfn'ByteReverse v30
       | ByteReversePackedHalfword v31 =>
         dfn'ByteReversePackedHalfword v31
       | ByteReverseSignedHalfword v32 =>
         dfn'ByteReverseSignedHalfword v32
       | ExtendByte v33 => dfn'ExtendByte v33
       | ExtendHalfword v34 => dfn'ExtendHalfword v34)
   | Multiply v35 => (case v35 of Multiply32 v36 => dfn'Multiply32 v36)
   | Store v37 =>
     (case v37 of
         Push v38 => dfn'Push v38
       | StoreByte v39 => dfn'StoreByte v39
       | StoreHalf v40 => dfn'StoreHalf v40
       | StoreMultiple v41 => dfn'StoreMultiple v41
       | StoreWord v42 => dfn'StoreWord v42)
   | System v43 =>
     (case v43 of
         ChangeProcessorState v44 => dfn'ChangeProcessorState v44
       | MoveToRegisterFromSpecial v45 =>
         dfn'MoveToRegisterFromSpecial v45
       | MoveToSpecialRegister v46 => dfn'MoveToSpecialRegister v46
       | SupervisorCall v47 => dfn'SupervisorCall v47);

fun Fetch () =
  let
    val fpc = Map.lookup((!REG),Cast.RNameToNat RName_PC)
    val ireg = MemA 16 (fpc,2)
  in
    if ((BitsN.bits(15,13) ireg) = (BitsN.B(0x7,3))) andalso
       (not((BitsN.bits(12,11) ireg) = (BitsN.B(0x0,2))))
      then Thumb2(ireg,MemA 16 (BitsN.+(fpc,BitsN.B(0x2,32)),2))
    else Thumb ireg
  end;

fun DECODE_UNPREDICTABLE (mc,s) =
  raise UNPREDICTABLE
    (String.concat
       ["Decode ",
        case mc of
           Thumb opc =>
             (Bitstring.toBinString(BitsN.toBitstring opc))
               ^
               ("; Thumb; ")
         | Thumb2(opc1,opc2) =>
           String.concat
             [Bitstring.toBinString(BitsN.toBitstring opc1),", ",
              Bitstring.toBinString(BitsN.toBitstring opc2),"; Thumb2; "],
        s]);

fun DecodeThumb h =
  let
    val mc = Thumb h
  in
    case boolify'16 h of
       (false,
        (false,
         (false,
          (true,
           (true,
            (false,
             (S'0,
              (Rm'2,(Rm'1,(Rm'0,(Rn'2,(Rn'1,(Rn'0,(Rd'2,(Rd'1,Rd'0))))))))))))))) =>
         let
           val d =
             BitsN.fromNat
               (BitsN.toNat(BitsN.fromBitstring([Rd'2,Rd'1,Rd'0],3)),4)
           val n =
             BitsN.fromNat
               (BitsN.toNat(BitsN.fromBitstring([Rn'2,Rn'1,Rn'0],3)),4)
           val m =
             BitsN.fromNat
               (BitsN.toNat(BitsN.fromBitstring([Rm'2,Rm'1,Rm'0],3)),4)
           val setflags = true
           val opc =
             if (BitsN.fromBitstring([S'0],1)) = (BitsN.B(0x1,1))
               then BitsN.B(0x2,4)
             else BitsN.B(0x4,4)
         in
           Data(Register(opc,(setflags,(d,(n,m)))))
         end
     | (false,
      (false,
       (false,
        (true,
         (true,
          (true,
           (S'0,
            (imm3'2,
             (imm3'1,(imm3'0,(Rn'2,(Rn'1,(Rn'0,(Rd'2,(Rd'1,Rd'0))))))))))))))) =>
       let
         val d =
           BitsN.fromNat
             (BitsN.toNat(BitsN.fromBitstring([Rd'2,Rd'1,Rd'0],3)),4)
         val n =
           BitsN.fromNat
             (BitsN.toNat(BitsN.fromBitstring([Rn'2,Rn'1,Rn'0],3)),4)
         val setflags = true
         val imm32 =
           BitsN.zeroExtend 32
             (BitsN.fromBitstring([imm3'2,imm3'1,imm3'0],3))
         val opc =
           if (BitsN.fromBitstring([S'0],1)) = (BitsN.B(0x1,1))
             then BitsN.B(0x2,4)
           else BitsN.B(0x4,4)
       in
         Data(ArithLogicImmediate(opc,(setflags,(d,(n,imm32)))))
       end
     | (false,
      (false,
       (false,
        (opc'1,
         (opc'0,
          (imm5'4,
           (imm5'3,
            (imm5'2,
             (imm5'1,(imm5'0,(Rm'2,(Rm'1,(Rm'0,(Rd'2,(Rd'1,Rd'0))))))))))))))) =>
       let
         val d =
           BitsN.fromNat
             (BitsN.toNat(BitsN.fromBitstring([Rd'2,Rd'1,Rd'0],3)),4)
         val m =
           BitsN.fromNat
             (BitsN.toNat(BitsN.fromBitstring([Rm'2,Rm'1,Rm'0],3)),4)
         val setflags = true
         val (shift_t,shift_n) =
           DecodeImmShift
             (BitsN.fromBitstring([opc'1,opc'0],2),
              BitsN.fromBitstring([imm5'4,imm5'3,imm5'2,imm5'1,imm5'0],5))
       in
         Data(ShiftImmediate(false,(setflags,(d,(m,(shift_t,shift_n))))))
       end
     | (false,
      (false,
       (true,
        (false,
         (false,
          (Rd'2,
           (Rd'1,
            (Rd'0,
             (imm8'7,
              (imm8'6,(imm8'5,(imm8'4,(imm8'3,(imm8'2,(imm8'1,imm8'0))))))))))))))) =>
       let
         val d =
           BitsN.fromNat
             (BitsN.toNat(BitsN.fromBitstring([Rd'2,Rd'1,Rd'0],3)),4)
         val imm32 =
           BitsN.zeroExtend 32
             (BitsN.fromBitstring
                ([imm8'7,imm8'6,imm8'5,imm8'4,imm8'3,imm8'2,imm8'1,imm8'0],
                 8))
       in
         Data(Move(d,imm32))
       end
     | (false,
      (false,
       (true,
        (false,
         (true,
          (Rn'2,
           (Rn'1,
            (Rn'0,
             (imm8'7,
              (imm8'6,(imm8'5,(imm8'4,(imm8'3,(imm8'2,(imm8'1,imm8'0))))))))))))))) =>
       let
         val n =
           BitsN.fromNat
             (BitsN.toNat(BitsN.fromBitstring([Rn'2,Rn'1,Rn'0],3)),4)
         val imm32 =
           BitsN.zeroExtend 32
             (BitsN.fromBitstring
                ([imm8'7,imm8'6,imm8'5,imm8'4,imm8'3,imm8'2,imm8'1,imm8'0],
                 8))
       in
         Data(CompareImmediate(n,imm32))
       end
     | (false,
      (false,
       (true,
        (true,
         (S'0,
          (Rdn'2,
           (Rdn'1,
            (Rdn'0,
             (imm8'7,
              (imm8'6,(imm8'5,(imm8'4,(imm8'3,(imm8'2,(imm8'1,imm8'0))))))))))))))) =>
       let
         val d =
           BitsN.fromNat
             (BitsN.toNat(BitsN.fromBitstring([Rdn'2,Rdn'1,Rdn'0],3)),4)
         val n = d
         val setflags = true
         val imm32 =
           BitsN.zeroExtend 32
             (BitsN.fromBitstring
                ([imm8'7,imm8'6,imm8'5,imm8'4,imm8'3,imm8'2,imm8'1,imm8'0],
                 8))
         val opc =
           if (BitsN.fromBitstring([S'0],1)) = (BitsN.B(0x1,1))
             then BitsN.B(0x2,4)
           else BitsN.B(0x4,4)
       in
         Data(ArithLogicImmediate(opc,(setflags,(d,(n,imm32)))))
       end
     | (false,
      (true,
       (false,
        (false,
         (false,
          (false,
           (opc'3,
            (opc'2,(opc'1,(opc'0,(Rx'2,(Rx'1,(Rx'0,(Ry'2,(Ry'1,Ry'0))))))))))))))) =>
       let
         val Ry = BitsN.fromBitstring([Ry'2,Ry'1,Ry'0],3)
         val Rx = BitsN.fromBitstring([Rx'2,Rx'1,Rx'0],3)
         val opc = BitsN.fromBitstring([opc'3,opc'2,opc'1,opc'0],4)
       in
         case opc of
            BitsN.B(0x0,_) =>
              let
                val d = BitsN.fromNat(BitsN.toNat Ry,4)
                val n = d
                val m = BitsN.fromNat(BitsN.toNat Rx,4)
                val setflags = true
              in
                Data(Register(opc,(setflags,(d,(n,m)))))
              end
          | BitsN.B(0x1,_) =>
            let
              val d = BitsN.fromNat(BitsN.toNat Ry,4)
              val n = d
              val m = BitsN.fromNat(BitsN.toNat Rx,4)
              val setflags = true
            in
              Data(Register(opc,(setflags,(d,(n,m)))))
            end
          | BitsN.B(0x5,_) =>
            let
              val d = BitsN.fromNat(BitsN.toNat Ry,4)
              val n = d
              val m = BitsN.fromNat(BitsN.toNat Rx,4)
              val setflags = true
            in
              Data(Register(opc,(setflags,(d,(n,m)))))
            end
          | BitsN.B(0x6,_) =>
            let
              val d = BitsN.fromNat(BitsN.toNat Ry,4)
              val n = d
              val m = BitsN.fromNat(BitsN.toNat Rx,4)
              val setflags = true
            in
              Data(Register(opc,(setflags,(d,(n,m)))))
            end
          | BitsN.B(0xC,_) =>
            let
              val d = BitsN.fromNat(BitsN.toNat Ry,4)
              val n = d
              val m = BitsN.fromNat(BitsN.toNat Rx,4)
              val setflags = true
            in
              Data(Register(opc,(setflags,(d,(n,m)))))
            end
          | BitsN.B(0xE,_) =>
            let
              val d = BitsN.fromNat(BitsN.toNat Ry,4)
              val n = d
              val m = BitsN.fromNat(BitsN.toNat Rx,4)
              val setflags = true
            in
              Data(Register(opc,(setflags,(d,(n,m)))))
            end
          | BitsN.B(0x2,_) =>
            let
              val d = BitsN.fromNat(BitsN.toNat Ry,4)
              val n = d
              val m = BitsN.fromNat(BitsN.toNat Rx,4)
              val shift_t =
                DecodeRegShift
                  (BitsN.fromNat
                     (BitsN.toNat(BitsN.-(opc,BitsN.B(0x2,4))),2))
            in
              Data(ShiftRegister(d,(n,(shift_t,m))))
            end
          | BitsN.B(0x3,_) =>
            let
              val d = BitsN.fromNat(BitsN.toNat Ry,4)
              val n = d
              val m = BitsN.fromNat(BitsN.toNat Rx,4)
              val shift_t =
                DecodeRegShift
                  (BitsN.fromNat
                     (BitsN.toNat(BitsN.-(opc,BitsN.B(0x2,4))),2))
            in
              Data(ShiftRegister(d,(n,(shift_t,m))))
            end
          | BitsN.B(0x4,_) =>
            let
              val d = BitsN.fromNat(BitsN.toNat Ry,4)
              val n = d
              val m = BitsN.fromNat(BitsN.toNat Rx,4)
              val shift_t =
                DecodeRegShift
                  (BitsN.fromNat
                     (BitsN.toNat(BitsN.-(opc,BitsN.B(0x2,4))),2))
            in
              Data(ShiftRegister(d,(n,(shift_t,m))))
            end
          | BitsN.B(0x7,_) =>
            let
              val d = BitsN.fromNat(BitsN.toNat Ry,4)
              val n = d
              val m = BitsN.fromNat(BitsN.toNat Rx,4)
            in
              Data(ShiftRegister(d,(n,(SRType_ROR,m))))
            end
          | BitsN.B(0x8,_) =>
            let
              val n = BitsN.fromNat(BitsN.toNat Ry,4)
              val m = BitsN.fromNat(BitsN.toNat Rx,4)
            in
              Data(TestCompareRegister(BitsN.bits(1,0) opc,(n,m)))
            end
          | BitsN.B(0xA,_) =>
            let
              val n = BitsN.fromNat(BitsN.toNat Ry,4)
              val m = BitsN.fromNat(BitsN.toNat Rx,4)
            in
              Data(TestCompareRegister(BitsN.bits(1,0) opc,(n,m)))
            end
          | BitsN.B(0xB,_) =>
            let
              val n = BitsN.fromNat(BitsN.toNat Ry,4)
              val m = BitsN.fromNat(BitsN.toNat Rx,4)
            in
              Data(TestCompareRegister(BitsN.bits(1,0) opc,(n,m)))
            end
          | BitsN.B(0x9,_) =>
            let
              val d = BitsN.fromNat(BitsN.toNat Ry,4)
              val n = BitsN.fromNat(BitsN.toNat Rx,4)
              val setflags = true
            in
              Data
                (ArithLogicImmediate
                   (BitsN.B(0x3,4),(setflags,(d,(n,BitsN.B(0x0,32))))))
            end
          | BitsN.B(0xD,_) =>
            let
              val d = BitsN.fromNat(BitsN.toNat Ry,4)
              val n = BitsN.fromNat(BitsN.toNat Rx,4)
              val m = d
            in
              Multiply(Multiply32(d,(n,m)))
            end
          | BitsN.B(0xF,_) =>
            let
              val d = BitsN.fromNat(BitsN.toNat Ry,4)
              val m = BitsN.fromNat(BitsN.toNat Rx,4)
              val setflags = true
              val (shift_t,shift_n) = (SRType_LSL,0)
            in
              Data
                (ShiftImmediate(true,(setflags,(d,(m,(shift_t,shift_n))))))
            end
          | _ => raise General.Bind
       end
     | (false,
      (true,
       (false,
        (false,
         (false,
          (true,
           (false,
            (false,
             (DN'0,(Rm'3,(Rm'2,(Rm'1,(Rm'0,(Rdn'2,(Rdn'1,Rdn'0))))))))))))))) =>
       let
         val Rm = BitsN.fromBitstring([Rm'3,Rm'2,Rm'1,Rm'0],4)
         val d =
           BitsN.@@
             (BitsN.fromBitstring([DN'0],1),
              BitsN.fromBitstring([Rdn'2,Rdn'1,Rdn'0],3))
         val n = d
       in
         ( if (n = (BitsN.B(0xF,4))) andalso (Rm = (BitsN.B(0xF,4)))
             then DECODE_UNPREDICTABLE(mc,"ADD")
           else ()
         ; let
             val setflags = false
           in
             Data(Register(BitsN.B(0x4,4),(setflags,(d,(n,Rm)))))
           end
         )
       end
     | (false,
      (true,
       (false,
        (false,
         (false,
          (true,
           (false,
            (true,(N'0,(Rm'3,(Rm'2,(Rm'1,(Rm'0,(Rn'2,(Rn'1,Rn'0))))))))))))))) =>
       let
         val Rm = BitsN.fromBitstring([Rm'3,Rm'2,Rm'1,Rm'0],4)
         val n =
           BitsN.@@
             (BitsN.fromBitstring([N'0],1),
              BitsN.fromBitstring([Rn'2,Rn'1,Rn'0],3))
       in
         ( if ((BitsN.<+(n,BitsN.B(0x8,4))) andalso
               (BitsN.<+(Rm,BitsN.B(0x8,4)))) orelse
              ((n = (BitsN.B(0xF,4))) orelse (Rm = (BitsN.B(0xF,4))))
             then DECODE_UNPREDICTABLE(mc,"CMP")
           else ()
         ; Data(TestCompareRegister(BitsN.B(0x2,2),(n,Rm)))
         )
       end
     | (false,
      (true,
       (false,
        (false,
         (false,
          (true,
           (true,
            (false,(D'0,(Rm'3,(Rm'2,(Rm'1,(Rm'0,(Rd'2,(Rd'1,Rd'0))))))))))))))) =>
       let
         val d =
           BitsN.@@
             (BitsN.fromBitstring([D'0],1),
              BitsN.fromBitstring([Rd'2,Rd'1,Rd'0],3))
         val setflags = false
         val (shift_t,shift_n) = (SRType_LSL,0)
       in
         Data
           (ShiftImmediate
              (false,
               (setflags,
                (d,
                 (BitsN.fromBitstring([Rm'3,Rm'2,Rm'1,Rm'0],4),
                  (shift_t,shift_n))))))
       end
     | (false,
      (true,
       (false,
        (false,
         (false,(true,(true,(true,(false,(Rm'3,(Rm'2,(Rm'1,(Rm'0,_))))))))))))) =>
       Branch
         (BranchExchange(BitsN.fromBitstring([Rm'3,Rm'2,Rm'1,Rm'0],4)))
     | (false,
      (true,
       (false,
        (false,
         (false,(true,(true,(true,(true,(Rm'3,(Rm'2,(Rm'1,(Rm'0,_))))))))))))) =>
       Branch
         (BranchLinkExchangeRegister
            (BitsN.fromBitstring([Rm'3,Rm'2,Rm'1,Rm'0],4)))
     | (false,
      (true,
       (false,
        (false,
         (true,
          (Rt'2,
           (Rt'1,
            (Rt'0,
             (imm8'7,
              (imm8'6,(imm8'5,(imm8'4,(imm8'3,(imm8'2,(imm8'1,imm8'0))))))))))))))) =>
       let
         val imm32 =
           BitsN.zeroExtend 32
             (BitsN.@@
                (BitsN.fromBitstring
                   ([imm8'7,imm8'6,imm8'5,imm8'4,imm8'3,imm8'2,imm8'1,
                     imm8'0],8),BitsN.B(0x0,2)))
       in
         Load
           (LoadLiteral
              (BitsN.fromNat
                 (BitsN.toNat(BitsN.fromBitstring([Rt'2,Rt'1,Rt'0],3)),4),
               imm32))
       end
     | (false,
      (true,
       (false,
        (true,
         (opc'2,
          (opc'1,
           (opc'0,
            (Rm'2,(Rm'1,(Rm'0,(Rn'2,(Rn'1,(Rn'0,(Rt'2,(Rt'1,Rt'0))))))))))))))) =>
       let
         val Rt = BitsN.fromBitstring([Rt'2,Rt'1,Rt'0],3)
         val Rn = BitsN.fromBitstring([Rn'2,Rn'1,Rn'0],3)
         val m =
           register_form
             (BitsN.fromNat
                (BitsN.toNat(BitsN.fromBitstring([Rm'2,Rm'1,Rm'0],3)),4))
       in
         case BitsN.fromBitstring([opc'2,opc'1,opc'0],3) of
            BitsN.B(0x0,_) =>
              Store
                (StoreWord
                   (BitsN.fromNat(BitsN.toNat Rt,4),
                    (BitsN.fromNat(BitsN.toNat Rn,4),m)))
          | BitsN.B(0x1,_) =>
            Store
              (StoreHalf
                 (BitsN.fromNat(BitsN.toNat Rt,4),
                  (BitsN.fromNat(BitsN.toNat Rn,4),m)))
          | BitsN.B(0x2,_) =>
            Store
              (StoreByte
                 (BitsN.fromNat(BitsN.toNat Rt,4),
                  (BitsN.fromNat(BitsN.toNat Rn,4),m)))
          | BitsN.B(0x3,_) =>
            Load
              (LoadByte
                 (false,
                  (BitsN.fromNat(BitsN.toNat Rt,4),
                   (BitsN.fromNat(BitsN.toNat Rn,4),m))))
          | BitsN.B(0x4,_) =>
            Load
              (LoadWord
                 (BitsN.fromNat(BitsN.toNat Rt,4),
                  (BitsN.fromNat(BitsN.toNat Rn,4),m)))
          | BitsN.B(0x5,_) =>
            Load
              (LoadHalf
                 (true,
                  (BitsN.fromNat(BitsN.toNat Rt,4),
                   (BitsN.fromNat(BitsN.toNat Rn,4),m))))
          | BitsN.B(0x6,_) =>
            Load
              (LoadByte
                 (true,
                  (BitsN.fromNat(BitsN.toNat Rt,4),
                   (BitsN.fromNat(BitsN.toNat Rn,4),m))))
          | BitsN.B(0x7,_) =>
            Load
              (LoadHalf
                 (false,
                  (BitsN.fromNat(BitsN.toNat Rt,4),
                   (BitsN.fromNat(BitsN.toNat Rn,4),m))))
          | _ => raise General.Bind
       end
     | (false,
      (true,
       (true,
        (false,
         (L'0,
          (imm5'4,
           (imm5'3,
            (imm5'2,
             (imm5'1,(imm5'0,(Rn'2,(Rn'1,(Rn'0,(Rt'2,(Rt'1,Rt'0))))))))))))))) =>
       let
         val Rt = BitsN.fromBitstring([Rt'2,Rt'1,Rt'0],3)
         val Rn = BitsN.fromBitstring([Rn'2,Rn'1,Rn'0],3)
         val imm32 =
           BitsN.zeroExtend 32
             (BitsN.@@
                (BitsN.fromBitstring
                   ([imm5'4,imm5'3,imm5'2,imm5'1,imm5'0],5),BitsN.B(0x0,2)))
         val m = immediate_form imm32
       in
         if (BitsN.fromBitstring([L'0],1)) = (BitsN.B(0x1,1))
           then Load
                  (LoadWord
                     (BitsN.fromNat(BitsN.toNat Rt,4),
                      (BitsN.fromNat(BitsN.toNat Rn,4),m)))
         else Store
                (StoreWord
                   (BitsN.fromNat(BitsN.toNat Rt,4),
                    (BitsN.fromNat(BitsN.toNat Rn,4),m)))
       end
     | (false,
      (true,
       (true,
        (true,
         (L'0,
          (imm5'4,
           (imm5'3,
            (imm5'2,
             (imm5'1,(imm5'0,(Rn'2,(Rn'1,(Rn'0,(Rt'2,(Rt'1,Rt'0))))))))))))))) =>
       let
         val Rt = BitsN.fromBitstring([Rt'2,Rt'1,Rt'0],3)
         val Rn = BitsN.fromBitstring([Rn'2,Rn'1,Rn'0],3)
         val imm32 =
           BitsN.zeroExtend 32
             (BitsN.fromBitstring([imm5'4,imm5'3,imm5'2,imm5'1,imm5'0],5))
         val m = immediate_form imm32
       in
         if (BitsN.fromBitstring([L'0],1)) = (BitsN.B(0x1,1))
           then Load
                  (LoadByte
                     (true,
                      (BitsN.fromNat(BitsN.toNat Rt,4),
                       (BitsN.fromNat(BitsN.toNat Rn,4),m))))
         else Store
                (StoreByte
                   (BitsN.fromNat(BitsN.toNat Rt,4),
                    (BitsN.fromNat(BitsN.toNat Rn,4),m)))
       end
     | (true,
      (false,
       (false,
        (false,
         (L'0,
          (imm5'4,
           (imm5'3,
            (imm5'2,
             (imm5'1,(imm5'0,(Rn'2,(Rn'1,(Rn'0,(Rt'2,(Rt'1,Rt'0))))))))))))))) =>
       let
         val Rt = BitsN.fromBitstring([Rt'2,Rt'1,Rt'0],3)
         val Rn = BitsN.fromBitstring([Rn'2,Rn'1,Rn'0],3)
         val imm32 =
           BitsN.zeroExtend 32
             (BitsN.@@
                (BitsN.fromBitstring
                   ([imm5'4,imm5'3,imm5'2,imm5'1,imm5'0],5),BitsN.B(0x0,1)))
         val m = immediate_form imm32
       in
         if (BitsN.fromBitstring([L'0],1)) = (BitsN.B(0x1,1))
           then Load
                  (LoadHalf
                     (true,
                      (BitsN.fromNat(BitsN.toNat Rt,4),
                       (BitsN.fromNat(BitsN.toNat Rn,4),m))))
         else Store
                (StoreHalf
                   (BitsN.fromNat(BitsN.toNat Rt,4),
                    (BitsN.fromNat(BitsN.toNat Rn,4),m)))
       end
     | (true,
      (false,
       (false,
        (true,
         (L'0,
          (Rt'2,
           (Rt'1,
            (Rt'0,
             (imm8'7,
              (imm8'6,(imm8'5,(imm8'4,(imm8'3,(imm8'2,(imm8'1,imm8'0))))))))))))))) =>
       let
         val Rt = BitsN.fromBitstring([Rt'2,Rt'1,Rt'0],3)
         val imm32 =
           BitsN.zeroExtend 32
             (BitsN.@@
                (BitsN.fromBitstring
                   ([imm8'7,imm8'6,imm8'5,imm8'4,imm8'3,imm8'2,imm8'1,
                     imm8'0],8),BitsN.B(0x0,2)))
         val m = immediate_form imm32
       in
         if (BitsN.fromBitstring([L'0],1)) = (BitsN.B(0x1,1))
           then Load
                  (LoadWord
                     (BitsN.fromNat(BitsN.toNat Rt,4),(BitsN.B(0xD,4),m)))
         else Store
                (StoreWord
                   (BitsN.fromNat(BitsN.toNat Rt,4),(BitsN.B(0xD,4),m)))
       end
     | (true,
      (false,
       (true,
        (false,
         (S'0,
          (Rd'2,
           (Rd'1,
            (Rd'0,
             (imm8'7,
              (imm8'6,(imm8'5,(imm8'4,(imm8'3,(imm8'2,(imm8'1,imm8'0))))))))))))))) =>
       let
         val imm32 =
           BitsN.zeroExtend 32
             (BitsN.@@
                (BitsN.fromBitstring
                   ([imm8'7,imm8'6,imm8'5,imm8'4,imm8'3,imm8'2,imm8'1,
                     imm8'0],8),BitsN.B(0x0,2)))
         val Rn =
           if (BitsN.fromBitstring([S'0],1)) = (BitsN.B(0x1,1))
             then BitsN.B(0xD,4)
           else BitsN.B(0xF,4)
       in
         Data
           (ArithLogicImmediate
              (BitsN.B(0x4,4),
               (false,
                (BitsN.fromNat
                   (BitsN.toNat(BitsN.fromBitstring([Rd'2,Rd'1,Rd'0],3)),4),
                 (Rn,imm32)))))
       end
     | (true,
      (false,
       (true,
        (true,
         (false,
          (false,
           (false,
            (false,
             (S'0,
              (imm7'6,(imm7'5,(imm7'4,(imm7'3,(imm7'2,(imm7'1,imm7'0))))))))))))))) =>
       let
         val imm32 =
           BitsN.zeroExtend 32
             (BitsN.@@
                (BitsN.fromBitstring
                   ([imm7'6,imm7'5,imm7'4,imm7'3,imm7'2,imm7'1,imm7'0],7),
                 BitsN.B(0x0,2)))
         val opc =
           if (BitsN.fromBitstring([S'0],1)) = (BitsN.B(0x1,1))
             then BitsN.B(0x2,4)
           else BitsN.B(0x4,4)
       in
         Data
           (ArithLogicImmediate
              (opc,(false,(BitsN.B(0xD,4),(BitsN.B(0xD,4),imm32)))))
       end
     | (true,
      (false,
       (true,
        (true,
         (false,
          (false,
           (true,
            (false,(U'0,(false,(Rm'2,(Rm'1,(Rm'0,(Rd'2,(Rd'1,Rd'0))))))))))))))) =>
       let
         val unsigned = (BitsN.fromBitstring([U'0],1)) = (BitsN.B(0x1,1))
       in
         Media
           (ExtendHalfword
              (unsigned,
               (BitsN.fromNat
                  (BitsN.toNat(BitsN.fromBitstring([Rd'2,Rd'1,Rd'0],3)),4),
                BitsN.fromNat
                  (BitsN.toNat(BitsN.fromBitstring([Rm'2,Rm'1,Rm'0],3)),4))))
       end
     | (true,
      (false,
       (true,
        (true,
         (false,
          (false,
           (true,
            (false,(U'0,(true,(Rm'2,(Rm'1,(Rm'0,(Rd'2,(Rd'1,Rd'0))))))))))))))) =>
       let
         val unsigned = (BitsN.fromBitstring([U'0],1)) = (BitsN.B(0x1,1))
       in
         Media
           (ExtendByte
              (unsigned,
               (BitsN.fromNat
                  (BitsN.toNat(BitsN.fromBitstring([Rd'2,Rd'1,Rd'0],3)),4),
                BitsN.fromNat
                  (BitsN.toNat(BitsN.fromBitstring([Rm'2,Rm'1,Rm'0],3)),4))))
       end
     | (true,
      (false,
       (true,
        (true,
         (false,
          (true,
           (false,
            (registers'8,
             (registers'7,
              (registers'6,
               (registers'5,
                (registers'4,
                 (registers'3,(registers'2,(registers'1,registers'0))))))))))))))) =>
       let
         val registers =
           BitsN.fromBitstring
             ([registers'8,registers'7,registers'6,registers'5,
               registers'4,registers'3,registers'2,registers'1,registers'0],
              9)
       in
         ( if Nat.<(BitCount 9 registers,1)
             then DECODE_UNPREDICTABLE(mc,"Push")
           else ()
         ; Store(Push registers)
         )
       end
     | (true,
      (false,
       (true,
        (true,(false,(true,(true,(false,(false,(true,(true,(im'0,_)))))))))))) =>
       System
         (ChangeProcessorState
            ((not o L3.equal (BitsN.zero (1)))
               (BitsN.fromBitstring([im'0],1))))
     | (true,
      (false,
       (true,
        (true,
         (true,
          (false,
           (true,
            (false,(opc'1,(opc'0,(Rm'2,(Rm'1,(Rm'0,(Rd'2,(Rd'1,Rd'0))))))))))))))) =>
       let
         val Rd = BitsN.fromBitstring([Rd'2,Rd'1,Rd'0],3)
         val Rm = BitsN.fromBitstring([Rm'2,Rm'1,Rm'0],3)
       in
         case BitsN.fromBitstring([opc'1,opc'0],2) of
            BitsN.B(0x0,_) =>
              Media
                (ByteReverse
                   (BitsN.fromNat(BitsN.toNat Rd,4),
                    BitsN.fromNat(BitsN.toNat Rm,4)))
          | BitsN.B(0x1,_) =>
            Media
              (ByteReversePackedHalfword
                 (BitsN.fromNat(BitsN.toNat Rd,4),
                  BitsN.fromNat(BitsN.toNat Rm,4)))
          | BitsN.B(0x3,_) =>
            Media
              (ByteReverseSignedHalfword
                 (BitsN.fromNat(BitsN.toNat Rd,4),
                  BitsN.fromNat(BitsN.toNat Rm,4)))
          | _ => Undefined(BitsN.B(0x0,32))
       end
     | (true,
      (false,
       (true,
        (true,
         (true,
          (true,
           (false,
            (registers'8,
             (registers'7,
              (registers'6,
               (registers'5,
                (registers'4,
                 (registers'3,(registers'2,(registers'1,registers'0))))))))))))))) =>
       let
         val registers =
           BitsN.fromBitstring
             ([registers'8,registers'7,registers'6,registers'5,
               registers'4,registers'3,registers'2,registers'1,registers'0],
              9)
       in
         ( if Nat.<(BitCount 9 registers,1)
             then DECODE_UNPREDICTABLE(mc,"POP")
           else ()
         ; let
             val wback = true
           in
             Load(LoadMultiple(wback,(BitsN.B(0xD,4),registers)))
           end
         )
       end
     | (true,
      (false,
       (true,
        (true,
         (true,
          (true,
           (true,
            (false,
             (imm8'7,
              (imm8'6,(imm8'5,(imm8'4,(imm8'3,(imm8'2,(imm8'1,imm8'0))))))))))))))) =>
       let
         val imm32 =
           BitsN.zeroExtend 32
             (BitsN.fromBitstring
                ([imm8'7,imm8'6,imm8'5,imm8'4,imm8'3,imm8'2,imm8'1,imm8'0],
                 8))
       in
         Hint(Breakpoint imm32)
       end
     | (true,
      (false,
       (true,
        (true,
         (true,
          (true,
           (true,
            (true,
             (op'3,(op'2,(op'1,(op'0,(false,(false,(false,false))))))))))))))) =>
       (case BitsN.fromBitstring([op'3,op'2,op'1,op'0],4) of
           BitsN.B(0x1,_) => Hint(Yield ())
         | BitsN.B(0x2,_) => Hint(WaitForEvent ())
         | BitsN.B(0x3,_) => Hint(WaitForInterrupt ())
         | BitsN.B(0x4,_) => Hint(SendEvent ())
         | _ => NoOperation ())
     | (true,
      (true,
       (false,
        (false,
         (false,
          (Rn'2,
           (Rn'1,
            (Rn'0,
             (registers'7,
              (registers'6,
               (registers'5,
                (registers'4,
                 (registers'3,(registers'2,(registers'1,registers'0))))))))))))))) =>
       let
         val registers =
           BitsN.fromBitstring
             ([registers'7,registers'6,registers'5,registers'4,
               registers'3,registers'2,registers'1,registers'0],8)
       in
         ( if Nat.<(BitCount 8 registers,1)
             then DECODE_UNPREDICTABLE(mc,"StoreMultiple")
           else ()
         ; Store
             (StoreMultiple
                (BitsN.fromNat
                   (BitsN.toNat(BitsN.fromBitstring([Rn'2,Rn'1,Rn'0],3)),4),
                 registers))
         )
       end
     | (true,
      (true,
       (false,
        (false,
         (true,
          (Rn'2,
           (Rn'1,
            (Rn'0,
             (register_list'7,
              (register_list'6,
               (register_list'5,
                (register_list'4,
                 (register_list'3,
                  (register_list'2,(register_list'1,register_list'0))))))))))))))) =>
       let
         val Rn = BitsN.fromBitstring([Rn'2,Rn'1,Rn'0],3)
         val registers =
           BitsN.fromNat
             (BitsN.toNat
                (BitsN.fromBitstring
                   ([register_list'7,register_list'6,register_list'5,
                     register_list'4,register_list'3,register_list'2,
                     register_list'1,register_list'0],8)),9)
       in
         ( if Nat.<(BitCount 9 registers,1)
             then DECODE_UNPREDICTABLE(mc,"LoadMultiple")
           else ()
         ; let
             val wback = not(BitsN.bit(registers,BitsN.toNat Rn))
           in
             Load
               (LoadMultiple
                  (wback,(BitsN.fromNat(BitsN.toNat Rn,4),registers)))
           end
         )
       end
     | (true,
      (true,
       (false,
        (true,
         (true,
          (true,
           (true,
            (false,
             (imm8'7,
              (imm8'6,(imm8'5,(imm8'4,(imm8'3,(imm8'2,(imm8'1,imm8'0))))))))))))))) =>
       let
         val imm32 =
           BitsN.zeroExtend 32
             (BitsN.fromBitstring
                ([imm8'7,imm8'6,imm8'5,imm8'4,imm8'3,imm8'2,imm8'1,imm8'0],
                 8))
       in
         Undefined imm32
       end
     | (true,
      (true,
       (false,
        (true,
         (true,
          (true,
           (true,
            (true,
             (imm8'7,
              (imm8'6,(imm8'5,(imm8'4,(imm8'3,(imm8'2,(imm8'1,imm8'0))))))))))))))) =>
       System
         (SupervisorCall
            (BitsN.zeroExtend 32
               (BitsN.fromBitstring
                  ([imm8'7,imm8'6,imm8'5,imm8'4,imm8'3,imm8'2,imm8'1,
                    imm8'0],8))))
     | (true,
      (true,
       (false,
        (true,
         (cond'3,
          (cond'2,
           (cond'1,
            (cond'0,
             (imm8'7,
              (imm8'6,(imm8'5,(imm8'4,(imm8'3,(imm8'2,(imm8'1,imm8'0))))))))))))))) =>
       (if ConditionPassed
             (BitsN.fromBitstring([cond'3,cond'2,cond'1,cond'0],4))
          then let
                 val imm32 =
                   BitsN.signExtend 32
                     (BitsN.@@
                        (BitsN.fromBitstring
                           ([imm8'7,imm8'6,imm8'5,imm8'4,imm8'3,imm8'2,
                             imm8'1,imm8'0],8),BitsN.B(0x0,1)))
               in
                 Branch(BranchTarget imm32)
               end
        else NoOperation ())
     | (true,
      (true,
       (true,
        (false,
         (false,
          (imm11'10,
           (imm11'9,
            (imm11'8,
             (imm11'7,
              (imm11'6,
               (imm11'5,(imm11'4,(imm11'3,(imm11'2,(imm11'1,imm11'0))))))))))))))) =>
       let
         val imm32 =
           BitsN.signExtend 32
             (BitsN.@@
                (BitsN.fromBitstring
                   ([imm11'10,imm11'9,imm11'8,imm11'7,imm11'6,imm11'5,
                     imm11'4,imm11'3,imm11'2,imm11'1,imm11'0],11),
                 BitsN.B(0x0,1)))
       in
         Branch(BranchTarget imm32)
       end
     | _ => Undefined(BitsN.B(0x0,32))
  end;

fun DecodeThumb2 h =
  let
    val mc = Thumb2 h
  in
    case (boolify'16(L3.fst h),boolify'16(L3.snd h)) of
       ((true,
         (true,
          (true,
           (true,
            (false,
             (false,
              (true,
               (true,(true,(false,(false,(_,(Rn'3,(Rn'2,(Rn'1,Rn'0))))))))))))))),
        (true,
         (false,
          (_,
           (false,
            (_,
             (_,
              (_,
               (_,
                (SYSm'7,
                 (SYSm'6,
                  (SYSm'5,(SYSm'4,(SYSm'3,(SYSm'2,(SYSm'1,SYSm'0)))))))))))))))) =>
         let
           val Rn = BitsN.fromBitstring([Rn'3,Rn'2,Rn'1,Rn'0],4)
           val SYSm =
             BitsN.fromBitstring
               ([SYSm'7,SYSm'6,SYSm'5,SYSm'4,SYSm'3,SYSm'2,SYSm'1,SYSm'0],
                8)
         in
           ( if (Set.mem(Rn,[BitsN.B(0xD,4),BitsN.B(0xF,4)])) orelse
                (not(Set.mem
                       (SYSm,
                        [BitsN.B(0x0,8),BitsN.B(0x1,8),BitsN.B(0x2,8),
                         BitsN.B(0x3,8),BitsN.B(0x5,8),BitsN.B(0x6,8),
                         BitsN.B(0x7,8),BitsN.B(0x8,8),BitsN.B(0x9,8),
                         BitsN.B(0x10,8),BitsN.B(0x11,8),BitsN.B(0x12,8),
                         BitsN.B(0x13,8),BitsN.B(0x14,8)])))
               then DECODE_UNPREDICTABLE(mc,"MoveToSpecialRegister")
             else ()
           ; System(MoveToSpecialRegister(SYSm,Rn))
           )
         end
     | ((true,
       (true,
        (true,
         (true,
          (false,(false,(true,(true,(true,(false,(true,(true,_)))))))))))),
      (true,
       (false,
        (_,
         (false,
          (_,
           (_,
            (_,
             (_,
              (op'3,
               (op'2,
                (op'1,(op'0,(option'3,(option'2,(option'1,option'0)))))))))))))))) =>
       let
         val option =
           BitsN.fromBitstring([option'3,option'2,option'1,option'0],4)
       in
         case BitsN.fromBitstring([op'3,op'2,op'1,op'0],4) of
            BitsN.B(0x4,_) => Hint(DataSynchronizationBarrier option)
          | BitsN.B(0x5,_) => Hint(DataMemoryBarrier option)
          | BitsN.B(0x6,_) =>
            Hint(InstructionSynchronizationBarrier option)
          | _ => Undefined(BitsN.B(0x0,32))
       end
     | ((true,
       (true,
        (true,(true,(false,(false,(true,(true,(true,(true,(true,_))))))))))),
      (true,
       (false,
        (_,
         (false,
          (Rd'3,
           (Rd'2,
            (Rd'1,
             (Rd'0,
              (SYSm'7,
               (SYSm'6,(SYSm'5,(SYSm'4,(SYSm'3,(SYSm'2,(SYSm'1,SYSm'0)))))))))))))))) =>
       let
         val SYSm =
           BitsN.fromBitstring
             ([SYSm'7,SYSm'6,SYSm'5,SYSm'4,SYSm'3,SYSm'2,SYSm'1,SYSm'0],8)
         val Rd = BitsN.fromBitstring([Rd'3,Rd'2,Rd'1,Rd'0],4)
       in
         ( if (Set.mem(Rd,[BitsN.B(0xD,4),BitsN.B(0xF,4)])) orelse
              (not(Set.mem
                     (SYSm,
                      [BitsN.B(0x0,8),BitsN.B(0x1,8),BitsN.B(0x2,8),
                       BitsN.B(0x3,8),BitsN.B(0x5,8),BitsN.B(0x6,8),
                       BitsN.B(0x7,8),BitsN.B(0x8,8),BitsN.B(0x9,8),
                       BitsN.B(0x10,8),BitsN.B(0x11,8),BitsN.B(0x12,8),
                       BitsN.B(0x13,8),BitsN.B(0x14,8)])))
             then DECODE_UNPREDICTABLE(mc,"MoveToRegisterFromSpecial")
           else ()
         ; System(MoveToRegisterFromSpecial(SYSm,Rd))
         )
       end
     | ((true,
       (true,
        (true,
         (true,
          (false,
           (true,
            (true,
             (true,
              (true,(true,(true,(true,(imm4'3,(imm4'2,(imm4'1,imm4'0))))))))))))))),
      (true,
       (false,
        (true,
         (false,
          (imm12'11,
           (imm12'10,
            (imm12'9,
             (imm12'8,
              (imm12'7,
               (imm12'6,
                (imm12'5,(imm12'4,(imm12'3,(imm12'2,(imm12'1,imm12'0)))))))))))))))) =>
       let
         val imm32 =
           BitsN.zeroExtend 32
             (BitsN.@@
                (BitsN.fromBitstring([imm4'3,imm4'2,imm4'1,imm4'0],4),
                 BitsN.fromBitstring
                   ([imm12'11,imm12'10,imm12'9,imm12'8,imm12'7,imm12'6,
                     imm12'5,imm12'4,imm12'3,imm12'2,imm12'1,imm12'0],12)))
       in
         Undefined imm32
       end
     | ((true,
       (true,
        (true,
         (true,
          (false,
           (S'0,
            (imm10'9,
             (imm10'8,
              (imm10'7,
               (imm10'6,
                (imm10'5,(imm10'4,(imm10'3,(imm10'2,(imm10'1,imm10'0))))))))))))))),
      (true,
       (true,
        (J1'0,
         (true,
          (J2'0,
           (imm11'10,
            (imm11'9,
             (imm11'8,
              (imm11'7,
               (imm11'6,
                (imm11'5,(imm11'4,(imm11'3,(imm11'2,(imm11'1,imm11'0)))))))))))))))) =>
       let
         val S = BitsN.fromBitstring([S'0],1)
         val I1 = BitsN.~(BitsN.??(BitsN.fromBitstring([J1'0],1),S))
         val I2 = BitsN.~(BitsN.??(BitsN.fromBitstring([J2'0],1),S))
         val imm32 =
           BitsN.signExtend 32
             (BitsN.concat
                [S,I1,I2,
                 BitsN.fromBitstring
                   ([imm10'9,imm10'8,imm10'7,imm10'6,imm10'5,imm10'4,
                     imm10'3,imm10'2,imm10'1,imm10'0],10),
                 BitsN.fromBitstring
                   ([imm11'10,imm11'9,imm11'8,imm11'7,imm11'6,imm11'5,
                     imm11'4,imm11'3,imm11'2,imm11'1,imm11'0],11),
                 BitsN.B(0x0,1)])
       in
         Branch(BranchLinkImmediate imm32)
       end
     | _ => Undefined(BitsN.B(0x0,32))
  end;

fun Decode mc =
  case mc of
     Thumb h => ( pcinc := (BitsN.B(0x2,32)); DecodeThumb h )
   | Thumb2 hs => ( pcinc := (BitsN.B(0x4,32)); DecodeThumb2 hs );

fun Next () = Run(Decode(Fetch ()));

fun EncodeImmShift (shift_t,shift_n) =
  case shift_t of
     SRType_LSL => (BitsN.B(0x0,2),BitsN.fromNat(shift_n,5))
   | SRType_LSR =>
     (BitsN.B(0x1,2),
      if shift_n = 32 then BitsN.B(0x0,5) else BitsN.fromNat(shift_n,5))
   | SRType_ASR =>
     (BitsN.B(0x2,2),
      if shift_n = 32 then BitsN.B(0x0,5) else BitsN.fromNat(shift_n,5))
   | SRType_ROR => (BitsN.B(0x3,2),BitsN.fromNat(shift_n,5))
   | SRType_RRX => (BitsN.B(0x3,2),BitsN.B(0x0,5));

fun e_branch (c,(ast,e)) =
  case ast of
     BranchTarget imm32 =>
       (if Set.mem(c,[BitsN.B(0xE,4),BitsN.B(0xF,4)])
          then if (BitsN.<=(BitsN.neg(BitsN.B(0x800,32)),imm32)) andalso
                  ((BitsN.<=(imm32,BitsN.B(0x7FE,32))) andalso
                   (not(e = Enc_Wide)))
                 then Thumb16
                        (BitsN.@@(BitsN.B(0x1C,5),BitsN.bits(11,1) imm32))
               else let
                      val S = BitsN.bits(24,24) imm32
                      val I1 = BitsN.bits(23,23) imm32
                      val I2 = BitsN.bits(22,22) imm32
                      val J1 = BitsN.fromBit(I1 = S)
                      val J2 = BitsN.fromBit(I2 = S)
                      val imm10 = BitsN.bits(21,12) imm32
                      val imm11 = BitsN.bits(11,1) imm32
                    in
                      Thumb32
                        (BitsN.concat[BitsN.B(0x1E,5),S,imm10],
                         BitsN.concat
                           [BitsN.B(0x2,2),J1,BitsN.B(0x1,1),J2,imm11])
                    end
        else if (BitsN.<=(BitsN.neg(BitsN.B(0x100,32)),imm32)) andalso
           ((BitsN.<=(imm32,BitsN.B(0xFE,32))) andalso (not(e = Enc_Wide)))
          then Thumb16
                 (BitsN.concat[BitsN.B(0xD,4),c,BitsN.bits(8,1) imm32])
        else BadCode("BranchTarget"))
   | BranchExchange Rm =>
     Thumb16(BitsN.concat[BitsN.B(0x8E,9),Rm,BitsN.B(0x0,3)])
   | BranchLinkExchangeRegister Rm =>
     Thumb16(BitsN.concat[BitsN.B(0x8F,9),Rm,BitsN.B(0x0,3)])
   | BranchLinkImmediate imm32 =>
     let
       val S = BitsN.bits(24,24) imm32
       val I1 = BitsN.bits(23,23) imm32
       val I2 = BitsN.bits(22,22) imm32
       val J1 = BitsN.fromBit(I1 = S)
       val J2 = BitsN.fromBit(I2 = S)
       val imm10 = BitsN.bits(21,12) imm32
       val imm11 = BitsN.bits(11,1) imm32
     in
       Thumb32
         (BitsN.concat[BitsN.B(0x1E,5),S,imm10],
          BitsN.concat[BitsN.B(0x3,2),J1,BitsN.B(0x1,1),J2,imm11])
     end;

fun e_data ast =
  case ast of
     Move(d,imm32) =>
       Thumb16
         (BitsN.concat
            [BitsN.B(0x4,5),BitsN.bits(2,0) d,BitsN.bits(7,0) imm32])
   | ArithLogicImmediate(opc,(setflags,(d,(n,imm32)))) =>
     (if (Set.mem(opc,[BitsN.B(0x4,4),BitsN.B(0x2,4)])) andalso
         ((BitsN.<=+(imm32,BitsN.B(0x7,32))) andalso
          (setflags andalso
           (not((BitsN.bit(d,3)) orelse (BitsN.bit(n,3))))))
        then let
               val Rd = BitsN.bits(2,0) d
               val Rn = BitsN.bits(2,0) n
               val imm3 = BitsN.bits(2,0) imm32
               val S = BitsN.bits(1,1) opc
             in
               Thumb16(BitsN.concat[BitsN.B(0x7,6),S,imm3,Rn,Rd])
             end
      else if (Set.mem(opc,[BitsN.B(0x4,4),BitsN.B(0x2,4)])) andalso
         ((d = n) andalso
          ((BitsN.<=+(imm32,BitsN.B(0xFF,32))) andalso
           (setflags andalso (not(BitsN.bit(d,3))))))
        then let
               val Rdn = BitsN.bits(2,0) d
               val imm8 = BitsN.bits(7,0) imm32
               val S = BitsN.bits(1,1) opc
             in
               Thumb16(BitsN.concat[BitsN.B(0x3,4),S,Rdn,imm8])
             end
      else if (opc = (BitsN.B(0x3,4))) andalso
         ((imm32 = (BitsN.B(0x0,32))) andalso
          (setflags andalso
           (not((BitsN.bit(d,3)) orelse (BitsN.bit(n,3))))))
        then let
               val Rd = BitsN.bits(2,0) d
               val Rn = BitsN.bits(2,0) n
             in
               Thumb16(BitsN.concat[BitsN.B(0x109,10),Rn,Rd])
             end
      else if (opc = (BitsN.B(0x4,4))) andalso
         ((not setflags) andalso
          ((Set.mem(n,[BitsN.B(0xD,4),BitsN.B(0xF,4)])) andalso
           ((not setflags) andalso
            (((BitsN.&&(imm32,BitsN.B(0xFFFFFC03,32))) = (BitsN.B(0x0,32))) andalso
             (not(BitsN.bit(d,3)))))))
        then let
               val Rd = BitsN.bits(2,0) d
               val imm8 = BitsN.bits(9,2) imm32
               val S = BitsN.fromBit(n = (BitsN.B(0xD,4)))
             in
               Thumb16(BitsN.concat[BitsN.B(0xA,4),S,Rd,imm8])
             end
      else if (Set.mem(opc,[BitsN.B(0x4,4),BitsN.B(0x2,4)])) andalso
         ((d = (BitsN.B(0xD,4))) andalso
          ((n = (BitsN.B(0xD,4))) andalso
           ((not setflags) andalso
            (((BitsN.&&(imm32,BitsN.B(0xFFFFFE03,32))) = (BitsN.B(0x0,32))) andalso
             (not setflags)))))
        then let
               val imm7 = BitsN.bits(8,2) imm32
               val S = BitsN.bits(1,1) opc
             in
               Thumb16(BitsN.concat[BitsN.B(0xB0,8),S,imm7])
             end
      else BadCode("ArithLogicImmediate"))
   | Register(opc,(setflags,(d,(n,m)))) =>
     (if (Set.mem(opc,[BitsN.B(0x2,4),BitsN.B(0x4,4)])) andalso
         (setflags andalso
          (not((BitsN.bit(d,3)) orelse
               ((BitsN.bit(n,3)) orelse (BitsN.bit(m,3))))))
        then let
               val Rn = BitsN.bits(2,0) n
               val Rd = BitsN.bits(2,0) d
               val Rm = BitsN.bits(2,0) m
               val S = BitsN.fromBit(opc = (BitsN.B(0x2,4)))
             in
               Thumb16(BitsN.concat[BitsN.B(0x6,6),S,Rm,Rn,Rd])
             end
      else if (Set.mem
            (opc,
             [BitsN.B(0x0,4),BitsN.B(0x1,4),BitsN.B(0x5,4),BitsN.B(0x6,4),
              BitsN.B(0xC,4),BitsN.B(0xE,4)])) andalso
         (setflags andalso
          ((d = n) andalso (not((BitsN.bit(d,3)) orelse (BitsN.bit(m,3))))))
        then let
               val Rdn = BitsN.bits(2,0) d
               val Rm = BitsN.bits(2,0) m
             in
               Thumb16(BitsN.concat[BitsN.B(0x10,6),opc,Rm,Rdn])
             end
      else if (opc = (BitsN.B(0x4,4))) andalso
         ((d = n) andalso (not setflags))
        then let
               val DN = BitsN.bits(3,3) d
               val Rdn = BitsN.bits(2,0) d
               val Rm = m
             in
               Thumb16(BitsN.concat[BitsN.B(0x44,8),DN,Rm,Rdn])
             end
      else BadCode("Register"))
   | TestCompareRegister(opc,(n,m)) =>
     (if not((opc = (BitsN.B(0x1,2))) orelse
             ((BitsN.bit(n,3)) orelse (BitsN.bit(m,3))))
        then let
               val Rn = BitsN.bits(2,0) n
               val Rm = BitsN.bits(2,0) m
             in
               Thumb16(BitsN.concat[BitsN.B(0x42,8),opc,Rm,Rn])
             end
      else if opc = (BitsN.B(0x2,2))
        then let
               val N = BitsN.bits(3,3) n
               val Rn = BitsN.bits(2,0) n
               val Rm = m
             in
               Thumb16(BitsN.concat[BitsN.B(0x45,8),N,Rm,Rn])
             end
      else BadCode("TestCompareRegister"))
   | CompareImmediate(n,imm32) =>
     Thumb16
       (BitsN.concat
          [BitsN.B(0x5,5),BitsN.bits(2,0) n,BitsN.bits(7,0) imm32])
   | ShiftImmediate(negate,(setflags,(d,(m,(shift_t,shift_n))))) =>
     (if negate andalso
         ((shift_t = SRType_LSL) andalso
          ((shift_n = 0) andalso
           (setflags andalso
            (not((BitsN.bit(m,3)) orelse (BitsN.bit(d,3)))))))
        then let
               val Rm = BitsN.bits(2,0) m
               val Rd = BitsN.bits(2,0) d
             in
               Thumb16(BitsN.concat[BitsN.B(0x10F,10),Rm,Rd])
             end
      else if (Set.mem(shift_t,[SRType_LSL,SRType_LSR,SRType_ASR])) andalso
         (setflags andalso
          (not(negate orelse ((BitsN.bit(m,3)) orelse (BitsN.bit(d,3))))))
        then let
               val Rm = BitsN.bits(2,0) m
               val Rd = BitsN.bits(2,0) d
               val (typ,imm5) = EncodeImmShift(shift_t,shift_n)
             in
               Thumb16(BitsN.concat[BitsN.B(0x0,3),typ,imm5,Rm,Rd])
             end
      else if (shift_t = SRType_LSL) andalso
         ((shift_n = 0) andalso (not(negate orelse setflags)))
        then let
               val D = BitsN.bits(3,3) d
               val Rd = BitsN.bits(2,0) d
               val Rm = m
             in
               Thumb16(BitsN.concat[BitsN.B(0x46,8),D,Rm,Rd])
             end
      else BadCode("ShiftImmediate"))
   | ShiftRegister(_,(_,(SRType_RRX,_))) => BadCode("ShiftRegister: rrx")
   | ShiftRegister(d,(n,(shift_t,m))) =>
     let
       val Rm = BitsN.bits(2,0) m
       val Rdn = BitsN.bits(2,0) d
       val opc =
         case shift_t of
            SRType_LSL => BitsN.B(0x2,3)
          | SRType_LSR => BitsN.B(0x3,3)
          | SRType_ASR => BitsN.B(0x4,3)
          | SRType_ROR => BitsN.B(0x7,3)
          | _ => BitsN.B(0x0,3)
     in
       Thumb16(BitsN.concat[BitsN.B(0x20,7),opc,Rm,Rdn])
     end;

fun e_media ast =
  case ast of
     ExtendByte(unsigned,(d,m)) =>
       let
         val U = BitsN.fromBit unsigned
         val Rd = BitsN.bits(2,0) d
         val Rm = BitsN.bits(2,0) m
       in
         Thumb16(BitsN.concat[BitsN.B(0xB2,8),U,BitsN.B(0x1,1),Rm,Rd])
       end
   | ExtendHalfword(unsigned,(d,m)) =>
     let
       val U = BitsN.fromBit unsigned
       val Rd = BitsN.bits(2,0) d
       val Rm = BitsN.bits(2,0) m
     in
       Thumb16(BitsN.concat[BitsN.B(0xB2,8),U,BitsN.B(0x0,1),Rm,Rd])
     end
   | ByteReverse(d,m) =>
     Thumb16
       (BitsN.concat
          [BitsN.B(0x2E8,10),BitsN.bits(2,0) m,BitsN.bits(2,0) d])
   | ByteReversePackedHalfword(d,m) =>
     Thumb16
       (BitsN.concat
          [BitsN.B(0x2E9,10),BitsN.bits(2,0) m,BitsN.bits(2,0) d])
   | ByteReverseSignedHalfword(d,m) =>
     Thumb16
       (BitsN.concat
          [BitsN.B(0x2EB,10),BitsN.bits(2,0) m,BitsN.bits(2,0) d]);

fun e_hint (ast,e) =
  case ast of
     Breakpoint imm32 =>
       Thumb16(BitsN.@@(BitsN.B(0xBE,8),BitsN.bits(7,0) imm32))
   | DataMemoryBarrier option =>
     Thumb32(BitsN.B(0xF3BF,16),BitsN.@@(BitsN.B(0x8F5,12),option))
   | DataSynchronizationBarrier option =>
     Thumb32(BitsN.B(0xF3BF,16),BitsN.@@(BitsN.B(0x8F4,12),option))
   | InstructionSynchronizationBarrier option =>
     Thumb32(BitsN.B(0xF3BF,16),BitsN.@@(BitsN.B(0x8F6,12),option))
   | SendEvent () =>
     if e = Enc_Wide
       then Thumb32(BitsN.B(0xF3AF,16),BitsN.B(0x8004,16))
     else Thumb16(BitsN.B(0xBF40,16))
   | WaitForEvent () =>
     if e = Enc_Wide
       then Thumb32(BitsN.B(0xF3AF,16),BitsN.B(0x8002,16))
     else Thumb16(BitsN.B(0xBF20,16))
   | WaitForInterrupt () =>
     if e = Enc_Wide
       then Thumb32(BitsN.B(0xF3AF,16),BitsN.B(0x8003,16))
     else Thumb16(BitsN.B(0xBF30,16))
   | Yield () =>
     if e = Enc_Wide
       then Thumb32(BitsN.B(0xF3AF,16),BitsN.B(0x8001,16))
     else Thumb16(BitsN.B(0xBF10,16));

fun e_system ast =
  case ast of
     ChangeProcessorState enable =>
       Thumb16
         (BitsN.concat
            [BitsN.B(0x5B3,11),BitsN.fromBit(not enable),BitsN.B(0x2,4)])
   | MoveToRegisterFromSpecial(SYSm,Rd) =>
     Thumb32(BitsN.B(0xF3EF,16),BitsN.concat[BitsN.B(0x8,4),Rd,SYSm])
   | MoveToSpecialRegister(SYSm,Rn) =>
     Thumb32
       (BitsN.@@(BitsN.B(0xF38,12),Rn),BitsN.@@(BitsN.B(0x88,8),SYSm))
   | SupervisorCall imm32 =>
     Thumb16(BitsN.@@(BitsN.B(0xDF,8),BitsN.bits(7,0) imm32));

fun e_multiply ast =
  case ast of
     Multiply32(d,(n,m)) =>
       (if d = m
          then let
                 val Rn = BitsN.bits(2,0) n
                 val Rdm = BitsN.bits(2,0) d
               in
                 Thumb16(BitsN.concat[BitsN.B(0x10D,10),Rn,Rdm])
               end
        else BadCode("Multiply32"));

fun e_load ast =
  case ast of
     LoadWord(t,(n,immediate_form imm32)) =>
       (if n = (BitsN.B(0xD,4))
          then Thumb16
                 (BitsN.concat
                    [BitsN.B(0x13,5),BitsN.bits(2,0) t,
                     BitsN.bits(9,2) imm32])
        else Thumb16
               (BitsN.concat
                  [BitsN.B(0xD,5),BitsN.bits(6,2) imm32,BitsN.bits(2,0) n,
                   BitsN.bits(2,0) t]))
   | LoadWord(t,(n,register_form m)) =>
     Thumb16
       (BitsN.concat
          [BitsN.B(0x2C,7),BitsN.bits(2,0) m,BitsN.bits(2,0) n,
           BitsN.bits(2,0) t])
   | LoadLiteral(t,imm32) =>
     Thumb16
       (BitsN.concat
          [BitsN.B(0x9,5),BitsN.bits(2,0) t,BitsN.bits(9,2) imm32])
   | LoadByte(unsigned,(t,(n,immediate_form imm32))) =>
     Thumb16
       (BitsN.concat
          [BitsN.B(0xF,5),BitsN.bits(4,0) imm32,BitsN.bits(2,0) n,
           BitsN.bits(2,0) t])
   | LoadByte(unsigned,(t,(n,register_form m))) =>
     let
       val Rm = BitsN.bits(2,0) m
       val Rn = BitsN.bits(2,0) n
       val Rt = BitsN.bits(2,0) t
       val U = BitsN.fromBit unsigned
       val S = BitsN.~ U
     in
       Thumb16(BitsN.concat[BitsN.B(0x5,4),U,BitsN.B(0x1,1),S,Rm,Rn,Rt])
     end
   | LoadHalf(unsigned,(t,(n,immediate_form imm32))) =>
     Thumb16
       (BitsN.concat
          [BitsN.B(0x11,5),BitsN.bits(5,1) imm32,BitsN.bits(2,0) n,
           BitsN.bits(2,0) t])
   | LoadHalf(unsigned,(t,(n,register_form m))) =>
     Thumb16
       (BitsN.concat
          [BitsN.B(0xB,5),BitsN.fromBit(not unsigned),BitsN.B(0x1,1),
           BitsN.bits(2,0) m,BitsN.bits(2,0) n,BitsN.bits(2,0) t])
   | LoadMultiple(wback,(n,registers)) =>
     (if n = (BitsN.B(0xD,4))
        then Thumb16(BitsN.@@(BitsN.B(0x5E,7),registers))
      else Thumb16
             (BitsN.concat
                [BitsN.B(0x19,5),BitsN.bits(2,0) n,
                 BitsN.bits(7,0) registers]));

fun e_store ast =
  case ast of
     StoreWord(t,(n,immediate_form imm32)) =>
       (if n = (BitsN.B(0xD,4))
          then Thumb16
                 (BitsN.concat
                    [BitsN.B(0x12,5),BitsN.bits(2,0) t,
                     BitsN.bits(9,2) imm32])
        else Thumb16
               (BitsN.concat
                  [BitsN.B(0xC,5),BitsN.bits(6,2) imm32,BitsN.bits(2,0) n,
                   BitsN.bits(2,0) t]))
   | StoreWord(t,(n,register_form m)) =>
     Thumb16
       (BitsN.concat
          [BitsN.B(0x28,7),BitsN.bits(2,0) m,BitsN.bits(2,0) n,
           BitsN.bits(2,0) t])
   | StoreByte(t,(n,immediate_form imm32)) =>
     Thumb16
       (BitsN.concat
          [BitsN.B(0xE,5),BitsN.bits(4,0) imm32,BitsN.bits(2,0) n,
           BitsN.bits(2,0) t])
   | StoreByte(t,(n,register_form m)) =>
     Thumb16
       (BitsN.concat
          [BitsN.B(0x2A,7),BitsN.bits(2,0) m,BitsN.bits(2,0) n,
           BitsN.bits(2,0) t])
   | StoreHalf(t,(n,immediate_form imm32)) =>
     Thumb16
       (BitsN.concat
          [BitsN.B(0x10,5),BitsN.bits(5,1) imm32,BitsN.bits(2,0) n,
           BitsN.bits(2,0) t])
   | StoreHalf(t,(n,register_form m)) =>
     Thumb16
       (BitsN.concat
          [BitsN.B(0x29,7),BitsN.bits(2,0) m,BitsN.bits(2,0) n,
           BitsN.bits(2,0) t])
   | Push registers => Thumb16(BitsN.@@(BitsN.B(0x5A,7),registers))
   | StoreMultiple(n,registers) =>
     Thumb16(BitsN.concat[BitsN.B(0x18,5),BitsN.bits(2,0) n,registers]);

fun instructionEncode (c,(ast,e)) =
  case ast of
     Branch b => e_branch(c,(b,e))
   | Data d => e_data d
   | Load l => e_load l
   | Store s => e_store s
   | Multiply m => e_multiply m
   | Media m => e_media m
   | System s => e_system s
   | Hint h => e_hint(h,e)
   | Undefined imm32 =>
     (if (not(e = Enc_Wide)) andalso
         ((BitsN.bits(31,8) imm32) = (BitsN.B(0x0,24)))
        then let
               val imm8 = BitsN.bits(7,0) imm32
             in
               Thumb16(BitsN.@@(BitsN.B(0xDE,8),imm8))
             end
      else if not(e = Enc_Narrow)
        then let
               val imm4 = BitsN.bits(15,12) imm32
               val imm12 = BitsN.bits(11,0) imm32
             in
               Thumb32
                 (BitsN.@@(BitsN.B(0xF7F,12),imm4),
                  BitsN.@@(BitsN.B(0xA,4),imm12))
             end
      else BadCode("Undefined"))
   | NoOperation () =>
     if e = Enc_Wide
       then Thumb32(BitsN.B(0xF3AF,16),BitsN.B(0x8000,16))
     else Thumb16(BitsN.B(0xBF00,16));

fun SetPassCondition c =
  case c of
     BitsN.B(0x0,_) => PSR := (PSR_Z_rupd((!PSR),true))
   | BitsN.B(0x1,_) => PSR := (PSR_Z_rupd((!PSR),false))
   | BitsN.B(0x2,_) => PSR := (PSR_C_rupd((!PSR),true))
   | BitsN.B(0x3,_) => PSR := (PSR_C_rupd((!PSR),false))
   | BitsN.B(0x4,_) => PSR := (PSR_N_rupd((!PSR),true))
   | BitsN.B(0x5,_) => PSR := (PSR_N_rupd((!PSR),false))
   | BitsN.B(0x6,_) => PSR := (PSR_V_rupd((!PSR),true))
   | BitsN.B(0x7,_) => PSR := (PSR_V_rupd((!PSR),false))
   | BitsN.B(0x8,_) =>
     ( PSR := (PSR_C_rupd((!PSR),true))
     ; PSR := (PSR_Z_rupd((!PSR),false))
     )
   | BitsN.B(0x9,_) => PSR := (PSR_C_rupd((!PSR),false))
   | BitsN.B(0xA,_) =>
     ( PSR := (PSR_N_rupd((!PSR),false))
     ; PSR := (PSR_V_rupd((!PSR),false))
     )
   | BitsN.B(0xB,_) =>
     ( PSR := (PSR_N_rupd((!PSR),false))
     ; PSR := (PSR_V_rupd((!PSR),true))
     )
   | BitsN.B(0xC,_) =>
     ( PSR := (PSR_N_rupd((!PSR),false))
     ; PSR := (PSR_V_rupd((!PSR),false))
     ; PSR := (PSR_Z_rupd((!PSR),false))
     )
   | BitsN.B(0xD,_) =>
     ( PSR := (PSR_N_rupd((!PSR),false))
     ; PSR := (PSR_V_rupd((!PSR),true))
     )
   | _ => ();

fun Encode (c,(ast,enc)) =
  ( SetPassCondition c
  ; case instructionEncode(c,(ast,enc)) of
       Thumb16 a =>
         (if (not(enc = Enc_Wide)) andalso ((Decode(Thumb a)) = ast)
            then Thumb16 a
          else BadCode("Failed to encode"))
     | Thumb32 a =>
       (if (not(enc = Enc_Narrow)) andalso ((Decode(Thumb2 a)) = ast)
          then Thumb32 a
        else BadCode("Failed to encode"))
     | mmc => mmc
  );

val al = (BitsN.B(0xE,4),"")

fun stripSpaces s =
  L3.fst
    (L3.splitr
       (fn c => Char.isSpace c,L3.snd(L3.splitl(fn c => Char.isSpace c,s))));

fun p_number s =
  case String.explode(stripSpaces s) of
     #"0" :: (#"b" :: t) => Nat.fromBinString(String.implode t)
   | #"0" :: (#"x" :: t) => Nat.fromHexString(String.implode t)
   | _ => Nat.fromString s;

fun p_signed_number (b,s) =
  case p_number s of Option.SOME n => Option.SOME(b,n) | NONE => NONE;

fun p_encode_immediate N s =
  case p_number s of
     Option.SOME n =>
       let
         val r = BitsN.fromNat(n,N)
       in
         Option.SOME(n = (BitsN.toNat r),r)
       end
   | NONE => NONE;

fun p_encode_signed_immediate N x =
  case p_signed_number x of
     Option.SOME(sub,n) =>
       let
         val r = BitsN.fromNat(n,N)
       in
         Option.SOME(sub,(n = (BitsN.toNat r),r))
       end
   | NONE => NONE;

fun p_encode_signed_offset N x =
  case p_signed_number x of
     Option.SOME(sub,n) =>
       let
         val i =
           IntInf.-(if sub then IntInf.~(Nat.toInt n) else Nat.toInt n,4)
         val r = BitsN.fromInt(i,N)
       in
         Option.SOME(i = (BitsN.toInt r),r)
       end
   | NONE => NONE;

fun p_unbounded_immediate s =
  case String.explode(stripSpaces s) of
     #"#" :: t => p_number(String.implode t)
   | _ => NONE;

fun p_immediate N s =
  case String.explode(stripSpaces s) of
     #"#" :: t => p_encode_immediate N (String.implode t)
   | _ => NONE;

fun p_immediate_number N s =
  case String.explode(stripSpaces s) of
     #"#" :: t => p_encode_immediate N (String.implode t)
   | t => p_encode_immediate N (String.implode t);

fun p_signed_immediate N s =
  case String.explode(stripSpaces s) of
     #"#" :: (#"-" :: t) =>
       p_encode_signed_immediate N (true,String.implode t)
   | #"#" :: (#"+" :: t) =>
     p_encode_signed_immediate N (false,String.implode t)
   | #"#" :: t => p_encode_signed_immediate N (false,String.implode t)
   | _ => NONE;

fun p_signed_offset N s =
  case String.explode(stripSpaces s) of
     #"+" :: (#"#" :: t) =>
       (case p_encode_signed_immediate N (false,String.implode t) of
           Option.SOME(false,(true,n)) =>
             Option.SOME
               (BitsN.<=+(BitsN.BV(0x4,N),n),BitsN.-(n,BitsN.BV(0x4,N)))
         | Option.SOME(_,(_,n)) => Option.SOME(false,n)
         | NONE => NONE)
   | _ => NONE;

fun p_offset N s =
  case String.explode(stripSpaces s) of
     #"-" :: (#"#" :: t) =>
       p_encode_signed_offset N (true,String.implode t)
   | #"+" :: (#"#" :: t) =>
     p_encode_signed_offset N (false,String.implode t)
   | _ => NONE;

fun p_label s =
  case L3.uncurry String.tokens (fn c => Char.isSpace c,s) of
     [t] =>
       let
         val (l,r) =
           L3.splitl
             (fn c => (Char.isAlphaNum c) orelse (Set.mem(c,[#"_",#"."])),
              t)
       in
         if (r = ("")) andalso
            ((not(l = (""))) andalso (not(Char.isDigit(L3.strHd l))))
           then Option.SOME l
         else NONE
       end
   | _ => NONE;

fun p_cond s =
  case s of
     "eq" => Option.SOME(BitsN.B(0x0,4))
   | "ne" => Option.SOME(BitsN.B(0x1,4))
   | "cs" => Option.SOME(BitsN.B(0x2,4))
   | "hs" => Option.SOME(BitsN.B(0x2,4))
   | "cc" => Option.SOME(BitsN.B(0x3,4))
   | "lo" => Option.SOME(BitsN.B(0x3,4))
   | "mi" => Option.SOME(BitsN.B(0x4,4))
   | "pl" => Option.SOME(BitsN.B(0x5,4))
   | "vs" => Option.SOME(BitsN.B(0x6,4))
   | "vc" => Option.SOME(BitsN.B(0x7,4))
   | "hi" => Option.SOME(BitsN.B(0x8,4))
   | "ls" => Option.SOME(BitsN.B(0x9,4))
   | "ge" => Option.SOME(BitsN.B(0xA,4))
   | "lt" => Option.SOME(BitsN.B(0xB,4))
   | "gt" => Option.SOME(BitsN.B(0xC,4))
   | "le" => Option.SOME(BitsN.B(0xD,4))
   | "al" => Option.SOME(BitsN.B(0xE,4))
   | "" => Option.SOME(BitsN.B(0xE,4))
   | _ => NONE;

fun p_suffix s =
  case L3.uncurry String.fields (fn c => c = #".",s) of
     [cond,s] =>
       (case (p_cond cond,Set.mem(s,["w","n"])) of
           (Option.SOME c,true) => Option.SOME(c,s)
         | _ => NONE)
   | [cond] =>
     (case p_cond cond of
         Option.SOME c => Option.SOME(c,"")
       | NONE => NONE)
   | _ => NONE;

fun p_al_suffix s =
  case p_suffix s of
     Option.SOME(BitsN.B(0xE,_),c) => Option.SOME(BitsN.B(0xE,4),c)
   | _ => NONE;

fun p_special_register s =
  case stripSpaces s of
     "apsr" => Option.SOME(BitsN.B(0x0,8))
   | "iapsr" => Option.SOME(BitsN.B(0x1,8))
   | "eapsr" => Option.SOME(BitsN.B(0x2,8))
   | "xpsr" => Option.SOME(BitsN.B(0x3,8))
   | "ipsr" => Option.SOME(BitsN.B(0x5,8))
   | "epsr" => Option.SOME(BitsN.B(0x6,8))
   | "iepsr" => Option.SOME(BitsN.B(0x7,8))
   | "msp" => Option.SOME(BitsN.B(0x8,8))
   | "psp" => Option.SOME(BitsN.B(0x9,8))
   | "primask" => Option.SOME(BitsN.B(0x10,8))
   | "control" => Option.SOME(BitsN.B(0x14,8))
   | n =>
     (case p_encode_immediate 8 n of
         Option.SOME(true,imm8) => Option.SOME imm8
       | _ => NONE);

fun p_register s =
  case stripSpaces s of
     "r0" => Option.SOME(BitsN.B(0x0,4))
   | "r1" => Option.SOME(BitsN.B(0x1,4))
   | "r2" => Option.SOME(BitsN.B(0x2,4))
   | "r3" => Option.SOME(BitsN.B(0x3,4))
   | "r4" => Option.SOME(BitsN.B(0x4,4))
   | "r5" => Option.SOME(BitsN.B(0x5,4))
   | "r6" => Option.SOME(BitsN.B(0x6,4))
   | "r7" => Option.SOME(BitsN.B(0x7,4))
   | "r8" => Option.SOME(BitsN.B(0x8,4))
   | "r9" => Option.SOME(BitsN.B(0x9,4))
   | "r10" => Option.SOME(BitsN.B(0xA,4))
   | "r11" => Option.SOME(BitsN.B(0xB,4))
   | "r12" => Option.SOME(BitsN.B(0xC,4))
   | "r13" => Option.SOME(BitsN.B(0xD,4))
   | "r14" => Option.SOME(BitsN.B(0xE,4))
   | "r15" => Option.SOME(BitsN.B(0xF,4))
   | "sp" => Option.SOME(BitsN.B(0xD,4))
   | "lr" => Option.SOME(BitsN.B(0xE,4))
   | "pc" => Option.SOME(BitsN.B(0xF,4))
   | _ => NONE;

fun p_register1 l = case l of [r1] => p_register r1 | _ => NONE;

fun p_register2 l =
  case l of
     [r1,r2] =>
       (case (p_register r1,p_register r2) of
           (Option.SOME v1,Option.SOME v2) => Option.SOME(v1,v2)
         | _ => NONE)
   | _ => NONE;

fun p_register3 l =
  case l of
     [r1,r2,r3] =>
       (case (p_register r1,(p_register r2,p_register r3)) of
           (Option.SOME v1,(Option.SOME v2,Option.SOME v3)) =>
             Option.SOME(v1,(v2,v3))
         | _ => NONE)
   | _ => NONE;

fun p_shift_amount (typ,(h,s)) =
  if Char.isSpace h
    then case p_unbounded_immediate s of
            Option.SOME n =>
              (if (Nat.<(n,32)) orelse
                  ((n = 32) andalso (Set.mem(typ,[SRType_LSR,SRType_ASR])))
                 then ("",(typ,NAT n))
               else ("shift amount too large",(SRType_LSL,NAT 0)))
          | NONE =>
            (case p_register s of
                Option.SOME rs => ("",(typ,REGISTER rs))
              | NONE => ("syntax error",(SRType_LSL,NAT 0)))
  else ("syntax error",(SRType_LSL,NAT 0));

fun p_shift_imm_or_reg s =
  case String.explode(stripSpaces s) of
     #"l" :: (#"s" :: (#"l" :: (h :: t))) =>
       p_shift_amount(SRType_LSL,(h,String.implode t))
   | #"l" :: (#"s" :: (#"r" :: (h :: t))) =>
     p_shift_amount(SRType_LSR,(h,String.implode t))
   | #"a" :: (#"s" :: (#"r" :: (h :: t))) =>
     p_shift_amount(SRType_ASR,(h,String.implode t))
   | #"r" :: (#"o" :: (#"r" :: (h :: t))) =>
     p_shift_amount(SRType_ROR,(h,String.implode t))
   | _ => ("syntax error",(SRType_LSL,NAT 0));

fun p_arith_logic_full (c,(opc,(setflags,l))) =
  case (p_al_suffix c,l) of
     (Option.SOME c,[r1,r2,x]) =>
       (case p_register2[r1,r2] of
           Option.SOME(rd,rn) =>
             (case p_register x of
                 Option.SOME rm =>
                   OK(c,Data(Register(opc,(setflags,(rd,(rn,rm))))))
               | NONE =>
                 (case p_immediate 32 x of
                     Option.SOME(true,imm32) =>
                       OK(c,
                          Data
                            (ArithLogicImmediate
                               (opc,(setflags,(rd,(rn,imm32))))))
                   | Option.SOME _ => FAIL("immediate too large")
                   | NONE => FAIL("syntax error")))
         | NONE => FAIL("syntax error"))
   | _ => FAIL("syntax error");

fun p_arith_logic (c,(opc,(setflags,l))) =
  case l of
     h :: _ =>
       (case p_arith_logic_full(c,(opc,(setflags,l))) of
           FAIL("syntax error") =>
             p_arith_logic_full(c,(opc,(setflags,h :: l)))
         | r => r)
   | [] => FAIL("syntax error");

fun p_test_compare (c,(opc,l)) =
  case (p_al_suffix c,l) of
     (Option.SOME c,[r1,x]) =>
       (case p_register r1 of
           Option.SOME rn =>
             (case p_register x of
                 Option.SOME rm =>
                   OK(c,Data(TestCompareRegister(opc,(rn,rm))))
               | NONE =>
                 (case (opc,p_immediate 32 x) of
                     (BitsN.B(0x2,_),Option.SOME(true,imm32)) =>
                       OK(c,Data(CompareImmediate(rn,imm32)))
                   | (BitsN.B(0x2,_),Option.SOME _) =>
                     FAIL("immediate too large")
                   | _ => FAIL("syntax error")))
         | NONE => FAIL("syntax error"))
   | _ => FAIL("syntax error");

fun p_mov_mvn (c,(negate,(setflags,l))) =
  case (p_al_suffix c,l) of
     (Option.SOME c,[r1,x]) =>
       (case p_register r1 of
           Option.SOME rd =>
             (case p_register x of
                 Option.SOME rm =>
                   OK(c,
                      Data
                        (ShiftImmediate
                           (negate,(setflags,(rd,(rm,(SRType_LSL,0)))))))
               | NONE =>
                 (case (negate,p_immediate 32 x) of
                     (false,Option.SOME(true,imm32)) =>
                       OK(c,Data(Move(rd,imm32)))
                   | (false,Option.SOME _) => FAIL("immediate too large")
                   | _ => FAIL("syntax error")))
         | NONE => FAIL("syntax error"))
   | (Option.SOME c,[r1,r2,sh]) =>
     (case (negate,(setflags,(p_register2[r1,r2],p_shift_imm_or_reg sh))) of
         (false,(true,(Option.SOME(rd,rm),("",(typ,NAT n))))) =>
           OK(c,Data(ShiftImmediate(negate,(setflags,(rd,(rm,(typ,n)))))))
       | (false,(true,(Option.SOME(rd,rm),("",(typ,REGISTER rs))))) =>
         OK(c,Data(ShiftRegister(rd,(rm,(typ,rs)))))
       | (false,(true,(Option.SOME _,(err,_)))) => FAIL err
       | _ => FAIL("syntax error"))
   | _ => FAIL("syntax error");

fun p_shift_full (c,(typ,l)) =
  case (p_al_suffix c,l) of
     (Option.SOME c,[r1,r2,s]) =>
       (case p_register2[r1,r2] of
           Option.SOME(rd,rn) =>
             (case p_register s of
                 Option.SOME rm =>
                   OK(c,Data(ShiftRegister(rd,(rn,(typ,rm)))))
               | NONE =>
                 (case p_unbounded_immediate s of
                     Option.SOME n =>
                       (if (Nat.<(n,32)) orelse
                           ((n = 32) andalso
                            (Set.mem(typ,[SRType_LSR,SRType_ASR])))
                          then OK(c,
                                  Data
                                    (ShiftImmediate
                                       (false,(true,(rd,(rn,(typ,n)))))))
                        else FAIL("shift amount too large"))
                   | NONE => FAIL("syntax error")))
         | NONE => FAIL("syntax error"))
   | _ => FAIL("syntax error");

fun p_shift (c,(typ,l)) =
  case l of
     h :: _ =>
       (case p_shift_full(c,(typ,l)) of
           FAIL("syntax error") => p_shift_full(c,(typ,h :: l))
         | r => r)
   | [] => FAIL("syntax error");

fun p_adr (c,l) =
  case (p_al_suffix c,l) of
     (Option.SOME c,[r,n]) =>
       (case p_register r of
           Option.SOME d =>
             (case p_signed_offset 10 n of
                 Option.SOME(true,imm10) =>
                   OK(c,
                      Data
                        (ArithLogicImmediate
                           (BitsN.B(0x4,4),
                            (false,
                             (d,
                              (BitsN.B(0xF,4),
                               BitsN.fromNat(BitsN.toNat imm10,32)))))))
               | Option.SOME _ => FAIL("bad offset")
               | NONE =>
                 (case p_label n of
                     Option.SOME s =>
                       PENDING
                         (s,
                          (c,
                           Data
                             (ArithLogicImmediate
                                (BitsN.B(0x4,4),
                                 (false,
                                  (d,(BitsN.B(0xF,4),BitsN.B(0x0,32))))))))
                   | NONE => FAIL("syntax error")))
         | NONE => FAIL("syntax error"))
   | _ => FAIL("syntax error");

fun p_bx (c,l) =
  case (p_al_suffix c,p_register1 l) of
     (Option.SOME c,Option.SOME rm) => OK(c,Branch(BranchExchange rm))
   | _ => FAIL("syntax error");

fun p_bl (c,l) =
  case (p_al_suffix c,l) of
     (Option.SOME c,[a]) =>
       (case p_offset 32 a of
           Option.SOME(true,offset) =>
             OK(c,Branch(BranchLinkImmediate offset))
         | Option.SOME(false,_) => FAIL("offset too large")
         | NONE =>
           (case p_label a of
               Option.SOME label =>
                 PENDING
                   (label,(c,Branch(BranchLinkImmediate(BitsN.B(0x0,32)))))
             | NONE => FAIL("syntax error")))
   | _ => FAIL("syntax error");

fun p_b (c,l) =
  case (p_suffix c,l) of
     (Option.SOME c,[a]) =>
       (case p_offset 32 a of
           Option.SOME(true,offset) => OK(c,Branch(BranchTarget offset))
         | Option.SOME(false,_) => FAIL("offset too large")
         | NONE =>
           (case p_label a of
               Option.SOME label =>
                 PENDING(label,(c,Branch(BranchTarget(BitsN.B(0x0,32)))))
             | NONE => FAIL("syntax error")))
   | _ => FAIL("syntax error");

fun p_blx (c,l) =
  case (p_al_suffix c,p_register1 l) of
     (Option.SOME c,Option.SOME rm) =>
       OK(c,Branch(BranchLinkExchangeRegister rm))
   | _ => FAIL("syntax error");

fun p_mul (c,l) =
  case (p_al_suffix c,l) of
     (Option.SOME c,[_,_,_]) =>
       (case p_register3 l of
           Option.SOME(rd,(rn,rm)) =>
             OK(c,Multiply(Multiply32(rd,(rn,rm))))
         | NONE => FAIL("syntax error"))
   | (Option.SOME c,[_,_]) =>
     (case p_register2 l of
         Option.SOME(rn,rm) => OK(c,Multiply(Multiply32(rn,(rm,rn))))
       | NONE => FAIL("syntax error"))
   | _ => FAIL("syntax error");

fun p_sxtb_etc (c,(half,(unsigned,l))) =
  case (p_al_suffix c,l) of
     (Option.SOME c,[r1,r2]) =>
       (case p_register2[r1,r2] of
           Option.SOME(rd,rm) =>
             let
               val a = (unsigned,(rd,rm))
             in
               OK(c,Media(if half then ExtendHalfword a else ExtendByte a))
             end
         | NONE => FAIL("syntax error"))
   | _ => FAIL("syntax error");

fun p_rev (c,l) =
  case (p_al_suffix c,p_register2 l) of
     (Option.SOME c,Option.SOME(rd,rm)) => OK(c,Media(ByteReverse(rd,rm)))
   | _ => FAIL("syntax error");

fun p_rev16 (c,l) =
  case (p_al_suffix c,p_register2 l) of
     (Option.SOME c,Option.SOME(rd,rm)) =>
       OK(c,Media(ByteReversePackedHalfword(rd,rm)))
   | _ => FAIL("syntax error");

fun p_revsh (c,l) =
  case (p_al_suffix c,p_register2 l) of
     (Option.SOME c,Option.SOME(rd,rm)) =>
       OK(c,Media(ByteReverseSignedHalfword(rd,rm)))
   | _ => FAIL("syntax error");

fun closingRegList s =
  case L3.splitr(fn c => c = #"}",stripSpaces s) of
     (l,"}") => Option.SOME l
   | _ => NONE;

fun p_reg_list (w,s) =
  case p_register s of
     Option.SOME r =>
       let
         val n = BitsN.toNat r
       in
         if BitsN.bit(w,n)
           then NONE
         else Option.SOME(BitsN.||(w,BitsN.<<(BitsN.B(0x1,16),n)))
       end
   | NONE =>
     (case L3.uncurry String.fields (fn c => c = #"-",s) of
         [r1,r2] =>
           (case p_register2[r1,r2] of
               Option.SOME(rlo,rhi) =>
                 let
                   val lo = BitsN.toNat rlo
                   val hi = BitsN.toNat rhi
                   val mask =
                     BitsN.-
                       (BitsN.<<(BitsN.B(0x1,16),Nat.+(hi,1)),
                        BitsN.<<(BitsN.B(0x1,16),lo))
                 in
                   if (Nat.<(lo,hi)) andalso
                      ((BitsN.&&(w,mask)) = (BitsN.B(0x0,16)))
                     then Option.SOME(BitsN.||(w,mask))
                   else NONE
                 end
             | NONE => NONE)
       | _ => NONE);

fun p_registers_loop (w,l) =
  case l of
     [s] =>
       (case closingRegList s of
           Option.SOME h =>
             (case p_reg_list(w,h) of
                 Option.SOME r => Option.SOME r
               | NONE => NONE)
         | NONE => NONE)
   | h :: t =>
     (case p_reg_list(w,h) of
         Option.SOME r => p_registers_loop(r,t)
       | NONE => NONE)
   | [] => NONE;

fun p_registers l =
  case l of
     h :: t =>
       (case String.explode(stripSpaces h) of
           #"{" :: r =>
             let
               val r = stripSpaces(String.implode r)
             in
               p_registers_loop
                 (BitsN.B(0x0,16),if r = ("") then t else r :: t)
             end
         | _ => NONE)
   | _ => NONE;

fun closingAddress l =
  case l of
     [s] =>
       (case L3.splitr(fn c => c = #"]",stripSpaces s) of
           (l,"]") => Option.SOME l
         | _ => NONE)
   | _ => NONE;

fun p_address_mode l =
  case l of
     h1 :: t1 =>
       (case String.explode(stripSpaces h1) of
           #"[" :: r1 =>
             let
               val r1 = String.implode r1
             in
               case p_register r1 of
                  Option.SOME rn =>
                    (case closingAddress t1 of
                        Option.SOME offset =>
                          (case p_signed_immediate 32 offset of
                              Option.SOME(false,(true,imm32)) =>
                                ("",Option.SOME(rn,immediate_form imm32))
                            | Option.SOME(true,_) =>
                              ("negative offset",NONE)
                            | Option.SOME(_,(false,_)) =>
                              ("immediate too large",NONE)
                            | NONE =>
                              (case p_register offset of
                                  Option.SOME rm =>
                                    ("",Option.SOME(rn,register_form rm))
                                | NONE => ("syntax error",NONE)))
                      | NONE => ("syntax error",NONE))
                | NONE =>
                  (case closingAddress(r1 :: t1) of
                      Option.SOME r2 =>
                        (case p_register r2 of
                            Option.SOME rn =>
                              ("",
                               Option.SOME
                                 (rn,immediate_form(BitsN.B(0x0,32))))
                          | NONE => ("syntax error",NONE))
                    | _ => ("syntax error",NONE))
             end
         | _ =>
           (case (p_signed_offset 32 h1,t1) of
               (Option.SOME(true,imm32),[]) =>
                 ("",Option.SOME(BitsN.B(0xF,4),immediate_form imm32))
             | (Option.SOME(false,_),[]) => ("bad offset",NONE)
             | _ => ("syntax error",NONE)))
   | _ => ("syntax error",NONE);

fun pick_ldr_str (opc,(rt,(rn,offset))) =
  let
    val r = (rt,(rn,offset))
  in
    case opc of
       0 =>
         (case (rn,offset) of
             (BitsN.B(0xF,_),immediate_form imm32) =>
               Load(LoadLiteral(rt,imm32))
           | _ => Load(LoadWord r))
     | 1 => Store(StoreByte r)
     | 2 => Store(StoreHalf r)
     | _ => Store(StoreWord r)
  end;

fun p_ldr_str (c,(opc,l)) =
  case (p_al_suffix c,l) of
     (Option.SOME c,h :: t) =>
       (case p_register h of
           Option.SOME rt =>
             (case p_address_mode t of
                 ("",Option.SOME(rn,offset)) =>
                   OK(c,pick_ldr_str(opc,(rt,(rn,offset))))
               | (err,_) =>
                 (case t of
                     [l] =>
                       (case p_label l of
                           Option.SOME s =>
                             PENDING
                               (s,
                                (c,
                                 pick_ldr_str
                                   (opc,
                                    (rt,
                                     (BitsN.B(0xF,4),
                                      immediate_form(BitsN.B(0x0,32)))))))
                         | NONE => FAIL err)
                   | _ => FAIL err))
         | NONE => FAIL("syntax error"))
   | _ => FAIL("syntax error");

fun p_ldrb_ldrh (c,(unsigned,(byte,l))) =
  case (p_al_suffix c,l) of
     (Option.SOME c,h :: t) =>
       (case p_register h of
           Option.SOME rt =>
             (case p_address_mode t of
                 ("",Option.SOME(rn,offset)) =>
                   let
                     val r = (unsigned,(rt,(rn,offset)))
                   in
                     OK(c,Load(if byte then LoadByte r else LoadHalf r))
                   end
               | (err,_) =>
                 (case t of
                     [l] =>
                       (case p_label l of
                           Option.SOME s =>
                             let
                               val r =
                                 (unsigned,
                                  (rt,
                                   (BitsN.B(0xF,4),
                                    immediate_form(BitsN.B(0x0,32)))))
                               val a =
                                 if byte then LoadByte r else LoadHalf r
                             in
                               PENDING(s,(c,Load a))
                             end
                         | NONE => FAIL err)
                   | _ => FAIL err))
         | NONE => FAIL("syntax error"))
   | _ => FAIL("syntax error");

fun p_pop_push (c,(pop,l)) =
  case (p_al_suffix c,p_registers l) of
     (Option.SOME c,Option.SOME w) =>
       (if pop
          then if (BitsN.&&(w,BitsN.B(0x7F00,16))) = (BitsN.B(0x0,16))
                 then OK(c,
                         Load
                           (LoadMultiple
                              (true,
                               (BitsN.B(0xD,4),
                                BitsN.@@
                                  (BitsN.bits(15,15) w,BitsN.bits(7,0) w)))))
               else FAIL("bad register list")
        else if (BitsN.&&(w,BitsN.B(0xBF00,16))) = (BitsN.B(0x0,16))
          then OK(c,
                  Store
                    (Push(BitsN.@@(BitsN.bits(14,14) w,BitsN.bits(7,0) w))))
        else FAIL("bad register list"))
   | (NONE,_) => FAIL("syntax error")
   | _ => FAIL("bad register list");

fun p_ldm_stm (c,(load,l)) =
  case (p_al_suffix c,l) of
     (Option.SOME c,h :: t) =>
       let
         val (r,wb) = L3.splitr(fn c => c = #"!",stripSpaces h)
       in
         case (p_register r,(p_registers t,Set.mem(wb,["","!"]))) of
            (Option.SOME rn,(Option.SOME w,true)) =>
              (if (BitsN.bits(15,8) w) = (BitsN.B(0x0,8))
                 then let
                        val wback = wb = ("!")
                      in
                        if load
                          then OK(c,
                                  Load
                                    (LoadMultiple
                                       (wback,(rn,BitsN.bits(8,0) w))))
                        else if wback
                          then if (rn = (BitsN.B(0xD,4))) andalso
                                  ((BitsN.&&(w,BitsN.B(0xBF00,16))) =
                                   (BitsN.B(0x0,16)))
                                 then OK(c,
                                         Store
                                           (Push
                                              (BitsN.@@
                                                 (BitsN.bits(14,14) w,
                                                  BitsN.bits(7,0) w))))
                               else OK(c,
                                       Store
                                         (StoreMultiple
                                            (rn,BitsN.bits(7,0) w)))
                        else FAIL("syntax error")
                      end
               else FAIL("bad register list"))
          | (Option.SOME _,(NONE,true)) => FAIL("bad register list")
          | _ => FAIL("syntax error")
       end
   | _ => FAIL("syntax error");

fun p_cps (enable,l) =
  case l of
     [i] =>
       (if (stripSpaces i) = ("i")
          then OK(al,System(ChangeProcessorState enable))
        else FAIL("syntax error"))
   | _ => FAIL("syntax error");

fun p_mrs (c,l) =
  case (p_al_suffix c,l) of
     (Option.SOME c,[r,s]) =>
       (case (p_register r,p_special_register s) of
           (Option.SOME rd,Option.SOME SYSm) =>
             OK(c,System(MoveToRegisterFromSpecial(SYSm,rd)))
         | _ => FAIL("syntax error"))
   | _ => FAIL("syntax error");

fun p_msr (c,l) =
  case (p_al_suffix c,l) of
     (Option.SOME c,[s,r]) =>
       (case (p_special_register s,p_register r) of
           (Option.SOME SYSm,Option.SOME rn) =>
             OK(c,System(MoveToSpecialRegister(SYSm,rn)))
         | _ => FAIL("syntax error"))
   | _ => FAIL("syntax error");

fun p_barrier_option l =
  case l of
     [] => Option.SOME(BitsN.B(0xF,4))
   | [s] =>
     (case stripSpaces s of
         "sy" => Option.SOME(BitsN.B(0xF,4))
       | "st" => Option.SOME(BitsN.B(0xE,4))
       | "ish" => Option.SOME(BitsN.B(0xB,4))
       | "ishst" => Option.SOME(BitsN.B(0xA,4))
       | "nsh" => Option.SOME(BitsN.B(0x7,4))
       | "nshst" => Option.SOME(BitsN.B(0x6,4))
       | "osh" => Option.SOME(BitsN.B(0x3,4))
       | "oshst" => Option.SOME(BitsN.B(0x2,4))
       | n =>
         (case Nat.fromString n of
             Option.SOME v => Option.SOME(BitsN.fromNat(v,4))
           | NONE => NONE))
   | _ => NONE;

fun p_dmb_dsb (c,(sync,l)) =
  case (p_suffix c,p_barrier_option l) of
     (Option.SOME c,Option.SOME option) =>
       OK(c,
          Hint
            (if sync
               then DataSynchronizationBarrier option
             else DataMemoryBarrier option))
   | _ => FAIL("syntax error");

fun p_isb (c,l) =
  case (p_suffix c,p_barrier_option l) of
     (Option.SOME c,Option.SOME(BitsN.B(0xF,_))) =>
       OK(c,Hint(InstructionSynchronizationBarrier(BitsN.B(0xF,4))))
   | _ => FAIL("syntax error");

fun p_call (c,(opc,l)) =
  case (p_al_suffix c,l) of
     (Option.SOME c,[imm]) =>
       (case p_immediate_number 32 imm of
           Option.SOME(true,imm32) =>
             let
               val ast =
                 case opc of
                    0 => Undefined imm32
                  | 1 => System(SupervisorCall imm32)
                  | _ => Hint(Breakpoint imm32)
             in
               OK(c,ast)
             end
         | Option.SOME(false,_) => FAIL("immediate too large")
         | _ => FAIL("syntax error"))
   | _ => FAIL("syntax error");

fun p_noarg (c,i) =
  case p_al_suffix c of
     Option.SOME c => OK(c,i)
   | NONE => FAIL("syntax error");

fun p_tokens s =
  let
    val (l,r) =
      L3.splitl
        (fn c => not(Char.isSpace c),
         L3.lowercase(L3.snd(L3.splitl(fn c => Char.isSpace c,s))))
    val r = L3.uncurry String.fields (fn c => c = #",",r)
    val r =
      if ((L3.length r) = 1) andalso ((stripSpaces(List.hd r)) = (""))
        then []
      else r
  in
    l :: r
  end;

fun instructionFromString s =
  case p_tokens s of
     v'0 :: v'1 =>
       (case (String.explode v'0,v'1) of
           (#"a" :: (#"d" :: (#"r" :: c)),l) => p_adr(String.implode c,l)
         | (#"a" :: (#"n" :: (#"d" :: (#"s" :: c))),l) =>
           p_arith_logic(String.implode c,(BitsN.B(0x0,4),(true,l)))
         | (#"e" :: (#"o" :: (#"r" :: (#"s" :: c))),l) =>
           p_arith_logic(String.implode c,(BitsN.B(0x1,4),(true,l)))
         | (#"s" :: (#"u" :: (#"b" :: (#"s" :: c))),l) =>
           p_arith_logic(String.implode c,(BitsN.B(0x2,4),(true,l)))
         | (#"s" :: (#"u" :: (#"b" :: c)),l) =>
           p_arith_logic(String.implode c,(BitsN.B(0x2,4),(false,l)))
         | (#"r" :: (#"s" :: (#"b" :: (#"s" :: c))),l) =>
           p_arith_logic(String.implode c,(BitsN.B(0x3,4),(true,l)))
         | (#"a" :: (#"d" :: (#"d" :: (#"s" :: c))),l) =>
           p_arith_logic(String.implode c,(BitsN.B(0x4,4),(true,l)))
         | (#"a" :: (#"d" :: (#"d" :: c)),l) =>
           p_arith_logic(String.implode c,(BitsN.B(0x4,4),(false,l)))
         | (#"a" :: (#"d" :: (#"c" :: (#"s" :: c))),l) =>
           p_arith_logic(String.implode c,(BitsN.B(0x5,4),(true,l)))
         | (#"s" :: (#"b" :: (#"c" :: (#"s" :: c))),l) =>
           p_arith_logic(String.implode c,(BitsN.B(0x6,4),(true,l)))
         | (#"o" :: (#"r" :: (#"r" :: (#"s" :: c))),l) =>
           p_arith_logic(String.implode c,(BitsN.B(0xC,4),(true,l)))
         | (#"b" :: (#"i" :: (#"c" :: (#"s" :: c))),l) =>
           p_arith_logic(String.implode c,(BitsN.B(0xE,4),(true,l)))
         | (#"t" :: (#"s" :: (#"t" :: c)),l) =>
           p_test_compare(String.implode c,(BitsN.B(0x0,2),l))
         | (#"c" :: (#"m" :: (#"p" :: c)),l) =>
           p_test_compare(String.implode c,(BitsN.B(0x2,2),l))
         | (#"c" :: (#"m" :: (#"n" :: c)),l) =>
           p_test_compare(String.implode c,(BitsN.B(0x3,2),l))
         | (#"m" :: (#"o" :: (#"v" :: (#"s" :: c))),l) =>
           p_mov_mvn(String.implode c,(false,(true,l)))
         | (#"m" :: (#"o" :: (#"v" :: c)),l) =>
           p_mov_mvn(String.implode c,(false,(false,l)))
         | (#"m" :: (#"v" :: (#"n" :: (#"s" :: c))),l) =>
           p_mov_mvn(String.implode c,(true,(true,l)))
         | (#"l" :: (#"s" :: (#"l" :: (#"s" :: c))),l) =>
           p_shift(String.implode c,(SRType_LSL,l))
         | (#"l" :: (#"s" :: (#"r" :: (#"s" :: c))),l) =>
           p_shift(String.implode c,(SRType_LSR,l))
         | (#"a" :: (#"s" :: (#"r" :: (#"s" :: c))),l) =>
           p_shift(String.implode c,(SRType_ASR,l))
         | (#"r" :: (#"o" :: (#"r" :: (#"s" :: c))),l) =>
           p_shift(String.implode c,(SRType_ROR,l))
         | (#"m" :: (#"u" :: (#"l" :: (#"s" :: c))),l) =>
           p_mul(String.implode c,l)
         | (#"s" :: (#"x" :: (#"t" :: (#"b" :: c))),l) =>
           p_sxtb_etc(String.implode c,(false,(false,l)))
         | (#"u" :: (#"x" :: (#"t" :: (#"b" :: c))),l) =>
           p_sxtb_etc(String.implode c,(false,(true,l)))
         | (#"s" :: (#"x" :: (#"t" :: (#"h" :: c))),l) =>
           p_sxtb_etc(String.implode c,(true,(false,l)))
         | (#"u" :: (#"x" :: (#"t" :: (#"h" :: c))),l) =>
           p_sxtb_etc(String.implode c,(true,(true,l)))
         | (#"r" :: (#"e" :: (#"v" :: (#"1" :: (#"6" :: c)))),l) =>
           p_rev16(String.implode c,l)
         | (#"r" :: (#"e" :: (#"v" :: (#"s" :: (#"h" :: c)))),l) =>
           p_revsh(String.implode c,l)
         | (#"r" :: (#"e" :: (#"v" :: c)),l) => p_rev(String.implode c,l)
         | (#"l" :: (#"d" :: (#"r" :: (#"b" :: c))),l) =>
           p_ldrb_ldrh(String.implode c,(true,(true,l)))
         | (#"l" :: (#"d" :: (#"r" :: (#"s" :: (#"b" :: c)))),l) =>
           p_ldrb_ldrh(String.implode c,(false,(true,l)))
         | (#"l" :: (#"d" :: (#"r" :: (#"h" :: c))),l) =>
           p_ldrb_ldrh(String.implode c,(true,(false,l)))
         | (#"l" :: (#"d" :: (#"r" :: (#"s" :: (#"h" :: c)))),l) =>
           p_ldrb_ldrh(String.implode c,(false,(false,l)))
         | (#"l" :: (#"d" :: (#"r" :: c)),l) =>
           p_ldr_str(String.implode c,(0,l))
         | (#"s" :: (#"t" :: (#"r" :: (#"b" :: c))),l) =>
           p_ldr_str(String.implode c,(1,l))
         | (#"s" :: (#"t" :: (#"r" :: (#"h" :: c))),l) =>
           p_ldr_str(String.implode c,(2,l))
         | (#"s" :: (#"t" :: (#"r" :: c)),l) =>
           p_ldr_str(String.implode c,(3,l))
         | (#"p" :: (#"o" :: (#"p" :: c)),l) =>
           p_pop_push(String.implode c,(true,l))
         | (#"p" :: (#"u" :: (#"s" :: (#"h" :: c))),l) =>
           p_pop_push(String.implode c,(false,l))
         | (#"l" :: (#"d" :: (#"m" :: (#"i" :: (#"a" :: c)))),l) =>
           p_ldm_stm(String.implode c,(true,l))
         | (#"l" :: (#"d" :: (#"m" :: (#"f" :: (#"d" :: c)))),l) =>
           p_ldm_stm(String.implode c,(true,l))
         | (#"l" :: (#"d" :: (#"m" :: c)),l) =>
           p_ldm_stm(String.implode c,(true,l))
         | (#"s" :: (#"t" :: (#"m" :: (#"i" :: (#"a" :: c)))),l) =>
           p_ldm_stm(String.implode c,(false,l))
         | (#"s" :: (#"t" :: (#"m" :: (#"e" :: (#"a" :: c)))),l) =>
           p_ldm_stm(String.implode c,(false,l))
         | (#"s" :: (#"t" :: (#"m" :: c)),l) =>
           p_ldm_stm(String.implode c,(false,l))
         | ([#"c",#"p",#"s",#"i",#"e"],l) => p_cps(true,l)
         | ([#"c",#"p",#"s",#"i",#"d"],l) => p_cps(false,l)
         | (#"m" :: (#"r" :: (#"s" :: c)),l) => p_mrs(String.implode c,l)
         | (#"m" :: (#"s" :: (#"r" :: c)),l) => p_msr(String.implode c,l)
         | (#"u" :: (#"d" :: (#"f" :: c)),l) =>
           p_call(String.implode c,(0,l))
         | (#"s" :: (#"v" :: (#"c" :: c)),l) =>
           p_call(String.implode c,(1,l))
         | (#"b" :: (#"k" :: (#"p" :: (#"t" :: c))),l) =>
           p_call(String.implode c,(2,l))
         | (#"d" :: (#"m" :: (#"b" :: c)),l) =>
           p_dmb_dsb(String.implode c,(false,l))
         | (#"d" :: (#"s" :: (#"b" :: c)),l) =>
           p_dmb_dsb(String.implode c,(true,l))
         | (#"i" :: (#"s" :: (#"b" :: c)),l) => p_isb(String.implode c,l)
         | (#"n" :: (#"o" :: (#"p" :: c)),[]) =>
           p_noarg(String.implode c,NoOperation ())
         | (#"s" :: (#"e" :: (#"v" :: c)),[]) =>
           p_noarg(String.implode c,Hint(SendEvent ()))
         | (#"w" :: (#"f" :: (#"e" :: c)),[]) =>
           p_noarg(String.implode c,Hint(WaitForEvent ()))
         | (#"w" :: (#"f" :: (#"i" :: c)),[]) =>
           p_noarg(String.implode c,Hint(WaitForInterrupt ()))
         | (#"y" :: (#"i" :: (#"e" :: (#"l" :: (#"d" :: c)))),[]) =>
           p_noarg(String.implode c,Hint(Yield ()))
         | ([#"b",#"l",c1,c2,#".",e],l) =>
           p_bl(String.implode[c1,c2,#".",e],l)
         | ([#"b",#"l",#".",e],l) => p_bl(String.implode[#".",e],l)
         | ([#"b",#"l"],l) => p_bl("",l)
         | (#"b" :: (#"x" :: c),l) => p_bx(String.implode c,l)
         | (#"b" :: (#"l" :: (#"x" :: c)),l) => p_blx(String.implode c,l)
         | (#"b" :: c,l) => p_b(String.implode c,l)
         | ([#"h",#"a",#"l",#"f"],[w]) =>
           (case p_encode_immediate 16 w of
               Option.SOME(true,w) => HALFWORD w
             | Option.SOME _ => FAIL("immediate too large")
             | NONE => FAIL("syntax error"))
         | _ => FAIL("Unrecognised op-code"))
   | _ => FAIL("Unrecognised op-code");

fun halfString w = L3.padLeftString(#"0",(4,BitsN.toHexString w));

fun EncodeThumb s =
  case instructionFromString s of
     OK((c,e),ast) =>
       let
         val enc =
           case e of "n" => Enc_Narrow | "w" => Enc_Wide | _ => Enc_Thumb
       in
         case instructionEncode(c,(ast,enc)) of
            Thumb16 w => ("",Option.SOME(halfString w))
          | Thumb32(w1,w2) =>
            ("",
             Option.SOME(String.concat[halfString w1," ",halfString w2]))
          | BadCode err => (("Encode error: ") ^ err,NONE)
       end
   | HALFWORD w => ("",Option.SOME(halfString w))
   | PENDING _ => ("Contains label",NONE)
   | FAIL err => (("Parse error: ") ^ err,NONE);

fun s_cond c =
  case c of
     BitsN.B(0x0,_) => "eq"
   | BitsN.B(0x1,_) => "ne"
   | BitsN.B(0x2,_) => "cs"
   | BitsN.B(0x3,_) => "cc"
   | BitsN.B(0x4,_) => "mi"
   | BitsN.B(0x5,_) => "pl"
   | BitsN.B(0x6,_) => "vs"
   | BitsN.B(0x7,_) => "vc"
   | BitsN.B(0x8,_) => "hi"
   | BitsN.B(0x9,_) => "ls"
   | BitsN.B(0xA,_) => "ge"
   | BitsN.B(0xB,_) => "lt"
   | BitsN.B(0xC,_) => "gt"
   | BitsN.B(0xD,_) => "le"
   | _ => "";

fun s_reg r =
  case r of
     BitsN.B(0xD,_) => "sp"
   | BitsN.B(0xE,_) => "lr"
   | BitsN.B(0xF,_) => "pc"
   | _ => ("r") ^ (Nat.toString(BitsN.toNat r));

fun s_reg2 (r1,r2) = String.concat[s_reg r1,", ",s_reg r2];

fun s_reg3 (r1,(r2,r3)) = String.concat[s_reg2(r1,r2),", ",s_reg r3];

fun s_reg4 (r1,(r2,(r3,r4))) =
  String.concat[s_reg3(r1,(r2,r3)),", ",s_reg r4];

fun s_hex N v =
  if BitsN.<+(v,BitsN.BV(0x64,N))
    then Nat.toString(BitsN.toNat v)
  else ("0x") ^ (BitsN.toHexString v);

fun s_offset imm32 =
  let
    val imm32 = BitsN.+(imm32,BitsN.B(0x4,32))
  in
    if BitsN.<(imm32,BitsN.B(0x0,32))
      then ("-#") ^ (s_hex 32 (BitsN.neg imm32))
    else ("+#") ^ (s_hex 32 imm32)
  end;

fun s_maybe_offset imm32 =
  if imm32 = (BitsN.B(0x0,32)) then "" else (", #") ^ (s_hex 32 imm32);

fun s_special_reg SYSm =
  case SYSm of
     BitsN.B(0x0,_) => "apsr"
   | BitsN.B(0x1,_) => "iapsr"
   | BitsN.B(0x2,_) => "eapsr"
   | BitsN.B(0x3,_) => "xpsr"
   | BitsN.B(0x5,_) => "ipsr"
   | BitsN.B(0x6,_) => "epsr"
   | BitsN.B(0x7,_) => "iepsr"
   | BitsN.B(0x8,_) => "msp"
   | BitsN.B(0x9,_) => "psp"
   | BitsN.B(0x10,_) => "primask"
   | BitsN.B(0x14,_) => "control"
   | _ => Nat.toString(BitsN.toNat SYSm);

fun s_barrier_option option =
  case option of
     BitsN.B(0x2,_) => "oshst"
   | BitsN.B(0x3,_) => "osh"
   | BitsN.B(0x6,_) => "nshst"
   | BitsN.B(0x7,_) => "nsh"
   | BitsN.B(0xA,_) => "ishst"
   | BitsN.B(0xB,_) => "ish"
   | BitsN.B(0xE,_) => "st"
   | BitsN.B(0xF,_) => "sy"
   | _ => Nat.toString(BitsN.toNat option);

fun s_imm_form (t,(n,imm32)) =
  String.concat[s_reg t,", [",s_reg n,s_maybe_offset imm32,"]"];

fun s_reg_form (t,(n,m)) = String.concat[s_reg t,", [",s_reg2(n,m),"]"];

fun contiguous (a,(i,l)) =
  case l of
     [] => a
   | y :: x =>
     contiguous
       (if y
          then case a of
                  [] => [(i,i)]
                | (b,t) :: r =>
                  (if (Nat.+(i,1)) = b then (i,t) :: r else (i,i) :: a)
        else a,(Nat.-(i,1),x));

fun s_registers_from_contiguous (a,l) =
  case l of
     [] => a
   | (b,t) :: r =>
     let
       val d = Nat.-(t,b)
     in
       s_registers_from_contiguous
         (if d = 0
            then String.concat[a,", ",s_reg(BitsN.fromNat(b,4))]
          else if d = 1
            then String.concat
                   [a,", ",s_reg2(BitsN.fromNat(b,4),BitsN.fromNat(t,4))]
          else String.concat
                 [a,", ",s_reg(BitsN.fromNat(b,4)),"-",
                  s_reg(BitsN.fromNat(t,4))],r)
     end;

fun s_registers N l =
  case String.explode
    (s_registers_from_contiguous
       ("",
        contiguous
          ([],(Nat.-(BitsN.size(BitsN.BV(0x0,N)),1),BitsN.toBitstring l)))) of
     [] => "{}"
   | #"," :: (#" " :: s) => String.concat["{",String.implode s,"}"]
   | _ => "???";

fun s_test_compare opc =
  case opc of
     BitsN.B(0x0,_) => "tst"
   | BitsN.B(0x1,_) => "teq"
   | BitsN.B(0x2,_) => "cmp"
   | BitsN.B(0x3,_) => "cmn"
   | _ => raise General.Bind;

fun s_arith_logic opc =
  case opc of
     BitsN.B(0x0,_) => "and"
   | BitsN.B(0x1,_) => "eor"
   | BitsN.B(0x2,_) => "sub"
   | BitsN.B(0x3,_) => "rsb"
   | BitsN.B(0x4,_) => "add"
   | BitsN.B(0x5,_) => "adc"
   | BitsN.B(0x6,_) => "sbc"
   | BitsN.B(0x7,_) => "rsc"
   | BitsN.B(0x8,_) => "tst"
   | BitsN.B(0x9,_) => "teq"
   | BitsN.B(0xA,_) => "cmp"
   | BitsN.B(0xB,_) => "cmn"
   | BitsN.B(0xC,_) => "orr"
   | BitsN.B(0xD,_) => "mov"
   | BitsN.B(0xE,_) => "bic"
   | BitsN.B(0xF,_) => "mvn"
   | _ => raise General.Bind;

fun s_shift shift_t =
  case shift_t of
     SRType_LSL => "lsl"
   | SRType_LSR => "lsr"
   | SRType_ASR => "asr"
   | SRType_ROR => "ror"
   | SRType_RRX => "rrx";

fun s_shift_n (shift_t,shift_n) =
  case (shift_t,shift_n) of
     (SRType_LSL,0) => ""
   | (SRType_RRX,1) => ", rrx"
   | _ => String.concat[", ",s_shift shift_t," #",Nat.toString shift_n];

fun s_shift_r (add,(r,(shift_t,shift_n))) =
  String.concat
    [", ",if add then "" else "-",s_reg r,s_shift_n(shift_t,shift_n)];

fun s_branch (c,ast) =
  case ast of
     BranchTarget imm32 => (("b") ^ (s_cond c),s_offset imm32)
   | BranchExchange m => ("bx",s_reg m)
   | BranchLinkImmediate imm32 => ("bl",s_offset imm32)
   | BranchLinkExchangeRegister m => ("blx",s_reg m);

fun s_data ast =
  case ast of
     Move(d,imm12) => ("movs",String.concat[s_reg d,", #",s_hex 32 imm12])
   | ArithLogicImmediate(opc,(setflags,(d,(n,imm12)))) =>
     ((s_arith_logic opc) ^ (if setflags then "s" else ""),
      String.concat[s_reg2(d,n),", #",s_hex 32 imm12])
   | Register(opc,(setflags,(d,(n,m)))) =>
     ((s_arith_logic opc) ^ (if setflags then "s" else ""),s_reg3(d,(n,m)))
   | TestCompareRegister(opc,(n,m)) => (s_test_compare opc,s_reg2(n,m))
   | CompareImmediate(n,imm32) =>
     ("cmp",String.concat[s_reg n,", #",s_hex 32 imm32])
   | ShiftImmediate(true,(setflags,(d,(m,(shift_t,shift_n))))) =>
     (("mvn") ^ (if setflags then "s" else ""),
      (s_reg2(d,m)) ^ (s_shift_n(shift_t,shift_n)))
   | ShiftImmediate(false,(setflags,(d,(m,(SRType_LSL,0))))) =>
     (("mov") ^ (if setflags then "s" else ""),s_reg2(d,m))
   | ShiftImmediate(false,(setflags,(d,(m,(shift_t,shift_n))))) =>
     ((s_shift shift_t) ^ (if setflags then "s" else ""),
      (s_reg2(d,m))
        ^
        (if (shift_t = SRType_RRX) andalso (shift_n = 1)
           then ""
         else (", #") ^ (Nat.toString shift_n)))
   | ShiftRegister(d,(n,(shift_t,m))) =>
     ((s_shift shift_t) ^ ("s"),s_reg3(d,(n,m)));

fun s_load ast =
  case ast of
     LoadWord(t,(n,immediate_form imm32)) =>
       ("ldr",s_imm_form(t,(n,imm32)))
   | LoadWord(t,(n,register_form m)) => ("ldr",s_reg_form(t,(n,m)))
   | LoadLiteral(t,imm32) =>
     ("ldr",String.concat[s_reg t,", [pc",s_maybe_offset imm32,"]"])
   | LoadByte(unsigned,(t,(n,immediate_form imm32))) =>
     (("ldr") ^ (if unsigned then "b" else "sb"),s_imm_form(t,(n,imm32)))
   | LoadByte(unsigned,(t,(n,register_form m))) =>
     (("ldr") ^ (if unsigned then "b" else "sb"),s_reg_form(t,(n,m)))
   | LoadHalf(unsigned,(t,(n,immediate_form imm32))) =>
     (("ldr") ^ (if unsigned then "h" else "sh"),s_imm_form(t,(n,imm32)))
   | LoadHalf(unsigned,(t,(n,register_form m))) =>
     (("ldr") ^ (if unsigned then "h" else "sh"),s_reg_form(t,(n,m)))
   | LoadMultiple(true,(BitsN.B(0xD,4),registers)) =>
     ("pop",
      s_registers 16
        (BitsN.concat
           [BitsN.bits(8,8) registers,BitsN.B(0x0,7),
            BitsN.bits(7,0) registers]))
   | LoadMultiple(wback,(n,registers)) =>
     ("ldm",
      String.concat
        [s_reg n,if wback then "!" else "",", ",
         s_registers 16
           (BitsN.concat
              [BitsN.bits(8,8) registers,BitsN.B(0x0,7),
               BitsN.bits(7,0) registers])]);

fun s_store ast =
  case ast of
     StoreWord(t,(n,immediate_form imm32)) =>
       ("str",s_imm_form(t,(n,imm32)))
   | StoreWord(t,(n,register_form m)) => ("str",s_reg_form(t,(n,m)))
   | StoreByte(t,(n,immediate_form imm32)) =>
     ("strb",s_imm_form(t,(n,imm32)))
   | StoreByte(t,(n,register_form m)) => ("strb",s_reg_form(t,(n,m)))
   | StoreHalf(t,(n,immediate_form imm32)) =>
     ("strh",s_imm_form(t,(n,imm32)))
   | StoreHalf(t,(n,register_form m)) => ("strh",s_reg_form(t,(n,m)))
   | Push registers =>
     ("push",
      s_registers 15
        (BitsN.concat
           [BitsN.bits(8,8) registers,BitsN.B(0x0,6),
            BitsN.bits(7,0) registers]))
   | StoreMultiple(n,registers) =>
     ("stm",String.concat[s_reg n,"!, ",s_registers 8 registers]);

fun s_hint ast =
  case ast of
     Breakpoint imm32 => ("bkpt",("#") ^ (s_hex 32 imm32))
   | DataMemoryBarrier option => ("dmb",s_barrier_option option)
   | DataSynchronizationBarrier option => ("dsb",s_barrier_option option)
   | InstructionSynchronizationBarrier option =>
     ("isb",s_barrier_option option)
   | SendEvent () => ("sev","")
   | WaitForEvent () => ("wfe","")
   | WaitForInterrupt () => ("wfi","")
   | Yield () => ("yield","");

fun s_media ast =
  case ast of
     ExtendByte(unsigned,(d,m)) =>
       ((if unsigned then "u" else "s") ^ ("xtb"),s_reg2(d,m))
   | ExtendHalfword(unsigned,(d,m)) =>
     ((if unsigned then "u" else "s") ^ ("xth"),s_reg2(d,m))
   | ByteReverse(d,m) => ("rev",s_reg2(d,m))
   | ByteReversePackedHalfword(d,m) => ("rev16",s_reg2(d,m))
   | ByteReverseSignedHalfword(d,m) => ("revsh",s_reg2(d,m));

fun s_system ast =
  case ast of
     ChangeProcessorState enable =>
       (("cps") ^ (if enable then "ie" else "id"),"i")
   | MoveToRegisterFromSpecial(SYSm,d) =>
     ("mrs",String.concat[s_reg d,", ",s_special_reg SYSm])
   | MoveToSpecialRegister(SYSm,n) =>
     ("msr",String.concat[s_special_reg SYSm,", ",s_reg n])
   | SupervisorCall imm32 => ("svc",("#") ^ (s_hex 32 imm32));

fun instructionToString (c,ast) =
  case ast of
     Branch b => s_branch(c,b)
   | Data d => s_data d
   | Load l => s_load l
   | Store s => s_store s
   | Media m => s_media m
   | System s => s_system s
   | Hint h => s_hint h
   | Multiply(Multiply32(d,(n,m))) => ("muls",s_reg3(d,(n,m)))
   | Undefined imm32 => ("udf",("#") ^ (s_hex 32 imm32))
   | NoOperation () => ("nop","");

end